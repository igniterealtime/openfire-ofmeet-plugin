/*! For license information please see lib-jitsi-meet.min.js.LICENSE.txt */ ! function(e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.JitsiMeetJS = t() : e.JitsiMeetJS = t()
}(self, (() => (() => {
    var __webpack_modules__ = {
            449: (e, t, n) => {
                const i = n(972).Z;
                e.exports = function(e) {
                    return "object" == typeof window.JitsiMeetJS ? Object.assign({}, window.JitsiMeetJS, e) : e
                }(i)
            },
            444: e => {
                e.exports = class {
                    constructor(e, t, n) {
                        this._userId = e, this.setDisplayName(t), this._isLocalStats = n || !1, this.setDominantSpeaker(!1), this.totalDominantSpeakerTime = 0, this._dominantSpeakerStart = 0, this._isDominantSpeaker = !1, this._isSilent = !1, this._hasLeft = !1, this._faceLandmarks = []
                    }
                    getUserId() {
                        return this._userId
                    }
                    getDisplayName() {
                        return this.displayName
                    }
                    setDisplayName(e) {
                        this.displayName = e
                    }
                    isLocalStats() {
                        return this._isLocalStats
                    }
                    isDominantSpeaker() {
                        return this._isDominantSpeaker
                    }
                    setDominantSpeaker(e, t) {
                        if (this.isDominantSpeaker() || !e || t) {
                            if (this.isDominantSpeaker())
                                if (e) {
                                    if (this._isSilent && !t) this._dominantSpeakerStart = Date.now();
                                    else if (!this._isSilent && t) {
                                        const e = Date.now() - this._dominantSpeakerStart;
                                        this.totalDominantSpeakerTime += e, this._dominantSpeakerStart = 0
                                    }
                                } else if (!this._isSilent) {
                                const e = Date.now() - this._dominantSpeakerStart;
                                this.totalDominantSpeakerTime += e, this._dominantSpeakerStart = 0
                            }
                        } else this._dominantSpeakerStart = Date.now();
                        this._isDominantSpeaker = e, this._isSilent = t
                    }
                    getTotalDominantSpeakerTime() {
                        let e = this.totalDominantSpeakerTime;
                        return this.isDominantSpeaker() && !this._isSilent && (e += Date.now() - this._dominantSpeakerStart), e
                    }
                    hasLeft() {
                        return this._hasLeft
                    }
                    markAsHasLeft() {
                        this._hasLeft = !0, this.setDominantSpeaker(!1)
                    }
                    getFaceLandmarks() {
                        return this._faceLandmarks
                    }
                    setFaceLandmarks(e) {
                        this._faceLandmarks = e
                    }
                    addFaceLandmarks(e) {
                        this._faceLandmarks.push(e)
                    }
                }
            },
            832: e => {
                function t(e, t) {
                    if (!e || !t || "function" != typeof e.addListener || "function" != typeof t.emit) throw new Error("Invalid arguments passed to EventEmitterForwarder");
                    this.src = e, this.dest = t, this.listeners = new Map
                }
                t.prototype.forward = function() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    const i = t[0];
                    t[0] = this.dest;
                    const r = Function.prototype.bind.apply(this.dest.emit, t);
                    this.src.addListener(i, r), this.listeners.set(i, r)
                }, t.prototype.removeListeners = function() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    t.forEach((e => {
                        const t = this.listeners.get(e);
                        t && (this.src.removeListener(e, t), this.listeners.delete(e))
                    }))
                }, e.exports = t
            },
            399: e => {
                function t(e, t) {
                    return Math.floor(Math.random() * (t - e + 1)) + e
                }

                function n(e) {
                    return e[t(0, e.length - 1)]
                }
                const i = {
                    randomHexDigit: () => n("0123456789abcdef"),
                    randomHexString(e) {
                        let t = "";
                        for (; e--;) t += this.randomHexDigit();
                        return t
                    },
                    randomElement: n,
                    randomAlphanumStr: function(e) {
                        let t = "";
                        for (let i = 0; i < e; i += 1) t += n("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
                        return t
                    },
                    randomInt: t
                };
                e.exports = i
            },
            549: (e, t, n) => {
                const i = n(799),
                    r = {
                        loadScript(e, t, n, r, o, s) {
                            const a = document,
                                d = "script",
                                c = a.createElement(d),
                                l = a.getElementsByTagName(d)[0];
                            if (c.async = t, r) {
                                const t = i();
                                if (t) {
                                    const n = t.src,
                                        i = n.substring(0, n.lastIndexOf("/") + 1);
                                    n && i && (e = i + e)
                                }
                            }
                            o && (c.onload = o), s && (c.onerror = s), c.src = e, n ? l.parentNode.insertBefore(c, l) : l.parentNode.appendChild(c)
                        }
                    };
                e.exports = r
            },
            667: (e, t, n) => {
                const i = n(399),
                    r = ["Aaliyah", "Aaron", "Abagail", "Abbey", "Abbie", "Abbigail", "Abby", "Abdiel", "Abdul", "Abdullah", "Abe", "Abel", "Abelardo", "Abigail", "Abigale", "Abigayle", "Abner", "Abraham", "Ada", "Adah", "Adalberto", "Adaline", "Adam", "Adan", "Addie", "Addison", "Adela", "Adelbert", "Adele", "Adelia", "Adeline", "Adell", "Adella", "Adelle", "Aditya", "Adolf", "Adolfo", "Adolph", "Adolphus", "Adonis", "Adrain", "Adrian", "Adriana", "Adrianna", "Adriel", "Adrien", "Adrienne", "Afton", "Aglae", "Agnes", "Agustin", "Agustina", "Ahmad", "Ahmed", "Aida", "Aidan", "Aiden", "Aileen", "Aisha", "Aiyana", "Akeem", "Al", "Alaina", "Alan", "Alana", "Alanis", "Alanna", "Alayna", "Alba", "Albert", "Alberta", "Albertha", "Alberto", "Albin", "Albina", "Alda", "Alden", "Alec", "Aleen", "Alejandra", "Alejandrin", "Alek", "Alena", "Alene", "Alessandra", "Alessandro", "Alessia", "Aletha", "Alex", "Alexa", "Alexander", "Alexandra", "Alexandre", "Alexandrea", "Alexandria", "Alexandrine", "Alexandro", "Alexane", "Alexanne", "Alexie", "Alexis", "Alexys", "Alexzander", "Alf", "Alfonso", "Alfonzo", "Alford", "Alfred", "Alfreda", "Alfredo", "Ali", "Alia", "Alice", "Alicia", "Alisa", "Alisha", "Alison", "Alivia", "Aliya", "Aliyah", "Aliza", "Alize", "Allan", "Allen", "Allene", "Allie", "Allison", "Ally", "Alphonso", "Alta", "Althea", "Alva", "Alvah", "Alvena", "Alvera", "Alverta", "Alvina", "Alvis", "Alyce", "Alycia", "Alysa", "Alysha", "Alyson", "Alysson", "Amalia", "Amanda", "Amani", "Amara", "Amari", "Amaya", "Amber", "Ambrose", "Amelia", "Amelie", "Amely", "America", "Americo", "Amie", "Amina", "Amir", "Amira", "Amiya", "Amos", "Amparo", "Amy", "Amya", "Ana", "Anabel", "Anabelle", "Anahi", "Anais", "Anastacio", "Anastasia", "Anderson", "Andre", "Andreane", "Andreanne", "Andres", "Andrew", "Andy", "Angel", "Angela", "Angelica", "Angelina", "Angeline", "Angelita", "Angelo", "Angie", "Angus", "Anibal", "Anika", "Anissa", "Anita", "Aniya", "Aniyah", "Anjali", "Anna", "Annabel", "Annabell", "Annabelle", "Annalise", "Annamae", "Annamarie", "Anne", "Annetta", "Annette", "Annie", "Ansel", "Ansley", "Anthony", "Antoinette", "Antone", "Antonetta", "Antonette", "Antonia", "Antonietta", "Antonina", "Antonio", "Antwan", "Antwon", "Anya", "April", "Ara", "Araceli", "Aracely", "Arch", "Archibald", "Ardella", "Arden", "Ardith", "Arely", "Ari", "Ariane", "Arianna", "Aric", "Ariel", "Arielle", "Arjun", "Arlene", "Arlie", "Arlo", "Armand", "Armando", "Armani", "Arnaldo", "Arne", "Arno", "Arnold", "Arnoldo", "Arnulfo", "Aron", "Art", "Arthur", "Arturo", "Arvel", "Arvid", "Arvilla", "Aryanna", "Asa", "Asha", "Ashlee", "Ashleigh", "Ashley", "Ashly", "Ashlynn", "Ashton", "Ashtyn", "Asia", "Assunta", "Astrid", "Athena", "Aubree", "Aubrey", "Audie", "Audra", "Audreanne", "Audrey", "August", "Augusta", "Augustine", "Augustus", "Aurelia", "Aurelie", "Aurelio", "Aurore", "Austen", "Austin", "Austyn", "Autumn", "Ava", "Avery", "Avis", "Axel", "Ayana", "Ayden", "Ayla", "Aylin", "Baby", "Bailee", "Bailey", "Barbara", "Barney", "Baron", "Barrett", "Barry", "Bart", "Bartholome", "Barton", "Baylee", "Beatrice", "Beau", "Beaulah", "Bell", "Bella", "Belle", "Ben", "Benedict", "Benjamin", "Bennett", "Bennie", "Benny", "Benton", "Berenice", "Bernadette", "Bernadine", "Bernard", "Bernardo", "Berneice", "Bernhard", "Bernice", "Bernie", "Berniece", "Bernita", "Berry", "Bert", "Berta", "Bertha", "Bertram", "Bertrand", "Beryl", "Bessie", "Beth", "Bethany", "Bethel", "Betsy", "Bette", "Bettie", "Betty", "Bettye", "Beulah", "Beverly", "Bianka", "Bill", "Billie", "Billy", "Birdie", "Blair", "Blaise", "Blake", "Blanca", "Blanche", "Blaze", "Bo", "Bobbie", "Bobby", "Bonita", "Bonnie", "Boris", "Boyd", "Brad", "Braden", "Bradford", "Bradley", "Bradly", "Brady", "Braeden", "Brain", "Brandi", "Brando", "Brandon", "Brandt", "Brandy", "Brandyn", "Brannon", "Branson", "Brant", "Braulio", "Braxton", "Brayan", "Breana", "Breanna", "Breanne", "Brenda", "Brendan", "Brenden", "Brendon", "Brenna", "Brennan", "Brennon", "Brent", "Bret", "Brett", "Bria", "Brian", "Briana", "Brianne", "Brice", "Bridget", "Bridgette", "Bridie", "Brielle", "Brigitte", "Brionna", "Brisa", "Britney", "Brittany", "Brock", "Broderick", "Brody", "Brook", "Brooke", "Brooklyn", "Brooks", "Brown", "Bruce", "Bryana", "Bryce", "Brycen", "Bryon", "Buck", "Bud", "Buddy", "Buford", "Bulah", "Burdette", "Burley", "Burnice", "Buster", "Cade", "Caden", "Caesar", "Caitlyn", "Cale", "Caleb", "Caleigh", "Cali", "Calista", "Callie", "Camden", "Cameron", "Camila", "Camilla", "Camille", "Camren", "Camron", "Camryn", "Camylle", "Candace", "Candelario", "Candice", "Candida", "Candido", "Cara", "Carey", "Carissa", "Carlee", "Carleton", "Carley", "Carli", "Carlie", "Carlo", "Carlos", "Carlotta", "Carmel", "Carmela", "Carmella", "Carmelo", "Carmen", "Carmine", "Carol", "Carolanne", "Carole", "Carolina", "Caroline", "Carolyn", "Carolyne", "Carrie", "Carroll", "Carson", "Carter", "Cary", "Casandra", "Casey", "Casimer", "Casimir", "Casper", "Cassandra", "Cassandre", "Cassidy", "Cassie", "Catalina", "Caterina", "Catharine", "Catherine", "Cathrine", "Cathryn", "Cathy", "Cayla", "Ceasar", "Cecelia", "Cecil", "Cecile", "Cecilia", "Cedrick", "Celestine", "Celestino", "Celia", "Celine", "Cesar", "Chad", "Chadd", "Chadrick", "Chaim", "Chance", "Chandler", "Chanel", "Chanelle", "Charity", "Charlene", "Charles", "Charley", "Charlie", "Charlotte", "Chase", "Chasity", "Chauncey", "Chaya", "Chaz", "Chelsea", "Chelsey", "Chelsie", "Chesley", "Chester", "Chet", "Cheyanne", "Cheyenne", "Chloe", "Chris", "Christ", "Christa", "Christelle", "Christian", "Christiana", "Christina", "Christine", "Christop", "Christophe", "Christopher", "Christy", "Chyna", "Ciara", "Cicero", "Cielo", "Cierra", "Cindy", "Citlalli", "Clair", "Claire", "Clara", "Clarabelle", "Clare", "Clarissa", "Clark", "Claud", "Claude", "Claudia", "Claudie", "Claudine", "Clay", "Clemens", "Clement", "Clementina", "Clementine", "Clemmie", "Cleo", "Cleora", "Cleta", "Cletus", "Cleve", "Cleveland", "Clifford", "Clifton", "Clint", "Clinton", "Clotilde", "Clovis", "Cloyd", "Clyde", "Coby", "Cody", "Colby", "Cole", "Coleman", "Colin", "Colleen", "Collin", "Colt", "Colten", "Colton", "Columbus", "Concepcion", "Conner", "Connie", "Connor", "Conor", "Conrad", "Constance", "Constantin", "Consuelo", "Cooper", "Cora", "Coralie", "Corbin", "Cordelia", "Cordell", "Cordia", "Cordie", "Corene", "Corine", "Cornelius", "Cornell", "Corrine", "Cortez", "Cortney", "Cory", "Coty", "Courtney", "Coy", "Craig", "Crawford", "Creola", "Cristal", "Cristian", "Cristina", "Cristobal", "Cristopher", "Cruz", "Crystal", "Crystel", "Cullen", "Curt", "Curtis", "Cydney", "Cynthia", "Cyril", "Cyrus", "Dagmar", "Dahlia", "Daija", "Daisha", "Daisy", "Dakota", "Dale", "Dallas", "Dallin", "Dalton", "Damaris", "Dameon", "Damian", "Damien", "Damion", "Damon", "Dan", "Dana", "Dandre", "Dane", "D'angelo", "Dangelo", "Danial", "Daniela", "Daniella", "Danielle", "Danika", "Dannie", "Danny", "Dante", "Danyka", "Daphne", "Daphnee", "Daphney", "Darby", "Daren", "Darian", "Dariana", "Darien", "Dario", "Darion", "Darius", "Darlene", "Daron", "Darrel", "Darrell", "Darren", "Darrick", "Darrin", "Darrion", "Darron", "Darryl", "Darwin", "Daryl", "Dashawn", "Dasia", "Dave", "David", "Davin", "Davion", "Davon", "Davonte", "Dawn", "Dawson", "Dax", "Dayana", "Dayna", "Dayne", "Dayton", "Dean", "Deangelo", "Deanna", "Deborah", "Declan", "Dedric", "Dedrick", "Dee", "Deion", "Deja", "Dejah", "Dejon", "Dejuan", "Delaney", "Delbert", "Delfina", "Delia", "Delilah", "Dell", "Della", "Delmer", "Delores", "Delpha", "Delphia", "Delphine", "Delta", "Demarco", "Demarcus", "Demario", "Demetris", "Demetrius", "Demond", "Dena", "Denis", "Dennis", "Deon", "Deondre", "Deontae", "Deonte", "Dereck", "Derek", "Derick", "Deron", "Derrick", "Deshaun", "Deshawn", "Desiree", "Desmond", "Dessie", "Destany", "Destin", "Destinee", "Destiney", "Destini", "Destiny", "Devan", "Devante", "Deven", "Devin", "Devon", "Devonte", "Devyn", "Dewayne", "Dewitt", "Dexter", "Diamond", "Diana", "Dianna", "Diego", "Dillan", "Dillon", "Dimitri", "Dina", "Dino", "Dion", "Dixie", "Dock", "Dolly", "Dolores", "Domenic", "Domenica", "Domenick", "Domenico", "Domingo", "Dominic", "Dominique", "Don", "Donald", "Donato", "Donavon", "Donna", "Donnell", "Donnie", "Donny", "Dora", "Dorcas", "Dorian", "Doris", "Dorothea", "Dorothy", "Dorris", "Dortha", "Dorthy", "Doug", "Douglas", "Dovie", "Doyle", "Drake", "Drew", "Duane", "Dudley", "Dulce", "Duncan", "Durward", "Dustin", "Dusty", "Dwight", "Dylan", "Earl", "Earlene", "Earline", "Earnest", "Earnestine", "Easter", "Easton", "Ebba", "Ebony", "Ed", "Eda", "Edd", "Eddie", "Eden", "Edgar", "Edgardo", "Edison", "Edmond", "Edmund", "Edna", "Eduardo", "Edward", "Edwardo", "Edwin", "Edwina", "Edyth", "Edythe", "Effie", "Efrain", "Efren", "Eileen", "Einar", "Eino", "Eladio", "Elaina", "Elbert", "Elda", "Eldon", "Eldora", "Eldred", "Eldridge", "Eleanora", "Eleanore", "Eleazar", "Electa", "Elena", "Elenor", "Elenora", "Eleonore", "Elfrieda", "Eli", "Elian", "Eliane", "Elias", "Eliezer", "Elijah", "Elinor", "Elinore", "Elisa", "Elisabeth", "Elise", "Eliseo", "Elisha", "Elissa", "Eliza", "Elizabeth", "Ella", "Ellen", "Ellie", "Elliot", "Elliott", "Ellis", "Ellsworth", "Elmer", "Elmira", "Elmo", "Elmore", "Elna", "Elnora", "Elody", "Eloisa", "Eloise", "Elouise", "Eloy", "Elroy", "Elsa", "Else", "Elsie", "Elta", "Elton", "Elva", "Elvera", "Elvie", "Elvis", "Elwin", "Elwyn", "Elyse", "Elyssa", "Elza", "Emanuel", "Emelia", "Emelie", "Emely", "Emerald", "Emerson", "Emery", "Emie", "Emil", "Emile", "Emilia", "Emiliano", "Emilie", "Emilio", "Emily", "Emma", "Emmalee", "Emmanuel", "Emmanuelle", "Emmet", "Emmett", "Emmie", "Emmitt", "Emmy", "Emory", "Ena", "Enid", "Enoch", "Enola", "Enos", "Enrico", "Enrique", "Ephraim", "Era", "Eriberto", "Eric", "Erica", "Erich", "Erick", "Ericka", "Erik", "Erika", "Erin", "Erling", "Erna", "Ernest", "Ernestina", "Ernestine", "Ernesto", "Ernie", "Ervin", "Erwin", "Eryn", "Esmeralda", "Esperanza", "Esta", "Esteban", "Estefania", "Estel", "Estell", "Estella", "Estelle", "Estevan", "Esther", "Estrella", "Etha", "Ethan", "Ethel", "Ethelyn", "Ethyl", "Ettie", "Eudora", "Eugene", "Eugenia", "Eula", "Eulah", "Eulalia", "Euna", "Eunice", "Eusebio", "Eva", "Evalyn", "Evan", "Evangeline", "Evans", "Eve", "Eveline", "Evelyn", "Everardo", "Everett", "Everette", "Evert", "Evie", "Ewald", "Ewell", "Ezekiel", "Ezequiel", "Ezra", "Fabian", "Fabiola", "Fae", "Fannie", "Fanny", "Fatima", "Faustino", "Fausto", "Favian", "Fay", "Faye", "Federico", "Felicia", "Felicita", "Felicity", "Felipa", "Felipe", "Felix", "Felton", "Fermin", "Fern", "Fernando", "Ferne", "Fidel", "Filiberto", "Filomena", "Finn", "Fiona", "Flavie", "Flavio", "Fleta", "Fletcher", "Flo", "Florence", "Florencio", "Florian", "Florida", "Florine", "Flossie", "Floy", "Floyd", "Ford", "Forest", "Forrest", "Foster", "Frances", "Francesca", "Francesco", "Francis", "Francisca", "Francisco", "Franco", "Frank", "Frankie", "Franz", "Fred", "Freda", "Freddie", "Freddy", "Frederic", "Frederick", "Frederik", "Frederique", "Fredrick", "Fredy", "Freeda", "Freeman", "Freida", "Frida", "Frieda", "Friedrich", "Fritz", "Furman", "Gabe", "Gabriel", "Gabriella", "Gabrielle", "Gaetano", "Gage", "Gail", "Gardner", "Garett", "Garfield", "Garland", "Garnet", "Garnett", "Garret", "Garrett", "Garrick", "Garrison", "Garry", "Garth", "Gaston", "Gavin", "Gay", "Gayle", "Gaylord", "Gene", "General", "Genesis", "Genevieve", "Gennaro", "Genoveva", "Geo", "Geoffrey", "George", "Georgette", "Georgiana", "Georgianna", "Geovanni", "Geovanny", "Geovany", "Gerald", "Geraldine", "Gerard", "Gerardo", "Gerda", "Gerhard", "Germaine", "German", "Gerry", "Gerson", "Gertrude", "Gia", "Gianni", "Gideon", "Gilbert", "Gilberto", "Gilda", "Giles", "Gillian", "Gina", "Gino", "Giovani", "Giovanna", "Giovanni", "Giovanny", "Gisselle", "Giuseppe", "Gladyce", "Gladys", "Glen", "Glenda", "Glenna", "Glennie", "Gloria", "Godfrey", "Golda", "Golden", "Gonzalo", "Gordon", "Grace", "Gracie", "Graciela", "Grady", "Graham", "Grant", "Granville", "Grayce", "Grayson", "Green", "Greg", "Gregg", "Gregoria", "Gregorio", "Gregory", "Greta", "Gretchen", "Greyson", "Griffin", "Grover", "Guadalupe", "Gudrun", "Guido", "Guillermo", "Guiseppe", "Gunnar", "Gunner", "Gus", "Gussie", "Gust", "Gustave", "Guy", "Gwen", "Gwendolyn", "Hadley", "Hailee", "Hailey", "Hailie", "Hal", "Haleigh", "Haley", "Halie", "Halle", "Hallie", "Hank", "Hanna", "Hannah", "Hans", "Hardy", "Harley", "Harmon", "Harmony", "Harold", "Harrison", "Harry", "Harvey", "Haskell", "Hassan", "Hassie", "Hattie", "Haven", "Hayden", "Haylee", "Hayley", "Haylie", "Hazel", "Hazle", "Heath", "Heather", "Heaven", "Heber", "Hector", "Heidi", "Helen", "Helena", "Helene", "Helga", "Hellen", "Helmer", "Heloise", "Henderson", "Henri", "Henriette", "Henry", "Herbert", "Herman", "Hermann", "Hermina", "Herminia", "Herminio", "Hershel", "Herta", "Hertha", "Hester", "Hettie", "Hilario", "Hilbert", "Hilda", "Hildegard", "Hillard", "Hillary", "Hilma", "Hilton", "Hipolito", "Hiram", "Hobart", "Holden", "Hollie", "Hollis", "Holly", "Hope", "Horace", "Horacio", "Hortense", "Hosea", "Houston", "Howard", "Howell", "Hoyt", "Hubert", "Hudson", "Hugh", "Hulda", "Humberto", "Hunter", "Hyman", "Ian", "Ibrahim", "Icie", "Ida", "Idell", "Idella", "Ignacio", "Ignatius", "Ike", "Ila", "Ilene", "Iliana", "Ima", "Imani", "Imelda", "Immanuel", "Imogene", "Ines", "Irma", "Irving", "Irwin", "Isaac", "Isabel", "Isabell", "Isabella", "Isabelle", "Isac", "Isadore", "Isai", "Isaiah", "Isaias", "Isidro", "Ismael", "Isobel", "Isom", "Israel", "Issac", "Itzel", "Iva", "Ivah", "Ivory", "Ivy", "Izabella", "Izaiah", "Jabari", "Jace", "Jacey", "Jacinthe", "Jacinto", "Jack", "Jackeline", "Jackie", "Jacklyn", "Jackson", "Jacky", "Jaclyn", "Jacquelyn", "Jacques", "Jacynthe", "Jada", "Jade", "Jaden", "Jadon", "Jadyn", "Jaeden", "Jaida", "Jaiden", "Jailyn", "Jaime", "Jairo", "Jakayla", "Jake", "Jakob", "Jaleel", "Jalen", "Jalon", "Jalyn", "Jamaal", "Jamal", "Jamar", "Jamarcus", "Jamel", "Jameson", "Jamey", "Jamie", "Jamil", "Jamir", "Jamison", "Jammie", "Jan", "Jana", "Janae", "Jane", "Janelle", "Janessa", "Janet", "Janice", "Janick", "Janie", "Janis", "Janiya", "Jannie", "Jany", "Jaquan", "Jaquelin", "Jaqueline", "Jared", "Jaren", "Jarod", "Jaron", "Jarred", "Jarrell", "Jarret", "Jarrett", "Jarrod", "Jarvis", "Jasen", "Jasmin", "Jason", "Jasper", "Jaunita", "Javier", "Javon", "Javonte", "Jay", "Jayce", "Jaycee", "Jayda", "Jayde", "Jayden", "Jaydon", "Jaylan", "Jaylen", "Jaylin", "Jaylon", "Jayme", "Jayne", "Jayson", "Jazlyn", "Jazmin", "Jazmyn", "Jazmyne", "Jean", "Jeanette", "Jeanie", "Jeanne", "Jed", "Jedediah", "Jedidiah", "Jeff", "Jefferey", "Jeffery", "Jeffrey", "Jeffry", "Jena", "Jenifer", "Jennie", "Jennifer", "Jennings", "Jennyfer", "Jensen", "Jerad", "Jerald", "Jeramie", "Jeramy", "Jerel", "Jeremie", "Jeremy", "Jermain", "Jermaine", "Jermey", "Jerod", "Jerome", "Jeromy", "Jerrell", "Jerrod", "Jerrold", "Jerry", "Jess", "Jesse", "Jessica", "Jessie", "Jessika", "Jessy", "Jessyca", "Jesus", "Jett", "Jettie", "Jevon", "Jewel", "Jewell", "Jillian", "Jimmie", "Jimmy", "Jo", "Joan", "Joana", "Joanie", "Joanne", "Joannie", "Joanny", "Joany", "Joaquin", "Jocelyn", "Jodie", "Jody", "Joe", "Joel", "Joelle", "Joesph", "Joey", "Johan", "Johann", "Johanna", "Johathan", "John", "Johnathan", "Johnathon", "Johnnie", "Johnny", "Johnpaul", "Johnson", "Jolie", "Jon", "Jonas", "Jonatan", "Jonathan", "Jonathon", "Jordan", "Jordane", "Jordi", "Jordon", "Jordy", "Jordyn", "Jorge", "Jose", "Josefa", "Josefina", "Joseph", "Josephine", "Josh", "Joshua", "Joshuah", "Josiah", "Josiane", "Josianne", "Josie", "Josue", "Jovan", "Jovani", "Jovanny", "Jovany", "Joy", "Joyce", "Juana", "Juanita", "Judah", "Judd", "Jude", "Judge", "Judson", "Judy", "Jules", "Julia", "Julian", "Juliana", "Julianne", "Julie", "Julien", "Juliet", "Julio", "Julius", "June", "Junior", "Junius", "Justen", "Justice", "Justina", "Justine", "Juston", "Justus", "Justyn", "Juvenal", "Juwan", "Kacey", "Kaci", "Kacie", "Kade", "Kaden", "Kadin", "Kaela", "Kaelyn", "Kaia", "Kailee", "Kailey", "Kailyn", "Kaitlin", "Kaitlyn", "Kale", "Kaleb", "Kaleigh", "Kaley", "Kali", "Kallie", "Kameron", "Kamille", "Kamren", "Kamron", "Kamryn", "Kane", "Kara", "Kareem", "Karelle", "Karen", "Kari", "Kariane", "Karianne", "Karina", "Karine", "Karl", "Karlee", "Karley", "Karli", "Karlie", "Karolann", "Karson", "Kasandra", "Kasey", "Kassandra", "Katarina", "Katelin", "Katelyn", "Katelynn", "Katharina", "Katherine", "Katheryn", "Kathleen", "Kathlyn", "Kathryn", "Kathryne", "Katlyn", "Katlynn", "Katrina", "Katrine", "Kattie", "Kavon", "Kay", "Kaya", "Kaycee", "Kayden", "Kayla", "Kaylah", "Kaylee", "Kayleigh", "Kayley", "Kayli", "Kaylie", "Kaylin", "Keagan", "Keanu", "Keara", "Keaton", "Keegan", "Keeley", "Keely", "Keenan", "Keira", "Keith", "Kellen", "Kelley", "Kelli", "Kellie", "Kelly", "Kelsi", "Kelsie", "Kelton", "Kelvin", "Ken", "Kendall", "Kendra", "Kendrick", "Kenna", "Kennedi", "Kennedy", "Kenneth", "Kennith", "Kenny", "Kenton", "Kenya", "Kenyatta", "Kenyon", "Keon", "Keshaun", "Keshawn", "Keven", "Kevin", "Kevon", "Keyon", "Keyshawn", "Khalid", "Khalil", "Kian", "Kiana", "Kianna", "Kiara", "Kiarra", "Kiel", "Kiera", "Kieran", "Kiley", "Kim", "Kimberly", "King", "Kip", "Kira", "Kirk", "Kirsten", "Kirstin", "Kitty", "Kobe", "Koby", "Kody", "Kolby", "Kole", "Korbin", "Korey", "Kory", "Kraig", "Kris", "Krista", "Kristian", "Kristin", "Kristina", "Kristofer", "Kristoffer", "Kristopher", "Kristy", "Krystal", "Krystel", "Krystina", "Kurt", "Kurtis", "Kyla", "Kyle", "Kylee", "Kyleigh", "Kyler", "Kylie", "Kyra", "Lacey", "Lacy", "Ladarius", "Lafayette", "Laila", "Laisha", "Lamar", "Lambert", "Lamont", "Lance", "Landen", "Lane", "Laney", "Larissa", "Laron", "Larry", "Larue", "Laura", "Laurel", "Lauren", "Laurence", "Lauretta", "Lauriane", "Laurianne", "Laurie", "Laurine", "Laury", "Lauryn", "Lavada", "Lavern", "Laverna", "Laverne", "Lavina", "Lavinia", "Lavon", "Lavonne", "Lawrence", "Lawson", "Layla", "Layne", "Lazaro", "Lea", "Leann", "Leanna", "Leanne", "Leatha", "Leda", "Lee", "Leif", "Leila", "Leilani", "Lela", "Lelah", "Leland", "Lelia", "Lempi", "Lemuel", "Lenna", "Lennie", "Lenny", "Lenora", "Lenore", "Leo", "Leola", "Leon", "Leonard", "Leonardo", "Leone", "Leonel", "Leonie", "Leonor", "Leonora", "Leopold", "Leopoldo", "Leora", "Lera", "Lesley", "Leslie", "Lesly", "Lessie", "Lester", "Leta", "Letha", "Letitia", "Levi", "Lew", "Lewis", "Lexi", "Lexie", "Lexus", "Lia", "Liam", "Liana", "Libbie", "Libby", "Lila", "Lilian", "Liliana", "Liliane", "Lilla", "Lillian", "Lilliana", "Lillie", "Lilly", "Lily", "Lilyan", "Lina", "Lincoln", "Linda", "Lindsay", "Lindsey", "Linnea", "Linnie", "Linwood", "Lionel", "Lisa", "Lisandro", "Lisette", "Litzy", "Liza", "Lizeth", "Lizzie", "Llewellyn", "Lloyd", "Logan", "Lois", "Lola", "Lolita", "Loma", "Lon", "London", "Lonie", "Lonnie", "Lonny", "Lonzo", "Lora", "Loraine", "Loren", "Lorena", "Lorenz", "Lorenza", "Lorenzo", "Lori", "Lorine", "Lorna", "Lottie", "Lou", "Louie", "Louisa", "Lourdes", "Louvenia", "Lowell", "Loy", "Loyal", "Loyce", "Lucas", "Luciano", "Lucie", "Lucienne", "Lucile", "Lucinda", "Lucio", "Lucious", "Lucius", "Lucy", "Ludie", "Ludwig", "Lue", "Luella", "Luigi", "Luis", "Luisa", "Lukas", "Lula", "Lulu", "Luna", "Lupe", "Lura", "Lurline", "Luther", "Luz", "Lyda", "Lydia", "Lyla", "Lynn", "Lyric", "Lysanne", "Mabel", "Mabelle", "Mable", "Mac", "Macey", "Maci", "Macie", "Mack", "Mackenzie", "Macy", "Madaline", "Madalyn", "Maddison", "Madeline", "Madelyn", "Madelynn", "Madge", "Madie", "Madilyn", "Madisen", "Madison", "Madisyn", "Madonna", "Madyson", "Mae", "Maegan", "Maeve", "Mafalda", "Magali", "Magdalen", "Magdalena", "Maggie", "Magnolia", "Magnus", "Maia", "Maida", "Maiya", "Major", "Makayla", "Makenna", "Makenzie", "Malachi", "Malcolm", "Malika", "Malinda", "Mallie", "Mallory", "Malvina", "Mandy", "Manley", "Manuel", "Manuela", "Mara", "Marc", "Marcel", "Marcelina", "Marcelino", "Marcella", "Marcelle", "Marcellus", "Marcelo", "Marcia", "Marco", "Marcos", "Marcus", "Margaret", "Margarete", "Margarett", "Margaretta", "Margarette", "Margarita", "Marge", "Margie", "Margot", "Margret", "Marguerite", "Maria", "Mariah", "Mariam", "Marian", "Mariana", "Mariane", "Marianna", "Marianne", "Mariano", "Maribel", "Marie", "Mariela", "Marielle", "Marietta", "Marilie", "Marilou", "Marilyne", "Marina", "Mario", "Marion", "Marisa", "Marisol", "Maritza", "Marjolaine", "Marjorie", "Marjory", "Mark", "Markus", "Marlee", "Marlen", "Marlene", "Marley", "Marlin", "Marlon", "Marques", "Marquis", "Marquise", "Marshall", "Marta", "Martin", "Martina", "Martine", "Marty", "Marvin", "Mary", "Maryam", "Maryjane", "Maryse", "Mason", "Mateo", "Mathew", "Mathias", "Mathilde", "Matilda", "Matilde", "Matt", "Matteo", "Mattie", "Maud", "Maude", "Maudie", "Maureen", "Maurice", "Mauricio", "Maurine", "Maverick", "Mavis", "Max", "Maxie", "Maxime", "Maximilian", "Maximillia", "Maximillian", "Maximo", "Maximus", "Maxine", "Maxwell", "May", "Maya", "Maybell", "Maybelle", "Maye", "Maymie", "Maynard", "Mayra", "Mazie", "Mckayla", "Mckenna", "Mckenzie", "Meagan", "Meaghan", "Meda", "Megane", "Meggie", "Meghan", "Mekhi", "Melany", "Melba", "Melisa", "Melissa", "Mellie", "Melody", "Melvin", "Melvina", "Melyna", "Melyssa", "Mercedes", "Meredith", "Merl", "Merle", "Merlin", "Merritt", "Mertie", "Mervin", "Meta", "Mia", "Micaela", "Micah", "Michael", "Michaela", "Michale", "Micheal", "Michel", "Michele", "Michelle", "Miguel", "Mikayla", "Mike", "Mikel", "Milan", "Miles", "Milford", "Miller", "Millie", "Milo", "Milton", "Mina", "Minerva", "Minnie", "Miracle", "Mireille", "Mireya", "Misael", "Missouri", "Misty", "Mitchel", "Mitchell", "Mittie", "Modesta", "Modesto", "Mohamed", "Mohammad", "Mohammed", "Moises", "Mollie", "Molly", "Mona", "Monica", "Monique", "Monroe", "Monserrat", "Monserrate", "Montana", "Monte", "Monty", "Morgan", "Moriah", "Morris", "Mortimer", "Morton", "Mose", "Moses", "Moshe", "Mossie", "Mozell", "Mozelle", "Muhammad", "Muriel", "Murl", "Murphy", "Murray", "Mustafa", "Mya", "Myah", "Mylene", "Myles", "Myra", "Myriam", "Myrl", "Myrna", "Myron", "Myrtice", "Myrtie", "Myrtis", "Myrtle", "Nadia", "Nakia", "Name", "Nannie", "Naomi", "Naomie", "Napoleon", "Narciso", "Nash", "Nasir", "Nat", "Natalia", "Natalie", "Natasha", "Nathan", "Nathanael", "Nathanial", "Nathaniel", "Nathen", "Nayeli", "Neal", "Ned", "Nedra", "Neha", "Neil", "Nelda", "Nella", "Nelle", "Nellie", "Nels", "Nelson", "Neoma", "Nestor", "Nettie", "Neva", "Newell", "Newton", "Nia", "Nicholas", "Nicholaus", "Nichole", "Nick", "Nicklaus", "Nickolas", "Nico", "Nicola", "Nicolas", "Nicole", "Nicolette", "Nigel", "Nikita", "Nikki", "Nikko", "Niko", "Nikolas", "Nils", "Nina", "Noah", "Noble", "Noe", "Noel", "Noelia", "Noemi", "Noemie", "Noemy", "Nola", "Nolan", "Nona", "Nora", "Norbert", "Norberto", "Norene", "Norma", "Norris", "Norval", "Norwood", "Nova", "Novella", "Nya", "Nyah", "Nyasia", "Obie", "Oceane", "Ocie", "Octavia", "Oda", "Odell", "Odessa", "Odie", "Ofelia", "Okey", "Ola", "Olaf", "Ole", "Olen", "Oleta", "Olga", "Olin", "Oliver", "Ollie", "Oma", "Omari", "Omer", "Ona", "Onie", "Opal", "Ophelia", "Ora", "Oral", "Oran", "Oren", "Orie", "Orin", "Orion", "Orland", "Orlando", "Orlo", "Orpha", "Orrin", "Orval", "Orville", "Osbaldo", "Osborne", "Oscar", "Osvaldo", "Oswald", "Oswaldo", "Otha", "Otho", "Otilia", "Otis", "Ottilie", "Ottis", "Otto", "Ova", "Owen", "Ozella", "Pablo", "Paige", "Palma", "Pamela", "Pansy", "Paolo", "Paris", "Parker", "Pascale", "Pasquale", "Pat", "Patience", "Patricia", "Patrick", "Patsy", "Pattie", "Paul", "Paula", "Pauline", "Paxton", "Payton", "Pearl", "Pearlie", "Pearline", "Pedro", "Peggie", "Penelope", "Percival", "Percy", "Perry", "Pete", "Peter", "Petra", "Peyton", "Philip", "Phoebe", "Phyllis", "Pierce", "Pierre", "Pietro", "Pink", "Pinkie", "Piper", "Polly", "Porter", "Precious", "Presley", "Preston", "Price", "Prince", "Princess", "Priscilla", "Providenci", "Prudence", "Queen", "Queenie", "Quentin", "Quincy", "Quinn", "Quinten", "Quinton", "Rachael", "Rachel", "Rachelle", "Rae", "Raegan", "Rafael", "Rafaela", "Raheem", "Rahsaan", "Rahul", "Raina", "Raleigh", "Ralph", "Ramiro", "Ramon", "Ramona", "Randal", "Randall", "Randi", "Randy", "Ransom", "Raoul", "Raphael", "Raphaelle", "Raquel", "Rashad", "Rashawn", "Rasheed", "Raul", "Raven", "Ray", "Raymond", "Raymundo", "Reagan", "Reanna", "Reba", "Rebeca", "Rebecca", "Rebeka", "Rebekah", "Reece", "Reed", "Reese", "Regan", "Reggie", "Reginald", "Reid", "Reilly", "Reina", "Reinhold", "Remington", "Rene", "Renee", "Ressie", "Reta", "Retha", "Retta", "Reuben", "Reva", "Rex", "Rey", "Reyes", "Reymundo", "Reyna", "Reynold", "Rhea", "Rhett", "Rhianna", "Rhiannon", "Rhoda", "Ricardo", "Richard", "Richie", "Richmond", "Rick", "Rickey", "Rickie", "Ricky", "Rico", "Rigoberto", "Riley", "Rita", "River", "Robb", "Robbie", "Robert", "Roberta", "Roberto", "Robin", "Robyn", "Rocio", "Rocky", "Rod", "Roderick", "Rodger", "Rodolfo", "Rodrick", "Rodrigo", "Roel", "Rogelio", "Roger", "Rogers", "Rolando", "Rollin", "Roma", "Romaine", "Roman", "Ron", "Ronaldo", "Ronny", "Roosevelt", "Rory", "Rosa", "Rosalee", "Rosalia", "Rosalind", "Rosalinda", "Rosalyn", "Rosamond", "Rosanna", "Rosario", "Roscoe", "Rose", "Rosella", "Roselyn", "Rosemarie", "Rosemary", "Rosendo", "Rosetta", "Rosie", "Rosina", "Roslyn", "Ross", "Rossie", "Rowan", "Rowena", "Rowland", "Roxane", "Roxanne", "Roy", "Royal", "Royce", "Rozella", "Ruben", "Rubie", "Ruby", "Rubye", "Rudolph", "Rudy", "Rupert", "Russ", "Russel", "Russell", "Rusty", "Ruth", "Ruthe", "Ruthie", "Ryan", "Ryann", "Ryder", "Rylan", "Rylee", "Ryleigh", "Ryley", "Sabina", "Sabrina", "Sabryna", "Sadie", "Sadye", "Sage", "Saige", "Sallie", "Sally", "Salma", "Salvador", "Salvatore", "Sam", "Samanta", "Samantha", "Samara", "Samir", "Sammie", "Sammy", "Samson", "Sandra", "Sandrine", "Sandy", "Sanford", "Santa", "Santiago", "Santina", "Santino", "Santos", "Sarah", "Sarai", "Sarina", "Sasha", "Saul", "Savanah", "Savanna", "Savannah", "Savion", "Scarlett", "Schuyler", "Scot", "Scottie", "Scotty", "Seamus", "Sean", "Sebastian", "Sedrick", "Selena", "Selina", "Selmer", "Serena", "Serenity", "Seth", "Shad", "Shaina", "Shakira", "Shana", "Shane", "Shanel", "Shanelle", "Shania", "Shanie", "Shaniya", "Shanna", "Shannon", "Shanny", "Shanon", "Shany", "Sharon", "Shaun", "Shawn", "Shawna", "Shaylee", "Shayna", "Shayne", "Shea", "Sheila", "Sheldon", "Shemar", "Sheridan", "Sherman", "Sherwood", "Shirley", "Shyann", "Shyanne", "Sibyl", "Sid", "Sidney", "Sienna", "Sierra", "Sigmund", "Sigrid", "Sigurd", "Silas", "Sim", "Simeon", "Simone", "Sincere", "Sister", "Skye", "Skyla", "Skylar", "Sofia", "Soledad", "Solon", "Sonia", "Sonny", "Sonya", "Sophia", "Sophie", "Spencer", "Stacey", "Stacy", "Stan", "Stanford", "Stanley", "Stanton", "Stefan", "Stefanie", "Stella", "Stephan", "Stephania", "Stephanie", "Stephany", "Stephen", "Stephon", "Sterling", "Steve", "Stevie", "Stewart", "Stone", "Stuart", "Summer", "Sunny", "Susan", "Susana", "Susanna", "Susie", "Suzanne", "Sven", "Syble", "Sydnee", "Sydney", "Sydni", "Sydnie", "Sylvan", "Sylvester", "Sylvia", "Tabitha", "Tad", "Talia", "Talon", "Tamara", "Tamia", "Tania", "Tanner", "Tanya", "Tara", "Taryn", "Tate", "Tatum", "Tatyana", "Taurean", "Tavares", "Taya", "Taylor", "Teagan", "Ted", "Telly", "Terence", "Teresa", "Terrance", "Terrell", "Terrence", "Terrill", "Terry", "Tess", "Tessie", "Tevin", "Thad", "Thaddeus", "Thalia", "Thea", "Thelma", "Theo", "Theodora", "Theodore", "Theresa", "Therese", "Theresia", "Theron", "Thomas", "Thora", "Thurman", "Tia", "Tiana", "Tianna", "Tiara", "Tierra", "Tiffany", "Tillman", "Timmothy", "Timmy", "Timothy", "Tina", "Tito", "Titus", "Tobin", "Toby", "Tod", "Tom", "Tomas", "Tomasa", "Tommie", "Toney", "Toni", "Tony", "Torey", "Torrance", "Torrey", "Toy", "Trace", "Tracey", "Tracy", "Travis", "Travon", "Tre", "Tremaine", "Tremayne", "Trent", "Trenton", "Tressa", "Tressie", "Treva", "Trever", "Trevion", "Trevor", "Trey", "Trinity", "Trisha", "Tristian", "Tristin", "Triston", "Troy", "Trudie", "Trycia", "Trystan", "Turner", "Twila", "Tyler", "Tyra", "Tyree", "Tyreek", "Tyrel", "Tyrell", "Tyrese", "Tyrique", "Tyshawn", "Tyson", "Ubaldo", "Ulices", "Ulises", "Una", "Unique", "Urban", "Uriah", "Uriel", "Ursula", "Vada", "Valentin", "Valentina", "Valentine", "Valerie", "Vallie", "Van", "Vance", "Vanessa", "Vaughn", "Veda", "Velda", "Vella", "Velma", "Velva", "Vena", "Verda", "Verdie", "Vergie", "Verla", "Verlie", "Vern", "Verna", "Verner", "Vernice", "Vernie", "Vernon", "Verona", "Veronica", "Vesta", "Vicenta", "Vicente", "Vickie", "Vicky", "Victor", "Victoria", "Vida", "Vidal", "Vilma", "Vince", "Vincent", "Vincenza", "Vincenzo", "Vinnie", "Viola", "Violet", "Violette", "Virgie", "Virgil", "Virginia", "Virginie", "Vita", "Vito", "Viva", "Vivian", "Viviane", "Vivianne", "Vivien", "Vivienne", "Vladimir", "Wade", "Waino", "Waldo", "Walker", "Wallace", "Walter", "Walton", "Wanda", "Ward", "Warren", "Watson", "Wava", "Waylon", "Wayne", "Webster", "Weldon", "Wellington", "Wendell", "Wendy", "Werner", "Westley", "Weston", "Whitney", "Wilber", "Wilbert", "Wilburn", "Wiley", "Wilford", "Wilfred", "Wilfredo", "Wilfrid", "Wilhelm", "Wilhelmine", "Will", "Willa", "Willard", "William", "Willie", "Willis", "Willow", "Willy", "Wilma", "Wilmer", "Wilson", "Wilton", "Winfield", "Winifred", "Winnifred", "Winona", "Winston", "Woodrow", "Wyatt", "Wyman", "Xander", "Xavier", "Xzavier", "Yadira", "Yasmeen", "Yasmin", "Yasmine", "Yazmin", "Yesenia", "Yessenia", "Yolanda", "Yoshiko", "Yvette", "Yvonne", "Zachariah", "Zachary", "Zachery", "Zack", "Zackary", "Zackery", "Zakary", "Zander", "Zane", "Zaria", "Zechariah", "Zelda", "Zella", "Zelma", "Zena", "Zetta", "Zion", "Zita", "Zoe", "Zoey", "Zoie", "Zoila", "Zola", "Zora", "Zula"];
                e.exports = {
                    generateUsername: function() {
                        return `${i.randomElement(r)}-${i.randomAlphanumStr(3)}`
                    }
                }
            },
            32: (e, t) => {
                "use strict";
                const n = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/;
                t.parse = function(e) {
                    const i = "object" == typeof(arguments.length <= 1 ? void 0 : arguments[1]) && (arguments.length <= 1 ? void 0 : arguments[1]),
                        r = (arguments.length <= 1 ? 0 : arguments.length - 1) > 1 || !i ? arguments.length <= 1 ? void 0 : arguments[1] : void 0,
                        o = (arguments.length <= 1 ? 0 : arguments.length - 1) > 1 && (arguments.length <= 2 ? void 0 : arguments[2]) || i || {},
                        s = JSON.parse(e, r);
                    return "ignore" === o.protoAction ? s : s && "object" == typeof s && e.match(n) ? (t.scan(s, o), s) : s
                }, t.scan = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        n = [e];
                    for (; n.length;) {
                        const e = n;
                        n = [];
                        for (const i of e) {
                            if (Object.prototype.hasOwnProperty.call(i, "__proto__")) {
                                if ("remove" !== t.protoAction) throw new SyntaxError("Object contains forbidden prototype property");
                                delete i.__proto__
                            }
                            for (const e in i) {
                                const t = i[e];
                                t && "object" == typeof t && n.push(i[e])
                            }
                        }
                    }
                }, t.safeParse = function(e, n) {
                    try {
                        return t.parse(e, n)
                    } catch (e) {
                        return null
                    }
                }
            },
            122: function(e, t, n) {
                var i;
                ! function(r, o) {
                    "use strict";
                    var s = "function",
                        a = "undefined",
                        d = "object",
                        c = "string",
                        l = "major",
                        h = "model",
                        u = "name",
                        p = "type",
                        m = "vendor",
                        g = "version",
                        f = "architecture",
                        v = "console",
                        _ = "mobile",
                        y = "tablet",
                        E = "smarttv",
                        S = "wearable",
                        b = "embedded",
                        T = "Amazon",
                        C = "Apple",
                        x = "ASUS",
                        R = "BlackBerry",
                        A = "Browser",
                        w = "Chrome",
                        I = "Firefox",
                        P = "Google",
                        D = "Huawei",
                        O = "LG",
                        N = "Microsoft",
                        k = "Motorola",
                        M = "Opera",
                        L = "Samsung",
                        F = "Sharp",
                        j = "Sony",
                        V = "Xiaomi",
                        U = "Zebra",
                        H = "Facebook",
                        $ = "Chromium OS",
                        J = "Mac OS",
                        B = function(e) {
                            for (var t = {}, n = 0; n < e.length; n++) t[e[n].toUpperCase()] = e[n];
                            return t
                        },
                        q = function(e, t) {
                            return typeof e === c && -1 !== G(t).indexOf(G(e))
                        },
                        G = function(e) {
                            return e.toLowerCase()
                        },
                        z = function(e, t) {
                            if (typeof e === c) return e = e.replace(/^\s\s*/, ""), typeof t === a ? e : e.substring(0, 350)
                        },
                        K = function(e, t) {
                            for (var n, i, r, a, c, l, h = 0; h < t.length && !c;) {
                                var u = t[h],
                                    p = t[h + 1];
                                for (n = i = 0; n < u.length && !c && u[n];)
                                    if (c = u[n++].exec(e))
                                        for (r = 0; r < p.length; r++) l = c[++i], typeof(a = p[r]) === d && a.length > 0 ? 2 === a.length ? typeof a[1] == s ? this[a[0]] = a[1].call(this, l) : this[a[0]] = a[1] : 3 === a.length ? typeof a[1] !== s || a[1].exec && a[1].test ? this[a[0]] = l ? l.replace(a[1], a[2]) : o : this[a[0]] = l ? a[1].call(this, l, a[2]) : o : 4 === a.length && (this[a[0]] = l ? a[3].call(this, l.replace(a[1], a[2])) : o) : this[a] = l || o;
                                h += 2
                            }
                        },
                        W = function(e, t) {
                            for (var n in t)
                                if (typeof t[n] === d && t[n].length > 0) {
                                    for (var i = 0; i < t[n].length; i++)
                                        if (q(t[n][i], e)) return "?" === n ? o : n
                                } else if (q(t[n], e)) return "?" === n ? o : n;
                            return e
                        },
                        X = {
                            ME: "4.90",
                            "NT 3.11": "NT3.51",
                            "NT 4.0": "NT4.0",
                            2e3: "NT 5.0",
                            XP: ["NT 5.1", "NT 5.2"],
                            Vista: "NT 6.0",
                            7: "NT 6.1",
                            8: "NT 6.2",
                            8.1: "NT 6.3",
                            10: ["NT 6.4", "NT 10.0"],
                            RT: "ARM"
                        },
                        Y = {
                            browser: [
                                [/\b(?:crmo|crios)\/([\w\.]+)/i],
                                [g, [u, "Chrome"]],
                                [/edg(?:e|ios|a)?\/([\w\.]+)/i],
                                [g, [u, "Edge"]],
                                [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i],
                                [u, g],
                                [/opios[\/ ]+([\w\.]+)/i],
                                [g, [u, M + " Mini"]],
                                [/\bopr\/([\w\.]+)/i],
                                [g, [u, M]],
                                [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i],
                                [u, g],
                                [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],
                                [g, [u, "UC" + A]],
                                [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i],
                                [g, [u, "WeChat(Win) Desktop"]],
                                [/micromessenger\/([\w\.]+)/i],
                                [g, [u, "WeChat"]],
                                [/konqueror\/([\w\.]+)/i],
                                [g, [u, "Konqueror"]],
                                [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],
                                [g, [u, "IE"]],
                                [/ya(?:search)?browser\/([\w\.]+)/i],
                                [g, [u, "Yandex"]],
                                [/(avast|avg)\/([\w\.]+)/i],
                                [
                                    [u, /(.+)/, "$1 Secure " + A], g
                                ],
                                [/\bfocus\/([\w\.]+)/i],
                                [g, [u, I + " Focus"]],
                                [/\bopt\/([\w\.]+)/i],
                                [g, [u, M + " Touch"]],
                                [/coc_coc\w+\/([\w\.]+)/i],
                                [g, [u, "Coc Coc"]],
                                [/dolfin\/([\w\.]+)/i],
                                [g, [u, "Dolphin"]],
                                [/coast\/([\w\.]+)/i],
                                [g, [u, M + " Coast"]],
                                [/miuibrowser\/([\w\.]+)/i],
                                [g, [u, "MIUI " + A]],
                                [/fxios\/([-\w\.]+)/i],
                                [g, [u, I]],
                                [/\bqihu|(qi?ho?o?|360)browser/i],
                                [
                                    [u, "360 " + A]
                                ],
                                [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i],
                                [
                                    [u, /(.+)/, "$1 " + A], g
                                ],
                                [/(comodo_dragon)\/([\w\.]+)/i],
                                [
                                    [u, /_/g, " "], g
                                ],
                                [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i],
                                [u, g],
                                [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i],
                                [u],
                                [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],
                                [
                                    [u, H], g
                                ],
                                [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i],
                                [u, g],
                                [/\bgsa\/([\w\.]+) .*safari\//i],
                                [g, [u, "GSA"]],
                                [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i],
                                [g, [u, "TikTok"]],
                                [/headlesschrome(?:\/([\w\.]+)| )/i],
                                [g, [u, w + " Headless"]],
                                [/ wv\).+(chrome)\/([\w\.]+)/i],
                                [
                                    [u, w + " WebView"], g
                                ],
                                [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],
                                [g, [u, "Android " + A]],
                                [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],
                                [u, g],
                                [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],
                                [g, [u, "Mobile Safari"]],
                                [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],
                                [g, u],
                                [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],
                                [u, [g, W, {
                                    "1.0": "/8",
                                    1.2: "/1",
                                    1.3: "/3",
                                    "2.0": "/412",
                                    "2.0.2": "/416",
                                    "2.0.3": "/417",
                                    "2.0.4": "/419",
                                    "?": "/"
                                }]],
                                [/(webkit|khtml)\/([\w\.]+)/i],
                                [u, g],
                                [/(navigator|netscape\d?)\/([-\w\.]+)/i],
                                [
                                    [u, "Netscape"], g
                                ],
                                [/mobile vr; rv:([\w\.]+)\).+firefox/i],
                                [g, [u, I + " Reality"]],
                                [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i],
                                [u, g],
                                [/(cobalt)\/([\w\.]+)/i],
                                [u, [g, /master.|lts./, ""]]
                            ],
                            cpu: [
                                [/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],
                                [
                                    [f, "amd64"]
                                ],
                                [/(ia32(?=;))/i],
                                [
                                    [f, G]
                                ],
                                [/((?:i[346]|x)86)[;\)]/i],
                                [
                                    [f, "ia32"]
                                ],
                                [/\b(aarch64|arm(v?8e?l?|_?64))\b/i],
                                [
                                    [f, "arm64"]
                                ],
                                [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],
                                [
                                    [f, "armhf"]
                                ],
                                [/windows (ce|mobile); ppc;/i],
                                [
                                    [f, "arm"]
                                ],
                                [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],
                                [
                                    [f, /ower/, "", G]
                                ],
                                [/(sun4\w)[;\)]/i],
                                [
                                    [f, "sparc"]
                                ],
                                [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i],
                                [
                                    [f, G]
                                ]
                            ],
                            device: [
                                [/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i],
                                [h, [m, L],
                                    [p, y]
                                ],
                                [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i],
                                [h, [m, L],
                                    [p, _]
                                ],
                                [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i],
                                [h, [m, C],
                                    [p, _]
                                ],
                                [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i],
                                [h, [m, C],
                                    [p, y]
                                ],
                                [/(macintosh);/i],
                                [h, [m, C]],
                                [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],
                                [h, [m, F],
                                    [p, _]
                                ],
                                [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],
                                [h, [m, D],
                                    [p, y]
                                ],
                                [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i],
                                [h, [m, D],
                                    [p, _]
                                ],
                                [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i],
                                [
                                    [h, /_/g, " "],
                                    [m, V],
                                    [p, _]
                                ],
                                [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],
                                [
                                    [h, /_/g, " "],
                                    [m, V],
                                    [p, y]
                                ],
                                [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i],
                                [h, [m, "OPPO"],
                                    [p, _]
                                ],
                                [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i],
                                [h, [m, "Vivo"],
                                    [p, _]
                                ],
                                [/\b(rmx[12]\d{3})(?: bui|;|\))/i],
                                [h, [m, "Realme"],
                                    [p, _]
                                ],
                                [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i],
                                [h, [m, k],
                                    [p, _]
                                ],
                                [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
                                [h, [m, k],
                                    [p, y]
                                ],
                                [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],
                                [h, [m, O],
                                    [p, y]
                                ],
                                [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i],
                                [h, [m, O],
                                    [p, _]
                                ],
                                [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i],
                                [h, [m, "Lenovo"],
                                    [p, y]
                                ],
                                [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i],
                                [
                                    [h, /_/g, " "],
                                    [m, "Nokia"],
                                    [p, _]
                                ],
                                [/(pixel c)\b/i],
                                [h, [m, P],
                                    [p, y]
                                ],
                                [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],
                                [h, [m, P],
                                    [p, _]
                                ],
                                [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i],
                                [h, [m, j],
                                    [p, _]
                                ],
                                [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i],
                                [
                                    [h, "Xperia Tablet"],
                                    [m, j],
                                    [p, y]
                                ],
                                [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i],
                                [h, [m, "OnePlus"],
                                    [p, _]
                                ],
                                [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i],
                                [h, [m, T],
                                    [p, y]
                                ],
                                [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],
                                [
                                    [h, /(.+)/g, "Fire Phone $1"],
                                    [m, T],
                                    [p, _]
                                ],
                                [/(playbook);[-\w\),; ]+(rim)/i],
                                [h, m, [p, y]],
                                [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i],
                                [h, [m, R],
                                    [p, _]
                                ],
                                [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i],
                                [h, [m, x],
                                    [p, y]
                                ],
                                [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
                                [h, [m, x],
                                    [p, _]
                                ],
                                [/(nexus 9)/i],
                                [h, [m, "HTC"],
                                    [p, y]
                                ],
                                [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i],
                                [m, [h, /_/g, " "],
                                    [p, _]
                                ],
                                [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],
                                [h, [m, "Acer"],
                                    [p, y]
                                ],
                                [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i],
                                [h, [m, "Meizu"],
                                    [p, _]
                                ],
                                [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i],
                                [m, h, [p, _]],
                                [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i],
                                [m, h, [p, y]],
                                [/(surface duo)/i],
                                [h, [m, N],
                                    [p, y]
                                ],
                                [/droid [\d\.]+; (fp\du?)(?: b|\))/i],
                                [h, [m, "Fairphone"],
                                    [p, _]
                                ],
                                [/(u304aa)/i],
                                [h, [m, "AT&T"],
                                    [p, _]
                                ],
                                [/\bsie-(\w*)/i],
                                [h, [m, "Siemens"],
                                    [p, _]
                                ],
                                [/\b(rct\w+) b/i],
                                [h, [m, "RCA"],
                                    [p, y]
                                ],
                                [/\b(venue[\d ]{2,7}) b/i],
                                [h, [m, "Dell"],
                                    [p, y]
                                ],
                                [/\b(q(?:mv|ta)\w+) b/i],
                                [h, [m, "Verizon"],
                                    [p, y]
                                ],
                                [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],
                                [h, [m, "Barnes & Noble"],
                                    [p, y]
                                ],
                                [/\b(tm\d{3}\w+) b/i],
                                [h, [m, "NuVision"],
                                    [p, y]
                                ],
                                [/\b(k88) b/i],
                                [h, [m, "ZTE"],
                                    [p, y]
                                ],
                                [/\b(nx\d{3}j) b/i],
                                [h, [m, "ZTE"],
                                    [p, _]
                                ],
                                [/\b(gen\d{3}) b.+49h/i],
                                [h, [m, "Swiss"],
                                    [p, _]
                                ],
                                [/\b(zur\d{3}) b/i],
                                [h, [m, "Swiss"],
                                    [p, y]
                                ],
                                [/\b((zeki)?tb.*\b) b/i],
                                [h, [m, "Zeki"],
                                    [p, y]
                                ],
                                [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i],
                                [
                                    [m, "Dragon Touch"], h, [p, y]
                                ],
                                [/\b(ns-?\w{0,9}) b/i],
                                [h, [m, "Insignia"],
                                    [p, y]
                                ],
                                [/\b((nxa|next)-?\w{0,9}) b/i],
                                [h, [m, "NextBook"],
                                    [p, y]
                                ],
                                [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],
                                [
                                    [m, "Voice"], h, [p, _]
                                ],
                                [/\b(lvtel\-)?(v1[12]) b/i],
                                [
                                    [m, "LvTel"], h, [p, _]
                                ],
                                [/\b(ph-1) /i],
                                [h, [m, "Essential"],
                                    [p, _]
                                ],
                                [/\b(v(100md|700na|7011|917g).*\b) b/i],
                                [h, [m, "Envizen"],
                                    [p, y]
                                ],
                                [/\b(trio[-\w\. ]+) b/i],
                                [h, [m, "MachSpeed"],
                                    [p, y]
                                ],
                                [/\btu_(1491) b/i],
                                [h, [m, "Rotor"],
                                    [p, y]
                                ],
                                [/(shield[\w ]+) b/i],
                                [h, [m, "Nvidia"],
                                    [p, y]
                                ],
                                [/(sprint) (\w+)/i],
                                [m, h, [p, _]],
                                [/(kin\.[onetw]{3})/i],
                                [
                                    [h, /\./g, " "],
                                    [m, N],
                                    [p, _]
                                ],
                                [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],
                                [h, [m, U],
                                    [p, y]
                                ],
                                [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
                                [h, [m, U],
                                    [p, _]
                                ],
                                [/smart-tv.+(samsung)/i],
                                [m, [p, E]],
                                [/hbbtv.+maple;(\d+)/i],
                                [
                                    [h, /^/, "SmartTV"],
                                    [m, L],
                                    [p, E]
                                ],
                                [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],
                                [
                                    [m, O],
                                    [p, E]
                                ],
                                [/(apple) ?tv/i],
                                [m, [h, C + " TV"],
                                    [p, E]
                                ],
                                [/crkey/i],
                                [
                                    [h, w + "cast"],
                                    [m, P],
                                    [p, E]
                                ],
                                [/droid.+aft(\w)( bui|\))/i],
                                [h, [m, T],
                                    [p, E]
                                ],
                                [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i],
                                [h, [m, F],
                                    [p, E]
                                ],
                                [/(bravia[\w ]+)( bui|\))/i],
                                [h, [m, j],
                                    [p, E]
                                ],
                                [/(mitv-\w{5}) bui/i],
                                [h, [m, V],
                                    [p, E]
                                ],
                                [/Hbbtv.*(technisat) (.*);/i],
                                [m, h, [p, E]],
                                [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i],
                                [
                                    [m, z],
                                    [h, z],
                                    [p, E]
                                ],
                                [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],
                                [
                                    [p, E]
                                ],
                                [/(ouya)/i, /(nintendo) ([wids3utch]+)/i],
                                [m, h, [p, v]],
                                [/droid.+; (shield) bui/i],
                                [h, [m, "Nvidia"],
                                    [p, v]
                                ],
                                [/(playstation [345portablevi]+)/i],
                                [h, [m, j],
                                    [p, v]
                                ],
                                [/\b(xbox(?: one)?(?!; xbox))[\); ]/i],
                                [h, [m, N],
                                    [p, v]
                                ],
                                [/((pebble))app/i],
                                [m, h, [p, S]],
                                [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i],
                                [h, [m, C],
                                    [p, S]
                                ],
                                [/droid.+; (glass) \d/i],
                                [h, [m, P],
                                    [p, S]
                                ],
                                [/droid.+; (wt63?0{2,3})\)/i],
                                [h, [m, U],
                                    [p, S]
                                ],
                                [/(quest( 2| pro)?)/i],
                                [h, [m, H],
                                    [p, S]
                                ],
                                [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],
                                [m, [p, b]],
                                [/(aeobc)\b/i],
                                [h, [m, T],
                                    [p, b]
                                ],
                                [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i],
                                [h, [p, _]],
                                [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],
                                [h, [p, y]],
                                [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],
                                [
                                    [p, y]
                                ],
                                [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i],
                                [
                                    [p, _]
                                ],
                                [/(android[-\w\. ]{0,9});.+buil/i],
                                [h, [m, "Generic"]]
                            ],
                            engine: [
                                [/windows.+ edge\/([\w\.]+)/i],
                                [g, [u, "EdgeHTML"]],
                                [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],
                                [g, [u, "Blink"]],
                                [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i],
                                [u, g],
                                [/rv\:([\w\.]{1,9})\b.+(gecko)/i],
                                [g, u]
                            ],
                            os: [
                                [/microsoft (windows) (vista|xp)/i],
                                [u, g],
                                [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i],
                                [u, [g, W, X]],
                                [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i],
                                [
                                    [u, "Windows"],
                                    [g, W, X]
                                ],
                                [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /ios;fbsv\/([\d\.]+)/i, /cfnetwork\/.+darwin/i],
                                [
                                    [g, /_/g, "."],
                                    [u, "iOS"]
                                ],
                                [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i],
                                [
                                    [u, J],
                                    [g, /_/g, "."]
                                ],
                                [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],
                                [g, u],
                                [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i],
                                [u, g],
                                [/\(bb(10);/i],
                                [g, [u, R]],
                                [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],
                                [g, [u, "Symbian"]],
                                [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i],
                                [g, [u, I + " OS"]],
                                [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],
                                [g, [u, "webOS"]],
                                [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i],
                                [g, [u, "watchOS"]],
                                [/crkey\/([\d\.]+)/i],
                                [g, [u, w + "cast"]],
                                [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i],
                                [
                                    [u, $], g
                                ],
                                [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i],
                                [u, g],
                                [/(sunos) ?([\w\.\d]*)/i],
                                [
                                    [u, "Solaris"], g
                                ],
                                [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i],
                                [u, g]
                            ]
                        },
                        Q = function(e, t) {
                            if (typeof e === d && (t = e, e = o), !(this instanceof Q)) return new Q(e, t).getResult();
                            var n = typeof r !== a && r.navigator ? r.navigator : o,
                                i = e || (n && n.userAgent ? n.userAgent : ""),
                                v = n && n.userAgentData ? n.userAgentData : o,
                                E = t ? function(e, t) {
                                    var n = {};
                                    for (var i in e) t[i] && t[i].length % 2 == 0 ? n[i] = t[i].concat(e[i]) : n[i] = e[i];
                                    return n
                                }(Y, t) : Y,
                                S = n && n.userAgent == i;
                            return this.getBrowser = function() {
                                var e, t = {};
                                return t[u] = o, t[g] = o, K.call(t, i, E.browser), t[l] = typeof(e = t[g]) === c ? e.replace(/[^\d\.]/g, "").split(".")[0] : o, S && n && n.brave && typeof n.brave.isBrave == s && (t[u] = "Brave"), t
                            }, this.getCPU = function() {
                                var e = {};
                                return e[f] = o, K.call(e, i, E.cpu), e
                            }, this.getDevice = function() {
                                var e = {};
                                return e[m] = o, e[h] = o, e[p] = o, K.call(e, i, E.device), S && !e[p] && v && v.mobile && (e[p] = _), S && "Macintosh" == e[h] && n && typeof n.standalone !== a && n.maxTouchPoints && n.maxTouchPoints > 2 && (e[h] = "iPad", e[p] = y), e
                            }, this.getEngine = function() {
                                var e = {};
                                return e[u] = o, e[g] = o, K.call(e, i, E.engine), e
                            }, this.getOS = function() {
                                var e = {};
                                return e[u] = o, e[g] = o, K.call(e, i, E.os), S && !e[u] && v && "Unknown" != v.platform && (e[u] = v.platform.replace(/chrome os/i, $).replace(/macos/i, J)), e
                            }, this.getResult = function() {
                                return {
                                    ua: this.getUA(),
                                    browser: this.getBrowser(),
                                    engine: this.getEngine(),
                                    os: this.getOS(),
                                    device: this.getDevice(),
                                    cpu: this.getCPU()
                                }
                            }, this.getUA = function() {
                                return i
                            }, this.setUA = function(e) {
                                return i = typeof e === c && e.length > 350 ? z(e, 350) : e, this
                            }, this.setUA(i), this
                        };
                    Q.VERSION = "1.0.35", Q.BROWSER = B([u, g, l]), Q.CPU = B([f]), Q.DEVICE = B([h, m, p, v, _, E, y, S, b]), Q.ENGINE = Q.OS = B([u, g]), typeof t !== a ? (e.exports && (t = e.exports = Q), t.UAParser = Q) : n.amdO ? (i = function() {
                        return Q
                    }.call(t, n, t, e)) === o || (e.exports = i) : typeof r !== a && (r.UAParser = Q);
                    var Z = typeof r !== a && (r.jQuery || r.Zepto);
                    if (Z && !Z.ua) {
                        var ee = new Q;
                        Z.ua = ee.getResult(), Z.ua.get = function() {
                            return ee.getUA()
                        }, Z.ua.set = function(e) {
                            ee.setUA(e);
                            var t = ee.getResult();
                            for (var n in t) Z.ua[n] = t[n]
                        }
                    }
                }("object" == typeof window ? window : this)
            },
            505: (e, t, n) => {
                var i = n(350);

                function r(e, t) {
                    this.logStorage = e, this.stringifyObjects = !(!t || !t.stringifyObjects) && t.stringifyObjects, this.storeInterval = t && t.storeInterval ? t.storeInterval : 3e4, this.maxEntryLength = t && t.maxEntryLength ? t.maxEntryLength : 1e4, Object.values(i.levels).forEach(function(e) {
                        this[e] = function() {
                            this._log.apply(this, arguments)
                        }.bind(this, e)
                    }.bind(this)), this.storeLogsIntervalID = null, this.queue = [], this.totalLen = 0, this.outputCache = []
                }
                r.prototype.stringify = function(e) {
                    try {
                        return JSON.stringify(e)
                    } catch (e) {
                        return "[object with circular refs?]"
                    }
                }, r.prototype.formatLogMessage = function(e) {
                    for (var t = "", n = 1, i = arguments.length; n < i; n++) {
                        var r = arguments[n];
                        r instanceof Error ? t += r.toString() + ": " + r.stack : this.stringifyObjects && "object" == typeof r ? t += this.stringify(r) : t += r, n !== i - 1 && (t += " ")
                    }
                    return t.length ? t : null
                }, r.prototype._log = function() {
                    var e = arguments[1],
                        t = this.formatLogMessage.apply(this, arguments);
                    if (t) {
                        var n = this.queue[this.queue.length - 1];
                        (n && n.text) === t ? n.count += 1 : (this.queue.push({
                            text: t,
                            timestamp: e,
                            count: 1
                        }), this.totalLen += t.length)
                    }
                    this.totalLen >= this.maxEntryLength && this._flush(!0, !0)
                }, r.prototype.start = function() {
                    this._reschedulePublishInterval()
                }, r.prototype._reschedulePublishInterval = function() {
                    this.storeLogsIntervalID && (window.clearTimeout(this.storeLogsIntervalID), this.storeLogsIntervalID = null), this.storeLogsIntervalID = window.setTimeout(this._flush.bind(this, !1, !0), this.storeInterval)
                }, r.prototype.flush = function() {
                    this._flush(!1, !0)
                }, r.prototype._storeLogs = function(e) {
                    try {
                        this.logStorage.storeLogs(e)
                    } catch (e) {
                        console.error("LogCollector error when calling logStorage.storeLogs(): ", e)
                    }
                }, r.prototype._flush = function(e, t) {
                    var n = !1;
                    try {
                        n = this.logStorage.isReady()
                    } catch (e) {
                        console.error("LogCollector error when calling logStorage.isReady(): ", e)
                    }
                    this.totalLen > 0 && (n || e) && (n ? (this.outputCache.length && (this.outputCache.forEach(function(e) {
                        this._storeLogs(e)
                    }.bind(this)), this.outputCache = []), this._storeLogs(this.queue)) : this.outputCache.push(this.queue), this.queue = [], this.totalLen = 0), t && this._reschedulePublishInterval()
                }, r.prototype.stop = function() {
                    this._flush(!1, !1)
                }, e.exports = r
            },
            350: e => {
                var t = {
                    trace: 0,
                    debug: 1,
                    info: 2,
                    log: 3,
                    warn: 4,
                    error: 5
                };
                o.consoleTransport = console;
                var n = [o.consoleTransport];
                o.addGlobalTransport = function(e) {
                    -1 === n.indexOf(e) && n.push(e)
                }, o.removeGlobalTransport = function(e) {
                    var t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                };
                var i = {};

                function r() {
                    var e = arguments[0],
                        r = arguments[1],
                        o = Array.prototype.slice.call(arguments, 2);
                    if (!(t[r] < e.level))
                        for (var s = !(e.options.disableCallerInfo || i.disableCallerInfo) && function() {
                                var e = {
                                        methodName: "",
                                        fileLocation: "",
                                        line: null,
                                        column: null
                                    },
                                    t = new Error,
                                    n = t.stack ? t.stack.split("\n") : [];
                                if (!n || n.length < 3) return e;
                                var i = null;
                                return n[3] && (i = n[3].match(/\s*at\s*(.+?)\s*\((\S*)\s*:(\d*)\s*:(\d*)\)/)), !i || i.length <= 4 ? (0 === n[2].indexOf("log@") ? e.methodName = n[3].substr(0, n[3].indexOf("@")) : e.methodName = n[2].substr(0, n[2].indexOf("@")), e) : (e.methodName = i[1], e.fileLocation = i[2], e.line = i[3], e.column = i[4], e)
                            }(), a = n.concat(e.transports), d = 0; d < a.length; d++) {
                            var c = a[d],
                                l = c[r];
                            if (l && "function" == typeof l) {
                                var h = [];
                                h.push((new Date).toISOString()), e.id && h.push("[" + e.id + "]"), s && s.methodName.length > 1 && h.push("<" + s.methodName + ">: ");
                                var u = h.concat(o);
                                try {
                                    l.bind(c).apply(c, u)
                                } catch (e) {
                                    console.error("An error occured when trying to log with one of the available transports", e)
                                }
                            }
                        }
                }

                function o(e, n, i, o) {
                    this.id = n, this.options = o || {}, this.transports = i, this.transports || (this.transports = []), this.level = t[e];
                    for (var s = Object.keys(t), a = 0; a < s.length; a++) this[s[a]] = r.bind(null, this, s[a])
                }
                o.setGlobalOptions = function(e) {
                    i = e || {}
                }, o.prototype.setLevel = function(e) {
                    this.level = t[e]
                }, e.exports = o, o.levels = {
                    TRACE: "trace",
                    DEBUG: "debug",
                    INFO: "info",
                    LOG: "log",
                    WARN: "warn",
                    ERROR: "error"
                }
            },
            810: (e, t, n) => {
                var i = n(350),
                    r = n(505),
                    o = {},
                    s = [],
                    a = i.levels.TRACE;
                e.exports = {
                    addGlobalTransport: function(e) {
                        i.addGlobalTransport(e)
                    },
                    removeGlobalTransport: function(e) {
                        i.removeGlobalTransport(e)
                    },
                    setGlobalOptions: function(e) {
                        i.setGlobalOptions(e)
                    },
                    getLogger: function(e, t, n) {
                        var r = new i(a, e, t, n);
                        return e ? (o[e] = o[e] || [], o[e].push(r)) : s.push(r), r
                    },
                    getUntrackedLogger: function(e, t, n) {
                        return new i(a, e, t, n)
                    },
                    setLogLevelById: function(e, t) {
                        for (var n = t ? o[t] || [] : s, i = 0; i < n.length; i++) n[i].setLevel(e)
                    },
                    setLogLevel: function(e) {
                        a = e;
                        for (var t = 0; t < s.length; t++) s[t].setLevel(e);
                        for (var n in o) {
                            var i = o[n] || [];
                            for (t = 0; t < i.length; t++) i[t].setLevel(e)
                        }
                    },
                    levels: i.levels,
                    LogCollector: r
                }
            },
            22: e => {
                var t = e.exports = {
                    v: [{
                        name: "version",
                        reg: /^(\d*)$/
                    }],
                    o: [{
                        name: "origin",
                        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                        names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
                        format: "%s %s %d %s IP%d %s"
                    }],
                    s: [{
                        name: "name"
                    }],
                    i: [{
                        name: "description"
                    }],
                    u: [{
                        name: "uri"
                    }],
                    e: [{
                        name: "email"
                    }],
                    p: [{
                        name: "phone"
                    }],
                    z: [{
                        name: "timezones"
                    }],
                    r: [{
                        name: "repeats"
                    }],
                    t: [{
                        name: "timing",
                        reg: /^(\d*) (\d*)/,
                        names: ["start", "stop"],
                        format: "%d %d"
                    }],
                    c: [{
                        name: "connection",
                        reg: /^IN IP(\d) (\S*)/,
                        names: ["version", "ip"],
                        format: "IN IP%d %s"
                    }],
                    b: [{
                        push: "bandwidth",
                        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                        names: ["type", "limit"],
                        format: "%s:%s"
                    }],
                    m: [{
                        reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
                        names: ["type", "port", "protocol", "payloads"],
                        format: "%s %d %s %s"
                    }],
                    a: [{
                        push: "rtp",
                        reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
                        names: ["payload", "codec", "rate", "encoding"],
                        format: function(e) {
                            return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
                        }
                    }, {
                        push: "fmtp",
                        reg: /^fmtp:(\d*) ([\S| ]*)/,
                        names: ["payload", "config"],
                        format: "fmtp:%d %s"
                    }, {
                        name: "control",
                        reg: /^control:(.*)/,
                        format: "control:%s"
                    }, {
                        name: "rtcp",
                        reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                        names: ["port", "netType", "ipVer", "address"],
                        format: function(e) {
                            return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
                        }
                    }, {
                        push: "rtcpFbTrrInt",
                        reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                        names: ["payload", "value"],
                        format: "rtcp-fb:%s trr-int %d"
                    }, {
                        push: "rtcpFb",
                        reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                        names: ["payload", "type", "subtype"],
                        format: function(e) {
                            return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
                        }
                    }, {
                        push: "ext",
                        reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
                        names: ["value", "direction", "encrypt-uri", "uri", "config"],
                        format: function(e) {
                            return "extmap:%d" + (e.direction ? "/%s" : "%v") + (e["encrypt-uri"] ? " %s" : "%v") + " %s" + (e.config ? " %s" : "")
                        }
                    }, {
                        name: "extmapAllowMixed",
                        reg: /^(extmap-allow-mixed)/
                    }, {
                        push: "crypto",
                        reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                        names: ["id", "suite", "config", "sessionConfig"],
                        format: function(e) {
                            return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
                        }
                    }, {
                        name: "setup",
                        reg: /^setup:(\w*)/,
                        format: "setup:%s"
                    }, {
                        name: "connectionType",
                        reg: /^connection:(new|existing)/,
                        format: "connection:%s"
                    }, {
                        name: "mid",
                        reg: /^mid:([^\s]*)/,
                        format: "mid:%s"
                    }, {
                        name: "msid",
                        reg: /^msid:(.*)/,
                        format: "msid:%s"
                    }, {
                        name: "ptime",
                        reg: /^ptime:(\d*(?:\.\d*)*)/,
                        format: "ptime:%d"
                    }, {
                        name: "maxptime",
                        reg: /^maxptime:(\d*(?:\.\d*)*)/,
                        format: "maxptime:%d"
                    }, {
                        name: "direction",
                        reg: /^(sendrecv|recvonly|sendonly|inactive)/
                    }, {
                        name: "icelite",
                        reg: /^(ice-lite)/
                    }, {
                        name: "iceUfrag",
                        reg: /^ice-ufrag:(\S*)/,
                        format: "ice-ufrag:%s"
                    }, {
                        name: "icePwd",
                        reg: /^ice-pwd:(\S*)/,
                        format: "ice-pwd:%s"
                    }, {
                        name: "fingerprint",
                        reg: /^fingerprint:(\S*) (\S*)/,
                        names: ["type", "hash"],
                        format: "fingerprint:%s %s"
                    }, {
                        push: "candidates",
                        reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
                        names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
                        format: function(e) {
                            var t = "candidate:%s %d %s %d %s %d typ %s";
                            return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), (t += null != e["network-id"] ? " network-id %d" : "%v") + (null != e["network-cost"] ? " network-cost %d" : "%v")
                        }
                    }, {
                        name: "endOfCandidates",
                        reg: /^(end-of-candidates)/
                    }, {
                        name: "remoteCandidates",
                        reg: /^remote-candidates:(.*)/,
                        format: "remote-candidates:%s"
                    }, {
                        name: "iceOptions",
                        reg: /^ice-options:(\S*)/,
                        format: "ice-options:%s"
                    }, {
                        push: "ssrcs",
                        reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
                        names: ["id", "attribute", "value"],
                        format: function(e) {
                            var t = "ssrc:%d";
                            return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
                        }
                    }, {
                        push: "ssrcGroups",
                        reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
                        names: ["semantics", "ssrcs"],
                        format: "ssrc-group:%s %s"
                    }, {
                        name: "msidSemantic",
                        reg: /^msid-semantic:\s?(\w*) (\S*)/,
                        names: ["semantic", "token"],
                        format: "msid-semantic: %s %s"
                    }, {
                        push: "groups",
                        reg: /^group:(\w*) (.*)/,
                        names: ["type", "mids"],
                        format: "group:%s %s"
                    }, {
                        name: "rtcpMux",
                        reg: /^(rtcp-mux)/
                    }, {
                        name: "rtcpRsize",
                        reg: /^(rtcp-rsize)/
                    }, {
                        name: "sctpmap",
                        reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
                        names: ["sctpmapNumber", "app", "maxMessageSize"],
                        format: function(e) {
                            return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
                        }
                    }, {
                        name: "xGoogleFlag",
                        reg: /^x-google-flag:([^\s]*)/,
                        format: "x-google-flag:%s"
                    }, {
                        push: "rids",
                        reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
                        names: ["id", "direction", "params"],
                        format: function(e) {
                            return e.params ? "rid:%s %s %s" : "rid:%s %s"
                        }
                    }, {
                        push: "imageattrs",
                        reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
                        names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
                        format: function(e) {
                            return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
                        }
                    }, {
                        name: "simulcast",
                        reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
                        names: ["dir1", "list1", "dir2", "list2"],
                        format: function(e) {
                            return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
                        }
                    }, {
                        name: "simulcast_03",
                        reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
                        names: ["value"],
                        format: "simulcast: %s"
                    }, {
                        name: "framerate",
                        reg: /^framerate:(\d+(?:$|\.\d+))/,
                        format: "framerate:%s"
                    }, {
                        name: "sourceFilter",
                        reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
                        names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
                        format: "source-filter: %s %s %s %s %s"
                    }, {
                        name: "bundleOnly",
                        reg: /^(bundle-only)/
                    }, {
                        name: "label",
                        reg: /^label:(.+)/,
                        format: "label:%s"
                    }, {
                        name: "sctpPort",
                        reg: /^sctp-port:(\d+)$/,
                        format: "sctp-port:%s"
                    }, {
                        name: "maxMessageSize",
                        reg: /^max-message-size:(\d+)$/,
                        format: "max-message-size:%s"
                    }, {
                        push: "tsRefClocks",
                        reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
                        names: ["clksrc", "clksrcExt"],
                        format: function(e) {
                            return "ts-refclk:%s" + (null != e.clksrcExt ? "=%s" : "")
                        }
                    }, {
                        name: "mediaClk",
                        reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
                        names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
                        format: function(e) {
                            var t = "mediaclk:";
                            return t += null != e.id ? "id=%s %s" : "%v%s", t += null != e.mediaClockValue ? "=%s" : "", (t += null != e.rateNumerator ? " rate=%s" : "") + (null != e.rateDenominator ? "/%s" : "")
                        }
                    }, {
                        name: "keywords",
                        reg: /^keywds:(.+)$/,
                        format: "keywds:%s"
                    }, {
                        name: "content",
                        reg: /^content:(.+)/,
                        format: "content:%s"
                    }, {
                        name: "bfcpFloorCtrl",
                        reg: /^floorctrl:(c-only|s-only|c-s)/,
                        format: "floorctrl:%s"
                    }, {
                        name: "bfcpConfId",
                        reg: /^confid:(\d+)/,
                        format: "confid:%s"
                    }, {
                        name: "bfcpUserId",
                        reg: /^userid:(\d+)/,
                        format: "userid:%s"
                    }, {
                        name: "bfcpFloorId",
                        reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
                        names: ["id", "mStream"],
                        format: "floorid:%s mstrm:%s"
                    }, {
                        push: "invalid",
                        names: ["value"]
                    }]
                };
                Object.keys(t).forEach((function(e) {
                    t[e].forEach((function(e) {
                        e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
                    }))
                }))
            },
            561: (e, t, n) => {
                var i = n(92),
                    r = n(508);
                t.write = r, t.parse = i.parse, t.parseParams = i.parseParams, t.parseFmtpConfig = i.parseFmtpConfig, t.parsePayloads = i.parsePayloads, t.parseRemoteCandidates = i.parseRemoteCandidates, t.parseImageAttributes = i.parseImageAttributes, t.parseSimulcastStreamList = i.parseSimulcastStreamList
            },
            92: (e, t, n) => {
                var i = function(e) {
                        return String(Number(e)) === e ? Number(e) : e
                    },
                    r = function(e, t, n) {
                        var r = e.name && e.names;
                        e.push && !t[e.push] ? t[e.push] = [] : r && !t[e.name] && (t[e.name] = {});
                        var o = e.push ? {} : r ? t[e.name] : t;
                        ! function(e, t, n, r) {
                            if (r && !n) t[r] = i(e[1]);
                            else
                                for (var o = 0; o < n.length; o += 1) null != e[o + 1] && (t[n[o]] = i(e[o + 1]))
                        }(n.match(e.reg), o, e.names, e.name), e.push && t[e.push].push(o)
                    },
                    o = n(22),
                    s = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
                t.parse = function(e) {
                    var t = {},
                        n = [],
                        i = t;
                    return e.split(/(\r\n|\r|\n)/).filter(s).forEach((function(e) {
                        var t = e[0],
                            s = e.slice(2);
                        "m" === t && (n.push({
                            rtp: [],
                            fmtp: []
                        }), i = n[n.length - 1]);
                        for (var a = 0; a < (o[t] || []).length; a += 1) {
                            var d = o[t][a];
                            if (d.reg.test(s)) return r(d, i, s)
                        }
                    })), t.media = n, t
                };
                var a = function(e, t) {
                    var n = t.split(/=(.+)/, 2);
                    return 2 === n.length ? e[n[0]] = i(n[1]) : 1 === n.length && t.length > 1 && (e[n[0]] = void 0), e
                };
                t.parseParams = function(e) {
                    return e.split(/;\s?/).reduce(a, {})
                }, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
                    return e.toString().split(" ").map(Number)
                }, t.parseRemoteCandidates = function(e) {
                    for (var t = [], n = e.split(" ").map(i), r = 0; r < n.length; r += 3) t.push({
                        component: n[r],
                        ip: n[r + 1],
                        port: n[r + 2]
                    });
                    return t
                }, t.parseImageAttributes = function(e) {
                    return e.split(" ").map((function(e) {
                        return e.substring(1, e.length - 1).split(",").reduce(a, {})
                    }))
                }, t.parseSimulcastStreamList = function(e) {
                    return e.split(";").map((function(e) {
                        return e.split(",").map((function(e) {
                            var t, n = !1;
                            return "~" !== e[0] ? t = i(e) : (t = i(e.substring(1, e.length)), n = !0), {
                                scid: t,
                                paused: n
                            }
                        }))
                    }))
                }
            },
            508: (e, t, n) => {
                var i = n(22),
                    r = /%[sdv%]/g,
                    o = function(e) {
                        var t = 1,
                            n = arguments,
                            i = n.length;
                        return e.replace(r, (function(e) {
                            if (t >= i) return e;
                            var r = n[t];
                            switch (t += 1, e) {
                                case "%%":
                                    return "%";
                                case "%s":
                                    return String(r);
                                case "%d":
                                    return Number(r);
                                case "%v":
                                    return ""
                            }
                        }))
                    },
                    s = function(e, t, n) {
                        var i = [e + "=" + (t.format instanceof Function ? t.format(t.push ? n : n[t.name]) : t.format)];
                        if (t.names)
                            for (var r = 0; r < t.names.length; r += 1) {
                                var s = t.names[r];
                                t.name ? i.push(n[t.name][s]) : i.push(n[t.names[r]])
                            } else i.push(n[t.name]);
                        return o.apply(null, i)
                    },
                    a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
                    d = ["i", "c", "b", "a"];
                e.exports = function(e, t) {
                    t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
                        null == e.payloads && (e.payloads = "")
                    }));
                    var n = t.outerOrder || a,
                        r = t.innerOrder || d,
                        o = [];
                    return n.forEach((function(t) {
                        i[t].forEach((function(n) {
                            n.name in e && null != e[n.name] ? o.push(s(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                                o.push(s(t, n, e))
                            }))
                        }))
                    })), e.media.forEach((function(e) {
                        o.push(s("m", i.m[0], e)), r.forEach((function(t) {
                            i[t].forEach((function(n) {
                                n.name in e && null != e[n.name] ? o.push(s(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                                    o.push(s(t, n, e))
                                }))
                            }))
                        }))
                    })), o.join("\r\n") + "\r\n"
                }
            },
            803: e => {
                self,
                e.exports = (() => {
                    var e = {
                            607: (e, t, n) => {
                                "use strict";
                                t.ap = t.Tk = t.Vk = t.b1 = t.zP = t.$j = t.dL = t.aM = t.vP = t.xt = t.Zt = t.UN = t.IO = t.zl = t.v6 = t.S1 = void 0, n(699);
                                var i = n(231);
                                t.S1 = function(e, t) {
                                    (0, i.initSDK)(e || {}, [""], t)
                                }, t.v6 = function(e) {
                                    (0, i.setConfig)(e)
                                }, t.zl = function(e) {}, t.IO = function(e, t) {
                                    (0, i.setUserRating)(e, t)
                                }, t.UN = function(e) {
                                    (0, i.addKeys)(e)
                                }, t.Zt = function() {
                                    (0, i.disableDataCollection)()
                                }, t.xt = function() {
                                    (0, i.enableDataCollection)()
                                }, t.vP = function(e) {
                                    (0, i.addEvent)(e)
                                }, t.aM = function(e, t) {
                                    (0, i.mapStream)(e, t)
                                }, t.dL = function(e, t) {
                                    (0, i.mapTrack)(e, t)
                                }, t.$j = function() {
                                    (0, i.connect)()
                                }, t.zP = function() {
                                    (0, i.disconnect)()
                                }, t.b1 = function(e) {
                                    (0, i.registerOnStatsListener)(e)
                                }, t.Vk = function(e) {
                                    (0, i.persistentEnd)(e)
                                }, t.Tk = function(e, t) {
                                    (0, i.persistentStart)(e, t)
                                }, t.ap = function(e) {
                                    (0, i.registerStateListener)(e)
                                }, t.default = {
                                    init: t.S1,
                                    addTags: t.zl,
                                    setUserRating: t.IO,
                                    addKeys: t.UN,
                                    setConfig: t.v6,
                                    disableDataCollection: t.Zt,
                                    enableDataCollection: t.xt,
                                    addEvent: t.vP,
                                    mapStream: t.aM,
                                    mapTrack: t.dL,
                                    connect: t.$j,
                                    disconnect: t.zP,
                                    addStatsListener: t.b1,
                                    persistentEnd: t.Vk,
                                    persistentStart: t.Tk,
                                    addStateListener: t.ap
                                }
                            },
                            231: function(e, t, n) {
                                "use strict";
                                var i = this && this.__assign || function() {
                                        return i = Object.assign || function(e) {
                                            for (var t, n = 1, i = arguments.length; n < i; n++)
                                                for (var r in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
                                            return e
                                        }, i.apply(this, arguments)
                                    },
                                    r = this && this.__awaiter || function(e, t, n, i) {
                                        return new(n || (n = Promise))((function(r, o) {
                                            function s(e) {
                                                try {
                                                    d(i.next(e))
                                                } catch (e) {
                                                    o(e)
                                                }
                                            }

                                            function a(e) {
                                                try {
                                                    d(i.throw(e))
                                                } catch (e) {
                                                    o(e)
                                                }
                                            }

                                            function d(e) {
                                                var t;
                                                e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                                                    e(t)
                                                }))).then(s, a)
                                            }
                                            d((i = i.apply(e, t || [])).next())
                                        }))
                                    },
                                    o = this && this.__generator || function(e, t) {
                                        var n, i, r, o, s = {
                                            label: 0,
                                            sent: function() {
                                                if (1 & r[0]) throw r[1];
                                                return r[1]
                                            },
                                            trys: [],
                                            ops: []
                                        };
                                        return o = {
                                            next: a(0),
                                            throw: a(1),
                                            return: a(2)
                                        }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
                                            return this
                                        }), o;

                                        function a(o) {
                                            return function(a) {
                                                return function(o) {
                                                    if (n) throw new TypeError("Generator is already executing.");
                                                    for (; s;) try {
                                                        if (n = 1, i && (r = 2 & o[0] ? i.return : o[0] ? i.throw || ((r = i.return) && r.call(i), 0) : i.next) && !(r = r.call(i, o[1])).done) return r;
                                                        switch (i = 0, r && (o = [2 & o[0], r.value]), o[0]) {
                                                            case 0:
                                                            case 1:
                                                                r = o;
                                                                break;
                                                            case 4:
                                                                return s.label++, {
                                                                    value: o[1],
                                                                    done: !1
                                                                };
                                                            case 5:
                                                                s.label++, i = o[1], o = [0];
                                                                continue;
                                                            case 7:
                                                                o = s.ops.pop(), s.trys.pop();
                                                                continue;
                                                            default:
                                                                if (!((r = (r = s.trys).length > 0 && r[r.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                                                    s = 0;
                                                                    continue
                                                                }
                                                                if (3 === o[0] && (!r || o[1] > r[0] && o[1] < r[3])) {
                                                                    s.label = o[1];
                                                                    break
                                                                }
                                                                if (6 === o[0] && s.label < r[1]) {
                                                                    s.label = r[1], r = o;
                                                                    break
                                                                }
                                                                if (r && s.label < r[2]) {
                                                                    s.label = r[2], s.ops.push(o);
                                                                    break
                                                                }
                                                                r[2] && s.ops.pop(), s.trys.pop();
                                                                continue
                                                        }
                                                        o = t.call(e, s)
                                                    } catch (e) {
                                                        o = [6, e], i = 0
                                                    } finally {
                                                        n = r = 0
                                                    }
                                                    if (5 & o[0]) throw o[1];
                                                    return {
                                                        value: o[0] ? o[1] : void 0,
                                                        done: !0
                                                    }
                                                }([o, a])
                                            }
                                        }
                                    },
                                    s = this && this.__spreadArray || function(e, t, n) {
                                        if (n || 2 === arguments.length)
                                            for (var i, r = 0, o = t.length; r < o; r++) !i && r in t || (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
                                        return e.concat(i || Array.prototype.slice.call(t))
                                    };
                                Object.defineProperty(t, "__esModule", {
                                    value: !0
                                }), t.persistentStart = t.persistentEnd = t.registerStateListener = t.registerOnStatsListener = t.disconnect = t.connect = t.mapTrack = t.mapStream = t.addEvent = t.enableDataCollection = t.disableDataCollection = t.addKeys = t.setUserRating = t.setConfig = t.initSDK = void 0;
                                var a, d, c, l, h, u, p = n(85),
                                    m = n(911),
                                    g = n(593),
                                    f = n(412),
                                    v = !!window.mozRTCPeerConnection,
                                    _ = (!v && window.RTCPeerConnection && window.navigator.webkitGetUserMedia, {}),
                                    y = 0,
                                    E = {},
                                    S = {
                                        rtcRoomId: void 0,
                                        rtcPeerId: void 0,
                                        projectId: void 0
                                    },
                                    b = null,
                                    T = null,
                                    C = null,
                                    x = 0,
                                    R = !1,
                                    A = !1,
                                    w = !1,
                                    I = !1,
                                    P = null,
                                    D = g.debugLog.bind(null, (function() {
                                        return null == b ? void 0 : b.debug
                                    })),
                                    O = {},
                                    N = function(e) {
                                        var t, n = e.forceRecreate,
                                            r = void 0 !== n && n,
                                            o = e.reconnecting,
                                            d = void 0 !== o && o,
                                            l = e.pcId,
                                            u = void 0 === l ? "PC_unknown" : l;
                                        if (D("info", "maybeOpenWebsocketConnection called: [".concat(u, "]"), {
                                                forceRecreate: r,
                                                reconnecting: d,
                                                isManualDisconnect: I,
                                                tryingToConnectSocket: R,
                                                watchrtcConfig: b,
                                                openChannels: JSON.stringify(_)
                                            }), I = !1, (null === (t = null == C ? void 0 : C.connection) || void 0 === t ? void 0 : t.readyState) === WebSocket.OPEN) {
                                            if (!(0, g.isRoomIdOrPeerIdChanged)(S, b) || !r) return void D("info", "maybeOpenWebsocketConnection. WS connection already opened [".concat(u, "]"));
                                            D("info", "maybeOpenWebsocketConnection. Closing WS connection. [".concat(u, "]")), null == C || C.close()
                                        }
                                        var p = (0, g.countOfValidConnections)(_);
                                        if (!w && p < 1 && !R) D("info", "maybeOpenWebsocketConnection. WS connection not opened - previous connect call not finished or missing peer connection [".concat(u, "]"), {
                                            openChannels: JSON.stringify(_),
                                            connectionCount: p,
                                            tryingToConnectSocket: R,
                                            isManualConnect: w
                                        });
                                        else {
                                            var m = (0, g.validateConfig)(b),
                                                v = Object.keys(_)[p - 1];
                                            if (!m) return R = !1, void D("info", "maybeOpenWebsocketConnection. WS connection not opened - invalid config [".concat(u, "]"), {
                                                watchrtcConfig: b
                                            });
                                            b.keys && Object.keys(b.keys || {}).forEach((function(e) {
                                                "string" == typeof b.keys[e] && (b.keys[e] = [b.keys[e]])
                                            }));
                                            var y = !!b.rtcToken,
                                                T = (0, g.getConnectionData)("ws", y ? b.rtcToken : b.rtcApiKey, b.proxyUrl);
                                            C || D("error", "maybeOpenWebsocketConnection. WS socket wasn't initialized [".concat(u, "]")), R = !0, x = Date.now(), D("info", "maybeOpenWebsocketConnection. Opening websocket connection [".concat(u, "]")), k();
                                            var O = Date.now();
                                            null == C || C.connect({
                                                url: "".concat(T.url, "?").concat(y ? "token" : "apiKey", "=").concat(T.key, "&timestamp=").concat(Date.now()),
                                                onData: function(e) {
                                                    for (var t, n = 0, r = Object.entries(e); n < r.length; n++) {
                                                        var o = r[n],
                                                            l = o[0],
                                                            h = o[1];
                                                        E[l] = h
                                                    }
                                                    if (S.projectId = e.projectId, R = !1, b.allowBrowserLogCollection = Boolean(e.collectConsoleLogEnabled), b.allowBrowserLogCollection ? !(null === (t = null == b ? void 0 : b.console) || void 0 === t ? void 0 : t.override) && e.collectConsoleLogLevel && (0, g.setConsoleLevel)(e.collectConsoleLogLevel, a) : ((0, g.restoreOriginalConsoleMethods)(), (null == C ? void 0 : C.buffer) && (C.buffer = C.buffer.filter((function(e) {
                                                            return "log" !== e[0]
                                                        })))), console.info.apply(console, s(s([], (0, g.logPrefix)("info"), !1), ["Connection established. watchRTCConnectionId: ".concat(e.connectionId, " sdkVersion:").concat(f.default, " [").concat(u, "]")], !1)), a({
                                                            data: ["watchrtc", v, i(i(i({}, b), e), {
                                                                sdkVersion: f.default
                                                            })]
                                                        }), d && a({
                                                            data: ["reconnect", null, null]
                                                        }), c && a({
                                                            data: ["hardware", null, c]
                                                        }), a({
                                                            data: ["sessionId", null, window.watchRTCSessionId]
                                                        }), e.interval !== b.collectionInterval) {
                                                        var p = b.collectionInterval;
                                                        b.collectionInterval = e.interval, j(), k(), console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["Collection interval missmatch - connection state reset"], !1)), a({
                                                            data: ["collectionIntervalChange", null, {
                                                                oldInterval: p
                                                            }]
                                                        })
                                                    }
                                                },
                                                onError: function(e, t) {
                                                    "auth" === t && (A = !0), R = !1, x = 0
                                                },
                                                onOpen: function() {
                                                    P && P({
                                                        connectionStatus: "connected"
                                                    }), A = !1, h && (clearInterval(h), h = void 0);
                                                    var e = Date.now() - O;
                                                    D("info", "maybeOpenWebsocketConnection. Connection opened. Opening time - ".concat(e, " ms [").concat(u, "]"))
                                                },
                                                onClose: function(e) {
                                                    P && P({
                                                        connectionStatus: "disconnected"
                                                    });
                                                    var t = e.code,
                                                        n = e.reason,
                                                        i = e.wasClean;
                                                    D("info", "close event", {
                                                        authFailed: A,
                                                        code: t,
                                                        reason: n,
                                                        wasClean: i
                                                    }), A ? h && clearInterval(h) : h || I || (N({
                                                        reconnecting: !0,
                                                        pcId: u
                                                    }), h = setInterval((function() {
                                                        N({
                                                            reconnecting: !0,
                                                            pcId: u
                                                        })
                                                    }), 3e4))
                                                }
                                            })
                                        }
                                    },
                                    k = function() {
                                        window.clearInterval(d), d = window.setInterval((function() {
                                            return r(this, void 0, void 0, (function() {
                                                var e, t, n, r, a, c, l;
                                                return o(this, (function(o) {
                                                    switch (o.label) {
                                                        case 0:
                                                            return w || 0 !== (0, g.countOfValidConnections)(_) ? [3, 1] : (D("info", "getStatsInterval. No valid connections at this time"), x && x + 2e4 < Date.now() && (window.clearInterval(d), null == C || C.close(), console.info.apply(console, s(s([], (0, g.logPrefix)("info"), !1), ["Last connection closed. watchRTCConnectionId: ".concat(null == E ? void 0 : E.connectionId, " sdkVersion: ").concat(f.default)], !1))), [3, 6]);
                                                        case 1:
                                                            x = Date.now(), e = {
                                                                connections: {},
                                                                streams: {}
                                                            }, t = 0, n = Object.values(_), o.label = 2;
                                                        case 2:
                                                            return t < n.length ? (r = n[t], D("info", "getStatsInterval. ".concat(r.id, " signalingState: ").concat(r.pc.signalingState)), "closed" === r.pc.signalingState ? [3, 4] : [4, M(r)]) : [3, 5];
                                                        case 3:
                                                            a = o.sent(), c = a.peer, l = a.streams, e.connections = i(i({}, e.connections), c), e.streams = i(i({}, e.streams), l), o.label = 4;
                                                        case 4:
                                                            return t++, [3, 2];
                                                        case 5:
                                                            u && u(e), o.label = 6;
                                                        case 6:
                                                            return [2]
                                                    }
                                                }))
                                            }))
                                        }), b.collectionInterval)
                                    },
                                    M = function(e) {
                                        return new Promise((function(t, n) {
                                            if (e) {
                                                var i = e.id,
                                                    r = e.pc,
                                                    o = e.prev;
                                                r.getStats(null).then((function(n) {
                                                    (null == b ? void 0 : b.logGetStats) && D("info", "getStats res", {
                                                        res: n
                                                    });
                                                    var r = {};
                                                    v ? n.forEach((function(e) {
                                                        r["".concat(e.type, "_").concat(e.id)] = e
                                                    })) : r = (0, g.map2obj)(n);
                                                    var s = JSON.parse(JSON.stringify(r));
                                                    r = (0, g.applyPatchForRTT)(o, r);
                                                    var d = (0, g.deltaCompression)(o, r);
                                                    (null == b ? void 0 : b.logGetStats) && D("info", "getStats(null) [".concat(i, "]"), {
                                                        data: d
                                                    }), null !== (null == d ? void 0 : d.timestamp) && (null == d ? void 0 : d.timestamp) !== -1 / 0 && a({
                                                        data: ["getstats", i, d]
                                                    }), e.prev = s, t((0, g.exposeApplicationStatsForPC)(i, o, r, O))
                                                }))
                                            }
                                        }))
                                    };
                                t.initSDK = function(e, t, n) {
                                    var r, o;
                                    if (!window.watchRTCInitialized) {
                                        -1 !== RTCPeerConnection.toString().indexOf("[native code]") || console.warn.apply(console, s(s([], (0, g.logPrefix)("info"), !1), ["init. RTCPeerConnection object has been already overridden"], !1)), window.watchRTCInitialized = !0, window.watchRTCSessionId = (0, g.generateID)(), setTimeout((function() {
                                            var e = Date.now();
                                            (0, g.getHardwareInfo)().then((function(t) {
                                                var n = Date.now() - e;
                                                n <= 5e4 ? D("info", "getHardware", {
                                                    hardwareInfo: c = t
                                                }) : D("info", "getHardware failure: getHardwareTime: ".concat(n), {
                                                    hardwareInfo: c
                                                })
                                            })).catch((function(e) {
                                                console.error("Error. Get hardware info: ".concat(e.message))
                                            }))
                                        }), 0);
                                        var d = new URLSearchParams(location.search);
                                        if (d.has("watchrtc") && "debug" === d.get("watchrtc") && (e.debug = !0), C = (null == n ? void 0 : n.socketService) || new p.default({
                                                debug: null == e ? void 0 : e.debug
                                            }), T = (null == n ? void 0 : n.httpService) || new m.default({
                                                debug: null == e ? void 0 : e.debug
                                            }), e.collectionInterval = null !== (r = e.collectionInterval) && void 0 !== r ? r : 8e3, b = e, S.rtcRoomId = b.rtcRoomId, S.rtcPeerId = b.rtcPeerId, a = C.trace, b.wsUrl && console.warn.apply(console, s(s([], (0, g.logPrefix)("info"), !1), ['"wsUrl" config property is deprecated. Use "proxyUrl" instead of it'], !1)), b.proxyUrl && console.info.apply(console, s(s([], (0, g.logPrefix)("info"), !1), ['"proxyUrl" is used'], !1)), t.forEach((function(e) {
                                                if (window[e + "RTCPeerConnection"]) {
                                                    var t = window[e + "RTCPeerConnection"],
                                                        n = function(e, n) {
                                                            (null == e ? void 0 : e.watchrtc) && (b = i(i({}, b), e.watchrtc)), D("info", "new RTCPeerConnection called.", {
                                                                config: e,
                                                                constraints: n
                                                            });
                                                            var r = new t(e, n),
                                                                o = "PC_" + y++;
                                                            return r.__rtcStatsId = o, _[o] = {
                                                                id: o,
                                                                pc: r,
                                                                validConnection: !1
                                                            }, e || (e = {
                                                                nullConfig: !0
                                                            }), ((e = JSON.parse(JSON.stringify(e))) && e.iceServers || []).forEach((function(e) {
                                                                delete e.credential
                                                            })), (null == e ? void 0 : e.watchrtc) && delete e.watchrtc, e.browserType = v ? "moz" : "webkit", a({
                                                                data: ["create", o, e]
                                                            }), n && a({
                                                                data: ["constraints", o, n]
                                                            }), r.addEventListener("icecandidate", (function(e) {
                                                                a({
                                                                    data: ["onicecandidate", o, e.candidate]
                                                                })
                                                            })), r.addEventListener("icecandidateerror", (function(e) {
                                                                a({
                                                                    data: ["onicecandidateerror", o, e]
                                                                })
                                                            })), r.addEventListener("addstream", (function(e) {
                                                                a({
                                                                    data: ["onaddstream", o, e.stream.id + " " + e.stream.getTracks().map((function(e) {
                                                                        return e.kind + ":" + e.id
                                                                    }))]
                                                                })
                                                            })), r.addEventListener("track", (function(e) {
                                                                a({
                                                                    data: ["ontrack", o, e.track.kind + ":" + e.track.id + " state:" + e.track.readyState + " muted:" + e.track.muted + " " + e.streams.map((function(e) {
                                                                        return "stream:" + e.id
                                                                    }))]
                                                                }), e.track.onended = function() {
                                                                    a({
                                                                        data: ["ontrack", o, e.track.kind + ":" + e.track.id + " state:" + e.track.readyState + " " + e.streams.map((function(e) {
                                                                            return "stream:" + e.id
                                                                        }))]
                                                                    })
                                                                }, e.track.onmute = function() {
                                                                    a({
                                                                        data: ["ontrack", o, e.track.kind + ":" + e.track.id + " state:" + e.track.readyState + " muted:" + e.track.muted + " " + e.streams.map((function(e) {
                                                                            return "stream:" + e.id
                                                                        }))]
                                                                    })
                                                                }, e.track.onunmute = function() {
                                                                    a({
                                                                        data: ["ontrack", o, e.track.kind + ":" + e.track.id + " state:" + e.track.readyState + " muted:" + e.track.muted + " " + e.streams.map((function(e) {
                                                                            return "stream:" + e.id
                                                                        }))]
                                                                    })
                                                                }
                                                            })), r.addEventListener("removestream", (function(e) {
                                                                a({
                                                                    data: ["onremovestream", o, e.stream.id + " " + e.stream.getTracks().map((function(e) {
                                                                        return e.kind + ":" + e.id
                                                                    }))]
                                                                })
                                                            })), r.addEventListener("signalingstatechange", (function() {
                                                                _[o] && !_[o].validConnection ? (_[o].validConnection = !0, setTimeout((function() {
                                                                    N({
                                                                        forceRecreate: !0,
                                                                        pcId: o
                                                                    })
                                                                }), 5e3)) : D("info", "signalingstatechage. WS connection opening not triggered - peer connection not in channels or was already opened [".concat(o, "]"), {
                                                                    openChannels: JSON.stringify(_)
                                                                }), a({
                                                                    data: ["onsignalingstatechange", o, r.signalingState]
                                                                })
                                                            })), r.addEventListener("iceconnectionstatechange", (function() {
                                                                a({
                                                                    data: ["oniceconnectionstatechange", o, r.iceConnectionState]
                                                                })
                                                            })), r.addEventListener("icegatheringstatechange", (function() {
                                                                a({
                                                                    data: ["onicegatheringstatechange", o, r.iceGatheringState]
                                                                })
                                                            })), r.addEventListener("connectionstatechange", (function() {
                                                                a({
                                                                    data: ["onconnectionstatechange", o, r.connectionState]
                                                                })
                                                            })), r.addEventListener("negotiationneeded", (function() {
                                                                a({
                                                                    data: ["onnegotiationneeded", o, void 0]
                                                                })
                                                            })), r.addEventListener("datachannel", (function(e) {
                                                                a({
                                                                    data: ["ondatachannel", o, [e.channel.id, e.channel.label]]
                                                                })
                                                            })), r
                                                        };
                                                    if ("HTMLMediaElement" in window && "setSinkId" in HTMLMediaElement.prototype) {
                                                        var r = HTMLMediaElement.prototype.setSinkId;
                                                        HTMLMediaElement.prototype.setSinkId = function() {
                                                            var e = arguments[0];
                                                            return navigator.mediaDevices.enumerateDevices().then((function(t) {
                                                                var n = t.find((function(t) {
                                                                    return t.deviceId === e
                                                                }));
                                                                n && n.deviceId !== l && a({
                                                                    data: ["audioOutputChange", null, n.label]
                                                                }), l = e
                                                            })).catch((function(e) {
                                                                D("error", e.message, {
                                                                    error: e
                                                                })
                                                            })), r.apply(this, arguments)
                                                        }
                                                    }
                                                    if ("RTCRtpTransceiver" in window && "setCodecPreferences" in window.RTCRtpTransceiver.prototype) {
                                                        var o = window.RTCRtpTransceiver,
                                                            s = o.prototype.setCodecPreferences;
                                                        o.prototype.setCodecPreferences = function() {
                                                            return a({
                                                                data: ["setCodecPreferences", this.__pcId, arguments]
                                                            }), s.apply(this, arguments)
                                                        }
                                                    }
                                                    if ("RTCRtpSender" in window && "setParameters" in window.RTCRtpSender.prototype) {
                                                        var d = (c = window.RTCRtpSender).prototype.setParameters;
                                                        c.prototype.setParameters = function() {
                                                            return a({
                                                                data: ["setParameters", this.__pcId, arguments]
                                                            }), d.apply(this, arguments)
                                                        }
                                                    }
                                                    if ("RTCRtpSender" in window && "replaceTrack" in window.RTCRtpSender.prototype) {
                                                        var c, h = (c = window.RTCRtpSender).prototype.replaceTrack;
                                                        c.prototype.replaceTrack = function() {
                                                            var e = arguments[0];
                                                            return a(e ? {
                                                                data: ["replaceTrack", this.__pcId, e.kind + ":" + e.id + " state:" + e.readyState + " muted:" + e.muted + " label:" + e.label]
                                                            } : {
                                                                data: ["replaceTrack", this.__pcId, null]
                                                            }), h.apply(this, arguments)
                                                        }
                                                    } ["addTransceiver"].forEach((function(e) {
                                                        var n = t.prototype[e];
                                                        n && (t.prototype[e] = function() {
                                                            var t = this,
                                                                r = "";
                                                            arguments[1] && arguments[1].streams && (r = arguments[1].streams.map((function(e) {
                                                                return "stream:" + e.id
                                                            })).join(";"));
                                                            var o = "string" == typeof arguments[0] ? arguments[0] : arguments[0].kind + ":" + arguments[0].id + " " + arguments[0].label,
                                                                s = arguments[1] ? i(i({}, arguments[1]), {
                                                                    streams: r
                                                                }) : null;
                                                            a({
                                                                data: [e, this.__rtcStatsId, [o, s]]
                                                            });
                                                            var d = n.apply(this, arguments);
                                                            d.sender.__pcId = this.__rtcStatsId;
                                                            var c = arguments[0];
                                                            return "object" == typeof c && (a({
                                                                data: ["onlocaltrack", this.__rtcStatsId, c.kind + ":" + c.id + " state:" + c.readyState + " muted:" + c.muted + " label:" + c.label]
                                                            }), c.onended = function() {
                                                                a({
                                                                    data: ["onlocaltrack", t.__rtcStatsId, c.kind + ":" + c.id + " state:" + c.readyState + " label:" + c.label]
                                                                })
                                                            }, c.onmute = function() {
                                                                a({
                                                                    data: ["onlocaltrack", t.__rtcStatsId, c.kind + ":" + c.id + " state:" + c.readyState + " muted:" + c.muted + " label:" + c.label]
                                                                })
                                                            }, c.onunmute = function() {
                                                                a({
                                                                    data: ["onlocaltrack", t.__rtcStatsId, c.kind + ":" + c.id + " state:" + c.readyState + " muted:" + c.muted + " label:" + c.label]
                                                                })
                                                            }), d
                                                        })
                                                    })), ["createDataChannel", "restartIce"].forEach((function(e) {
                                                        var n = t.prototype[e];
                                                        n && (t.prototype[e] = function() {
                                                            return a({
                                                                data: [e, this.__rtcStatsId, arguments]
                                                            }), n.apply(this, arguments)
                                                        })
                                                    })), ["close"].forEach((function(e) {
                                                        var n = t.prototype[e];
                                                        n && (t.prototype[e] = function() {
                                                            return a({
                                                                data: [e, this.__rtcStatsId, arguments]
                                                            }), delete _[this.__rtcStatsId], I = !0, D("info", "on RTCPeerConnection(".concat(this.__rtcStatsId, ") close")), n.apply(this, arguments)
                                                        })
                                                    })), ["addStream", "removeStream"].forEach((function(e) {
                                                        var n = t.prototype[e];
                                                        n && (t.prototype[e] = function() {
                                                            var t = this,
                                                                i = arguments[0],
                                                                r = i.getTracks().map((function(e) {
                                                                    return e.kind + ":" + e.id
                                                                })).join(",");
                                                            return a({
                                                                data: [e, this.__rtcStatsId, i.id + " " + r]
                                                            }), "addStream" === e && i.getTracks().map((function(e) {
                                                                a({
                                                                    data: ["onlocaltrack", t.__rtcStatsId, e.kind + ":" + e.id + " state:" + e.readyState + " muted:" + e.muted + " label:" + e.label + " " + i.id]
                                                                }), e.onended = function() {
                                                                    a({
                                                                        data: ["onlocaltrack", t.__rtcStatsId, e.kind + ":" + e.id + " state:" + e.readyState + " label:" + e.label + " " + i.id]
                                                                    })
                                                                }, e.onmute = function() {
                                                                    a({
                                                                        data: ["onlocaltrack", t.__rtcStatsId, e.kind + ":" + e.id + " state:" + e.readyState + " muted:" + e.muted + " label:" + e.label + " " + i.id]
                                                                    })
                                                                }, e.onunmute = function() {
                                                                    a({
                                                                        data: ["onlocaltrack", t.__rtcStatsId, e.kind + ":" + e.id + " state:" + e.readyState + " muted:" + e.muted + " label:" + e.label + " " + i.id]
                                                                    })
                                                                }
                                                            })), n.apply(this, arguments)
                                                        })
                                                    })), ["addTrack"].forEach((function(e) {
                                                        var n = t.prototype[e];
                                                        n && (t.prototype[e] = function() {
                                                            var t = this,
                                                                i = arguments[0],
                                                                r = [].slice.call(arguments, 1);
                                                            a({
                                                                data: [e, this.__rtcStatsId, i.kind + ":" + i.id + " " + i.label + " " + (r.map((function(e) {
                                                                    return "stream:" + e.id
                                                                })).join(";") || "-")]
                                                            }), a({
                                                                data: ["onlocaltrack", this.__rtcStatsId, i.kind + ":" + i.id + " state:" + i.readyState + " muted:" + i.muted + " label:" + i.label + " " + r.map((function(e) {
                                                                    return "stream:" + e.id
                                                                }))]
                                                            }), i.onended = function() {
                                                                a({
                                                                    data: ["onlocaltrack", t.__rtcStatsId, i.kind + ":" + i.id + " state:" + i.readyState + " label:" + i.label + " " + r.map((function(e) {
                                                                        return "stream:" + e.id
                                                                    }))]
                                                                })
                                                            }, i.onmute = function() {
                                                                a({
                                                                    data: ["onlocaltrack", t.__rtcStatsId, i.kind + ":" + i.id + " state:" + i.readyState + " muted:" + i.muted + " label:" + i.label + " " + r.map((function(e) {
                                                                        return "stream:" + e.id
                                                                    }))]
                                                                })
                                                            }, i.onunmute = function() {
                                                                a({
                                                                    data: ["onlocaltrack", t.__rtcStatsId, i.kind + ":" + i.id + " state:" + i.readyState + " muted:" + i.muted + " label:" + i.label + " " + r.map((function(e) {
                                                                        return "stream:" + e.id
                                                                    }))]
                                                                })
                                                            };
                                                            var o = n.apply(this, arguments);
                                                            o.__pcId = this.__rtcStatsId;
                                                            var s = this.getTransceivers();
                                                            return s && s.forEach((function(e) {
                                                                e.__pcId = t.__rtcStatsId
                                                            })), o
                                                        })
                                                    })), ["removeTrack"].forEach((function(e) {
                                                        var n = t.prototype[e];
                                                        n && (t.prototype[e] = function() {
                                                            var t = arguments[0].track;
                                                            return a({
                                                                data: [e, this.__rtcStatsId, t ? t.kind + ":" + t.id + " " + t.label : "null"]
                                                            }), n.apply(this, arguments)
                                                        })
                                                    })), ["createOffer", "createAnswer"].forEach((function(e) {
                                                        var n = t.prototype[e];
                                                        n && (t.prototype[e] = function() {
                                                            var t, i = this.__rtcStatsId,
                                                                r = arguments;
                                                            return 1 === arguments.length && "object" == typeof arguments[0] ? t = arguments[0] : 3 === arguments.length && "object" == typeof arguments[2] && (t = arguments[2]), a({
                                                                data: [e, this.__rtcStatsId, t]
                                                            }), n.apply(this, t ? [t] : void 0).then((function(t) {
                                                                if (a({
                                                                        data: [e + "OnSuccess", i, t]
                                                                    }), !(r.length > 0 && "function" == typeof r[0])) return t;
                                                                r[0].apply(null, [t])
                                                            }), (function(t) {
                                                                if (a({
                                                                        data: [e + "OnFailure", i, t.toString()]
                                                                    }), !(r.length > 1 && "function" == typeof r[1])) throw t;
                                                                r[1].apply(null, [t])
                                                            }))
                                                        })
                                                    })), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(e) {
                                                        var n = t.prototype[e];
                                                        n && (t.prototype[e] = function() {
                                                            var t = this.__rtcStatsId,
                                                                i = arguments,
                                                                r = this,
                                                                o = "setLocalDescription" === e && (!i[0] || i[0] && !i[0].sdp);
                                                            return a({
                                                                data: [e, this.__rtcStatsId, o ? {
                                                                    parameterless: !0
                                                                } : i[0]]
                                                            }), n.apply(this, [i[0]]).then((function() {
                                                                a({
                                                                    data: [e + "OnSuccess", t, o ? null == r ? void 0 : r.localDescription : void 0]
                                                                }), i.length >= 2 && "function" == typeof i[1] && i[1].apply(null, [])
                                                            }), (function(n) {
                                                                if (a({
                                                                        data: [e + "OnFailure", t, n.toString()]
                                                                    }), !(i.length >= 3 && "function" == typeof i[2])) throw n;
                                                                i[2].apply(null, [n])
                                                            }))
                                                        })
                                                    })), t.generateCertificate && Object.defineProperty(n, "generateCertificate", {
                                                        get: function() {
                                                            return arguments.length ? t.generateCertificate.apply(null, arguments) : t.generateCertificate
                                                        }
                                                    }), window[e + "RTCPeerConnection"] = n, window[e + "RTCPeerConnection"].prototype = t.prototype
                                                }
                                            })), t.forEach((function(e) {
                                                var t = e + (e.length ? "GetUserMedia" : "getUserMedia");
                                                if (navigator[t]) {
                                                    var n = navigator[t].bind(navigator);
                                                    navigator[t] = function() {
                                                        a({
                                                            data: ["getUserMedia", null, arguments[0]]
                                                        });
                                                        var e = arguments[1],
                                                            t = arguments[2];
                                                        n(arguments[0], (function(t) {
                                                            a({
                                                                data: ["getUserMediaOnSuccess", null, (0, g.dumpStream)(t)]
                                                            }), e && e(t)
                                                        }), (function(e) {
                                                            var n = ["getUserMediaOnFailure", null, e.name];
                                                            a({
                                                                data: n
                                                            }), F(n), t && t(e)
                                                        }))
                                                    }.bind(navigator)
                                                }
                                            })), navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                                            var h = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
                                            navigator.mediaDevices.getUserMedia = function() {
                                                return a({
                                                    data: ["navigator.mediaDevices.getUserMedia", null, arguments[0]]
                                                }), h.apply(navigator.mediaDevices, arguments).then((function(e) {
                                                    return a({
                                                        data: ["navigator.mediaDevices.getUserMediaOnSuccess", null, (0, g.dumpStream)(e)]
                                                    }), e
                                                }), (function(e) {
                                                    var t = ["navigator.mediaDevices.getUserMediaOnFailure", null, e.name];
                                                    return a({
                                                        data: t
                                                    }), F(t), Promise.reject(e)
                                                }))
                                            }.bind(navigator.mediaDevices)
                                        }
                                        if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                                            var u = navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices);
                                            navigator.mediaDevices.getDisplayMedia = function() {
                                                return a({
                                                    data: ["navigator.mediaDevices.getDisplayMedia", null, arguments[0]]
                                                }), u.apply(navigator.mediaDevices, arguments).then((function(e) {
                                                    return a({
                                                        data: ["navigator.mediaDevices.getDisplayMediaOnSuccess", null, (0, g.dumpStream)(e)]
                                                    }), e
                                                }), (function(e) {
                                                    var t = ["navigator.mediaDevices.getDisplayMediaOnFailure", null, e.name];
                                                    return a({
                                                        data: t
                                                    }), F(t), Promise.reject(e)
                                                }))
                                            }.bind(navigator.mediaDevices)
                                        }(null === (o = e.console) || void 0 === o ? void 0 : o.level) && (0, g.setConsoleLevel)(e.console.level, a)
                                    }
                                }, t.setConfig = function(e) {
                                    var t;
                                    window.watchRTCInitialized ? (!(!1 === (null == b ? void 0 : b.allowBrowserLogCollection)) && !0 === (null === (t = null == e ? void 0 : e.console) || void 0 === t ? void 0 : t.override) && e.console.level && (0, g.setConsoleLevel)(e.console.level, a), "collectionInterval" in e && delete e.collectionInterval, b = i(i({}, b), e), S.rtcRoomId = b.rtcRoomId, S.rtcPeerId = b.rtcPeerId, D("info", "setConfig", {
                                        newWatchrtcConfig: e,
                                        watchrtcConfig: b
                                    }), N({})) : console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["SDK is not initialized. Use 'init' function first."], !1))
                                }, t.setUserRating = function(e, t) {
                                    var n;
                                    if (!window.watchRTCInitialized) return console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["SDK is not initialized. Use 'init' function first."], !1)), Promise.resolve({
                                        error: "SDK is not initialized. Use 'init' function first."
                                    });
                                    if (!(0, g.validateRating)(e)) return Promise.resolve({
                                        error: "Rating is invalid"
                                    });
                                    var i = (null === (n = null == C ? void 0 : C.connection) || void 0 === n ? void 0 : n.readyState) === WebSocket.OPEN,
                                        r = ["userRating", null, {
                                            rating: e,
                                            ratingComment: t
                                        }];
                                    return new Promise((function(e, t) {
                                        i ? a({
                                            data: r,
                                            options: {
                                                promiseFuncs: {
                                                    resolve: e,
                                                    reject: t
                                                }
                                            }
                                        }) : L.apply(void 0, r).then((function() {
                                            return e({})
                                        })).catch((function(t) {
                                            return e({
                                                error: t
                                            })
                                        }))
                                    }))
                                }, t.addKeys = function(e) {
                                    var t;
                                    if (window.watchRTCInitialized) {
                                        Object.keys(e || {}).forEach((function(t) {
                                            "string" == typeof e[t] && (e[t] = [e[t]])
                                        }));
                                        var n = ["keys", null, e],
                                            i = (null === (t = null == C ? void 0 : C.connection) || void 0 === t ? void 0 : t.readyState) === WebSocket.OPEN,
                                            r = null == C ? void 0 : C.wasConnected;
                                        return new Promise((function(e, t) {
                                            var o = {
                                                promiseFuncs: {
                                                    resolve: e,
                                                    reject: t
                                                }
                                            };
                                            i ? a({
                                                data: n,
                                                options: o
                                            }) : r ? L.apply(void 0, n).then((function() {
                                                return e({})
                                            })).catch((function(t) {
                                                return e({
                                                    error: t
                                                })
                                            })) : a({
                                                data: n,
                                                options: o
                                            })
                                        }))
                                    }
                                    console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["SDK is not initialized. Use 'init' function first."], !1))
                                }, t.disableDataCollection = function() {
                                    window.watchRTCInitialized ? null == C || C.disableDataCollection() : console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["SDK is not initialized. Use 'init' function first."], !1))
                                }, t.enableDataCollection = function() {
                                    window.watchRTCInitialized ? null == C || C.enableDataCollection() : console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["SDK is not initialized. Use 'init' function first."], !1))
                                }, t.addEvent = function(e) {
                                    if (window.watchRTCInitialized) {
                                        if ((0, g.validateEvent)(e)) {
                                            var t = ["event", null, e];
                                            return new Promise((function(e, n) {
                                                a({
                                                    data: t,
                                                    options: {
                                                        promiseFuncs: {
                                                            resolve: e,
                                                            reject: n
                                                        }
                                                    }
                                                })
                                            }))
                                        }
                                    } else console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["addEvent error. SDK is not initialized. Use 'init' function first."], !1))
                                }, t.mapStream = function(e, t) {
                                    if (window.watchRTCInitialized) {
                                        if (e && t) {
                                            var n = ["mapStream", null, {
                                                id: e,
                                                name: t
                                            }];
                                            console.info.apply(console, s(s([], (0, g.logPrefix)("info"), !1), ["mapStream method is deprecated. Please use mapTrack instead."], !1)), a({
                                                data: n
                                            })
                                        }
                                    } else console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["mapStream error. SDK is not initialized. Use 'init' function first."], !1))
                                }, t.mapTrack = function(e, t) {
                                    window.watchRTCInitialized ? !e || !t || (O[e] = t, a({
                                        data: ["mapTrack", null, {
                                            id: e,
                                            name: t
                                        }]
                                    })) : console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["mapTrack error. SDK is not initialized. Use 'init' function first."], !1))
                                }, t.connect = function() {
                                    window.watchRTCInitialized ? (w = !0, D("info", "manual connect"), N({})) : console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["connect error. SDK is not initialized. Use 'init' function first."], !1))
                                }, t.disconnect = function() {
                                    window.watchRTCInitialized ? (w = !1, I = !0, null == C || C.close(), D("info", "manual disconnect")) : console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["disconnect error. SDK is not initialized. Use 'init' function first."], !1))
                                }, t.registerOnStatsListener = function(e) {
                                    u = e
                                }, t.registerStateListener = function(e) {
                                    P = e
                                };
                                var L = function() {
                                        for (var e, t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
                                        if (!S.rtcRoomId || !S.rtcPeerId) {
                                            var i = "Cannot do http without room and peer ids";
                                            return console.log.apply(console, s(s([], (0, g.logPrefix)("info"), !1), [i], !1)), Promise.reject(i)
                                        }
                                        if (!S.projectId && !b.rtcApiKey) return i = "Missing apiKey to enable trace before connection establishment", console.log.apply(console, s(s([], (0, g.logPrefix)("info"), !1), [i], !1)), Promise.reject(i);
                                        var r = (0, g.getConnectionData)("http", b.rtcApiKey, b.proxyUrl);
                                        return T ? T.trace.apply(T, s(["".concat(r.url, "/trace"), null !== (e = S.projectId) && void 0 !== e ? e : r.key, S.rtcRoomId, S.rtcPeerId], t, !1)) : Promise.reject("Invalid configuration of http service")
                                    },
                                    F = function(e) {
                                        var t = null == b ? void 0 : b.rtcApiKey,
                                            n = null == b ? void 0 : b.rtcRoomId,
                                            i = null == b ? void 0 : b.rtcPeerId;
                                        if (t && n && i) {
                                            var r = (0, g.getConnectionData)("http", null == b ? void 0 : b.rtcApiKey, b.proxyUrl);
                                            e = e || (null == C ? void 0 : C.buffer) || [], null == T || T.trace("".concat(r.url, "/error"), r.key, n, i, e)
                                        } else console.log.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["Cannot report an error. Please provide apiKey, rtcRoomId and rtcPeerId "], !1))
                                    };
                                t.persistentEnd = function(e) {
                                    window.watchRTCInitialized ? (clearInterval(d), w = !1, I = !0, null == C || C.close(e), D("info", "persistentEnd. sessionId: ".concat(window.watchRTCSessionId))) : console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["persistentEnd error. SDK is not initialized. Use 'init' function first."], !1))
                                };
                                var j = function() {
                                    for (var e, t = 0, n = Object.values(_); t < n.length; t++) n[t].prev = null;
                                    (null === (e = null == C ? void 0 : C.buffer) || void 0 === e ? void 0 : e.length) && (C.buffer = [])
                                };
                                t.persistentStart = function(e, t) {
                                    window.watchRTCInitialized ? (b = i(i({}, b), {
                                        rtcRoomId: e,
                                        rtcPeerId: t
                                    }), S.rtcRoomId = e, S.rtcPeerId = t, j(), N({}), D("info", "persistentStart. sessionId: ".concat(window.watchRTCSessionId), {
                                        watchrtcConfig: b
                                    })) : console.info.apply(console, s(s([], (0, g.logPrefix)("error"), !1), ["persistentStart error. SDK is not initialized. Use 'init' function first."], !1))
                                }
                            },
                            527: (e, t) => {
                                "use strict";
                                Object.defineProperty(t, "__esModule", {
                                    value: !0
                                }), t.getStreamsFromStats = t.getTransportFromStats = void 0, t.getTransportFromStats = function(e, t) {
                                    if (!t) return null;
                                    var n = Object.keys(t),
                                        i = n.filter((function(e) {
                                            return "candidate-pair" === t[e].type && t[e].nominated
                                        }));
                                    if (i.length > 0) {
                                        var r = t[i[0]],
                                            o = r.localCandidateId,
                                            s = r.remoteCandidateId,
                                            a = n.find((function(e) {
                                                return "local-candidate" === t[e].type && t[e].id === o
                                            })),
                                            d = n.find((function(e) {
                                                return "remote-candidate" === t[e].type && t[e].id === s
                                            }));
                                        if (a && d) {
                                            var c = t[a],
                                                l = t[d],
                                                h = {};
                                            return h[e] = {
                                                connection: "relay" === c.candidateType ? "relay" : "direct",
                                                transport: "relay" === c.candidateType ? c.relayProtocol : "udp",
                                                address: "".concat(l.address, ":").concat(l.port)
                                            }, h
                                        }
                                    }
                                    return null
                                }, t.getStreamsFromStats = function(e, t, n, i) {
                                    var r = {},
                                        o = Object.keys(n);
                                    return o.filter((function(e) {
                                        return "inbound-rtp" === n[e].type || "outbound-rtp" === n[e].type
                                    })).forEach((function(s) {
                                        var a = n[s],
                                            d = t && s in t ? t[s] : null,
                                            c = "inbound-rtp" === a.type ? "inbound" : "outbound",
                                            l = a.kind,
                                            h = a.remoteId in n ? n[a.remoteId] : null,
                                            u = d && d.remoteId in t ? t[d.remoteId] : null,
                                            p = d ? (a.timestamp - d.timestamp) / 1e3 : null,
                                            m = {
                                                direction: c,
                                                kind: l,
                                                peerId: e
                                            };
                                        if ("video" === l && (m.frameWidth = a.frameWidth, m.frameHeight = a.frameHeight, m.framerate = a.framesPerSecond), "inbound-rtp" === a.type) m.jitter = a.jitter, m.mappedName = a.trackIdentifier in i ? i[a.trackIdentifier] : null, m.bytesReceived = d ? a.bytesReceived - d.bytesReceived : null, m.packetsReceived = d ? a.packetsReceived - d.packetsReceived : null, m.packetsLost = d ? a.packetsLost - d.packetsLost : null, m.packetsLoss = m.packetsLost + m.packetsReceived > 0 ? 100 * m.packetsLost / (m.packetsLost + m.packetsReceived) : null, m.bitrate = p ? 8 * m.bytesReceived / p : null, m.roundTripTime = h && "roundTripTime" in h ? h.roundTripTime : null;
                                        else {
                                            m.bytesSent = d ? a.bytesSent - d.bytesSent : null, m.packetsSent = d ? a.packetsSent - d.packetsSent : null, m.bitrate = p ? 8 * m.bytesSent / p : null, m.roundTripTime = h && "roundTripTime" in h ? h.roundTripTime : null, m.jitter = h && "jitter" in h ? h.jitter : null, m.packetsLost = h && u ? h.packetsLost - u.packetsLost : null, m.packetsLoss = h && "fractionLost" in h ? h.fractionLost : null;
                                            var g = o.find((function(e) {
                                                return n[e].id === a.mediaSourceId
                                            }));
                                            if (g) {
                                                var f = n[g].trackIdentifier;
                                                m.mappedName = f in i ? i[f] : null
                                            }
                                        }
                                        r[n[s].id] = m
                                    })), r
                                }
                            },
                            699: (e, t) => {
                                "use strict";
                                Object.defineProperty(t, "__esModule", {
                                    value: !0
                                })
                            },
                            593: function(e, t, n) {
                                "use strict";
                                var i = this && this.__assign || function() {
                                        return i = Object.assign || function(e) {
                                            for (var t, n = 1, i = arguments.length; n < i; n++)
                                                for (var r in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
                                            return e
                                        }, i.apply(this, arguments)
                                    },
                                    r = this && this.__awaiter || function(e, t, n, i) {
                                        return new(n || (n = Promise))((function(r, o) {
                                            function s(e) {
                                                try {
                                                    d(i.next(e))
                                                } catch (e) {
                                                    o(e)
                                                }
                                            }

                                            function a(e) {
                                                try {
                                                    d(i.throw(e))
                                                } catch (e) {
                                                    o(e)
                                                }
                                            }

                                            function d(e) {
                                                var t;
                                                e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                                                    e(t)
                                                }))).then(s, a)
                                            }
                                            d((i = i.apply(e, t || [])).next())
                                        }))
                                    },
                                    o = this && this.__generator || function(e, t) {
                                        var n, i, r, o, s = {
                                            label: 0,
                                            sent: function() {
                                                if (1 & r[0]) throw r[1];
                                                return r[1]
                                            },
                                            trys: [],
                                            ops: []
                                        };
                                        return o = {
                                            next: a(0),
                                            throw: a(1),
                                            return: a(2)
                                        }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
                                            return this
                                        }), o;

                                        function a(o) {
                                            return function(a) {
                                                return function(o) {
                                                    if (n) throw new TypeError("Generator is already executing.");
                                                    for (; s;) try {
                                                        if (n = 1, i && (r = 2 & o[0] ? i.return : o[0] ? i.throw || ((r = i.return) && r.call(i), 0) : i.next) && !(r = r.call(i, o[1])).done) return r;
                                                        switch (i = 0, r && (o = [2 & o[0], r.value]), o[0]) {
                                                            case 0:
                                                            case 1:
                                                                r = o;
                                                                break;
                                                            case 4:
                                                                return s.label++, {
                                                                    value: o[1],
                                                                    done: !1
                                                                };
                                                            case 5:
                                                                s.label++, i = o[1], o = [0];
                                                                continue;
                                                            case 7:
                                                                o = s.ops.pop(), s.trys.pop();
                                                                continue;
                                                            default:
                                                                if (!((r = (r = s.trys).length > 0 && r[r.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                                                    s = 0;
                                                                    continue
                                                                }
                                                                if (3 === o[0] && (!r || o[1] > r[0] && o[1] < r[3])) {
                                                                    s.label = o[1];
                                                                    break
                                                                }
                                                                if (6 === o[0] && s.label < r[1]) {
                                                                    s.label = r[1], r = o;
                                                                    break
                                                                }
                                                                if (r && s.label < r[2]) {
                                                                    s.label = r[2], s.ops.push(o);
                                                                    break
                                                                }
                                                                r[2] && s.ops.pop(), s.trys.pop();
                                                                continue
                                                        }
                                                        o = t.call(e, s)
                                                    } catch (e) {
                                                        o = [6, e], i = 0
                                                    } finally {
                                                        n = r = 0
                                                    }
                                                    if (5 & o[0]) throw o[1];
                                                    return {
                                                        value: o[0] ? o[1] : void 0,
                                                        done: !0
                                                    }
                                                }([o, a])
                                            }
                                        }
                                    },
                                    s = this && this.__spreadArray || function(e, t, n) {
                                        if (n || 2 === arguments.length)
                                            for (var i, r = 0, o = t.length; r < o; r++) !i && r in t || (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
                                        return e.concat(i || Array.prototype.slice.call(t))
                                    };
                                Object.defineProperty(t, "__esModule", {
                                    value: !0
                                }), t.generateID = t.applyPatchForRTT = t.exposeApplicationStatsForPC = t.restoreOriginalConsoleMethods = t.setConsoleLevel = t.getHardwareInfo = t.validateEvent = t.validateRating = t.isRoomIdOrPeerIdChanged = t.countOfValidConnections = t.validateConfig = t.getConnectionData = t.dumpStream = t.map2obj = t.mangleChromeStats = t.deltaCompression = t.debugLog = t.logPrefix = void 0;
                                var a = n(240),
                                    d = n(527);
                                t.logPrefix = function(e) {
                                    return void 0 === e && (e = "info"), "error" === e ? ["%cwatchRTC %cERROR", "background: ".concat("gold", "; color: black; padding: 2px 0.5em; border-radius: 0.5em;"), "background: ".concat("red", "; color: white; padding: 2px 0.5em; border-radius: 0.5em;")] : ["%cwatchRTC", "background: ".concat("gold", "; color: black; padding: 2px 0.5em; border-radius: 0.5em;")]
                                }, t.debugLog = function(e, n, i, r) {
                                    if (e()) {
                                        var o = s(s([], (0, t.logPrefix)(n), !0), [i], !1);
                                        r && o.push(r), console.log.apply(console, o)
                                    }
                                }, t.deltaCompression = function(e, t) {
                                    e = e || {}, t = t || {}, t = JSON.parse(JSON.stringify(t)), Object.keys(t).forEach((function(n) {
                                        var i = t[n];
                                        delete i.id, e[n] && Object.keys(i).forEach((function(r) {
                                            i.timestamp && "string" == typeof i.timestamp && (i.timestamp = new Date(i.timestamp).getTime()), (i[r] === e[n][r] || Array.isArray(i[r]) && JSON.stringify(i[r]) === JSON.stringify(e[n][r])) && delete t[n][r], (0 === Object.keys(i).length || 1 === Object.keys(i).length && i.timestamp) && delete t[n]
                                        }))
                                    }));
                                    var n = -1 / 0;
                                    return Object.keys(t).forEach((function(e) {
                                        var i = t[e];
                                        i.timestamp > n && (n = i.timestamp)
                                    })), Object.keys(t).forEach((function(e) {
                                        var i = t[e];
                                        i.timestamp === n && (i.timestamp = 0)
                                    })), t.timestamp = n, t
                                }, t.mangleChromeStats = function(e, t) {
                                    var n = {};
                                    return t.result().forEach((function(e) {
                                        var t = {
                                            id: e.id,
                                            timestamp: e.timestamp.getTime(),
                                            type: e.type
                                        };
                                        e.names().forEach((function(n) {
                                            t[n] = e.stat(n)
                                        })), n[t.id] = t
                                    })), n
                                }, t.map2obj = function(e) {
                                    if (!e.entries) return e;
                                    var t = {};
                                    return e.forEach((function(e, n) {
                                        t[n] = e
                                    })), t
                                }, t.dumpStream = function(e) {
                                    return {
                                        id: e.id,
                                        tracks: e.getTracks().map((function(e) {
                                            return {
                                                id: e.id,
                                                kind: e.kind,
                                                label: e.label,
                                                enabled: e.enabled,
                                                muted: e.muted,
                                                readyState: e.readyState
                                            }
                                        }))
                                    }
                                }, t.getConnectionData = function(e, t, n) {
                                    var i = "".concat("ws" == e ? "ws" : "http", "://localhost:9101"),
                                        r = "".concat("ws" == e ? "wss" : "https", "://watchrtc-staging1.testrtc.com"),
                                        o = "".concat("ws" == e ? "wss" : "https", "://watchrtc-staging2.testrtc.com"),
                                        s = "".concat("ws" == e ? "wss" : "https", "://watchrtc.testrtc.com"),
                                        a = "".concat("ws" == e ? "wss" : "https", "://watchrtc-app1.testrtc.com");
                                    n && "http" === e && (n = n.includes("wss://") ? n.replace("wss://", "https://") : n.replace("ws://", "http://"));
                                    var d = t.split(":");
                                    return -1 !== t.indexOf("local") ? {
                                        url: n || i,
                                        key: d[1]
                                    } : -1 !== t.indexOf("staging1") ? {
                                        url: n || r,
                                        key: d[1]
                                    } : -1 !== t.indexOf("staging") ? {
                                        url: n || o,
                                        key: d[1]
                                    } : -1 !== t.indexOf("production1") ? {
                                        url: n || a,
                                        key: d[1]
                                    } : -1 !== t.indexOf("production") ? {
                                        url: n || s,
                                        key: d[1]
                                    } : {
                                        url: n || s,
                                        key: d[0]
                                    }
                                }, t.validateConfig = function(e) {
                                    return !(null == e ? void 0 : e.rtcApiKey) && (null == e ? void 0 : e.debug) ? (console.info.apply(console, s(s([], (0, t.logPrefix)("error"), !1), ["config.rtcApiKey or config.rtcToken need to be provided."], !1)), !1) : !(!(null == e ? void 0 : e.rtcRoomId) || !(null == e ? void 0 : e.rtcPeerId)) || ((null == e ? void 0 : e.debug) && console.info.apply(console, s(s([], (0, t.logPrefix)("info"), !1), ["config.rtcRoomId or config.rtcPeerId is empty."], !1)), !1)
                                }, t.countOfValidConnections = function(e) {
                                    return Object.keys(e).filter((function(t) {
                                        return e[t].validConnection
                                    })).length
                                }, t.isRoomIdOrPeerIdChanged = function(e, n) {
                                    var i = !1;
                                    return n.rtcRoomId && e.rtcRoomId && e.rtcRoomId !== n.rtcRoomId && (i = !0), n.rtcPeerId && e.rtcPeerId && e.rtcPeerId !== n.rtcPeerId && (i = !0), i && n.debug && console.log.apply(console, s(s([], (0, t.logPrefix)("info"), !1), ["maybeOpenWebsocketConnection. rtcRoomId or rtcPeerId has been changed", {
                                        old: {
                                            rtcRoomId: e.rtcRoomId,
                                            rtcPeerId: e.rtcPeerId
                                        },
                                        new: {
                                            rtcRoomId: n.rtcRoomId,
                                            rtcPeerId: n.rtcPeerId
                                        }
                                    }], !1)), i
                                }, t.validateRating = function(e) {
                                    return e ? !("number" != typeof e || e < 1 || e > 5) || (console.info.apply(console, s(s([], (0, t.logPrefix)("error"), !1), ["rating parameter should be number from 1 to 5"], !1)), !1) : (console.info.apply(console, s(s([], (0, t.logPrefix)("error"), !1), ["rating parameter is required"], !1)), !1)
                                }, t.validateEvent = function(e) {
                                    return e ? "global" !== e.type && "local" !== e.type && "log" !== e.type ? (console.info.apply(console, s(s([], (0, t.logPrefix)("error"), !1), ['event.type should be either "global" or "local" or "log"'], !1)), !1) : !e.parameters || "object" == typeof e.parameters || (console.info.apply(console, s(s([], (0, t.logPrefix)("error"), !1), ['event.parameters should be JSON object"'], !1)), !1) : (console.info.apply(console, s(s([], (0, t.logPrefix)("error"), !1), ["event parameter is required"], !1)), !1)
                                }, t.getHardwareInfo = function() {
                                    return r(void 0, void 0, void 0, (function() {
                                        function e(e) {
                                            return (Math.round(100 * e) / 100).toFixed(2)
                                        }
                                        var t, s, d, c;
                                        return o(this, (function(l) {
                                            switch (l.label) {
                                                case 0:
                                                    return t = function(e) {
                                                        return r(void 0, void 0, void 0, (function() {
                                                            return o(this, (function(t) {
                                                                switch (t.label) {
                                                                    case 0:
                                                                        return [4, new Promise((function(t) {
                                                                            try {
                                                                                var i = n(804)("./".concat(e));
                                                                                return i.shift(), t(i)
                                                                            } catch (n) {
                                                                                console.error("Error. getHardwareInfo. loadBenchmarks", {
                                                                                    err: n.stack,
                                                                                    fileName: e
                                                                                }), t([])
                                                                            }
                                                                        }))];
                                                                    case 1:
                                                                        return [2, t.sent()]
                                                                }
                                                            }))
                                                        }))
                                                    }, [4, a.getGPUTier({
                                                        override: {
                                                            loadBenchmarks: t
                                                        }
                                                    })];
                                                case 1:
                                                    return s = l.sent(), d = i(i({}, s), {
                                                        cores_count: window.navigator.hardwareConcurrency
                                                    }), (c = window.performance.memory) && (d.jsHeapSizeLimit = e(c.jsHeapSizeLimit / 1048576), d.totalJSHeapSize = e(c.totalJSHeapSize / 1048576), d.usedJSHeapSize = e(c.usedJSHeapSize / 1048576)), [2, d]
                                            }
                                        }))
                                    }))
                                };
                                var c = {
                                        originalMethodPrefix: "_original_",
                                        methodsToPatch: ["log", "debug", "info", "warn", "error"],
                                        level: ""
                                    },
                                    l = function(e, t) {
                                        var n = console[e];
                                        n && (console[c.originalMethodPrefix + e] = n, console[e] = function() {
                                            for (var i = [], r = 0; r < arguments.length; r++) i[r] = arguments[r];
                                            if (c.level && i.length && t) {
                                                var o = c.methodsToPatch.indexOf(e),
                                                    s = c.methodsToPatch.indexOf(c.level);
                                                if (o >= 0 && o >= s) {
                                                    var a = h(i);
                                                    t({
                                                        data: ["log", null, {
                                                            type: e,
                                                            text: a
                                                        }]
                                                    })
                                                }
                                            }
                                            n.apply(console, i)
                                        })
                                    };
                                t.setConsoleLevel = function(e, t) {
                                    if (e && c.methodsToPatch.includes(e) && e !== c.level) {
                                        var n = c.methodsToPatch.indexOf(e),
                                            i = c.methodsToPatch.indexOf(c.level);
                                        if (i < 0)
                                            for (var r = 0, o = c.methodsToPatch.slice(n); r < o.length; r++) {
                                                var s = o[r];
                                                l(s, t)
                                            } else if (n < i)
                                                for (var a = 0, d = c.methodsToPatch.slice(n, i); a < d.length; a++) s = d[a], l(s, t);
                                        c.level = e
                                    }
                                }, t.restoreOriginalConsoleMethods = function() {
                                    if ("console" in window)
                                        for (var e = 0, t = c.methodsToPatch; e < t.length; e++) {
                                            var n = t[e],
                                                i = console[c.originalMethodPrefix + n];
                                            i && (console[n] = i.bind(console), delete console[c.originalMethodPrefix + n])
                                        }
                                }, t.exposeApplicationStatsForPC = function(e, t, n, i) {
                                    return {
                                        peer: (0, d.getTransportFromStats)(e, n),
                                        streams: (0, d.getStreamsFromStats)(e, t, n, i)
                                    }
                                };
                                var h = function(e) {
                                        try {
                                            return e.map((function(e) {
                                                return "string" == typeof e ? e : JSON.stringify(e, u())
                                            })).join(" ")
                                        } catch (e) {
                                            return ""
                                        }
                                    },
                                    u = function() {
                                        var e = new WeakSet;
                                        return function(t, n) {
                                            if ("object" == typeof n && null !== n) {
                                                if (e.has(n)) return;
                                                e.add(n)
                                            }
                                            return n
                                        }
                                    };
                                t.applyPatchForRTT = function(e, t) {
                                    e = e || {}, t = t || {};
                                    var n = !0;
                                    return 0 === Object.keys(e).length && (n = !1), Object.keys(t).filter((function(e) {
                                        return "remote-outbound-rtp" === t[e].type || "remote-inbound-rtp" === t[e].type
                                    })).forEach((function(i) {
                                        if ("roundTripTime" in t[i]) {
                                            var r = "roundTripTimeMeasurements" in t[i] && Boolean(e[i]) && "roundTripTimeMeasurements" in e[i];
                                            n && r && t[i].roundTripTimeMeasurements === e[i].roundTripTimeMeasurements && (t[i].roundTripTime = NaN)
                                        } else t[i].roundTripTime = NaN
                                    })), t
                                }, t.generateID = function() {
                                    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
                                }
                            },
                            412: (e, t) => {
                                "use strict";
                                Object.defineProperty(t, "__esModule", {
                                    value: !0
                                }), t.default = "1.36.3"
                            },
                            911: function(e, t, n) {
                                "use strict";
                                var i = this && this.__spreadArray || function(e, t, n) {
                                    if (n || 2 === arguments.length)
                                        for (var i, r = 0, o = t.length; r < o; r++) !i && r in t || (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
                                    return e.concat(i || Array.prototype.slice.call(t))
                                };
                                Object.defineProperty(t, "__esModule", {
                                    value: !0
                                });
                                var r = n(593),
                                    o = function() {
                                        function e(t) {
                                            this.debug = !1, e._instance ? console.info.apply(console, i(i([], (0, r.logPrefix)("info"), !1), ["WatchRTCSocket instance already created"], !1)) : (e._instance = this, this.debug = !!t.debug)
                                        }
                                        return e.prototype.trace = function(e, t, n, o) {
                                            for (var s = [], a = 4; a < arguments.length; a++) s[a - 4] = arguments[a];
                                            var d = Array.prototype.slice.call(s);
                                            return d.push(Date.now()), d[1] instanceof RTCPeerConnection && (d[1] = d[1].__rtcStatsId), fetch(e, {
                                                method: "POST",
                                                mode: "cors",
                                                cache: "no-cache",
                                                credentials: "same-origin",
                                                headers: {
                                                    "Content-Type": "application/json"
                                                },
                                                body: JSON.stringify({
                                                    data: s,
                                                    projectId: t,
                                                    rtcRoomId: n,
                                                    rtcPeerId: o
                                                })
                                            }).then((function() {
                                                return {}
                                            })).catch((function(e) {
                                                return console.log.apply(console, i(i([], (0, r.logPrefix)("error"), !1), [e.message, {
                                                    err: e.stack
                                                }], !1)), {
                                                    error: e
                                                }
                                            }))
                                        }, e
                                    }();
                                t.default = o
                            },
                            85: function(e, t, n) {
                                "use strict";
                                var i = this && this.__spreadArray || function(e, t, n) {
                                    if (n || 2 === arguments.length)
                                        for (var i, r = 0, o = t.length; r < o; r++) !i && r in t || (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
                                    return e.concat(i || Array.prototype.slice.call(t))
                                };
                                Object.defineProperty(t, "__esModule", {
                                    value: !0
                                });
                                var r = n(593),
                                    o = n(354),
                                    s = function() {
                                        function e(t) {
                                            this.connection = null, this.wasConnected = !1, this.buffer = [], this.sendInterval = 1, this.onClose = function() {}, this.debug = !1, this.dataCollection = !0, this.sendPromises = [], this.trace = function(t) {
                                                var n, s = t.data,
                                                    a = t.options,
                                                    d = Array.prototype.slice.call(s);
                                                if (d.push(Date.now()), d[1] instanceof RTCPeerConnection && (d[1] = d[1].__rtcStatsId), e._instance.dataCollection) {
                                                    if (!e._instance.connection) return e._instance.buffer.length > 1e3 ? void((null == a ? void 0 : a.promiseFuncs) && a.promiseFuncs.resolve({
                                                        error: "Message buffer size exceeded"
                                                    })) : (e._instance.buffer.push(d), void((null == a ? void 0 : a.promiseFuncs) && e._instance.sendPromises.push(a.promiseFuncs)));
                                                    if (e._instance.connection.readyState === WebSocket.OPEN && (e._instance.buffer.push(d), (null == a ? void 0 : a.promiseFuncs) && e._instance.sendPromises.push(a.promiseFuncs), e._instance.buffer.length >= e._instance.sendInterval)) {
                                                        var c = JSON.stringify(e._instance.buffer),
                                                            l = o.compressToEncodedURIComponent(c);
                                                        if (e._instance.debug) {
                                                            var h = null !== (n = console._original_log) && void 0 !== n ? n : console.log;
                                                            h.apply(void 0, i(i([], (0, r.logPrefix)("info"), !1), ["lines: ".concat(c.length)], !1)), h.apply(void 0, i(i([], (0, r.logPrefix)("info"), !1), ["compressedMessage: ".concat(l.length)], !1))
                                                        }
                                                        e._instance.buffer = [], e._instance.connection.send(l), e._instance.sendPromises.forEach((function(e) {
                                                            return (0, e.resolve)({})
                                                        })), e._instance.sendPromises = []
                                                    }
                                                } else(null == a ? void 0 : a.promiseFuncs) && a.promiseFuncs.resolve({
                                                    error: "Data collection disabled"
                                                })
                                            }, e._instance ? console.info.apply(console, i(i([], (0, r.logPrefix)("info"), !1), ["WatchRTCSocket instance already created"], !1)) : (e._instance = this, this.debug = !!t.debug)
                                        }
                                        return e.prototype.connect = function(t) {
                                            var n = t.url,
                                                o = t.onData,
                                                s = t.onError,
                                                a = t.onOpen,
                                                d = t.onClose;
                                            e._instance.connection && e._instance.connection.close();
                                            var c = e._instance;
                                            e._instance.connection = new WebSocket(n, "2.0"), e._instance.connection.onopen = a || null, e._instance.connection.onclose = d || null, e._instance.connection.onmessage = function(t) {
                                                var n;
                                                try {
                                                    var a = JSON.parse(t.data);
                                                    a.error ? (null === (n = null == c ? void 0 : c.connection) || void 0 === n || n.close(), c.connection = null, console.info.apply(console, i(i([], (0, r.logPrefix)("error"), !1), ["\n" + a.error], !1)), s(a.error, "auth")) : (a.sendInterval && (e._instance.sendInterval = a.sendInterval), o(a), e._instance.wasConnected = !0)
                                                } catch (e) {
                                                    console.info.apply(console, i(i([], (0, r.logPrefix)("error"), !1), [{
                                                        err: e.stack
                                                    }], !1)), s(e.message)
                                                }
                                            }, e._instance.connection.onerror = function(e) {
                                                console.info.apply(console, i(i([], (0, r.logPrefix)("error"), !1), ["\n", e], !1)), s(e, "connection")
                                            }
                                        }, e.prototype.close = function(t) {
                                            var n, i;
                                            if (t && (null === (i = null === (n = e._instance) || void 0 === n ? void 0 : n.connection) || void 0 === i ? void 0 : i.readyState) === WebSocket.OPEN) {
                                                var r = JSON.stringify(["nailUpCallEnd", null, null]),
                                                    s = o.compressToEncodedURIComponent(r);
                                                e._instance.connection.send(s)
                                            }
                                            e._instance.buffer = [], e._instance.sendPromises.forEach((function(e) {
                                                return (0, e.resolve)({
                                                    error: "Connection was close"
                                                })
                                            })), e._instance.sendPromises = [], e._instance.connection && (e._instance.connection.close(), e._instance.onClose(), e._instance.connection = null)
                                        }, e.prototype.disableDataCollection = function() {
                                            e._instance.debug && console.log.apply(console, i(i([], (0, r.logPrefix)("info"), !1), ["Data collection disabled."], !1)), e._instance.dataCollection = !1
                                        }, e.prototype.enableDataCollection = function() {
                                            e._instance.debug && console.log.apply(console, i(i([], (0, r.logPrefix)("info"), !1), ["Data collection enabled."], !1)), e._instance.dataCollection = !0
                                        }, e.prototype.toggleDebug = function(t) {
                                            e._instance.debug = t
                                        }, e
                                    }();
                                t.default = s
                            },
                            240: function(e, t) {
                                ! function(e) {
                                    "use strict";
                                    var t = function(e, n) {
                                        return (t = Object.setPrototypeOf || {
                                                __proto__: []
                                            }
                                            instanceof Array && function(e, t) {
                                                e.__proto__ = t
                                            } || function(e, t) {
                                                for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
                                            })(e, n)
                                    };

                                    function n(e, t, n, i) {
                                        return new(n || (n = Promise))((function(r, o) {
                                            function s(e) {
                                                try {
                                                    d(i.next(e))
                                                } catch (e) {
                                                    o(e)
                                                }
                                            }

                                            function a(e) {
                                                try {
                                                    d(i.throw(e))
                                                } catch (e) {
                                                    o(e)
                                                }
                                            }

                                            function d(e) {
                                                var t;
                                                e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                                                    e(t)
                                                }))).then(s, a)
                                            }
                                            d((i = i.apply(e, t || [])).next())
                                        }))
                                    }

                                    function i(e, t) {
                                        var n, i, r, o, s = {
                                            label: 0,
                                            sent: function() {
                                                if (1 & r[0]) throw r[1];
                                                return r[1]
                                            },
                                            trys: [],
                                            ops: []
                                        };
                                        return o = {
                                            next: a(0),
                                            throw: a(1),
                                            return: a(2)
                                        }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
                                            return this
                                        }), o;

                                        function a(o) {
                                            return function(a) {
                                                return function(o) {
                                                    if (n) throw new TypeError("Generator is already executing.");
                                                    for (; s;) try {
                                                        if (n = 1, i && (r = 2 & o[0] ? i.return : o[0] ? i.throw || ((r = i.return) && r.call(i), 0) : i.next) && !(r = r.call(i, o[1])).done) return r;
                                                        switch (i = 0, r && (o = [2 & o[0], r.value]), o[0]) {
                                                            case 0:
                                                            case 1:
                                                                r = o;
                                                                break;
                                                            case 4:
                                                                return s.label++, {
                                                                    value: o[1],
                                                                    done: !1
                                                                };
                                                            case 5:
                                                                s.label++, i = o[1], o = [0];
                                                                continue;
                                                            case 7:
                                                                o = s.ops.pop(), s.trys.pop();
                                                                continue;
                                                            default:
                                                                if (!((r = (r = s.trys).length > 0 && r[r.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                                                    s = 0;
                                                                    continue
                                                                }
                                                                if (3 === o[0] && (!r || o[1] > r[0] && o[1] < r[3])) {
                                                                    s.label = o[1];
                                                                    break
                                                                }
                                                                if (6 === o[0] && s.label < r[1]) {
                                                                    s.label = r[1], r = o;
                                                                    break
                                                                }
                                                                if (r && s.label < r[2]) {
                                                                    s.label = r[2], s.ops.push(o);
                                                                    break
                                                                }
                                                                r[2] && s.ops.pop(), s.trys.pop();
                                                                continue
                                                        }
                                                        o = t.call(e, s)
                                                    } catch (e) {
                                                        o = [6, e], i = 0
                                                    } finally {
                                                        n = r = 0
                                                    }
                                                    if (5 & o[0]) throw o[1];
                                                    return {
                                                        value: o[0] ? o[1] : void 0,
                                                        done: !0
                                                    }
                                                }([o, a])
                                            }
                                        }
                                    }
                                    var r = ["geforce 320m", "geforce 8600", "geforce 8600m gt", "geforce 8800 gs", "geforce 8800 gt", "geforce 9400", "geforce 9400m g", "geforce 9400m", "geforce 9600m gt", "geforce 9600m", "geforce fx go5200", "geforce gt 120", "geforce gt 130", "geforce gt 330m", "geforce gtx 285", "google swiftshader", "intel g41", "intel g45", "intel gma 4500mhd", "intel gma x3100", "intel hd 3000", "intel q45", "legacy", "mali-2", "mali-3", "mali-4", "quadro fx 1500", "quadro fx 4", "quadro fx 5", "radeon hd 2400", "radeon hd 2600", "radeon hd 4670", "radeon hd 4850", "radeon hd 4870", "radeon hd 5670", "radeon hd 5750", "radeon hd 6290", "radeon hd 6300", "radeon hd 6310", "radeon hd 6320", "radeon hd 6490m", "radeon hd 6630m", "radeon hd 6750m", "radeon hd 6770m", "radeon hd 6970m", "sgx 543", "sgx543"];

                                    function o(e) {
                                        return e.toLowerCase().replace(/^angle ?\((.+)\)*$/, "$1").replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g, "")
                                    }
                                    var s = "undefined" == typeof window,
                                        a = function() {
                                            if (!s) {
                                                var e = window.navigator,
                                                    t = e.userAgent,
                                                    n = e.platform,
                                                    i = e.maxTouchPoints,
                                                    r = /(iphone|ipod|ipad)/i.test(t),
                                                    o = "iPad" === n || "MacIntel" === n && i > 0 && !window.MSStream;
                                                return {
                                                    isIpad: o,
                                                    isMobile: /android/i.test(t) || r || o,
                                                    isSafari12: /Version\/12.+Safari/.test(t)
                                                }
                                            }
                                        }();
                                    var d = [],
                                        c = [];

                                    function l(e, t) {
                                        if (e === t) return 0;
                                        var n = e;
                                        e.length > t.length && (e = t, t = n);
                                        for (var i = e.length, r = t.length; i > 0 && e.charCodeAt(~-i) === t.charCodeAt(~-r);) i--, r--;
                                        for (var o, s = 0; s < i && e.charCodeAt(s) === t.charCodeAt(s);) s++;
                                        if (r -= s, 0 == (i -= s)) return r;
                                        for (var a, l, h = 0, u = 0, p = 0; u < i;) c[u] = e.charCodeAt(s + u), d[u] = ++u;
                                        for (; p < r;)
                                            for (o = t.charCodeAt(s + p), a = p++, h = p, u = 0; u < i; u++) l = o === c[u] ? a : a + 1, a = d[u], h = d[u] = a > h ? l > h ? h + 1 : l : l > a ? a + 1 : l;
                                        return h
                                    }

                                    function h(e) {
                                        return null != e
                                    }
                                    var u = function(e) {
                                        function n(t) {
                                            var n = this.constructor,
                                                i = e.call(this, t) || this;
                                            return Object.setPrototypeOf(i, n.prototype), i
                                        }
                                        return function(e, n) {
                                            if ("function" != typeof n && null !== n) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");

                                            function i() {
                                                this.constructor = e
                                            }
                                            t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
                                        }(n, e), n
                                    }(Error);
                                    e.getGPUTier = function(e) {
                                        var t = void 0 === e ? {} : e,
                                            d = t.mobileTiers,
                                            c = void 0 === d ? [0, 15, 30, 60] : d,
                                            p = t.desktopTiers,
                                            m = void 0 === p ? [0, 15, 30, 60] : p,
                                            g = t.override,
                                            f = void 0 === g ? {} : g,
                                            v = t.glContext,
                                            _ = t.failIfMajorPerformanceCaveat,
                                            y = void 0 !== _ && _,
                                            E = t.benchmarksURL,
                                            S = void 0 === E ? "https://unpkg.com/detect-gpu@".concat("4.0.8", "/dist/benchmarks") : E;
                                        return n(void 0, void 0, void 0, (function() {
                                            var e, t, d, p, g, _, E, b, T, C, x, R, A, w, I, P, D, O, N, k, M, L, F, j, V, U;
                                            return i(this, (function(H) {
                                                switch (H.label) {
                                                    case 0:
                                                        if (e = {}, s) return [2, {
                                                            tier: 0,
                                                            type: "SSR"
                                                        }];
                                                        if (t = f.isIpad, d = void 0 === t ? !!(null == a ? void 0 : a.isIpad) : t, p = f.isMobile, g = void 0 === p ? !!(null == a ? void 0 : a.isMobile) : p, _ = f.screenSize, E = void 0 === _ ? window.screen : _, b = f.loadBenchmarks, T = void 0 === b ? function(e) {
                                                                return n(void 0, void 0, void 0, (function() {
                                                                    var t;
                                                                    return i(this, (function(n) {
                                                                        switch (n.label) {
                                                                            case 0:
                                                                                return [4, fetch("".concat(S, "/").concat(e)).then((function(e) {
                                                                                    return e.json()
                                                                                }))];
                                                                            case 1:
                                                                                if (t = n.sent(), parseInt(t.shift().split(".")[0], 10) < 4) throw new u("Detect GPU benchmark data is out of date. Please update to version 4x");
                                                                                return [2, t]
                                                                        }
                                                                    }))
                                                                }))
                                                            } : b, C = f.renderer, x = function(e) {
                                                                for (var t = 0, n = g ? ["adreno", "apple", "mali-t", "mali", "nvidia", "powervr"] : ["intel", "apple", "amd", "radeon", "nvidia", "geforce"]; t < n.length; t++) {
                                                                    var i = n[t];
                                                                    if (e.includes(i)) return i
                                                                }
                                                            }, R = function(t) {
                                                                return n(void 0, void 0, void 0, (function() {
                                                                    var n, r, o, s, a, c, h, p, m, f, v, _, y, S, b, C, R, A, w, I, P, D, O, N, k, M;
                                                                    return i(this, (function(i) {
                                                                        switch (i.label) {
                                                                            case 0:
                                                                                if (!(n = x(t))) return [2];
                                                                                r = "".concat(g ? "m" : "d", "-").concat(n).concat(d ? "-ipad" : "", ".json"), o = e[r] = null !== (M = e[r]) && void 0 !== M ? M : T(r), i.label = 1;
                                                                            case 1:
                                                                                return i.trys.push([1, 3, , 4]), [4, o];
                                                                            case 2:
                                                                                return s = i.sent(), [3, 4];
                                                                            case 3:
                                                                                if ((a = i.sent()) instanceof u) throw a;
                                                                                return [2];
                                                                            case 4:
                                                                                if (c = function(e) {
                                                                                        var t, n = (e = e.replace(/\([^)]+\)/, "")).match(/\d+/) || e.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);
                                                                                        return null !== (t = null == n ? void 0 : n.join("").replace(/\W|amd/g, "")) && void 0 !== t ? t : ""
                                                                                    }(t), (h = s.filter((function(e) {
                                                                                        return e[1] === c
                                                                                    }))).length || (h = s.filter((function(e) {
                                                                                        return e[0].includes(t)
                                                                                    }))), 0 === (p = h.length)) return [2];
                                                                                for (m = p > 1 ? h.map((function(e) {
                                                                                        return [e, l(t, e[0])]
                                                                                    })).sort((function(e, t) {
                                                                                        return e[1] - t[1]
                                                                                    }))[0][0] : h[0], f = m[0], v = m[3], _ = Number.MAX_VALUE, S = window.devicePixelRatio, b = E.width * S * E.height * S, C = 0, R = v; C < R.length; C++) A = R[C], w = A[0], I = A[1], P = w * I, (D = Math.abs(b - P)) < _ && (_ = D, y = A);
                                                                                return y ? (N = (O = y)[2], k = O[3], [2, [_, N, f, k]]) : [2]
                                                                        }
                                                                    }))
                                                                }))
                                                            }, A = function(e, t, n, i, r) {
                                                                return {
                                                                    device: r,
                                                                    fps: i,
                                                                    gpu: n,
                                                                    isMobile: g,
                                                                    tier: e,
                                                                    type: t
                                                                }
                                                            }, I = "", C) C = o(C), w = [C];
                                                        else {
                                                            if (!(P = v || function(e, t) {
                                                                    void 0 === t && (t = !1);
                                                                    var n = {
                                                                        alpha: !1,
                                                                        antialias: !1,
                                                                        depth: !1,
                                                                        failIfMajorPerformanceCaveat: t,
                                                                        powerPreference: "high-performance",
                                                                        stencil: !1
                                                                    };
                                                                    e && delete n.powerPreference;
                                                                    var i = window.document.createElement("canvas"),
                                                                        r = i.getContext("webgl", n) || i.getContext("experimental-webgl", n);
                                                                    return null != r ? r : void 0
                                                                }(null == a ? void 0 : a.isSafari12, y))) return [2, A(0, "WEBGL_UNSUPPORTED")];
                                                            if ((D = P.getExtension("WEBGL_debug_renderer_info")) && (C = P.getParameter(D.UNMASKED_RENDERER_WEBGL)), !C) return [2, A(1, "FALLBACK")];
                                                            I = C, C = o(C), w = function(e, t, n) {
                                                                return "apple gpu" === t ? function(e, t, n) {
                                                                    if (!n) return [t];
                                                                    var i, r = function(e) {
                                                                            var t = e.createShader(35633),
                                                                                n = e.createShader(35632),
                                                                                i = e.createProgram();
                                                                            if (n && t && i) {
                                                                                e.shaderSource(t, "\n    precision highp float;\n    attribute vec3 aPosition;\n    varying float vvv;\n    void main() {\n      vvv = 0.31622776601683794;\n      gl_Position = vec4(aPosition, 1.0);\n    }\n  "), e.shaderSource(n, "\n    precision highp float;\n    varying float vvv;\n    void main() {\n      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;\n      enc = fract(enc);\n      enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n      gl_FragColor = enc;\n    }\n  "), e.compileShader(t), e.compileShader(n), e.attachShader(i, t), e.attachShader(i, n), e.linkProgram(i), e.detachShader(i, t), e.detachShader(i, n), e.deleteShader(t), e.deleteShader(n), e.useProgram(i);
                                                                                var r = e.createBuffer();
                                                                                e.bindBuffer(34962, r), e.bufferData(34962, new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), 35044);
                                                                                var o = e.getAttribLocation(i, "aPosition");
                                                                                e.vertexAttribPointer(o, 3, 5126, !1, 0, 0), e.enableVertexAttribArray(o), e.clearColor(1, 1, 1, 1), e.clear(16384), e.viewport(0, 0, 1, 1), e.drawArrays(4, 0, 3);
                                                                                var s = new Uint8Array(4);
                                                                                return e.readPixels(0, 0, 1, 1, 6408, 5121, s), e.deleteProgram(i), e.deleteBuffer(r), s.join("")
                                                                            }
                                                                        }(e),
                                                                        o = "801621810",
                                                                        s = "8016218135",
                                                                        d = "80162181161",
                                                                        c = (null == a ? void 0 : a.isIpad) ? [
                                                                            ["a7", d, 12],
                                                                            ["a8", s, 15],
                                                                            ["a8x", s, 15],
                                                                            ["a9", s, 15],
                                                                            ["a9x", s, 15],
                                                                            ["a10", s, 15],
                                                                            ["a10x", s, 15],
                                                                            ["a12", o, 15],
                                                                            ["a12x", o, 15],
                                                                            ["a12z", o, 15],
                                                                            ["a14", o, 15],
                                                                            ["m1", o, 15]
                                                                        ] : [
                                                                            ["a7", d, 12],
                                                                            ["a8", s, 12],
                                                                            ["a9", s, 15],
                                                                            ["a10", s, 15],
                                                                            ["a11", o, 15],
                                                                            ["a12", o, 15],
                                                                            ["a13", o, 15],
                                                                            ["a14", o, 15]
                                                                        ];
                                                                    return "80162181255" === r ? i = c.filter((function(e) {
                                                                        return e[2] >= 14
                                                                    })) : (i = c.filter((function(e) {
                                                                        return e[1] === r
                                                                    }))).length || (i = c), i.map((function(e) {
                                                                        var t = e[0];
                                                                        return "apple ".concat(t, " gpu")
                                                                    }))
                                                                }(e, t, n) : [t]
                                                            }(P, C, g)
                                                        }
                                                        return [4, Promise.all(w.map(R))];
                                                    case 1:
                                                        if (!(O = H.sent().filter(h).sort((function(e, t) {
                                                                var n = e[0],
                                                                    i = void 0 === n ? Number.MAX_VALUE : n,
                                                                    r = e[1],
                                                                    o = t[0],
                                                                    s = void 0 === o ? Number.MAX_VALUE : o,
                                                                    a = t[1];
                                                                return i === s ? r - a : i - s
                                                            }))).length) return [2, (N = r.find((function(e) {
                                                            return C.includes(e)
                                                        }))) ? A(0, "BLOCKLISTED", N) : A(1, "FALLBACK", "".concat(C, " (").concat(I, ")"))];
                                                        if (k = O[0], M = k[1], L = k[2], F = k[3], -1 === M) return [2, A(0, "BLOCKLISTED", L, M, F)];
                                                        for (j = g ? c : m, V = 0, U = 0; U < j.length; U++) M >= j[U] && (V = U);
                                                        return [2, A(V, "BENCHMARK", L, M, F)]
                                                }
                                            }))
                                        }))
                                    }, Object.defineProperty(e, "__esModule", {
                                        value: !0
                                    })
                                }(t)
                            },
                            622: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["qualcomm adreno 540","540",0,[[1919,1279,19]]],["qualcomm adreno 540 gpu","540",0,[[1919,1279,24]]],["qualcomm adreno 618 gpu","618",0,[[1920,1080,20]]],["qualcomm adreno 630 gpu","630",0,[[1920,1080,21]]],["qualcomm adreno 680 gpu","680",0,[[2880,1920,25]]],["qualcomm adreno 685 gpu","685",0,[[1920,1080,28]]],["qualcomm adreno 690 gpu","690",0,[[1920,1280,28]]],["qualcomm adreno 8cx gen 3","8",0,[[1920,1080,22]]]]')
                            },
                            183: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["amd ???","",0,[[1920,1080,144]]],["amd [amd/ati] fiji [radeon r9 fury / nano series]","9",0,[[1920,1200,162]]],["amd 15dd","15",0,[[3840,2160,14]]],["amd 66af:f1","66",0,[[3840,2160,181]]],["amd 67df:c4","67",0,[[2560,1600,59]]],["amd 67e8:00","67",0,[[1920,1080,59]]],["amd 67ef:c5","67",0,[[1920,1080,52]]],["amd 67ef:cf","67",0,[[1920,1080,74]]],["amd 67ef:e7","67",0,[[1920,1080,60]]],["amd 67ff:08","67",0,[[1920,1200,31]]],["amd 694c:c0","694",0,[[1919,1080,28],[3840,2160,12]]],["amd 694e:c0","694",0,[[3840,2160,27]]],["amd 6980:00","6980",0,[[1920,1200,59]]],["amd 699f:c1","699",0,[[1920,1080,48]]],["amd 7310:00","7310",0,[[3840,2160,55]]],["amd 731f:c1","731",0,[[1920,1080,60]]],["amd 7340:c5","7340",0,[[2560,1600,44]]],["amd advanced micro devices [amd] nee ati device","nee",0,[[1920,1200,157]]],["amd asus amd radeon r9-990x","9",0,[[1920,1080,60]]],["amd asus eah5450","5450",0,[[1600,900,12],[1680,1050,11],[1920,1200,12]]],["amd asus eah5670","5670",0,[[1920,1080,28]]],["amd asus eah6450","6450",0,[[1920,1080,12]]],["amd asus hd7750","7750",0,[[1920,1080,105]]],["amd asus hd7770","7770",0,[[1680,1050,60]]],["amd asus hd7850","7850",0,[[1920,1080,60]]],["amd asus hd7970","7970",0,[[3840,2160,50]]],["amd asus hd8760","8760",0,[[1680,1050,59]]],["amd asus r5 230","5",0,[[1920,1080,12]]],["amd asus r7 240","7",0,[[1600,900,28],[1920,1080,31]]],["amd asus r7 250","7",0,[[1920,1080,59]]],["amd asus r7 250x","7",0,[[1920,1080,60]]],["amd asus r7 265","7",0,[[1920,1080,60]]],["amd asus r7 360","7",0,[[1920,1080,78]]],["amd asus r7 370","7",0,[[1600,900,60],[1920,1080,143]]],["amd asus r9 270","9",0,[[1600,900,60]]],["amd asus r9 280x","9",0,[[1920,1080,146]]],["amd asus r9 295x2","9",0,[[2560,1440,93]]],["amd asus r9 380","9",0,[[1920,1080,60]]],["amd asus r9 390","9",0,[[1920,1080,235]]],["amd asus radeon r7 250","7",0,[[800,638,60]]],["amd asus radeon r7 260x","7",0,[[2560,1080,65]]],["amd asus radeon r9 270x","9",0,[[1024,768,85],[1920,1080,60]]],["amd asus radeon r9 280","9",0,[[1920,1080,60]]],["amd asus radeon rx 460","460",0,[[1360,768,104]]],["amd asus radeon rx 470","470",0,[[1920,1080,60]]],["amd asus radeon rx 480","480",0,[[1920,1080,124]]],["amd asus radeon rx 550","550",0,[[1440,900,60],[1920,1080,49]]],["amd asus radeon rx 5500 xt","5500",0,[[1920,1080,325]]],["amd asus radeon rx 560","560",0,[[1360,768,60],[1920,1080,85]]],["amd asus radeon rx 570","570",0,[[1600,900,202],[1920,1080,60]]],["amd asus radeon rx 5700","5700",0,[[1920,1080,327]]],["amd asus radeon rx 5700 xt","5700",0,[[1920,1080,224],[2560,1440,60]]],["amd asus radeon rx 580","580",0,[[1920,1080,177],[2560,1080,60]]],["amd asus radeon rx vega","rx",0,[[2560,1440,117]]],["amd asus rx 6600xt macos","6600",0,[[3840,2160,60]]],["amd ati mobility radeon hd 5870","5870",0,[[1920,1200,19]]],["amd baffin amd radeon rx 560","560",0,[[1920,1080,60]]],["amd barco mxrt 5600","5600",0,[[2800,2100,30]]],["amd carrizo 9874","9874",0,[[1920,1200,11]]],["amd cezanne","",0,[[1920,1080,162]]],["amd device","",0,[[1920,1080,188]]],["amd ellesmere radeon rx 570","570",0,[[1920,1080,60]]],["amd embedded radeon e9171","9171",0,[[3840,2160,26]]],["amd embedded radeon e9173","9173",0,[[3840,2160,16]]],["amd firepro 2270","2270",0,[[1245,768,19],[1920,1200,9]]],["amd firepro 3800 graphics adapter","3800",0,[[1920,1080,18]]],["amd firepro d300","300",0,[[1920,1080,60],[2560,1440,60],[3440,1440,60],[3840,2160,30]]],["amd firepro d500","500",0,[[1600,900,60],[2560,1440,59],[2560,1600,87],[3840,2160,57]]],["amd firepro d700","700",0,[[2048,1152,59],[2560,1440,59]]],["amd firepro m2000","2000",0,[[1600,900,28],[1920,1080,24]]],["amd firepro m4000","4000",0,[[1920,1080,57]]],["amd firepro m4000 mobility pro","4000",0,[[1920,1080,57]]],["amd firepro m4100","4100",0,[[1920,1080,58]]],["amd firepro m4100 firegl v","4100",0,[[1920,1080,24]]],["amd firepro m4150","4150",0,[[1600,900,51]]],["amd firepro m4170","4170",0,[[1920,1080,43]]],["amd firepro m5100","5100",0,[[1920,1080,60]]],["amd firepro m5100 firegl v","5100",0,[[1920,1080,29]]],["amd firepro m5950","5950",0,[[1920,1080,42]]],["amd firepro m6000 mobility pro","6000",0,[[1600,900,33],[1920,1080,60]]],["amd firepro m6100","6100",0,[[1920,1080,60]]],["amd firepro m6100 firegl v","6100",0,[[1920,1080,60]]],["amd firepro m7820","7820",0,[[1680,1050,44]]],["amd firepro r5000","5000",0,[[1920,1080,60]]],["amd firepro s10000","10000",0,[[2560,1440,58]]],["amd firepro s7150","7150",0,[[1440,900,70]]],["amd firepro s9000","9000",0,[[1920,1080,60]]],["amd firepro s9050","9050",0,[[1920,1080,101]]],["amd firepro v graphics adapter","v",0,[[1680,1050,53],[1920,1080,54]]],["amd firepro v3800","3800",0,[[1280,992,28],[1680,1050,25]]],["amd firepro v3900","3900",0,[[1920,1080,28],[2560,1440,26]]],["amd firepro v4800","4800",0,[[1440,900,37],[1920,1080,50]]],["amd firepro v4800 graphics adapter","4800",0,[[1920,1080,46]]],["amd firepro v4900","4900",0,[[1600,900,76],[1920,1080,53]]],["amd firepro v4900 graphics adapter","4900",0,[[1920,1200,40]]],["amd firepro v5800","5800",0,[[1366,768,60],[1920,1200,62]]],["amd firepro v5800 graphics adapter","5800",0,[[1360,768,83],[1280,1024,58]]],["amd firepro v5900","5900",0,[[1920,1080,53],[1920,1200,58],[3440,1440,34]]],["amd firepro v5900 graphics adapter","5900",0,[[1600,1200,54],[1920,1080,65]]],["amd firepro v7800 graphics adapter","7800",0,[[1680,1050,60],[1920,1080,60]]],["amd firepro v7900","7900",0,[[1920,1080,135],[1920,1200,60],[2560,1080,124]]],["amd firepro v7900 graphics adapter","7900",0,[[1920,1080,58]]],["amd firepro v8800","8800",0,[[2560,1440,58]]],["amd firepro w2100","2100",0,[[1920,1080,33]]],["amd firepro w4100","4100",0,[[1920,1080,55]]],["amd firepro w4100 graphics adapter","4100",0,[[1600,1200,70],[1920,1080,56]]],["amd firepro w4150m firegl v","4150",0,[[1920,1080,45]]],["amd firepro w4170m","4170",0,[[1366,768,11]]],["amd firepro w4190m","4190",0,[[1920,1080,42]]],["amd firepro w4300","4300",0,[[1280,1024,116]]],["amd firepro w5000","5000",0,[[1920,1080,60],[2560,1600,75]]],["amd firepro w5000 graphics adapter","5000",0,[[1280,1024,60],[1920,1080,117]]],["amd firepro w5100","5100",0,[[1920,1080,60],[1920,1200,59]]],["amd firepro w5100 graphics adapter","5100",0,[[1920,1080,89],[3840,2160,29]]],["amd firepro w5130m","5130",0,[[1920,1080,60]]],["amd firepro w5170m","5170",0,[[1920,1080,84],[2560,1440,51]]],["amd firepro w600","600",0,[[3840,2160,25]]],["amd firepro w6150m","6150",0,[[1920,1080,45]]],["amd firepro w7000","7000",0,[[1920,1080,60],[1920,1200,136]]],["amd firepro w7000 graphics adapter","7000",0,[[1920,1080,60]]],["amd firepro w7100","7100",0,[[1920,1080,60],[1920,1200,141]]],["amd firepro w7100 graphics adapter","7100",0,[[1200,900,60]]],["amd firepro w7170m","7170",0,[[1920,1080,60]]],["amd firepro w8000","8000",0,[[1920,1200,110],[2560,1440,60]]],["amd firepro w8100","8100",0,[[1920,1080,60],[1920,1200,60]]],["amd firepro w8100 graphic adapter","8100",0,[[1280,1024,113]]],["amd firepro w9100","9100",0,[[1920,1080,60],[1920,1200,188],[2560,1600,59]]],["amd gigabyte radeon rx 580","580",0,[[1920,1080,60]]],["amd gigabyte vega 64 macos","64",0,[[1920,1080,60]]],["amd hd7950 martin rev.","7950",0,[[2560,1440,101]]],["amd hd7950 martin ver.","7950",0,[[2560,1440,104]]],["amd kamen rider black rx","rx",0,[[1920,1080,60]]],["amd kaveri","",0,[[1920,1080,9]]],["amd madison [mobility radeon hd 5650 / 6530m/6550m]","5650",0,[[1366,768,43]]],["amd matrox c680 pcie x16","680",0,[[2560,1440,49]]],["amd matrox c900 pcie x16","900",0,[[5760,3240,9]]],["amd metal","",0,[[1920,1080,120]]],["amd mobility radeon hd 4250","4250",0,[[963,722,26]]],["amd mobility radeon hd 5000","5000",0,[[1366,768,47]]],["amd mobility radeon hd 5400","5400",0,[[1366,768,24]]],["amd mobility radeon hd 5430","5430",0,[[1600,900,15],[1920,1080,60]]],["amd mobility radeon hd 5470","5470",0,[[1366,768,24]]],["amd mobility radeon hd 5570","5570",0,[[1920,1080,27]]],["amd mobility radeon hd 5730 / 6570m","5730",0,[[1366,768,58]]],["amd mobility radeon hd 5850","5850",0,[[1600,900,55]]],["amd mobility radeon hd 5870","5870",0,[[1600,900,64],[1920,1200,53]]],["amd msi / amd rx 560","560",0,[[1920,1080,60]]],["amd msi / amd rx 560 4g","560",0,[[1920,1080,60]]],["amd msi baffin rx650","650",0,[[1920,1080,399]]],["amd msi rx560","560",0,[[1920,1080,343]]],["amd msi rx650","650",0,[[1920,1080,60]]],["amd mxgpu","",0,[[1920,1012,67],[1920,1080,106]]],["amd navi 10 5700 xt","10",0,[[3840,2160,60]]],["amd opal xt/gl","xt",0,[[1366,768,60]]],["amd park [mobility radeon hd 5430","5430",0,[[1280,720,11]]],["amd picasso","",0,[[1920,1080,48]]],["amd pitcairn pro radeon hd 7850","7850",0,[[1920,1080,60]]],["amd powercolor radeon r9 280","9",0,[[1920,1080,60]]],["amd r9 270x devil","9",0,[[1920,1080,60]]],["amd r9 280x dual-x","9",0,[[1920,1080,60]]],["amd r9 380","9",0,[[2560,1440,119]]],["amd r9 xxx","9",0,[[1920,1080,60]]],["amd radeon","",0,[[1920,1080,299],[3440,1440,60]]],["amd radeon 500","500",0,[[1920,1080,73]]],["amd radeon 520","520",0,[[1920,1080,35],[2560,1440,29]]],["amd radeon 530","530",0,[[1366,768,60],[1920,1080,30]]],["amd radeon 535","535",0,[[1920,1080,35]]],["amd radeon 535dx","535",0,[[1366,768,31],[1920,1080,37]]],["amd radeon 540","540",0,[[1920,1080,38]]],["amd radeon 540 / rx 540x/550/550x","540",0,[[2560,1440,88]]],["amd radeon 540x","540",0,[[1920,1080,59]]],["amd radeon 550","550",0,[[1920,1080,115]]],["amd radeon 550x","550",0,[[1920,1080,28]]],["amd radeon 610","610",0,[[1920,1080,29]]],["amd radeon 620","620",0,[[1920,1080,18]]],["amd radeon 625","625",0,[[1366,768,55],[1920,1080,47]]],["amd radeon 630","630",0,[[1920,1080,29]]],["amd radeon 6600m and 6700m","6600",0,[[1366,768,36],[1440,900,60]]],["amd radeon 6800","6800",0,[[3440,1440,100]]],["amd radeon 7500m/7600m","7500",0,[[1366,768,37]]],["amd radeon 7950 x2","7950",0,[[2560,1440,174]]],["amd radeon d700","700",0,[[2560,1440,120]]],["amd radeon e6460","6460",0,[[1600,1200,13]]],["amd radeon e6760","6760",0,[[1200,900,54],[1920,1080,42]]],["amd radeon e8860","8860",0,[[1920,1200,27],[2560,1374,88]]],["amd radeon e8870","8870",0,[[1920,1080,81]]],["amd radeon e8870mxm","8870",0,[[1920,1080,60]]],["amd radeon e9260","9260",0,[[1680,1050,60],[3840,2160,38]]],["amd radeon e9550","9550",0,[[1680,1050,60],[3840,2160,58]]],["amd radeon embedded e9560","9560",0,[[1920,1200,60]]],["amd radeon fury","",0,[[1920,1080,60]]],["amd radeon fury x","x",0,[[1920,1080,60],[2560,1440,144]]],["amd radeon hd - firepro d300","300",0,[[1920,1080,60]]],["amd radeon hd - firepro d300 opengl engine","300",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd - firepro d500 opengl engine","500",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd - firepro d700 opengl engine","700",0,[[3840,2160,52]]],["amd radeon hd 2600 xt","2600",1,[[2560,1600,-1]]],["amd radeon hd 5000","5000",0,[[1920,1080,8]]],["amd radeon hd 5400","5400",0,[[1920,1080,12]]],["amd radeon hd 5450","5450",0,[[1920,1080,13]]],["amd radeon hd 5470","5470",0,[[1280,1024,16]]],["amd radeon hd 5500","5500",0,[[1920,1080,27]]],["amd radeon hd 5570","5570",0,[[1920,1080,60],[2048,1152,31]]],["amd radeon hd 5600","5600",0,[[1920,1080,56]]],["amd radeon hd 5650","5650",0,[[1366,768,53]]],["amd radeon hd 5670","5670",1,[[1920,1080,-1],[2560,1440,-1]]],["amd radeon hd 5670 opengl engine","5670",1,[[2560,1440,-1]]],["amd radeon hd 5700","5700",0,[[1920,1080,59]]],["amd radeon hd 5730","5730",0,[[1366,768,46],[1680,1050,40]]],["amd radeon hd 5750","5750",1,[[1920,1080,-1],[1920,1200,-1],[2560,1440,-1]]],["amd radeon hd 5750 opengl engine","5750",1,[[2560,1440,-1]]],["amd radeon hd 5770","5770",0,[[1776,1000,43],[1920,1080,59]]],["amd radeon hd 5800","5800",0,[[1366,768,60],[1920,1200,102]]],["amd radeon hd 5850","5850",0,[[1920,1080,60]]],["amd radeon hd 5870","5870",0,[[1280,960,75],[1920,1080,60],[2048,1280,60]]],["amd radeon hd 5870m","5870",0,[[2560,1080,31]]],["amd radeon hd 5970","5970",0,[[1360,768,60],[1920,1080,60]]],["amd radeon hd 6230","6230",0,[[1366,768,13]]],["amd radeon hd 6250","6250",0,[[1280,800,8],[1366,768,8]]],["amd radeon hd 6290","6290",1,[[1366,768,-1]]],["amd radeon hd 6300m","6300",1,[[1366,768,-1]]],["amd radeon hd 6310","6310",1,[[1366,768,-1]]],["amd radeon hd 6320","6320",1,[[1366,768,-1]]],["amd radeon hd 6350","6350",0,[[1280,1024,18],[1920,1080,14]]],["amd radeon hd 6370d","6370",0,[[1920,1080,14]]],["amd radeon hd 6370m","6370",0,[[1366,768,25]]],["amd radeon hd 6380g","6380",0,[[1366,768,19]]],["amd radeon hd 6400","6400",0,[[1920,1080,13]]],["amd radeon hd 6400m","6400",0,[[1366,768,28]]],["amd radeon hd 6400m/7400m","6400",0,[[1366,768,28]]],["amd radeon hd 6410d","6410",0,[[1920,1080,11]]],["amd radeon hd 6450","6450",0,[[1920,1080,14]]],["amd radeon hd 6450 / r5 230","6450",0,[[1440,900,12]]],["amd radeon hd 6450 230","6450",0,[[1920,1080,15]]],["amd radeon hd 6470m","6470",0,[[1366,768,27],[1600,900,21]]],["amd radeon hd 6470m/7400m","6470",0,[[1366,768,44]]],["amd radeon hd 6480g","6480",0,[[1280,768,19],[1366,768,27],[1600,900,18]]],["amd radeon hd 6490m","6490",1,[[1366,768,-1],[1440,900,-1],[1680,1050,-1]]],["amd radeon hd 6500","6500",0,[[1920,1080,25]]],["amd radeon hd 6500m/5600","6500",0,[[1920,1080,27]]],["amd radeon hd 6510","6510",0,[[1600,900,32]]],["amd radeon hd 6520g","6520",0,[[1366,768,21],[1600,900,20]]],["amd radeon hd 6530d","6530",0,[[1366,768,31],[1440,900,36],[1920,1080,24]]],["amd radeon hd 6540","6540",0,[[1600,1200,13]]],["amd radeon hd 6550d","6550",0,[[1920,1080,28]]],["amd radeon hd 6570","6570",0,[[1920,1080,52],[2560,1440,17]]],["amd radeon hd 6620g","6620",0,[[1360,768,43],[1366,768,28]]],["amd radeon hd 6630m","6630",1,[[1366,768,-1],[1600,900,-1],[1920,1080,-1]]],["amd radeon hd 6630m/6650m/6750m/7670m/7690m","6630",1,[[1366,768,-1],[1920,1080,-1]]],["amd radeon hd 6650m","6650",0,[[1366,768,51],[1600,900,31]]],["amd radeon hd 6670","6670",0,[[1920,1080,55]]],["amd radeon hd 6700","6700",0,[[1920,1080,56]]],["amd radeon hd 6700 green","6700",0,[[1360,768,89]]],["amd radeon hd 6700m/7700m/7900m","6700",0,[[1366,768,59]]],["amd radeon hd 6730m/6770m","6730",0,[[1366,768,58],[1920,1080,46]]],["amd radeon hd 6730m/6770m/7690m xt","6730",0,[[1920,1080,48]]],["amd radeon hd 6750","6750",0,[[1440,900,72],[1920,1080,60]]],["amd radeon hd 6750m","6750",1,[[1440,900,-1],[1920,1080,-1],[1920,1200,-1]]],["amd radeon hd 6770","6770",0,[[1920,1080,60]]],["amd radeon hd 6770m","6770",1,[[1440,900,-1],[2560,1440,-1]]],["amd radeon hd 6770m opengl engine","6770",1,[[2560,1440,-1]]],["amd radeon hd 6790","6790",0,[[1920,1080,59]]],["amd radeon hd 6800","6800",0,[[1280,1024,89],[1920,1080,60]]],["amd radeon hd 6800m","6800",0,[[1600,900,18],[1920,1080,40]]],["amd radeon hd 6850","6850",0,[[1920,1080,59],[2560,1600,54]]],["amd radeon hd 6870","6870",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd 6900","6900",0,[[1920,1080,60]]],["amd radeon hd 6900m","6900",0,[[1920,1080,60]]],["amd radeon hd 6950","6950",0,[[1680,1050,60],[1920,1080,41]]],["amd radeon hd 6970","6970",0,[[1920,1080,60]]],["amd radeon hd 6970m","6970",1,[[2560,1440,-1]]],["amd radeon hd 6970m opengl engine","6970",1,[[2560,1440,-1]]],["amd radeon hd 6990","6990",0,[[1920,1080,60]]],["amd radeon hd 7000","7000",0,[[1920,1080,24]]],["amd radeon hd 7290","7290",0,[[1366,768,9]]],["amd radeon hd 7310","7310",0,[[1366,768,14]]],["amd radeon hd 7340","7340",0,[[1366,768,17],[1920,1080,10]]],["amd radeon hd 7340g","7340",0,[[1366,768,15]]],["amd radeon hd 7340m","7340",0,[[1366,768,15]]],["amd radeon hd 7350","7350",0,[[1920,1080,13]]],["amd radeon hd 7400","7400",0,[[1920,1080,18]]],["amd radeon hd 7400g","7400",0,[[963,768,31]]],["amd radeon hd 7400m","7400",0,[[1366,768,44]]],["amd radeon hd 7420g","7420",0,[[1366,768,28],[1600,900,26]]],["amd radeon hd 7450","7450",0,[[1920,1080,15]]],["amd radeon hd 7450a","7450",0,[[1920,1080,15]]],["amd radeon hd 7450m","7450",0,[[1366,768,30]]],["amd radeon hd 7470","7470",0,[[1680,1050,22],[1920,1080,144]]],["amd radeon hd 7470m","7470",0,[[1366,768,31],[1600,900,23]]],["amd radeon hd 7480d","7480",0,[[1280,1024,25],[1920,1080,24],[1920,1200,18]]],["amd radeon hd 7500","7500",0,[[1366,696,49],[1366,768,49]]],["amd radeon hd 7500g","7500",0,[[1366,768,26]]],["amd radeon hd 7500m/7600m","7500",0,[[1366,768,46]]],["amd radeon hd 7520g","7520",0,[[1366,768,33]]],["amd radeon hd 7520g + hd 7400m dual","7520",0,[[1366,768,34]]],["amd radeon hd 7520g + hd 7600m dual","7520",0,[[1366,768,31],[1600,900,41]]],["amd radeon hd 7540d","7540",0,[[1024,768,55],[1280,1024,44],[1920,1080,22]]],["amd radeon hd 7540d + hd 6670 dual","7540",0,[[1280,1024,36]]],["amd radeon hd 7550m/7650m","7550",0,[[1366,768,57]]],["amd radeon hd 7560d","7560",0,[[1920,1080,34]]],["amd radeon hd 7560d + hd 6570 dual","7560",0,[[1680,1050,44]]],["amd radeon hd 7560d + hd 6670 dual","7560",0,[[800,638,60]]],["amd radeon hd 7570","7570",0,[[1024,768,72],[1920,1080,52]]],["amd radeon hd 7570m","7570",0,[[1366,768,35]]],["amd radeon hd 7570m/hd 7670m","7570",0,[[1366,768,50],[1600,900,29]]],["amd radeon hd 7600","7600",0,[[1920,1080,60]]],["amd radeon hd 7600a","7600",0,[[1920,1080,28]]],["amd radeon hd 7600g","7600",0,[[1366,768,29]]],["amd radeon hd 7600g + 7500m/7600m dual","7600",0,[[1366,768,19]]],["amd radeon hd 7600g + hd 8670m dual","7600",0,[[1366,768,29]]],["amd radeon hd 7600g + hd dual","7600",0,[[1366,768,20]]],["amd radeon hd 7600m","7600",0,[[1366,768,56]]],["amd radeon hd 7600m/7700m","7600",0,[[1366,768,31]]],["amd radeon hd 7610m","7610",0,[[1366,768,43]]],["amd radeon hd 7620g","7620",0,[[1366,768,22],[1920,1080,19]]],["amd radeon hd 7640g","7640",0,[[1366,768,38]]],["amd radeon hd 7640g + 7470m dual","7640",0,[[1366,768,32]]],["amd radeon hd 7640g + 7600m dual","7640",0,[[1366,768,23]]],["amd radeon hd 7640g + 7670m dual","7640",0,[[1600,900,15]]],["amd radeon hd 7640g + 8500m dual","7640",0,[[1366,768,35]]],["amd radeon hd 7640g + hd 7400m dual","7640",0,[[1366,768,37]]],["amd radeon hd 7640g + hd 7500 dual","7640",0,[[1366,768,35]]],["amd radeon hd 7640g + hd 7670m dual","7640",0,[[1366,768,34]]],["amd radeon hd 7640g + hd 8500m dual","7640",0,[[1366,768,40]]],["amd radeon hd 7640g + hd 8570m dual","7640",0,[[1366,768,31]]],["amd radeon hd 7650a","7650",0,[[1680,1050,43],[1920,1080,15]]],["amd radeon hd 7650m","7650",0,[[1366,768,41],[1600,900,45]]],["amd radeon hd 7660d","7660",0,[[1680,1050,40],[1920,1008,60],[1920,1080,38]]],["amd radeon hd 7660d + hd 6570 dual","7660",0,[[1200,900,32]]],["amd radeon hd 7660d + hd 6670 dual","7660",0,[[1360,768,57],[1920,1080,53]]],["amd radeon hd 7660g","7660",0,[[1366,768,44],[1600,900,41],[1920,1080,34],[1920,1200,27]]],["amd radeon hd 7660g + 7600m dual","7660",0,[[1366,768,53],[1600,900,45]]],["amd radeon hd 7660g + 7670m dual","7660",0,[[1366,768,52]]],["amd radeon hd 7660g + 8670m dual","7660",0,[[1600,900,46]]],["amd radeon hd 7660g + hd 7600m dual","7660",0,[[1366,768,50]]],["amd radeon hd 7660g + hd 7670m dual","7660",0,[[1366,768,35]]],["amd radeon hd 7660g + hd 8600m dual","7660",0,[[1600,900,29]]],["amd radeon hd 7670","7670",0,[[1920,1080,39]]],["amd radeon hd 7670m","7670",0,[[1366,768,49],[1920,1080,36]]],["amd radeon hd 7700","7700",0,[[1400,1050,45],[1920,1080,60]]],["amd radeon hd 7700m","7700",0,[[1920,1080,54]]],["amd radeon hd 7730m","7730",0,[[1920,1080,57]]],["amd radeon hd 7750","7750",0,[[1280,1024,60],[1600,900,60],[1400,1050,98],[1920,1080,60],[3840,2160,23]]],["amd radeon hd 7750 / r7 250e","7750",0,[[2560,1080,69]]],["amd radeon hd 7750m","7750",0,[[1680,1050,57]]],["amd radeon hd 7770","7770",0,[[1920,1080,60]]],["amd radeon hd 7770 / r7 250x","7770",0,[[1680,1050,78]]],["amd radeon hd 7770 ghz","7770",0,[[1920,1080,78]]],["amd radeon hd 7790","7790",0,[[1920,1080,16]]],["amd radeon hd 7790 / r7 360 / r9 260/360","7790",0,[[1280,1024,131]]],["amd radeon hd 7800","7800",0,[[1920,1080,60]]],["amd radeon hd 7800m","7800",0,[[1920,1080,57]]],["amd radeon hd 7850","7850",0,[[1920,1080,60]]],["amd radeon hd 7850 / r7 265 / r9 270 1024sp","7850",0,[[1280,1024,87]]],["amd radeon hd 7870","7870",0,[[1920,1080,120],[2560,1440,60],[2560,1600,114],[3840,2160,30]]],["amd radeon hd 7870 ghz","7870",0,[[1920,1080,75]]],["amd radeon hd 7870 xt","7870",0,[[1920,1080,57],[3840,2160,53]]],["amd radeon hd 7870m","7870",0,[[1920,1080,22],[2732,1536,40]]],["amd radeon hd 7900","7900",0,[[2560,1600,59]]],["amd radeon hd 7950","7950",0,[[1920,1080,50]]],["amd radeon hd 7950 / r9 280","7950",0,[[1920,1080,59]]],["amd radeon hd 7950 oem / r9 280","7950",0,[[1920,1080,60]]],["amd radeon hd 7970","7970",0,[[1920,1080,60]]],["amd radeon hd 7970 / r9 280x","7970",0,[[1920,1080,193]]],["amd radeon hd 7970m","7970",0,[[1366,768,60],[1920,1080,60]]],["amd radeon hd 7970x/8970 280x","7970",0,[[1920,1080,60]]],["amd radeon hd 7990","7990",0,[[1920,1080,60],[5120,2880,63]]],["amd radeon hd 7xxx","7",0,[[1920,1080,60]]],["amd radeon hd 8180","8180",0,[[1366,768,10]]],["amd radeon hd 8200 / r3","8200",0,[[1366,768,21],[1600,900,13],[1680,1050,13]]],["amd radeon hd 8210","8210",0,[[1366,768,18]]],["amd radeon hd 8240","8240",0,[[1600,900,17]]],["amd radeon hd 8240 / r3","8240",0,[[1366,768,14]]],["amd radeon hd 8250","8250",0,[[1366,768,14],[1920,1200,10]]],["amd radeon hd 8280","8280",0,[[1600,900,60]]],["amd radeon hd 8280 / r3","8280",0,[[1366,768,22]]],["amd radeon hd 8280e","8280",0,[[2880,1620,6]]],["amd radeon hd 8330","8330",0,[[1366,768,24]]],["amd radeon hd 8350","8350",0,[[1920,1080,57]]],["amd radeon hd 8350g","8350",0,[[1366,768,18]]],["amd radeon hd 8370d","8370",0,[[1366,768,60],[1280,1024,26],[1920,1080,22]]],["amd radeon hd 8400","8400",0,[[1366,768,30],[1920,1080,16]]],["amd radeon hd 8400 / r3","8400",0,[[1360,768,19],[1366,768,22],[1920,1080,12]]],["amd radeon hd 8400e","8400",0,[[1680,1050,17],[1920,1080,16],[1920,1200,14]]],["amd radeon hd 8410g","8410",0,[[1366,768,32]]],["amd radeon hd 8450g","8450",0,[[1366,768,23]]],["amd radeon hd 8450g + hd 8750m dual","8450",0,[[1366,768,21]]],["amd radeon hd 8470","8470",0,[[1920,1080,17]]],["amd radeon hd 8470 + 7660d dual","8470",0,[[1920,1080,60]]],["amd radeon hd 8470d","8470",0,[[1280,1024,44],[1920,1080,21]]],["amd radeon hd 8470d + hd 6450 dual","8470",0,[[1600,900,37]]],["amd radeon hd 8490","8490",0,[[1920,1080,18],[1920,1200,20]]],["amd radeon hd 8500m","8500",0,[[1366,768,41],[1920,1080,19]]],["amd radeon hd 8500m/8700m","8500",0,[[1920,1080,30]]],["amd radeon hd 8510g","8510",0,[[1366,768,29],[1920,1080,17]]],["amd radeon hd 8550","8550",0,[[1920,1080,25]]],["amd radeon hd 8550g","8550",0,[[1366,768,34],[1600,900,41],[1920,1080,34]]],["amd radeon hd 8550g + 8500m dual","8550",0,[[1366,768,42]]],["amd radeon hd 8550g + 8600 dual","8550",0,[[1920,1080,27]]],["amd radeon hd 8550g + hd 8570m dual","8550",0,[[1366,768,32]]],["amd radeon hd 8550g + hd 8600 dual","8550",0,[[1366,768,60]]],["amd radeon hd 8550g + hd 8750m dual","8550",0,[[1366,768,37]]],["amd radeon hd 8550g + r5 m230 dual","8550",0,[[1366,768,29]]],["amd radeon hd 8570","8570",0,[[1280,1024,60],[1680,1050,54],[1920,1080,50]]],["amd radeon hd 8570 / r5 430 / r7 240 / radeon 520","8570",0,[[1920,1080,25]]],["amd radeon hd 8570d","8570",0,[[1920,1080,16]]],["amd radeon hd 8570d + r7 240 dual","8570",0,[[1920,1080,45]]],["amd radeon hd 8570m","8570",0,[[1366,768,40]]],["amd radeon hd 8600","8600",0,[[1366,768,41]]],["amd radeon hd 8600m","8600",0,[[1366,768,42],[1920,1080,14]]],["amd radeon hd 8610g","8610",0,[[1366,768,31],[1920,1080,16]]],["amd radeon hd 8610g + 8600m dual","8610",0,[[1366,768,22]]],["amd radeon hd 8610g + hd 8600m dual","8610",0,[[1366,768,41]]],["amd radeon hd 8610g + hd 8670m dual","8610",0,[[1366,768,33]]],["amd radeon hd 8650g","8650",0,[[1360,768,44],[1366,768,44]]],["amd radeon hd 8650g + 8500m dual","8650",0,[[1366,768,35]]],["amd radeon hd 8650g + 8600 dual","8650",0,[[1920,1080,38]]],["amd radeon hd 8650g + 8600m dual","8650",0,[[1366,768,21]]],["amd radeon hd 8650g + 8670m dual","8650",0,[[1366,768,66]]],["amd radeon hd 8650g + 8750m dual","8650",0,[[1920,1080,28]]],["amd radeon hd 8650g + hd 7600m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + hd 8500m dual","8650",0,[[1366,768,23]]],["amd radeon hd 8650g + hd 8570m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + hd 8600m dual","8650",0,[[1366,768,46],[1600,900,29]]],["amd radeon hd 8650g + hd 8750m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + r5 m200 dual","8650",0,[[1366,768,35]]],["amd radeon hd 8670 / r7 250","8670",0,[[1024,768,1]]],["amd radeon hd 8670a/8670m/8690m","8670",0,[[1366,768,47]]],["amd radeon hd 8670a/8670m/8750m","8670",0,[[1366,768,60]]],["amd radeon hd 8670d","8670",0,[[1024,768,45],[1280,1024,69],[1920,1080,38]]],["amd radeon hd 8670d + 7700 dual","8670",0,[[1680,1050,58]]],["amd radeon hd 8670d + hd 6670 dual","8670",0,[[1680,1050,33]]],["amd radeon hd 8670d + r5 200 dual","8670",0,[[2560,1080,14]]],["amd radeon hd 8670d + r7 200 dual","8670",0,[[1920,1080,37]]],["amd radeon hd 8670m","8670",0,[[1366,768,41]]],["amd radeon hd 8690a","8690",0,[[1920,1080,31]]],["amd radeon hd 8690m","8690",0,[[1600,900,35]]],["amd radeon hd 8700m","8700",0,[[1366,768,60]]],["amd radeon hd 8730m","8730",0,[[1366,768,59]]],["amd radeon hd 8750m","8750",0,[[1366,768,60]]],["amd radeon hd 8770","8770",0,[[1920,1080,111]]],["amd radeon hd 8790m","8790",0,[[1600,900,78],[1920,1080,60]]],["amd radeon hd 8800m","8800",0,[[1920,1080,60],[2880,1800,45]]],["amd radeon hd 8830m","8830",0,[[1920,1080,82]]],["amd radeon hd 8850m","8850",0,[[1366,768,45]]],["amd radeon hd 8870m","8870",0,[[1280,1024,60],[1600,900,60]]],["amd radeon hd 8950","8950",0,[[1920,1080,60],[1920,1200,59]]],["amd radeon hd 8970","8970",0,[[2560,1600,60]]],["amd radeon hd 8970m","8970",0,[[1920,1080,146],[1920,1200,60]]],["amd radeon hd 8xxx","8",0,[[1920,1080,120],[2560,1440,58]]],["amd radeon hd5450","5450",0,[[1280,720,24]]],["amd radeon hd6870","6870",0,[[1920,1080,60]]],["amd radeon hd7970m","7970",0,[[2560,1440,116]]],["amd radeon hd8530m","8530",0,[[1366,768,40]]],["amd radeon hd8730","8730",0,[[1680,1050,42]]],["amd radeon hd8970m","8970",0,[[1920,1080,74]]],["amd radeon hybrid","",0,[[1366,768,27]]],["amd radeon infoshock rx 460","460",0,[[1360,768,102]]],["amd radeon instinct mi25","25",0,[[1920,1200,26]]],["amd radeon instinct mi25 mxgpu","25",0,[[1920,1080,20],[1920,1200,32]]],["amd radeon m535dx","535",0,[[1366,768,58]]],["amd radeon navi14","14",0,[[3840,2160,60]]],["amd radeon polaris","",0,[[3840,2160,60],[5120,2880,44]]],["amd radeon polaris 10","10",0,[[1920,1200,60]]],["amd radeon pro","pro",0,[[1920,1080,114]]],["amd radeon pro 270x","270",0,[[2560,1440,74]]],["amd radeon pro 450","450",0,[[1920,1080,30],[2880,1800,43],[3360,2100,36],[5120,2880,30]]],["amd radeon pro 450 opengl engine","450",0,[[1920,1200,60]]],["amd radeon pro 455","455",0,[[2879,1800,54],[2880,1800,48],[3360,2100,37]]],["amd radeon pro 455 opengl engine","455",0,[[3360,2100,36]]],["amd radeon pro 460","460",0,[[2880,1800,50],[3360,2100,42]]],["amd radeon pro 460 opengl engine","460",0,[[5760,3240,15]]],["amd radeon pro 470","470",0,[[6016,3384,49]]],["amd radeon pro 480","480",0,[[1920,1080,60]]],["amd radeon pro 5300","5300",0,[[5120,2880,60]]],["amd radeon pro 5300m","5300",0,[[1920,1080,214],[3584,2240,130]]],["amd radeon pro 5500 xt","5500",0,[[5120,2880,51]]],["amd radeon pro 5500m","5500",0,[[3072,1920,60],[3584,2240,139]]],["amd radeon pro 555","555",0,[[2879,1800,54],[2880,1800,36],[3360,2100,40]]],["amd radeon pro 555x","555",0,[[2880,1800,42],[3360,2100,39]]],["amd radeon pro 560","560",0,[[2879,1800,56],[2880,1800,56],[3360,2100,42]]],["amd radeon pro 5600m","5600",0,[[3072,1920,60],[3584,2240,60]]],["amd radeon pro 560x","560",0,[[2879,1800,59],[2880,1800,71],[3360,2100,43]]],["amd radeon pro 570","570",0,[[5120,2880,48]]],["amd radeon pro 570 opengl engine","570",0,[[5120,2880,46]]],["amd radeon pro 5700","5700",0,[[5120,2880,60]]],["amd radeon pro 5700 xt","5700",0,[[5120,2880,60]]],["amd radeon pro 570x","570",0,[[5120,2880,50]]],["amd radeon pro 575","575",0,[[4096,2304,60],[5120,2880,50]]],["amd radeon pro 575 opengl engine","575",0,[[5120,2880,48]]],["amd radeon pro 575x","575",0,[[5120,2880,56]]],["amd radeon pro 580","580",0,[[5120,2880,54]]],["amd radeon pro 580 opengl engine","580",0,[[5120,2880,50]]],["amd radeon pro 580x","580",0,[[5120,2880,52]]],["amd radeon pro duo","pro",0,[[1920,1080,234],[1800,1350,59],[3840,2160,82],[4096,2160,60]]],["amd radeon pro rx 560","560",0,[[2560,1080,60]]],["amd radeon pro ssg","pro",0,[[3440,1440,125]]],["amd radeon pro v340","340",0,[[1920,1080,112]]],["amd radeon pro v520 mxgpu","520",0,[[1920,1080,271]]],["amd radeon pro v7350x2","7350",0,[[1920,1080,60]]],["amd radeon pro vega 16","16",0,[[2879,1800,60],[3360,2100,60]]],["amd radeon pro vega 20","20",0,[[2880,1800,120],[3360,2100,121],[3840,2160,30]]],["amd radeon pro vega 48","48",0,[[5120,2880,86]]],["amd radeon pro vega 56","56",0,[[1920,1080,60],[5120,2880,60]]],["amd radeon pro vega 56 opengl engine","56",0,[[5120,2880,60]]],["amd radeon pro vega 64","64",0,[[5120,2880,60]]],["amd radeon pro vega 64 opengl engine","64",0,[[5120,2880,60]]],["amd radeon pro vega 64x","64",0,[[2560,1440,206],[4096,2304,60],[5120,2880,60]]],["amd radeon pro vega ii","proii",0,[[3840,1600,60],[5120,2880,60]]],["amd radeon pro vega ii duo","proii",0,[[2560,1440,239],[5120,2880,60]]],["amd radeon pro w5500","5500",0,[[1920,1080,195],[3840,2160,59],[7680,3240,56]]],["amd radeon pro w5500m","5500",0,[[1920,1080,60]]],["amd radeon pro w5500x","5500",0,[[1920,1200,60]]],["amd radeon pro w5700","5700",0,[[1680,1050,253],[5120,1440,120],[3840,2160,60]]],["amd radeon pro w5700x","5700",0,[[3840,2160,60]]],["amd radeon pro w6600","6600",0,[[1920,1200,60],[3840,2160,166]]],["amd radeon pro w6600m","6600",0,[[1920,1080,60]]],["amd radeon pro w6800","6800",0,[[1920,1080,60],[3840,2160,237]]],["amd radeon pro w6800x","6800",0,[[6016,3384,60]]],["amd radeon pro w6800x duo","6800",0,[[3840,1600,60],[5120,2880,45]]],["amd radeon pro w6900x","6900",0,[[3840,2160,60]]],["amd radeon pro wx","pro",0,[[2560,1080,69]]],["amd radeon pro wx 2100","2100",0,[[1280,1024,145],[1920,1080,60]]],["amd radeon pro wx 3100","3100",0,[[1919,1080,58],[1920,1080,123],[2560,1440,82]]],["amd radeon pro wx 3200","3200",0,[[2560,1440,92]]],["amd radeon pro wx 4100","4100",0,[[1920,1080,60],[1920,1200,60],[3840,2160,30],[5120,2880,18]]],["amd radeon pro wx 4130","4130",0,[[1920,1080,60],[3840,2160,30]]],["amd radeon pro wx 4150","4150",0,[[1920,1080,56],[3840,2160,37],[4096,2160,34]]],["amd radeon pro wx 5100","5100",0,[[1920,1080,60],[2560,1440,91],[3840,2160,55]]],["amd radeon pro wx 5100 opengl engine","5100",0,[[2560,1440,60]]],["amd radeon pro wx 7100","7100",0,[[1920,1080,122],[2560,1080,58],[3840,2160,60],[5120,2880,60]]],["amd radeon pro wx 7100 mobile","7100",0,[[2560,1440,60]]],["amd radeon pro wx 7100 opengl engine","7100",0,[[3840,2160,60]]],["amd radeon pro wx 8200","8200",0,[[3440,1440,124]]],["amd radeon pro wx 9100","9100",0,[[1920,1080,60],[4096,2160,101]]],["amd radeon pro wx 9100 opengl engine","9100",0,[[1920,1080,60]]],["amd radeon pro wx vega m gl","prom",0,[[3840,2160,14]]],["amd radeon pro wx3200","3200",0,[[1920,1080,55]]],["amd radeon pro wx9100","9100",0,[[2560,1440,60]]],["amd radeon r2","2",0,[[1366,768,13],[1600,900,14]]],["amd radeon r2e","2",0,[[1366,768,16],[1920,1080,45],[3840,2160,4]]],["amd radeon r3","3",0,[[1366,768,17],[1920,1080,15]]],["amd radeon r4","4",0,[[1366,768,19],[1920,1080,13]]],["amd radeon r4e","4",0,[[3840,2160,6]]],["amd radeon r5","5",0,[[1024,768,38],[1360,768,25],[1366,768,21],[1280,1024,33],[1920,1080,14],[3200,1800,7]]],["amd radeon r5 220","5",0,[[1366,768,19],[1920,1080,12]]],["amd radeon r5 230","5",0,[[1920,1080,21]]],["amd radeon r5 235","5",0,[[1920,1080,17]]],["amd radeon r5 240","5",0,[[1280,1024,34],[1920,1080,24]]],["amd radeon r5 340","5",0,[[1920,1080,27]]],["amd radeon r5 340x","5",0,[[1920,1080,31]]],["amd radeon r5 430","5",0,[[1280,1024,31],[1680,1050,54],[1920,1080,54]]],["amd radeon r5 435","5",0,[[1920,1080,30]]],["amd radeon r5 m200","5",0,[[1600,900,45],[1920,1080,20]]],["amd radeon r5 m200 / hd 8500m","5",0,[[1366,768,31],[1920,1080,24]]],["amd radeon r5 m230","5",0,[[1366,768,37]]],["amd radeon r5 m240","5",0,[[1366,768,42],[1920,1080,23]]],["amd radeon r5 m255","5",0,[[1366,768,59],[1600,900,33]]],["amd radeon r5 m315","5",0,[[1366,768,45]]],["amd radeon r5 m320","5",0,[[1920,1080,19]]],["amd radeon r5 m330","5",0,[[1366,768,27],[1920,1080,26]]],["amd radeon r5 m335","5",0,[[1366,768,55],[1920,1080,19]]],["amd radeon r5 m420","5",0,[[1366,768,49]]],["amd radeon r5 m430","5",0,[[1366,768,36],[1920,1080,20]]],["amd radeon r5 m435","5",0,[[1920,1080,41],[2560,1440,67]]],["amd radeon r5 m445","5",0,[[1920,1080,32]]],["amd radeon r5e","5",0,[[1600,768,14],[1920,1080,16]]],["amd radeon r6","6",0,[[1366,768,30],[1280,1024,23],[1920,1080,12]]],["amd radeon r6 m255dx","6",0,[[1366,768,25]]],["amd radeon r6 m340dx","6",0,[[1366,768,31],[1920,1080,15]]],["amd radeon r6e","6",0,[[3840,2160,5]]],["amd radeon r7","7",0,[[1366,768,35],[1280,1024,31],[1680,1050,39],[1920,1080,12],[1920,1200,16],[2560,1080,15],[2560,1440,21],[3840,2160,8]]],["amd radeon r7 200","7",0,[[1280,1024,45],[1920,1080,120]]],["amd radeon r7 200 series","7",0,[[1920,1080,43]]],["amd radeon r7 240","7",0,[[1920,1080,29]]],["amd radeon r7 240 + hd 8570d dual","7",0,[[1920,1080,43]]],["amd radeon r7 250","7",0,[[1920,1080,49]]],["amd radeon r7 250e","7",0,[[1920,1080,60]]],["amd radeon r7 250x","7",0,[[1920,1080,60]]],["amd radeon r7 260x","7",0,[[1920,1080,56]]],["amd radeon r7 260x/360","7",0,[[1920,1200,102]]],["amd radeon r7 350","7",0,[[1024,768,60],[1280,1024,79],[1920,1080,59]]],["amd radeon r7 350x","7",0,[[1920,1080,50]]],["amd radeon r7 360","7",0,[[1920,1048,60],[1920,1080,102]]],["amd radeon r7 360 / r9 360","7",0,[[1920,1080,60]]],["amd radeon r7 370","7",0,[[1600,900,60],[1920,1080,75]]],["amd radeon r7 370 / r9 270","7",0,[[1920,1080,74]]],["amd radeon r7 370 / r9 270x/370","7",0,[[1600,900,115],[1920,1080,60]]],["amd radeon r7 370 / r9 270x/370x","7",0,[[1920,1080,115]]],["amd radeon r7 370 series","7",0,[[1920,1080,212],[3840,2160,60]]],["amd radeon r7 430","7",0,[[1920,1080,55],[3840,2160,10]]],["amd radeon r7 450","7",0,[[1920,1080,60]]],["amd radeon r7 a360","7",0,[[1920,1080,28]]],["amd radeon r7 graphics + hd 7700 dual","7",0,[[1600,1200,72]]],["amd radeon r7 graphics + r5 340 dual","7",0,[[1920,1080,47]]],["amd radeon r7 graphics + r7 200 dual","7",0,[[1920,1080,45],[1920,1200,47]]],["amd radeon r7 graphics + r7 350 dual","7",0,[[1919,1080,60]]],["amd radeon r7 m260","7",0,[[1600,900,44],[1920,1080,13]]],["amd radeon r7 m260dx","7",0,[[1366,768,46],[1920,1080,18]]],["amd radeon r7 m260x","7",0,[[1920,1080,29]]],["amd radeon r7 m265","7",0,[[1366,768,48],[1920,1080,27]]],["amd radeon r7 m270","7",0,[[1920,1080,31],[3840,2160,10]]],["amd radeon r7 m340","7",0,[[1366,768,60],[1920,1080,32]]],["amd radeon r7 m350","7",0,[[3840,2160,12]]],["amd radeon r7 m360","7",0,[[1366,768,40],[1920,1080,22]]],["amd radeon r7 m370","7",0,[[1920,1080,24]]],["amd radeon r7 m440","7",0,[[1920,1080,39]]],["amd radeon r7 m445","7",0,[[1920,1080,36]]],["amd radeon r7 m460","7",0,[[1919,1080,24],[1920,1080,29]]],["amd radeon r7 m520","7",0,[[1919,1080,17]]],["amd radeon r7 series / hd 9000","7",0,[[1920,1080,71],[2560,1080,59]]],["amd radeon r7e","7",0,[[1024,768,41]]],["amd radeon r8 m350dx","8",0,[[1366,768,30]]],["amd radeon r8 m365dx","8",0,[[1920,1080,28]]],["amd radeon r8 m435dx","8",0,[[1920,1080,22]]],["amd radeon r8 m445dx","8",0,[[1366,768,38],[1920,1080,27]]],["amd radeon r8 m535dx","8",0,[[1366,768,55]]],["amd radeon r9","9",0,[[1920,1080,60]]],["amd radeon r9 200","9",0,[[1920,1080,60]]],["amd radeon r9 200 / hd 7900","9",0,[[1920,1080,250]]],["amd radeon r9 255","9",0,[[1600,900,52],[1920,1080,51]]],["amd radeon r9 260","9",0,[[1920,1080,16]]],["amd radeon r9 270","9",0,[[1280,1024,60],[1920,1080,60]]],["amd radeon r9 270 1024sp","9",0,[[1920,1080,135]]],["amd radeon r9 270x","9",0,[[1920,1080,30]]],["amd radeon r9 280","9",0,[[1920,1080,75],[1920,1200,428],[2560,1440,60]]],["amd radeon r9 280,","9",0,[[5120,2880,39]]],["amd radeon r9 280x","9",0,[[1920,1080,137]]],["amd radeon r9 285","9",0,[[1920,1080,60],[1920,1200,129]]],["amd radeon r9 290","9",0,[[1920,1080,60]]],["amd radeon r9 290x","9",0,[[1920,1080,60],[2560,1440,60],[3840,2160,118]]],["amd radeon r9 300","9",0,[[1920,1080,59]]],["amd radeon r9 350","9",0,[[1920,1200,63]]],["amd radeon r9 360","9",0,[[1600,900,83],[1920,1080,60],[2560,1440,59]]],["amd radeon r9 370","9",0,[[1680,1050,205],[1920,1080,60],[3840,2160,49]]],["amd radeon r9 370x","9",0,[[1920,1080,60]]],["amd radeon r9 380","9",0,[[1920,1080,41],[2560,1440,75]]],["amd radeon r9 380x","9",0,[[2560,1600,60]]],["amd radeon r9 390","9",0,[[1920,1080,60],[2560,1440,60]]],["amd radeon r9 390x","9",0,[[2560,1440,60],[3840,2160,60]]],["amd radeon r9 a375","9",0,[[1920,1080,28]]],["amd radeon r9 fury","9",0,[[1920,1080,75],[3840,2160,133]]],["amd radeon r9 fury / nano","9",0,[[1920,1200,155]]],["amd radeon r9 m200x","9",0,[[1366,768,104],[1920,1080,60]]],["amd radeon r9 m265x","9",0,[[1920,1080,33]]],["amd radeon r9 m270x","9",0,[[1600,900,60],[1920,1080,68]]],["amd radeon r9 m275","9",0,[[1920,1080,29]]],["amd radeon r9 m275x","9",0,[[1920,1080,20]]],["amd radeon r9 m280x","9",0,[[1920,1080,60],[2560,1440,25]]],["amd radeon r9 m290","9",0,[[5120,2880,33]]],["amd radeon r9 m290x","9",0,[[1920,1080,60],[3840,2160,61],[5120,2880,33]]],["amd radeon r9 m295x","9",0,[[3840,2160,33],[5120,2880,36]]],["amd radeon r9 m295x mac","9",0,[[5120,2880,42]]],["amd radeon r9 m295x mac edition / r9 380x","9",0,[[1920,1080,128]]],["amd radeon r9 m360","9",0,[[1920,1080,60],[3840,2160,26]]],["amd radeon r9 m370x","9",0,[[2560,1440,30],[2880,1800,27]]],["amd radeon r9 m370x opengl engine","9",0,[[5120,2880,14]]],["amd radeon r9 m375","9",0,[[1920,1080,29]]],["amd radeon r9 m375x","9",0,[[1920,1080,60],[3840,2160,22]]],["amd radeon r9 m380","9",0,[[1920,1080,50],[3840,2160,8],[5120,2880,9]]],["amd radeon r9 m380 opengl engine","9",0,[[5120,2880,15]]],["amd radeon r9 m385","9",0,[[1920,1080,58]]],["amd radeon r9 m385x","9",0,[[1920,1080,60]]],["amd radeon r9 m390","9",0,[[5119,2879,29],[5120,2880,21],[5760,3240,32]]],["amd radeon r9 m390 opengl engine","9",0,[[5120,2880,27]]],["amd radeon r9 m390x","9",0,[[1920,1080,140]]],["amd radeon r9 m395","9",0,[[2560,1440,59],[5120,2880,19]]],["amd radeon r9 m395 opengl engine","9",0,[[5120,2880,38]]],["amd radeon r9 m395x","9",0,[[3840,2160,58],[5120,2880,36]]],["amd radeon r9 m395x opengl engine","9",0,[[5120,2880,35]]],["amd radeon r9 m470","9",0,[[3840,2160,29]]],["amd radeon r9 m470x","9",0,[[1920,1080,60]]],["amd radeon r9-290x","9",0,[[1920,1080,60]]],["amd radeon renoir graphics d1","1",0,[[1366,768,60]]],["amd radeon rro 580x","580",0,[[5120,2880,59]]],["amd radeon rx 460","460",0,[[1920,1080,55],[2560,1080,60],[3840,2160,31]]],["amd radeon rx 460 / pro 450/455/460/555/555x/560/560x","460",0,[[3440,1440,93]]],["amd radeon rx 460 / pro 450/455/460/560","460",0,[[1920,1080,72]]],["amd radeon rx 470","470",0,[[1280,1024,73],[1920,1080,58],[1920,1200,147],[3840,2160,51]]],["amd radeon rx 470 opengl engine","470",0,[[2560,1440,60]]],["amd radeon rx 475m","475",0,[[1920,1080,60]]],["amd radeon rx 480","480",0,[[1400,1050,267],[1920,1080,60],[2560,1080,71]]],["amd radeon rx 480 opengl engine","480",0,[[1920,1080,60]]],["amd radeon rx 5300m","5300",0,[[1920,1080,60],[3840,2160,60]]],["amd radeon rx 540","540",0,[[1919,1080,52],[1920,1080,36]]],["amd radeon rx 550","550",0,[[1280,1024,135],[1920,1080,60],[1920,1200,60],[6016,3384,15]]],["amd radeon rx 550 640sp / rx 560","550",0,[[1920,1080,60]]],["amd radeon rx 5500","5500",0,[[1920,1080,139]]],["amd radeon rx 5500 / pro 5500m","5500",0,[[1920,1080,60],[2560,1440,227]]],["amd radeon rx 5500 xt","5500",0,[[1920,1080,239]]],["amd radeon rx 5500m","5500",0,[[1920,1048,144],[1920,1080,144],[3840,2160,60]]],["amd radeon rx 550x","550",0,[[1920,1080,52]]],["amd radeon rx 560","560",0,[[1920,1080,60],[1920,1200,42],[2560,1440,60]]],["amd radeon rx 560 [baffin]","560",0,[[1920,1080,60]]],["amd radeon rx 5600 oem/5600 xt / 5700 xt","5600",0,[[1920,1080,360],[2560,1440,164]]],["amd radeon rx 5600 xt","5600",0,[[1920,1080,75]]],["amd radeon rx 5600m","5600",0,[[1920,1080,144]]],["amd radeon rx 560d","560",0,[[2560,1080,60]]],["amd radeon rx 560x","560",0,[[1920,1080,115],[3840,2160,35]]],["amd radeon rx 570","570",0,[[1920,1080,60],[3072,1728,60]]],["amd radeon rx 570 opengl engine","570",0,[[1920,1080,226]]],["amd radeon rx 5700","5700",0,[[1920,1080,144]]],["amd radeon rx 5700 / 5700 xt","5700",0,[[3840,2160,201]]],["amd radeon rx 5700 xt","5700",0,[[1920,1080,464],[3840,2160,60],[6016,3384,34]]],["amd radeon rx 5700 xt 50th anniversary","5700",0,[[2560,1440,144],[3840,1600,60],[3840,2160,222],[5120,2880,60]]],["amd radeon rx 5700xt","5700",0,[[1920,1080,369]]],["amd radeon rx 580","580",0,[[1920,1080,60],[1920,1200,97],[2560,1440,60],[3840,2160,60]]],["amd radeon rx 580 2048sp","580",0,[[1920,1080,60]]],["amd radeon rx 580 opengl engine","580",0,[[1920,1080,145]]],["amd radeon rx 580 special","580",0,[[2560,1440,60]]],["amd radeon rx 580x","580",0,[[1920,1200,60],[3840,2160,79]]],["amd radeon rx 590","590",0,[[1920,1080,75],[2560,1440,164],[3584,2240,60]]],["amd radeon rx 640","640",0,[[1920,1080,39]]],["amd radeon rx 6500 xt","6500",0,[[1920,1080,60]]],["amd radeon rx 6600","6600",0,[[1920,1080,433],[3840,2160,57]]],["amd radeon rx 6600 xt","6600",0,[[1920,1080,60]]],["amd radeon rx 6600 xt/6600m","6600",0,[[2560,1440,60]]],["amd radeon rx 6600m","6600",0,[[1920,1080,139]]],["amd radeon rx 6700 xt","6700",0,[[1920,1080,451]]],["amd radeon rx 6700 xt / 6800m","6700",0,[[2560,1440,144]]],["amd radeon rx 6700m","6700",0,[[1920,1080,240]]],["amd radeon rx 6800","6800",0,[[2560,1440,564],[3840,2160,60]]],["amd radeon rx 6800 xt","6800",0,[[2560,1440,446],[3440,1440,144],[3840,2160,60]]],["amd radeon rx 6800 xt / 6900 xt","6800",0,[[2560,1440,239]]],["amd radeon rx 6800 xt 16gb","6800",0,[[6400,2666,60]]],["amd radeon rx 6800m","6800",0,[[1920,1080,300]]],["amd radeon rx 6900 xt","6900",0,[[3840,2160,60]]],["amd radeon rx rx 560","560",0,[[1920,1080,60]]],["amd radeon rx vega","rx",0,[[1920,1080,39]]],["amd radeon rx vega 10","10",0,[[1920,1080,38]]],["amd radeon rx vega 11","11",0,[[1920,1080,35]]],["amd radeon rx vega 56","56",0,[[1920,1080,144],[3440,1440,60],[3840,2160,60]]],["amd radeon rx vega 56 8gb","56",0,[[2560,1600,60]]],["amd radeon rx vega 56 opengl engine","56",0,[[2560,1440,60]]],["amd radeon rx vega 64","64",0,[[2560,1440,518]]],["amd radeon rx vega 64 8gb","64",0,[[2560,1440,60]]],["amd radeon rx vega 64 opengl engine","64",0,[[3840,2160,119]]],["amd radeon rx vega 64.1","64",0,[[6016,3384,60]]],["amd radeon rx vega 8","8",0,[[1920,1080,53]]],["amd radeon rx vega m gh","rxm",0,[[1920,1080,60],[2560,1440,60],[3840,2160,51]]],["amd radeon rx vega m gl","rxm",0,[[2560,1440,567],[3840,2160,59]]],["amd radeon rx vega11","11",0,[[2496,1664,30]]],["amd radeon rx460","460",0,[[1920,1080,60]]],["amd radeon rx480","480",0,[[1920,1080,102],[2560,1080,71]]],["amd radeon rx540","540",0,[[2400,1800,37]]],["amd radeon rx550","550",0,[[1920,1080,60]]],["amd radeon rx560","560",0,[[1920,1080,93]]],["amd radeon rx5600","5600",0,[[3840,2160,129]]],["amd radeon rx570","570",0,[[5120,2880,59]]],["amd radeon rx5700","5700",0,[[1920,1080,60]]],["amd radeon rx580","580",0,[[1920,1080,60]]],["amd radeon rx590 gme","590",0,[[1920,1080,112]]],["amd radeon rx6600xt","6600",0,[[3840,2160,60]]],["amd radeon sky 500","500",0,[[4096,2160,34]]],["amd radeon vega","",0,[[5120,2880,32]]],["amd radeon vega 10","10",0,[[1920,1080,44]]],["amd radeon vega 10 mobile","10",0,[[1920,1080,30]]],["amd radeon vega 11","11",0,[[1280,1024,60],[1920,1080,60],[3840,2160,17]]],["amd radeon vega 2","2",0,[[1366,768,30]]],["amd radeon vega 3","3",0,[[1440,900,44],[1920,1080,29],[3840,2160,8]]],["amd radeon vega 3 mobile","3",0,[[1920,1080,30]]],["amd radeon vega 56","56",0,[[2560,1440,144]]],["amd radeon vega 6","6",0,[[1366,768,61],[1920,1080,23]]],["amd radeon vega 64","64",0,[[6016,3384,35]]],["amd radeon vega 64 lc","64",0,[[2560,1080,60]]],["amd radeon vega 8","8",0,[[1920,1080,35],[2560,1440,24],[4096,2160,15]]],["amd radeon vega 8 mobile","8",0,[[1920,1080,36]]],["amd radeon vega 9","9",0,[[2496,1663,32],[2496,1664,39]]],["amd radeon vega fe","fe",0,[[1920,1080,120],[2560,1440,60]]],["amd radeon vega frontier","",0,[[1920,1080,120],[3840,2160,60]]],["amd radeon vega frontier edition opengl engine","",0,[[3440,1440,60]]],["amd radeon vega series / radeon vega mobile","",0,[[1920,1080,67]]],["amd radeon vii","vii",0,[[1920,1080,468],[2560,1440,60],[3840,2160,60]]],["amd radeont 540x","540",0,[[1920,1080,74],[3840,2160,22]]],["amd radeont rx 5300","5300",0,[[1920,1080,60]]],["amd radeont rx 5500m","5500",0,[[1920,1080,303]]],["amd radeont rx 560x","560",0,[[1920,1080,60]]],["amd renoir","",0,[[1920,1080,60]]],["amd rx 480","480",0,[[1680,1050,119]]],["amd rx 560","560",0,[[5120,2880,37]]],["amd rx 5700xt","5700",0,[[3840,2160,60]]],["amd rx 580","580",0,[[1920,1200,60],[5120,2880,60]]],["amd rx 590","590",0,[[5120,2880,60]]],["amd rx vega 64","64",0,[[1920,1080,60]]],["amd rx xxx","xxx",0,[[1920,1080,60],[2560,1440,144]]],["amd saphire radeon rx 580","580",0,[[1920,1080,57]]],["amd sapphire hd 5770","5770",0,[[1440,900,60]]],["amd sapphire nitro+ rx 6800","6800",0,[[1920,1080,75]]],["amd sapphire radeon hd6870","6870",0,[[1680,1050,60]]],["amd sapphire radeon rx 560","560",0,[[1280,1024,60]]],["amd sapphire radeon rx vega 64 8gb","64",0,[[2560,1440,144]]],["amd tonga pro gl [firepro w7100]","7100",0,[[1920,1200,127]]],["amd video controller","",0,[[1919,1079,60],[1920,1080,291]]],["intel radeong 0.4 on amd bonaire","0",0,[[1920,1200,92]]],["intel radeong 0.4 on amd cape verde","0",0,[[1920,1200,73]]],["intel radeong 0.4 on amd polaris10","0",0,[[3840,2160,108]]],["intel radeong 0.4 on amd tonga","0",0,[[1920,1080,124]]],["radeong 0.4 on amd polaris10","0",0,[[3840,2160,109]]],["radeong 0.4 on amd tahiti","0",0,[[1920,1080,223]]]]')
                            },
                            732: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["apple a14","14",0,[[2704,1756,120]]],["apple m1","1",0,[[2880,1800,60]]],["apple m1 max","1",0,[[3456,2234,120]]],["apple m1 pro","1",0,[[3024,1964,120]]],["apple paravirtual device","",0,[[1024,768,30]]]]')
                            },
                            405: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["intel geforce gtx 960","960",0,[[1920,1080,26]]],["nvidia asus geforce gt 430","430",0,[[1366,768,35]]],["nvidia asus geforce gt 440","440",0,[[1920,1080,28]]],["nvidia asus geforce gt 520","520",0,[[1680,1050,12]]],["nvidia asus geforce gt 610","610",0,[[1920,1200,15]]],["nvidia asus geforce gt 630","630",0,[[1680,1050,41]]],["nvidia asus geforce gt 640","640",0,[[2560,1440,34]]],["nvidia asus geforce gt 710","710",0,[[1920,1080,31]]],["nvidia asus geforce gt 730","730",0,[[2560,1080,28],[3840,2160,12]]],["nvidia asus geforce gts 450","450",0,[[1920,1080,54]]],["nvidia asus geforce gtx 1060","1060",0,[[3840,2160,38]]],["nvidia asus geforce gtx 1080","1080",0,[[2560,1440,120]]],["nvidia asus geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia asus geforce gtx 480","480",0,[[1920,1080,59]]],["nvidia asus geforce gtx 550 ti","550",0,[[1920,1080,57]]],["nvidia asus geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia asus geforce gtx 560 se","560",0,[[1920,1080,59]]],["nvidia asus geforce gtx 560 ti","560",0,[[1680,1050,58]]],["nvidia asus geforce gtx 570","570",0,[[1280,1024,74]]],["nvidia asus geforce gtx 570 hd","570",0,[[1920,1080,60]]],["nvidia asus geforce gtx 580","580",0,[[1920,1200,59]]],["nvidia asus geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia asus geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia asus geforce gtx 750 ti","750",0,[[1360,768,59],[1920,1080,118]]],["nvidia asus geforce gtx 760","760",0,[[1920,1080,60],[1920,1200,60]]],["nvidia asus geforce gtx 770","770",0,[[1920,1080,60]]],["nvidia asus geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia asus geforce gtx 950","950",0,[[1920,1080,60]]],["nvidia asus geforce gtx 960","960",0,[[1920,1080,60],[2560,1600,117]]],["nvidia asus geforce gtx 970","970",0,[[2560,1600,60]]],["nvidia asus geforce gtx 980 ti","980",0,[[2560,1440,131]]],["nvidia colorful geforce gtx 960","960",0,[[2560,1440,60]]],["nvidia elitegroup geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia evga geforce gt 545","545",0,[[1920,1080,37]]],["nvidia evga geforce gt 640","640",0,[[1366,768,60]]],["nvidia evga geforce gt 710","710",0,[[1680,1050,36],[1920,1080,29]]],["nvidia evga geforce gt 730","730",0,[[1600,900,59]]],["nvidia evga geforce gt 740","740",0,[[1280,1024,45]]],["nvidia evga geforce gtx 1050 ti","1050",0,[[2560,1440,60],[4096,2304,58]]],["nvidia evga geforce gtx 1070","1070",0,[[5120,2880,60]]],["nvidia evga geforce gtx 1080 ti","1080",0,[[1920,1200,60]]],["nvidia evga geforce gtx 560 ti","560",0,[[1680,1050,59]]],["nvidia evga geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia evga geforce gtx 580","580",0,[[2560,1440,60]]],["nvidia evga geforce gtx 650","650",0,[[1920,1200,87],[2560,1600,43]]],["nvidia evga geforce gtx 650 ti","650",0,[[1680,1050,116],[2560,1440,55]]],["nvidia evga geforce gtx 650 ti boost","650",0,[[1920,1080,56]]],["nvidia evga geforce gtx 660 ti","660",0,[[1920,1200,60]]],["nvidia evga geforce gtx 680","680",0,[[1600,1200,60]]],["nvidia evga geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia evga geforce gtx 760","760",0,[[1920,1080,119],[1920,1200,60]]],["nvidia evga geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia evga geforce gtx 960","960",0,[[1920,1080,60],[2560,1440,115]]],["nvidia evga geforce gtx 970","970",0,[[1920,1080,120]]],["nvidia evga geforce gtx 980","980",0,[[3440,1440,60]]],["nvidia evga geforce gtx 980 ti","980",0,[[1920,1080,60]]],["nvidia gainward geforce gt 630","630",0,[[1920,1080,28]]],["nvidia gainward geforce gts 450","450",0,[[1920,1080,55]]],["nvidia gainward geforce gtx 460","460",0,[[1920,1080,58]]],["nvidia gainward geforce gtx 550 ti","550",0,[[1280,1024,67]]],["nvidia gainward geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia gainward geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia gainward geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia geforce 210","210",0,[[1920,1080,8]]],["nvidia geforce 410m","410",0,[[1366,768,25],[1600,900,19]]],["nvidia geforce 510","510",0,[[1280,960,20]]],["nvidia geforce 605","605",0,[[1768,992,17],[1920,1080,15]]],["nvidia geforce 610m","610",0,[[1366,768,26]]],["nvidia geforce 610m/710m/810m/820m / gt 620m/625m/630m/720m","610",0,[[1366,768,51]]],["nvidia geforce 615","615",0,[[1920,1080,21]]],["nvidia geforce 705m","705",0,[[1920,1080,18]]],["nvidia geforce 710a","710",0,[[1920,1080,32]]],["nvidia geforce 710m","710",0,[[1366,768,55]]],["nvidia geforce 730a","730",0,[[1920,1080,37]]],["nvidia geforce 800m","800",0,[[1920,1080,18]]],["nvidia geforce 810m","810",0,[[1366,768,44],[1920,1080,31]]],["nvidia geforce 820a","820",0,[[1920,1080,28]]],["nvidia geforce 820m","820",0,[[1366,768,57],[1920,1080,23]]],["nvidia geforce 830a","830",0,[[1920,1080,53]]],["nvidia geforce 830m","830",0,[[1366,768,60]]],["nvidia geforce 8400 gs","8400",0,[[1680,1050,4]]],["nvidia geforce 8400 gs rev. 3","8400",0,[[1920,1080,4]]],["nvidia geforce 840a","840",0,[[1920,1080,56]]],["nvidia geforce 840m","840",0,[[1920,1080,56]]],["nvidia geforce 845m","845",0,[[1920,1080,59]]],["nvidia geforce 8600 gt","8600",1,[[1920,1200,-1]]],["nvidia geforce 8600 gts","8600",1,[[1920,1080,-1]]],["nvidia geforce 910m","910",0,[[1366,768,58],[1600,900,45]]],["nvidia geforce 920m","920",0,[[1366,768,60]]],["nvidia geforce 920mx","920",0,[[1366,768,60],[1920,1080,60]]],["nvidia geforce 9300 / nforce 730i","9300",0,[[1920,1080,6]]],["nvidia geforce 930a","930",0,[[1920,1080,55]]],["nvidia geforce 930m","930",0,[[1366,768,60]]],["nvidia geforce 930mx","930",0,[[1366,768,89],[1920,1080,59]]],["nvidia geforce 9400 gt","9400",1,[[1366,768,-1]]],["nvidia geforce 940a","940",0,[[1920,1080,58]]],["nvidia geforce 940m","940",0,[[1920,1080,54]]],["nvidia geforce 940mx","940",0,[[1920,1080,60]]],["nvidia geforce 945m","945",0,[[1920,1080,59]]],["nvidia geforce 9600 gt","9600",0,[[1920,1200,2]]],["nvidia geforce 9600m gt","9600",1,[[1440,900,-1]]],["nvidia geforce 9800 gt","9800",0,[[1920,1200,52]]],["nvidia geforce 9800 gtx / 9800 gtx+","9800",0,[[1280,1024,59]]],["nvidia geforce gpu","gpu",0,[[3000,2000,36]]],["nvidia geforce gt 1010","1010",0,[[1920,1080,135]]],["nvidia geforce gt 1030","1030",0,[[1920,1080,60]]],["nvidia geforce gt 1030 opengl engine","1030",0,[[6720,3780,15]]],["nvidia geforce gt 120","120",1,[[1920,1080,-1]]],["nvidia geforce gt 240","240",0,[[1366,768,32]]],["nvidia geforce gt 320m","320",0,[[1366,768,26]]],["nvidia geforce gt 415m","415",0,[[1366,768,19]]],["nvidia geforce gt 420","420",0,[[1024,768,33],[1920,1080,20]]],["nvidia geforce gt 420m","420",0,[[1366,768,28]]],["nvidia geforce gt 425m","425",0,[[1366,768,55],[1600,900,28]]],["nvidia geforce gt 430","430",0,[[1600,1200,16],[1920,1080,28]]],["nvidia geforce gt 435m","435",0,[[1366,768,53],[1920,1080,22]]],["nvidia geforce gt 440","440",0,[[1280,1024,51],[1680,1050,38],[1920,1080,45]]],["nvidia geforce gt 445m","445",0,[[1600,900,53]]],["nvidia geforce gt 520","520",0,[[1440,900,19],[1920,1080,17]]],["nvidia geforce gt 520m","520",0,[[1366,768,29]]],["nvidia geforce gt 520mx","520",0,[[1366,768,35]]],["nvidia geforce gt 525m","525",0,[[1366,768,28],[1600,900,22]]],["nvidia geforce gt 530","530",0,[[1920,1080,26]]],["nvidia geforce gt 540m","540",0,[[1366,768,38]]],["nvidia geforce gt 545","545",0,[[1920,1080,54]]],["nvidia geforce gt 550m","550",0,[[1600,900,44],[1920,1080,29]]],["nvidia geforce gt 555m","555",0,[[1920,1080,42]]],["nvidia geforce gt 555m/635m","555",0,[[1920,1080,36]]],["nvidia geforce gt 610","610",0,[[1280,1024,22],[1920,1080,15]]],["nvidia geforce gt 620","620",0,[[1920,1080,19]]],["nvidia geforce gt 620 oem","620",0,[[1920,1080,20],[1920,1200,20]]],["nvidia geforce gt 620m","620",0,[[1366,768,55],[1920,1080,30]]],["nvidia geforce gt 620m/630m/635m/640m le","620",0,[[1368,768,38]]],["nvidia geforce gt 625","625",0,[[1920,1080,18]]],["nvidia geforce gt 625m","625",0,[[1366,768,38]]],["nvidia geforce gt 630","630",0,[[1680,1050,36],[1920,1080,36],[1920,1200,30]]],["nvidia geforce gt 630 oem","630",0,[[1600,900,33]]],["nvidia geforce gt 630 opengl engine","630",0,[[1920,1080,33]]],["nvidia geforce gt 630 rev. 2","630",0,[[1920,1080,26]]],["nvidia geforce gt 630m","630",0,[[1366,768,57]]],["nvidia geforce gt 635","635",0,[[1920,1080,27]]],["nvidia geforce gt 635m","635",0,[[1366,768,47]]],["nvidia geforce gt 640","640",0,[[1920,1080,47]]],["nvidia geforce gt 640 oem","640",0,[[1920,1080,46],[2560,1440,35]]],["nvidia geforce gt 640 opengl engine","640",0,[[1280,1024,43]]],["nvidia geforce gt 640 rev. 2","640",0,[[1280,1024,60],[1920,1080,55]]],["nvidia geforce gt 640m","640",0,[[1366,768,82],[1600,900,59],[1920,1080,34]]],["nvidia geforce gt 640m le","640",0,[[1920,1080,49]]],["nvidia geforce gt 640m mac","640",0,[[1366,768,56],[1920,1080,20]]],["nvidia geforce gt 640m opengl engine","640",0,[[1920,1080,45]]],["nvidia geforce gt 645m","645",0,[[1366,768,60]]],["nvidia geforce gt 650m","650",0,[[1360,768,59],[1920,1080,58],[2560,1440,59]]],["nvidia geforce gt 650m mac","650",0,[[1440,900,56],[1920,1080,15],[2560,1440,19],[2880,1800,31]]],["nvidia geforce gt 650m opengl engine","650",0,[[1920,1080,56],[3840,2160,27]]],["nvidia geforce gt 705","705",0,[[1920,1080,11]]],["nvidia geforce gt 710","710",0,[[1920,1080,28]]],["nvidia geforce gt 710b","710",0,[[1920,1080,26]]],["nvidia geforce gt 710m","710",0,[[1366,768,46]]],["nvidia geforce gt 720","720",0,[[1920,1080,19],[2560,1440,16],[5120,2880,5]]],["nvidia geforce gt 720 opengl engine","720",0,[[2560,1600,20]]],["nvidia geforce gt 720m","720",0,[[1366,768,42]]],["nvidia geforce gt 730","730",0,[[1920,1080,54]]],["nvidia geforce gt 730a","730",0,[[1920,1080,23]]],["nvidia geforce gt 730m","730",0,[[1920,1080,43]]],["nvidia geforce gt 735m","735",0,[[1920,1080,39]]],["nvidia geforce gt 740","740",0,[[1920,1080,55],[3440,1440,23]]],["nvidia geforce gt 740 opengl engine","740",0,[[1920,1200,51]]],["nvidia geforce gt 740m","740",0,[[1366,768,60]]],["nvidia geforce gt 745m","745",0,[[1920,1080,55]]],["nvidia geforce gt 750m","750",0,[[1920,1080,57]]],["nvidia geforce gt 750m mac","750",0,[[1920,1080,58],[2880,1800,28]]],["nvidia geforce gt 755m","755",0,[[1920,1080,57]]],["nvidia geforce gt 755m mac","755",0,[[2560,1440,41]]],["nvidia geforce gt 755m opengl engine","755",0,[[2560,1440,51]]],["nvidia geforce gt 820m","820",0,[[1600,900,47]]],["nvidia geforce gts 250","250",0,[[1680,1050,53]]],["nvidia geforce gts 450","450",0,[[1360,768,60],[1680,1050,57],[1920,1080,55]]],["nvidia geforce gts 450 rev. 2","450",0,[[1920,1080,56]]],["nvidia geforce gtx 1050","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 3gb","1050",0,[[1280,1024,60]]],["nvidia geforce gtx 1050 mobile","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 opengl engine","1050",0,[[1920,1080,116]]],["nvidia geforce gtx 1050 ti","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 ti mobile","1050",0,[[1920,1080,298]]],["nvidia geforce gtx 1050 ti opengl engine","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 ti with max-q design","1050",0,[[1920,1080,268],[2560,1440,102],[3840,2160,60]]],["nvidia geforce gtx 1050 with max-q design","1050",0,[[1920,1080,60],[3840,2160,24]]],["nvidia geforce gtx 1060","1060",0,[[1920,1080,60],[3840,2160,59]]],["nvidia geforce gtx 1060 3gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 3gb opengl engine","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 5gb","1060",0,[[1920,1080,55]]],["nvidia geforce gtx 1060 6gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 6gb opengl engine","1060",0,[[1920,1080,75]]],["nvidia geforce gtx 1060 mobile","1060",0,[[1920,1080,422]]],["nvidia geforce gtx 1060 mobile 6gb","1060",0,[[1920,1080,120]]],["nvidia geforce gtx 1060 with max-q design","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060se 3gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1070","1070",0,[[1920,1080,134]]],["nvidia geforce gtx 1070 a17","1070",0,[[1920,1080,60]]],["nvidia geforce gtx 1070 mobile","1070",0,[[1920,1080,467]]],["nvidia geforce gtx 1070 opengl engine","1070",0,[[1920,1080,143]]],["nvidia geforce gtx 1070 ti","1070",0,[[1920,1080,60],[6016,3384,59]]],["nvidia geforce gtx 1070 ti opengl engine","1070",0,[[1920,1080,75]]],["nvidia geforce gtx 1070 with max-q design","1070",0,[[1920,1080,448]]],["nvidia geforce gtx 1070 with maxq design","1070",0,[[1920,1080,60],[3840,2160,59]]],["nvidia geforce gtx 1080","1080",0,[[1920,1080,119],[2560,1440,326],[3840,2160,286]]],["nvidia geforce gtx 1080 mobile","1080",0,[[1920,1080,120]]],["nvidia geforce gtx 1080 opengl engine","1080",0,[[1920,1080,79]]],["nvidia geforce gtx 1080 ti","1080",0,[[1920,1080,120]]],["nvidia geforce gtx 1080 ti opengl engine","1080",0,[[1920,1080,127]]],["nvidia geforce gtx 1080 with max-q design","1080",0,[[1920,1080,144]]],["nvidia geforce gtx 1180","1180",0,[[3440,1440,60]]],["nvidia geforce gtx 1650","1650",0,[[1920,1080,380]]],["nvidia geforce gtx 1650 mobile / max-q","1650",0,[[1920,1080,292]]],["nvidia geforce gtx 1650 super","1650",0,[[1920,1080,433]]],["nvidia geforce gtx 1650 ti","1650",0,[[1920,1080,144],[3840,2400,59]]],["nvidia geforce gtx 1650 ti mobile","1650",0,[[1920,1080,144]]],["nvidia geforce gtx 1650 ti with max-q design","1650",0,[[1920,1080,60],[3839,2160,60]]],["nvidia geforce gtx 1650 with max-q design","1650",0,[[1920,1080,142],[3000,2000,60]]],["nvidia geforce gtx 1660","1660",0,[[1920,1080,144]]],["nvidia geforce gtx 1660 super","1660",0,[[1920,1080,60]]],["nvidia geforce gtx 1660 ti","1660",0,[[1920,1080,546],[3840,2160,60]]],["nvidia geforce gtx 1660 ti mobile","1660",0,[[1920,1080,451]]],["nvidia geforce gtx 1660 ti with max-q design","1660",0,[[1920,1080,144]]],["nvidia geforce gtx 280","280",0,[[1680,1050,56]]],["nvidia geforce gtx 295","295",0,[[1920,1080,56]]],["nvidia geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia geforce gtx 460 oem","460",0,[[1360,768,60],[1920,1080,60]]],["nvidia geforce gtx 460 opengl engine","460",0,[[1920,1080,59]]],["nvidia geforce gtx 460 se","460",0,[[1920,1080,56],[1920,1200,57]]],["nvidia geforce gtx 460 v2","460",0,[[1920,1080,60],[1920,1200,60],[2560,1600,55]]],["nvidia geforce gtx 460m","460",0,[[1920,1080,46]]],["nvidia geforce gtx 465","465",0,[[1920,1080,134],[1920,1200,59]]],["nvidia geforce gtx 470","470",0,[[1680,1050,60],[1920,1080,59]]],["nvidia geforce gtx 470m","470",0,[[1920,1200,55]]],["nvidia geforce gtx 480","480",0,[[1440,900,191],[1920,1080,115],[1920,1200,60]]],["nvidia geforce gtx 480 opengl engine","480",0,[[1600,1200,60]]],["nvidia geforce gtx 550 ti","550",0,[[1280,1024,58],[1920,1080,58]]],["nvidia geforce gtx 550 ti opengl engine","550",0,[[1920,1080,55]]],["nvidia geforce gtx 555","555",0,[[1920,1080,54]]],["nvidia geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia geforce gtx 560 se","560",0,[[1680,1050,52],[1920,1080,111]]],["nvidia geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia geforce gtx 560 ti 448 cores","560",0,[[1920,1080,60],[2560,1440,60]]],["nvidia geforce gtx 560 ti oem","560",0,[[1920,1080,176]]],["nvidia geforce gtx 560 ti opengl engine","560",0,[[1920,1080,48]]],["nvidia geforce gtx 560m","560",0,[[1920,1080,55]]],["nvidia geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia geforce gtx 570 opengl engine","570",0,[[1920,1080,60]]],["nvidia geforce gtx 570 rev. 2","570",0,[[1920,1080,60],[1920,1200,60]]],["nvidia geforce gtx 570m","570",0,[[1920,1080,125],[2560,1440,8]]],["nvidia geforce gtx 580","580",0,[[1920,1080,60]]],["nvidia geforce gtx 580 opengl engine","580",0,[[1680,1050,59]]],["nvidia geforce gtx 580m","580",0,[[1920,1080,60]]],["nvidia geforce gtx 590","590",0,[[1920,1080,59]]],["nvidia geforce gtx 645","645",0,[[1920,1080,57],[1920,1200,58]]],["nvidia geforce gtx 645 opengl engine","645",0,[[1920,1200,58]]],["nvidia geforce gtx 650","650",0,[[1920,1080,72]]],["nvidia geforce gtx 650 oem","650",0,[[1366,768,59]]],["nvidia geforce gtx 650 opengl engine","650",0,[[1920,1080,59]]],["nvidia geforce gtx 650 ti","650",0,[[1920,1080,60]]],["nvidia geforce gtx 650 ti boost","650",0,[[1280,1024,60],[1600,1200,187],[1920,1080,60]]],["nvidia geforce gtx 650 ti opengl engine","650",0,[[1920,1080,60]]],["nvidia geforce gtx 660","660",0,[[1920,1080,111]]],["nvidia geforce gtx 660 oem","660",0,[[1920,1080,59]]],["nvidia geforce gtx 660 ti","660",0,[[1920,1080,60]]],["nvidia geforce gtx 660 ti opengl engine","660",0,[[1280,1024,60]]],["nvidia geforce gtx 660m","660",0,[[1680,1050,36],[1920,1080,59]]],["nvidia geforce gtx 660m mac","660",0,[[2560,1440,2]]],["nvidia geforce gtx 660m opengl engine","660",0,[[2560,1440,36]]],["nvidia geforce gtx 670","670",0,[[1920,1080,100]]],["nvidia geforce gtx 670 opengl engine","670",0,[[1920,1080,60]]],["nvidia geforce gtx 670m","670",0,[[1920,1080,66]]],["nvidia geforce gtx 670mx","670",0,[[1920,1080,60]]],["nvidia geforce gtx 675m","675",0,[[1920,1080,60]]],["nvidia geforce gtx 675mx","675",0,[[1680,1050,60],[1920,1080,60],[2560,1440,55]]],["nvidia geforce gtx 675mx mac","675",0,[[2560,1440,36]]],["nvidia geforce gtx 675mx opengl engine","675",0,[[2560,1440,60]]],["nvidia geforce gtx 680","680",0,[[1920,1080,60]]],["nvidia geforce gtx 680 opengl engine","680",0,[[1920,1080,60]]],["nvidia geforce gtx 680m","680",0,[[1920,1080,39],[1920,1200,60]]],["nvidia geforce gtx 680m opengl engine","680",0,[[1920,1080,36]]],["nvidia geforce gtx 680mx","680",0,[[2560,1440,59]]],["nvidia geforce gtx 680mx opengl engine","680",0,[[2560,1440,59]]],["nvidia geforce gtx 690","690",0,[[1920,1080,60],[3840,2160,30]]],["nvidia geforce gtx 745","745",0,[[1920,1080,60],[2560,1600,29]]],["nvidia geforce gtx 750","750",0,[[1920,1080,60]]],["nvidia geforce gtx 750 opengl engine","750",0,[[1920,1200,58]]],["nvidia geforce gtx 750 ti","750",0,[[1920,1080,97]]],["nvidia geforce gtx 760","760",0,[[1920,1080,60],[1920,1200,116]]],["nvidia geforce gtx 760 oem","760",0,[[1920,1080,60]]],["nvidia geforce gtx 760 opengl engine","760",0,[[1920,1080,52]]],["nvidia geforce gtx 760 ti","760",0,[[1920,1080,60],[1920,1200,60]]],["nvidia geforce gtx 760 ti oem","760",0,[[1920,1200,60]]],["nvidia geforce gtx 760 ti opengl engine","760",0,[[1920,1080,60]]],["nvidia geforce gtx 760a","760",0,[[2560,1080,15]]],["nvidia geforce gtx 760m","760",0,[[1920,1080,60]]],["nvidia geforce gtx 765m","765",0,[[1920,1080,53],[2560,1440,57]]],["nvidia geforce gtx 765m by nick[d]vb","765",0,[[2560,1440,58]]],["nvidia geforce gtx 765m opengl engine","765",0,[[2560,1440,57]]],["nvidia geforce gtx 770","770",0,[[1920,1080,143],[2560,1440,203]]],["nvidia geforce gtx 770 opengl engine","770",0,[[1920,1080,60]]],["nvidia geforce gtx 770m","770",0,[[1920,1080,60],[2560,1440,59]]],["nvidia geforce gtx 770m by nick[d]vb","770",0,[[2560,1440,34]]],["nvidia geforce gtx 770m opengl engine","770",0,[[2560,1440,59]]],["nvidia geforce gtx 775m by idopt mac","775",0,[[2560,1440,56]]],["nvidia geforce gtx 775m mac","775",0,[[2560,1440,59]]],["nvidia geforce gtx 775m opengl engine","775",0,[[2560,1440,60]]],["nvidia geforce gtx 780","780",0,[[1920,1080,159]]],["nvidia geforce gtx 780 by st3phl3","780",0,[[3840,2160,30]]],["nvidia geforce gtx 780 mac","780",0,[[1680,1050,60],[1920,1080,60]]],["nvidia geforce gtx 780 rev. 2","780",0,[[1920,1080,144],[2560,1440,119],[3840,2160,58],[5120,2880,58]]],["nvidia geforce gtx 780 ti","780",0,[[1280,1024,120],[1920,1080,119]]],["nvidia geforce gtx 780 ti opengl engine","780",0,[[2560,1440,60]]],["nvidia geforce gtx 780m","780",0,[[1920,1080,60],[2560,1440,59]]],["nvidia geforce gtx 780m by nick[d]vb","780",0,[[1920,1080,59],[2560,1440,60]]],["nvidia geforce gtx 780m mac","780",0,[[2560,1440,60]]],["nvidia geforce gtx 780m opengl engine","780",0,[[2560,1440,60]]],["nvidia geforce gtx 850a","850",0,[[2560,1440,48]]],["nvidia geforce gtx 850m","850",0,[[1920,1080,60]]],["nvidia geforce gtx 860m","860",0,[[1920,1080,59]]],["nvidia geforce gtx 860m opengl engine","860",0,[[2560,1440,58]]],["nvidia geforce gtx 870m","870",0,[[1920,1080,60],[2560,1440,102]]],["nvidia geforce gtx 880m","880",0,[[1920,1080,60],[2560,1440,74]]],["nvidia geforce gtx 880m opengl engine","880",0,[[2560,1440,60]]],["nvidia geforce gtx 950","950",0,[[1920,1080,98]]],["nvidia geforce gtx 950 opengl engine","950",0,[[1920,1200,60]]],["nvidia geforce gtx 950a","950",0,[[1920,1080,60],[3840,2160,38]]],["nvidia geforce gtx 950m","950",0,[[1920,1080,114]]],["nvidia geforce gtx 960","960",0,[[1920,1080,60]]],["nvidia geforce gtx 960a","960",0,[[1920,1440,128]]],["nvidia geforce gtx 960m","960",0,[[1920,1080,119],[3840,2160,37]]],["nvidia geforce gtx 965m","965",0,[[1920,1080,195],[3000,2000,59],[3840,2160,41]]],["nvidia geforce gtx 965m opengl engine","965",0,[[2880,1620,55]]],["nvidia geforce gtx 970","970",0,[[1920,1080,143]]],["nvidia geforce gtx 970 opengl engine","970",0,[[2560,1600,60]]],["nvidia geforce gtx 970m","970",0,[[1920,1080,60]]],["nvidia geforce gtx 980","980",0,[[1920,1080,60],[3440,1440,294]]],["nvidia geforce gtx 980 ti","980",0,[[1920,1080,119],[2560,1440,456]]],["nvidia geforce gtx 980 ti opengl engine","980",0,[[1920,1080,60]]],["nvidia geforce gtx 980m","980",0,[[1920,1080,60],[3840,2160,104]]],["nvidia geforce gtx titan","gtx",0,[[1920,1080,119],[1920,1200,119],[2560,1440,60]]],["nvidia geforce gtx titan black","gtx",0,[[1680,1050,60],[1920,1080,60],[1920,1200,60],[2560,1440,60]]],["nvidia geforce gtx titan black opengl engine","gtx",0,[[3840,2160,60]]],["nvidia geforce gtx titan opengl engine","gtx",0,[[2560,1440,60]]],["nvidia geforce gtx titan x","gtxx",0,[[1920,1080,144],[2560,1440,120],[2560,1600,60]]],["nvidia geforce gtx titan xp","gtxxp",0,[[2560,1440,60],[3440,1440,60]]],["nvidia geforce gtx titan z","gtxz",0,[[1440,900,59],[1920,1080,39],[3840,2160,60]]],["nvidia geforce gtx780m by nikey22","780",0,[[2560,1440,60]]],["nvidia geforce gtx870m by nikey22","870",0,[[2560,1440,60]]],["nvidia geforce gtx880m","880",0,[[1920,1080,60]]],["nvidia geforce gtx880m by nikey22","880",0,[[2560,1440,59]]],["nvidia geforce gtx880m opengl engine","880",0,[[2560,1440,59]]],["nvidia geforce mx110","110",0,[[1366,768,61],[1920,1080,57]]],["nvidia geforce mx130","130",0,[[1920,1080,60]]],["nvidia geforce mx150","150",0,[[1920,1080,113]]],["nvidia geforce mx230","230",0,[[1920,1080,60]]],["nvidia geforce mx250","250",0,[[1920,1080,60]]],["nvidia geforce mx330","330",0,[[1920,1080,60],[3840,2160,51]]],["nvidia geforce mx350","350",0,[[1920,1080,60]]],["nvidia geforce mx450","450",0,[[1920,1080,60]]],["nvidia geforce pre-release graphics device","pre",0,[[2560,1440,60]]],["nvidia geforce pre-release tesla c2075 opengl engine","2075",0,[[1600,900,59]]],["nvidia geforce pre-release titan x opengl engine","prex",0,[[1920,1080,60]]],["nvidia geforce pre-release titan xp collectors edition opengl e","prexpe",0,[[1920,1080,59]]],["nvidia geforce pre-release titan xp opengl engine","prexp",0,[[2560,1440,60]]],["nvidia geforce rtx 2060","2060",0,[[1920,1080,512]]],["nvidia geforce rtx 2060 max-q","2060",0,[[2560,1440,301]]],["nvidia geforce rtx 2060 mobile","2060",0,[[1920,1080,518]]],["nvidia geforce rtx 2060 rev. a","2060",0,[[3840,2160,257]]],["nvidia geforce rtx 2060 super","2060",0,[[1920,1080,645],[2560,1440,143]]],["nvidia geforce rtx 2060 with max-q design","2060",0,[[1920,1080,292],[1920,1200,60]]],["nvidia geforce rtx 2070","2070",0,[[1920,1080,60],[3840,2160,60]]],["nvidia geforce rtx 2070 mobile","2070",0,[[1920,1080,477]]],["nvidia geforce rtx 2070 mobile / max-q","2070",0,[[1920,1080,526]]],["nvidia geforce rtx 2070 mobile / max-q refresh","2070",0,[[1920,1080,143]]],["nvidia geforce rtx 2070 rev. a","2070",0,[[2560,1440,144]]],["nvidia geforce rtx 2070 super","2070",0,[[1920,1080,510]]],["nvidia geforce rtx 2070 super with max-q design","2070",0,[[1920,1080,300]]],["nvidia geforce rtx 2070 with max-q design","2070",0,[[1920,1080,240]]],["nvidia geforce rtx 2080","2080",0,[[1920,1080,632],[2560,1440,165]]],["nvidia geforce rtx 2080 mobile","2080",0,[[1920,1080,144]]],["nvidia geforce rtx 2080 rev. a","2080",0,[[2560,1440,143]]],["nvidia geforce rtx 2080 super","2080",0,[[1920,1080,601]]],["nvidia geforce rtx 2080 super mobile / max-q","2080",0,[[3840,2160,59]]],["nvidia geforce rtx 2080 super with max-q design","2080",0,[[1920,1080,300]]],["nvidia geforce rtx 2080 ti","2080",0,[[1920,1080,83]]],["nvidia geforce rtx 2080 ti rev. a","2080",0,[[1920,1080,403]]],["nvidia geforce rtx 2080 with max-q design","2080",0,[[1920,1080,476]]],["nvidia geforce rtx 3050","3050",0,[[1920,1080,60]]],["nvidia geforce rtx 3050 laptop gpu","3050",0,[[1920,1080,144]]],["nvidia geforce rtx 3050 ti laptop gpu","3050",0,[[1920,1080,144]]],["nvidia geforce rtx 3060","3060",0,[[1920,1080,674]]],["nvidia geforce rtx 3060 laptop gpu","3060",0,[[1920,1080,300]]],["nvidia geforce rtx 3060 lite hash rate","3060",0,[[1920,1080,60]]],["nvidia geforce rtx 3060 mobile / max-q","3060",0,[[1920,1080,435]]],["nvidia geforce rtx 3060 ti","3060",0,[[1920,1080,779]]],["nvidia geforce rtx 3070","3070",0,[[1920,1080,723],[2560,1440,294]]],["nvidia geforce rtx 3070 laptop gpu","3070",0,[[1920,1080,357]]],["nvidia geforce rtx 3070 mobile / max-q","3070",0,[[2560,1440,386]]],["nvidia geforce rtx 3070 ti","3070",0,[[1920,1080,60]]],["nvidia geforce rtx 3080","3080",0,[[1920,1080,726],[2560,1440,60],[3840,2160,60]]],["nvidia geforce rtx 3080 laptop gpu","3080",0,[[1920,1080,294],[2560,1440,244]]],["nvidia geforce rtx 3080 mobile / max-q 8gb/16gb","3080",0,[[1920,1080,293]]],["nvidia geforce rtx 3080 ti","3080",0,[[1920,1080,239],[2560,1440,60]]],["nvidia geforce rtx 3090","3090",0,[[2560,1440,60],[3840,2160,474]]],["nvidia geforce rtx t10-16","10",0,[[2560,1600,3]]],["nvidia geforce rtx t10-8","10",0,[[2560,1600,3]]],["nvidia gigabyte geforce gt 440","440",0,[[1280,1024,34]]],["nvidia gigabyte geforce gt 610","610",0,[[1920,1080,17]]],["nvidia gigabyte geforce gt 630","630",0,[[1920,1080,34]]],["nvidia gigabyte geforce gt 730","730",0,[[1280,1024,38]]],["nvidia gigabyte geforce gts 450","450",0,[[1280,1024,37]]],["nvidia gigabyte geforce gtx 1050 ti","1050",0,[[1920,1080,30]]],["nvidia gigabyte geforce gtx 460","460",0,[[1680,1050,60]]],["nvidia gigabyte geforce gtx 550 ti","550",0,[[1920,1080,57]]],["nvidia gigabyte geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 570 hd","570",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 580","580",0,[[1920,1200,60]]],["nvidia gigabyte geforce gtx 650","650",0,[[1680,1050,55]]],["nvidia gigabyte geforce gtx 650 ti","650",0,[[2560,1440,40]]],["nvidia gigabyte geforce gtx 660","660",0,[[1920,1080,31]]],["nvidia gigabyte geforce gtx 660 ti","660",0,[[5120,2880,29]]],["nvidia gigabyte geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 750","750",0,[[1920,1080,59]]],["nvidia gigabyte geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 760","760",0,[[3440,1440,17]]],["nvidia gigabyte geforce gtx 770","770",0,[[2560,1440,59]]],["nvidia gigabyte geforce gtx 780 ti","780",0,[[1920,1080,240]]],["nvidia gigabyte geforce gtx 960","960",0,[[1920,1080,142],[1920,1200,120]]],["nvidia gigabyte geforce gtx 970","970",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 980","980",0,[[2560,1440,60]]],["nvidia gigabyte geforce gtx 980 ti","980",0,[[1920,1080,60]]],["nvidia hp geforce gt 730","730",0,[[1920,1080,55]]],["nvidia inno3d geforce gtx660","3",0,[[2560,1440,107]]],["nvidia msi geforce gt 610","610",0,[[1920,1080,16]]],["nvidia msi geforce gt 630","630",0,[[1440,900,12]]],["nvidia msi geforce gt 635","635",0,[[1920,1080,30]]],["nvidia msi geforce gt 710","710",0,[[1920,1080,27]]],["nvidia msi geforce gt 730","730",0,[[1920,1080,53]]],["nvidia msi geforce gtx 1050 ti","1050",0,[[1920,1080,59]]],["nvidia msi geforce gtx 1060","1060",0,[[1920,1080,120]]],["nvidia msi geforce gtx 1070","1070",0,[[1920,1200,45]]],["nvidia msi geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia msi geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia msi geforce gtx 570 hd","570",0,[[1920,1200,60]]],["nvidia msi geforce gtx 580","580",0,[[2560,1440,60]]],["nvidia msi geforce gtx 650","650",0,[[2560,1080,52]]],["nvidia msi geforce gtx 650 ti","650",0,[[1920,1080,60]]],["nvidia msi geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia msi geforce gtx 660 ti","660",0,[[1680,1050,49]]],["nvidia msi geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia msi geforce gtx 745","745",0,[[1920,1080,55]]],["nvidia msi geforce gtx 760","760",0,[[1280,1024,30],[1920,1080,58]]],["nvidia msi geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia msi geforce gtx 950","950",0,[[1920,1080,59]]],["nvidia msi geforce gtx 960","960",0,[[1680,1050,120],[2560,1440,59]]],["nvidia msi geforce gtx 970","970",0,[[1680,1050,60]]],["nvidia msi geforce gtx 980","980",0,[[1920,1080,120],[3840,2160,60]]],["nvidia msi geforce gtx 980 ti","980",0,[[5120,2880,56]]],["nvidia null geforce 920a","920",0,[[1920,1080,25]]],["nvidia palit geforce gtx 650","650",0,[[1920,1080,49]]],["nvidia palit geforce gtx 650 ti","650",0,[[1920,1080,59]]],["nvidia palit geforce gtx 660","660",0,[[1920,1080,26]]],["nvidia pegatron geforce gt 420","420",0,[[1400,1050,25]]],["nvidia pny geforce gt 610","610",0,[[1280,1024,19]]],["nvidia pny geforce gtx 1060","1060",0,[[1920,1080,60]]],["nvidia pny geforce gtx 460","460",0,[[1360,768,59]]],["nvidia pny geforce gtx 550 ti","550",0,[[1920,1080,55]]],["nvidia pny geforce gtx 570 hd","570",0,[[1280,1024,72]]],["nvidia pny geforce gtx 580","580",0,[[1920,1200,59]]],["nvidia pny geforce gtx 680","680",0,[[2560,1080,120]]],["nvidia pny geforce gtx 750","750",0,[[1280,1024,60]]],["nvidia pny geforce gtx 970","970",0,[[2560,1440,60]]],["nvidia pny geforce gtx 980","980",0,[[1920,1080,120]]],["nvidia point of view geforce gtx 470","470",0,[[1920,1080,59]]],["nvidia point of view geforce gtx 660 ti","660",0,[[1680,1050,59]]],["nvidia sony geforce 410m","410",0,[[1366,768,24]]],["nvidia toshiba geforce gt 525m","525",0,[[1366,768,33]]],["nvidia zotac geforce gt 430","430",0,[[1600,900,32]]],["nvidia zotac geforce gt 610","610",0,[[1920,1080,15]]],["nvidia zotac geforce gt 630","630",0,[[1360,768,46]]],["nvidia zotac geforce gt 740","740",0,[[1280,1024,118]]],["nvidia zotac geforce gtx 460","460",0,[[1920,1080,59]]],["nvidia zotac geforce gtx 550 ti","550",0,[[1920,1080,42]]],["nvidia zotac geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 580","580",0,[[1920,1080,48]]],["nvidia zotac geforce gtx 650","650",0,[[1920,1080,44]]],["nvidia zotac geforce gtx 650 ti","650",0,[[1920,1080,58]]],["nvidia zotac geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 680","680",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 750","750",0,[[1680,1050,114],[1920,1080,60]]],["nvidia zotac geforce gtx 760","760",0,[[1920,1080,101]]],["nvidia zotac geforce gtx 770","770",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 960","960",0,[[2048,1152,60]]]]')
                            },
                            178: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["intel","",0,[[4096,2304,12]]],["intel 0x496e74656c2048442047726170686963000732034343","0",0,[[1920,1080,22]]],["intel broxton-p hd","p",0,[[1920,1080,73]]],["intel cherryview hd","hd",0,[[1920,1080,16]]],["intel coffee lake uhd","uhd",0,[[1920,1080,49]]],["intel cometlake uhd graphics 630","630",0,[[2560,1440,40]]],["intel corporation 2nd gen core processor family integrated graphics controller","2",0,[[1366,768,25]]],["intel corporation 2nd generation core processor family integrated graphics controller","2",0,[[1600,900,28]]],["intel corporation 3rd gen core processor graphics controller","3",0,[[1366,768,20]]],["intel corporation 8th gen core processor gaussian mixture model","8",0,[[1366,768,17]]],["intel corporation atom processor z36xxx/z37xxx series graphics & display","36",0,[[1280,799,18],[1366,768,18]]],["intel corporation atom/celeron/pentium processor n4200 series integrated graphics controller","4200",0,[[1280,1024,28]]],["intel corporation atom/celeron/pentium processor x5-e8000 integrated graphics controller","5",0,[[1366,768,34]]],["intel corporation atom/celeron/pentium processor x5-e8000 series pci configuration registers","5",0,[[1920,1080,14]]],["intel corporation broadwell-u integrated","u",0,[[1920,1080,38]]],["intel corporation celeron n3350 n4200/atom e3900 series integrated graphics controller","3350",0,[[1680,1050,33]]],["intel corporation coffeelake-h gt2 [uhd graphics 630]","2",0,[[1920,1080,76]]],["intel corporation cometlake-h gt2 [uhd graphics]","2",0,[[3072,1728,29]]],["intel corporation cometlake-s gt2 [uhd graphics 630]","2",0,[[1920,1080,52]]],["intel corporation cometlake-u gt2 [uhd graphics]","2",0,[[1920,1080,39]]],["intel corporation device","",0,[[1920,1080,31]]],["intel corporation geminilake [uhd graphics 600]","600",0,[[1920,1080,15]]],["intel corporation haswell-ult integrated graphics controller","ult",0,[[1366,768,35]]],["intel corporation hd","hd",0,[[1920,1080,24]]],["intel corporation hd graphics 500","500",0,[[1366,768,19]]],["intel corporation hd graphics 510","510",0,[[1368,768,48]]],["intel corporation hd graphics 515","515",0,[[1920,1080,29]]],["intel corporation hd graphics 520","520",0,[[1366,768,59]]],["intel corporation hd graphics 530","530",0,[[1920,1080,58]]],["intel corporation hd graphics 5300","5300",0,[[1920,1080,35]]],["intel corporation hd graphics 5500","5500",0,[[1920,1080,36]]],["intel corporation hd graphics 610","610",0,[[1920,1080,28]]],["intel corporation hd graphics 620","620",0,[[1920,1080,56],[3200,1800,17]]],["intel corporation hd graphics 630","630",0,[[1920,1080,58]]],["intel corporation iris graphics 540","540",0,[[1920,1080,54]]],["intel corporation iris graphics 6100","6100",0,[[2560,1600,20]]],["intel corporation iris plus graphics 650","650",0,[[1440,900,60]]],["intel corporation iris plus graphics 655","655",0,[[1920,1080,119]]],["intel corporation iris plus graphics g1","1",0,[[1920,1080,57]]],["intel corporation iris plus graphics g7","7",0,[[1920,1080,112]]],["intel corporation iris pro graphics 580","580",0,[[1920,1080,60]]],["intel corporation iris pro graphics 6200","6200",0,[[2560,1080,41]]],["intel corporation iris xe","xe",0,[[1920,1200,60]]],["intel corporation sky lake integrated","sky",0,[[2560,1440,52]]],["intel corporation skylake gt2 [hd graphics 520]","2",0,[[1920,1080,52],[2560,1440,31]]],["intel corporation skylake integrated","",0,[[1920,1080,51]]],["intel corporation tigerlake gt2 [iris xe graphics]","2",0,[[1920,1080,60]]],["intel corporation tigerlake-lp gt2 [iris xe graphics]","2",0,[[1920,1080,60]]],["intel corporation uhd","uhd",0,[[1920,1080,65]]],["intel corporation uhd graphics 605","605",0,[[1920,1080,21]]],["intel corporation uhd graphics 615","615",0,[[1920,1080,30]]],["intel corporation uhd graphics 620","620",0,[[1920,1080,55]]],["intel corporation uhd graphics 630","630",0,[[1920,1080,57]]],["intel corporation whiskeylake-u gt2 [uhd graphics 620]","2",0,[[1920,1080,57]]],["intel corporation xeon e3-1200 v2 gen core processor graphics controller","3",0,[[1920,1080,15]]],["intel corporation xeon e3-1200 v3 gen core processor integrated graphics controller","3",0,[[1360,768,42],[1440,900,34],[1280,1024,23],[1920,1080,22]]],["intel corporation, series chipset iris plus graphics 655","655",0,[[1920,1080,42]]],["intel geforce gtx 960","960",0,[[1920,1080,26]]],["intel gen12 desktop graphics controller","12",0,[[3840,2160,20]]],["intel graphics gfx-driver-user-feature_dg1_poweron-27723 dch releaseinternal","1",0,[[3840,2160,11]]],["intel hd","hd",0,[[1280,800,18],[1366,768,26],[1600,900,12],[1920,1080,13],[1920,1200,16],[1920,1280,18],[3000,2002,6],[4096,2160,4]]],["intel hd 4000","4000",0,[[1366,768,37]]],["intel hd 530","530",0,[[1920,1200,54]]],["intel hd graphics 3000","3000",0,[[1920,1080,21]]],["intel hd graphics 4000","4000",0,[[1280,800,41],[1366,768,33],[1440,900,31],[1680,1050,50],[1920,1080,27],[2560,1600,13],[2880,1800,12]]],["intel hd graphics 4000,,,,,,,","4000",0,[[1920,1080,19]]],["intel hd graphics 4400","4400",0,[[1366,768,28],[1280,1024,48],[1920,1080,18],[2160,1440,20]]],["intel hd graphics 4600","4600",0,[[1366,768,14],[1280,960,65],[1280,1024,60],[1600,900,33],[1680,1050,31],[1600,1200,47],[1920,1080,19],[1920,1200,22],[2880,1620,14]]],["intel hd graphics 500","500",0,[[1920,1080,15]]],["intel hd graphics 5000","5000",0,[[1366,768,45],[1440,900,42],[1920,1032,25],[1920,1080,27],[2160,1439,19],[2160,1440,23],[2560,1440,15]]],["intel hd graphics 505","505",0,[[1366,768,28],[1920,1080,16]]],["intel hd graphics 510","510",0,[[1366,768,29],[1440,900,46],[1680,1050,12],[1920,1080,27]]],["intel hd graphics 515","515",0,[[1920,1080,45],[2720,768,22],[1920,1280,41],[2160,1440,28],[2560,1600,16],[2736,1824,19],[3200,1800,12],[3840,2160,10]]],["intel hd graphics 520","520",0,[[1366,768,90],[1920,1080,30],[2736,1824,26],[3000,2000,21]]],["intel hd graphics 530","530",0,[[1366,768,21],[1280,1024,65],[1920,1080,47],[1920,1200,39],[3840,2160,6]]],["intel hd graphics 5300","5300",0,[[1920,1080,21],[2304,1440,19],[2560,1600,13]]],["intel hd graphics 5500","5500",0,[[1366,768,37],[1920,1080,21]]],["intel hd graphics 5600","5600",0,[[1920,1080,26],[1920,1200,40],[2880,1620,21]]],["intel hd graphics 6000","6000",0,[[1366,768,43],[1440,900,40],[1920,1080,21]]],["intel hd graphics 610","610",0,[[1366,768,33],[1600,900,42],[1920,1080,27],[3840,2160,8]]],["intel hd graphics 615","615",0,[[1600,900,13],[1920,1080,18],[1800,1200,29],[1920,1200,34],[2560,1440,25],[2560,1600,21],[2736,1824,21]]],["intel hd graphics 620","620",0,[[1920,1080,37],[2736,1824,27],[3200,1800,25],[3840,2160,13]]],["intel hd graphics 630","630",0,[[1366,768,69],[1920,1080,40],[2560,1440,27],[2560,1600,23],[3360,2100,56],[3840,2160,12]]],["intel hd graphics 630 gt2","630",0,[[1920,1080,39],[1720,1440,120]]],["intel hd graphics cfl crb","hdcfl",0,[[2560,1440,38]]],["intel hd graphics family","hd",0,[[1366,768,44]]],["intel hd graphics icl rvp","hdicl",0,[[1920,1080,58]]],["intel hd graphics icl rvp bigsur","hdicl",0,[[1920,1080,57]]],["intel hd graphics kbl crb","hdkbl",0,[[1920,1080,57],[3840,2160,13]]],["intel hd graphics p4600","4600",0,[[1280,1024,57],[1920,1080,18],[2560,1600,60]]],["intel hd graphics p530","530",0,[[2560,1440,36],[3840,2160,12]]],["intel hd graphics p630","630",0,[[1440,900,35],[1920,1200,50]]],["intel hd graphics, gen10","10",0,[[3840,2160,4]]],["intel hd5500 broadwell pg7","5500",0,[[1366,768,31]]],["intel hd5500 graphics pg7","5500",0,[[1366,768,56]]],["intel iris","",0,[[1366,768,57],[1600,900,34],[1920,1080,34],[2560,1600,17],[2880,1800,14]]],["intel iris graphics 5100","5100",0,[[1920,1080,35],[2560,1600,18]]],["intel iris graphics 540","540",0,[[1920,1080,20],[2736,1824,28],[2880,1800,23],[3200,1800,17],[3840,2160,17]]],["intel iris graphics 550","550",0,[[1920,1080,81],[2160,1440,45],[2560,1600,28],[2880,1800,26],[3840,2160,24]]],["intel iris graphics 6100","6100",0,[[1920,1080,26],[2560,1600,19],[3840,2160,10]]],["intel iris graphics 6200","6200",0,[[4096,2304,13]]],["intel iris graphics 640","640",0,[[2256,1504,24],[3840,2160,9]]],["intel iris graphics 650","650",0,[[2560,1440,24]]],["intel iris graphics p580","580",0,[[3840,2160,12]]],["intel iris plus","",0,[[1920,1080,60],[2256,1504,95],[2496,1664,93],[2736,1824,60],[2880,1800,60],[3000,2000,56]]],["intel iris plus graphics 640","640",0,[[1920,1080,87],[2256,1504,46],[2560,1600,44],[2735,1823,28],[2736,1824,28],[2880,1800,26],[3072,1728,25],[3200,1800,37],[3840,2160,16]]],["intel iris plus graphics 645","645",0,[[2560,1599,32],[2560,1600,56],[2880,1800,47]]],["intel iris plus graphics 650","650",0,[[1920,1080,60],[2560,1600,49],[2880,1800,27],[3840,2160,16]]],["intel iris plus graphics 655","655",0,[[1920,1080,58],[2560,1440,85],[2880,1800,32],[3840,2160,24]]],["intel iris pro","pro",0,[[1920,1080,56]]],["intel iris pro graphics 5200","5200",0,[[1920,1080,53],[2879,1800,24],[2880,1800,21]]],["intel iris pro graphics 580","580",0,[[1920,1080,58],[2560,1080,91],[2560,1440,58],[3840,1600,27]]],["intel iris pro graphics 6200","6200",0,[[1366,696,38],[1920,1080,58],[1920,1200,60],[3840,2160,19],[4096,2304,14]]],["intel iris pro graphics p580","580",0,[[1024,768,42],[1920,1080,103],[3840,2160,27]]],["intel iris pro graphics p6300","6300",0,[[1366,768,102],[1440,900,128],[1920,1080,30]]],["intel iris xe","xe",0,[[1920,1080,88]]],["intel iris xe graphics releaseinternal","xe",0,[[3840,2160,38]]],["intel iris xe max","xe",0,[[1920,1080,60],[3840,2160,56]]],["intel kabylake hd graphics ult gt2","2",0,[[3840,2160,11]]],["intel kabylake hd graphics ulx gt2","2",0,[[1920,1080,28],[3840,2160,6]]],["intel kbl unknown","kbl",0,[[1920,1080,54]]],["intel mesa dri intel bay trail","dribay",0,[[1366,768,14]]],["intel mesa dri intel haswell mobile","dri",0,[[1920,1080,27]]],["intel mesa dri intel hd","drihd",0,[[1920,1080,10]]],["intel mesa dri intel hd graphics 400","400",0,[[1366,768,30]]],["intel mesa dri intel hd graphics 505","505",0,[[1920,1080,27]]],["intel mesa dri intel hd graphics 520","520",0,[[1920,1080,45],[2560,1440,24]]],["intel mesa dri intel hd graphics 530","530",0,[[3840,2160,12]]],["intel mesa dri intel hd graphics 5500","5500",0,[[1366,768,40]]],["intel mesa dri intel hd graphics 620","620",0,[[1920,1080,53]]],["intel mesa dri intel hd graphics 630","630",0,[[1477,831,58]]],["intel mesa dri intel hd graphics p4000","4000",0,[[1920,1080,36]]],["intel mesa dri intel iris graphics 540","540",0,[[1280,720,40]]],["intel mesa dri intel ivybridge desktop","dri",0,[[2560,1080,16]]],["intel mesa dri intel ivybridge mobile","dri",0,[[1920,1080,25]]],["intel mesa dri intel kabylake gt2","2",0,[[1920,1080,36]]],["intel mesa dri intel sandybridge desktop","dri",0,[[1280,1024,12]]],["intel mesa dri intel sandybridge mobile","dri",0,[[1366,768,33]]],["intel mesa dri intel uhd graphics 620","620",0,[[2736,1824,22]]],["intel mesa dri intel uhd graphics 630","630",0,[[1920,1080,42]]],["intel mesa intel hd graphics 520","520",0,[[1920,1080,47]]],["intel mesa intel hd graphics 530","530",0,[[1920,1080,55]]],["intel phdgd ivy 4","4",0,[[1366,768,45]]],["intel radeon pro vega 16","16",0,[[3360,1890,20]]],["intel radeong 0.4 on amd bonaire","0",0,[[1920,1200,92]]],["intel radeong 0.4 on amd cape verde","0",0,[[1920,1200,73]]],["intel radeong 0.4 on amd polaris10","0",0,[[3840,2160,108]]],["intel radeong 0.4 on amd tonga","0",0,[[1920,1080,124]]],["intel skl unknown","skl",0,[[1920,1080,43]]],["intel skylake gt2 [hd graphics 520]","2",0,[[1920,1080,39]]],["intel uhd","uhd",0,[[1920,1080,58],[2560,1600,22],[3440,1440,14],[2736,1824,32],[3840,2160,31]]],["intel uhd 630","630",0,[[2560,1440,38]]],["intel uhd graphics 600","600",0,[[1366,768,27],[1920,1080,13],[1920,1200,13],[2560,1440,11],[3840,2160,5]]],["intel uhd graphics 600 universal","600",0,[[1919,1031,15]]],["intel uhd graphics 605","605",0,[[1366,768,29],[1920,1080,37]]],["intel uhd graphics 610","610",0,[[1366,768,58],[1920,1080,32],[1920,1200,37],[2560,1440,17],[3840,2160,11]]],["intel uhd graphics 615","615",0,[[1920,1080,34],[1920,1280,29],[3840,2160,9]]],["intel uhd graphics 617","617",0,[[1920,1080,43],[2560,1599,24],[2560,1600,26],[2880,1800,24]]],["intel uhd graphics 620","620",0,[[1920,1080,50],[2736,1824,33],[3200,1800,16]]],["intel uhd graphics 630","630",0,[[1440,900,112],[1920,1080,44],[1920,1200,65],[2560,1080,68],[2560,1440,26],[3440,1440,25],[3584,2240,137],[3840,2160,12],[6016,3384,8]]],["intel uhd graphics 730","730",0,[[1920,1080,53]]],["intel uhd graphics 750","750",0,[[1920,1080,56],[3840,2160,36]]],["intel uhd graphics 770","770",0,[[3440,1440,78],[5120,1440,31]]],["intel uhd graphics gfx-driver-user-comp_core-23599","23599",0,[[3840,2160,18]]],["intel uhd graphics p630","630",0,[[1920,1080,54],[3840,2160,21]]],["intel uhd graphics releaseinternal","uhd",0,[[3199,1800,22],[3000,2000,47]]],["intel uhd graphics, gen11 lp","11",0,[[3840,2160,10]]],["intel uhd graphics, gen12 lp releaseinternal","12",0,[[3839,2159,4]]],["intel uhd graphics, lkf","uhdlkf",0,[[1927,1439,14]]],["intel unknown","",0,[[1920,1080,37]]],["intel xe","xe",0,[[1920,1080,268],[2560,1440,137]]],["intel xeon e3-1200 v3 gen core processor integrated graphics controller","3",0,[[1600,900,49]]]]')
                            },
                            217: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["nvidia %nvidia_dev.13d7.0580.1028%","13",0,[[1920,1018,60]]],["nvidia a100-pcie-40gb","100",0,[[1920,1080,449]]],["nvidia a40","40",0,[[1920,1080,504]]],["nvidia a40-8q","40",0,[[2560,1440,58]]],["nvidia ashley","",0,[[1920,1080,60]]],["nvidia asus geforce gt 430","430",0,[[1366,768,35]]],["nvidia asus geforce gt 440","440",0,[[1920,1080,28]]],["nvidia asus geforce gt 520","520",0,[[1680,1050,12]]],["nvidia asus geforce gt 610","610",0,[[1920,1200,15]]],["nvidia asus geforce gt 630","630",0,[[1680,1050,41]]],["nvidia asus geforce gt 640","640",0,[[2560,1440,34]]],["nvidia asus geforce gt 710","710",0,[[1920,1080,31]]],["nvidia asus geforce gt 730","730",0,[[2560,1080,28],[3840,2160,12]]],["nvidia asus geforce gts 450","450",0,[[1920,1080,54]]],["nvidia asus geforce gtx 1060","1060",0,[[3840,2160,38]]],["nvidia asus geforce gtx 1080","1080",0,[[2560,1440,120]]],["nvidia asus geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia asus geforce gtx 480","480",0,[[1920,1080,59]]],["nvidia asus geforce gtx 550 ti","550",0,[[1920,1080,57]]],["nvidia asus geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia asus geforce gtx 560 se","560",0,[[1920,1080,59]]],["nvidia asus geforce gtx 560 ti","560",0,[[1680,1050,58]]],["nvidia asus geforce gtx 570","570",0,[[1280,1024,74]]],["nvidia asus geforce gtx 570 hd","570",0,[[1920,1080,60]]],["nvidia asus geforce gtx 580","580",0,[[1920,1200,59]]],["nvidia asus geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia asus geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia asus geforce gtx 750 ti","750",0,[[1360,768,59],[1920,1080,118]]],["nvidia asus geforce gtx 760","760",0,[[1920,1080,60],[1920,1200,60]]],["nvidia asus geforce gtx 770","770",0,[[1920,1080,60]]],["nvidia asus geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia asus geforce gtx 950","950",0,[[1920,1080,60]]],["nvidia asus geforce gtx 960","960",0,[[1920,1080,60],[2560,1600,117]]],["nvidia asus geforce gtx 970","970",0,[[2560,1600,60]]],["nvidia asus geforce gtx 980 ti","980",0,[[2560,1440,131]]],["nvidia chip model","",0,[[1920,1080,60]]],["nvidia colorful geforce gtx 960","960",0,[[2560,1440,60]]],["nvidia dell nvs 5200m","5200",0,[[1920,1080,27]]],["nvidia dell quadro 2000m","2000",0,[[1920,1080,29]]],["nvidia device","",0,[[1920,1080,746]]],["nvidia elitegroup geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia evga geforce gt 545","545",0,[[1920,1080,37]]],["nvidia evga geforce gt 640","640",0,[[1366,768,60]]],["nvidia evga geforce gt 710","710",0,[[1680,1050,36],[1920,1080,29]]],["nvidia evga geforce gt 730","730",0,[[1600,900,59]]],["nvidia evga geforce gt 740","740",0,[[1280,1024,45]]],["nvidia evga geforce gtx 1050 ti","1050",0,[[2560,1440,60],[4096,2304,58]]],["nvidia evga geforce gtx 1070","1070",0,[[5120,2880,60]]],["nvidia evga geforce gtx 1080 ti","1080",0,[[1920,1200,60]]],["nvidia evga geforce gtx 560 ti","560",0,[[1680,1050,59]]],["nvidia evga geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia evga geforce gtx 580","580",0,[[2560,1440,60]]],["nvidia evga geforce gtx 650","650",0,[[1920,1200,87],[2560,1600,43]]],["nvidia evga geforce gtx 650 ti","650",0,[[1680,1050,116],[2560,1440,55]]],["nvidia evga geforce gtx 650 ti boost","650",0,[[1920,1080,56]]],["nvidia evga geforce gtx 660 ti","660",0,[[1920,1200,60]]],["nvidia evga geforce gtx 680","680",0,[[1600,1200,60]]],["nvidia evga geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia evga geforce gtx 760","760",0,[[1920,1080,119],[1920,1200,60]]],["nvidia evga geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia evga geforce gtx 960","960",0,[[1920,1080,60],[2560,1440,115]]],["nvidia evga geforce gtx 970","970",0,[[1920,1080,120]]],["nvidia evga geforce gtx 980","980",0,[[3440,1440,60]]],["nvidia evga geforce gtx 980 ti","980",0,[[1920,1080,60]]],["nvidia ga104gl [rtx a4000]","104",0,[[3840,2160,60]]],["nvidia gainward geforce gt 630","630",0,[[1920,1080,28]]],["nvidia gainward geforce gts 450","450",0,[[1920,1080,55]]],["nvidia gainward geforce gtx 460","460",0,[[1920,1080,58]]],["nvidia gainward geforce gtx 550 ti","550",0,[[1280,1024,67]]],["nvidia gainward geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia gainward geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia gainward geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia geforce 210","210",0,[[1920,1080,8]]],["nvidia geforce 410m","410",0,[[1366,768,25],[1600,900,19]]],["nvidia geforce 510","510",0,[[1280,960,20]]],["nvidia geforce 605","605",0,[[1768,992,17],[1920,1080,15]]],["nvidia geforce 610m","610",0,[[1366,768,26]]],["nvidia geforce 610m/710m/810m/820m / gt 620m/625m/630m/720m","610",0,[[1366,768,51]]],["nvidia geforce 615","615",0,[[1920,1080,21]]],["nvidia geforce 705m","705",0,[[1920,1080,18]]],["nvidia geforce 710a","710",0,[[1920,1080,32]]],["nvidia geforce 710m","710",0,[[1366,768,55]]],["nvidia geforce 730a","730",0,[[1920,1080,37]]],["nvidia geforce 800m","800",0,[[1920,1080,18]]],["nvidia geforce 810m","810",0,[[1366,768,44],[1920,1080,31]]],["nvidia geforce 820a","820",0,[[1920,1080,28]]],["nvidia geforce 820m","820",0,[[1366,768,57],[1920,1080,23]]],["nvidia geforce 830a","830",0,[[1920,1080,53]]],["nvidia geforce 830m","830",0,[[1366,768,60]]],["nvidia geforce 8400 gs","8400",0,[[1680,1050,4]]],["nvidia geforce 8400 gs rev. 3","8400",0,[[1920,1080,4]]],["nvidia geforce 840a","840",0,[[1920,1080,56]]],["nvidia geforce 840m","840",0,[[1920,1080,56]]],["nvidia geforce 845m","845",0,[[1920,1080,59]]],["nvidia geforce 8600 gt","8600",1,[[1920,1200,-1]]],["nvidia geforce 8600 gts","8600",1,[[1920,1080,-1]]],["nvidia geforce 910m","910",0,[[1366,768,58],[1600,900,45]]],["nvidia geforce 920m","920",0,[[1366,768,60]]],["nvidia geforce 920mx","920",0,[[1366,768,60],[1920,1080,60]]],["nvidia geforce 9300 / nforce 730i","9300",0,[[1920,1080,6]]],["nvidia geforce 930a","930",0,[[1920,1080,55]]],["nvidia geforce 930m","930",0,[[1366,768,60]]],["nvidia geforce 930mx","930",0,[[1366,768,89],[1920,1080,59]]],["nvidia geforce 9400 gt","9400",1,[[1366,768,-1]]],["nvidia geforce 940a","940",0,[[1920,1080,58]]],["nvidia geforce 940m","940",0,[[1920,1080,54]]],["nvidia geforce 940mx","940",0,[[1920,1080,60]]],["nvidia geforce 945m","945",0,[[1920,1080,59]]],["nvidia geforce 9600 gt","9600",0,[[1920,1200,2]]],["nvidia geforce 9600m gt","9600",1,[[1440,900,-1]]],["nvidia geforce 9800 gt","9800",0,[[1920,1200,52]]],["nvidia geforce 9800 gtx / 9800 gtx+","9800",0,[[1280,1024,59]]],["nvidia geforce gpu","gpu",0,[[3000,2000,36]]],["nvidia geforce gt 1010","1010",0,[[1920,1080,135]]],["nvidia geforce gt 1030","1030",0,[[1920,1080,60]]],["nvidia geforce gt 1030 opengl engine","1030",0,[[6720,3780,15]]],["nvidia geforce gt 120","120",1,[[1920,1080,-1]]],["nvidia geforce gt 240","240",0,[[1366,768,32]]],["nvidia geforce gt 320m","320",0,[[1366,768,26]]],["nvidia geforce gt 415m","415",0,[[1366,768,19]]],["nvidia geforce gt 420","420",0,[[1024,768,33],[1920,1080,20]]],["nvidia geforce gt 420m","420",0,[[1366,768,28]]],["nvidia geforce gt 425m","425",0,[[1366,768,55],[1600,900,28]]],["nvidia geforce gt 430","430",0,[[1600,1200,16],[1920,1080,28]]],["nvidia geforce gt 435m","435",0,[[1366,768,53],[1920,1080,22]]],["nvidia geforce gt 440","440",0,[[1280,1024,51],[1680,1050,38],[1920,1080,45]]],["nvidia geforce gt 445m","445",0,[[1600,900,53]]],["nvidia geforce gt 520","520",0,[[1440,900,19],[1920,1080,17]]],["nvidia geforce gt 520m","520",0,[[1366,768,29]]],["nvidia geforce gt 520mx","520",0,[[1366,768,35]]],["nvidia geforce gt 525m","525",0,[[1366,768,28],[1600,900,22]]],["nvidia geforce gt 530","530",0,[[1920,1080,26]]],["nvidia geforce gt 540m","540",0,[[1366,768,38]]],["nvidia geforce gt 545","545",0,[[1920,1080,54]]],["nvidia geforce gt 550m","550",0,[[1600,900,44],[1920,1080,29]]],["nvidia geforce gt 555m","555",0,[[1920,1080,42]]],["nvidia geforce gt 555m/635m","555",0,[[1920,1080,36]]],["nvidia geforce gt 610","610",0,[[1280,1024,22],[1920,1080,15]]],["nvidia geforce gt 620","620",0,[[1920,1080,19]]],["nvidia geforce gt 620 oem","620",0,[[1920,1080,20],[1920,1200,20]]],["nvidia geforce gt 620m","620",0,[[1366,768,55],[1920,1080,30]]],["nvidia geforce gt 620m/630m/635m/640m le","620",0,[[1368,768,38]]],["nvidia geforce gt 625","625",0,[[1920,1080,18]]],["nvidia geforce gt 625m","625",0,[[1366,768,38]]],["nvidia geforce gt 630","630",0,[[1680,1050,36],[1920,1080,36],[1920,1200,30]]],["nvidia geforce gt 630 oem","630",0,[[1600,900,33]]],["nvidia geforce gt 630 opengl engine","630",0,[[1920,1080,33]]],["nvidia geforce gt 630 rev. 2","630",0,[[1920,1080,26]]],["nvidia geforce gt 630m","630",0,[[1366,768,57]]],["nvidia geforce gt 635","635",0,[[1920,1080,27]]],["nvidia geforce gt 635m","635",0,[[1366,768,47]]],["nvidia geforce gt 640","640",0,[[1920,1080,47]]],["nvidia geforce gt 640 oem","640",0,[[1920,1080,46],[2560,1440,35]]],["nvidia geforce gt 640 opengl engine","640",0,[[1280,1024,43]]],["nvidia geforce gt 640 rev. 2","640",0,[[1280,1024,60],[1920,1080,55]]],["nvidia geforce gt 640m","640",0,[[1366,768,82],[1600,900,59],[1920,1080,34]]],["nvidia geforce gt 640m le","640",0,[[1920,1080,49]]],["nvidia geforce gt 640m mac","640",0,[[1366,768,56],[1920,1080,20]]],["nvidia geforce gt 640m opengl engine","640",0,[[1920,1080,45]]],["nvidia geforce gt 645m","645",0,[[1366,768,60]]],["nvidia geforce gt 650m","650",0,[[1360,768,59],[1920,1080,58],[2560,1440,59]]],["nvidia geforce gt 650m mac","650",0,[[1440,900,56],[1920,1080,15],[2560,1440,19],[2880,1800,31]]],["nvidia geforce gt 650m opengl engine","650",0,[[1920,1080,56],[3840,2160,27]]],["nvidia geforce gt 705","705",0,[[1920,1080,11]]],["nvidia geforce gt 710","710",0,[[1920,1080,28]]],["nvidia geforce gt 710b","710",0,[[1920,1080,26]]],["nvidia geforce gt 710m","710",0,[[1366,768,46]]],["nvidia geforce gt 720","720",0,[[1920,1080,19],[2560,1440,16],[5120,2880,5]]],["nvidia geforce gt 720 opengl engine","720",0,[[2560,1600,20]]],["nvidia geforce gt 720m","720",0,[[1366,768,42]]],["nvidia geforce gt 730","730",0,[[1920,1080,54]]],["nvidia geforce gt 730a","730",0,[[1920,1080,23]]],["nvidia geforce gt 730m","730",0,[[1920,1080,43]]],["nvidia geforce gt 735m","735",0,[[1920,1080,39]]],["nvidia geforce gt 740","740",0,[[1920,1080,55],[3440,1440,23]]],["nvidia geforce gt 740 opengl engine","740",0,[[1920,1200,51]]],["nvidia geforce gt 740m","740",0,[[1366,768,60]]],["nvidia geforce gt 745m","745",0,[[1920,1080,55]]],["nvidia geforce gt 750m","750",0,[[1920,1080,57]]],["nvidia geforce gt 750m mac","750",0,[[1920,1080,58],[2880,1800,28]]],["nvidia geforce gt 755m","755",0,[[1920,1080,57]]],["nvidia geforce gt 755m mac","755",0,[[2560,1440,41]]],["nvidia geforce gt 755m opengl engine","755",0,[[2560,1440,51]]],["nvidia geforce gt 820m","820",0,[[1600,900,47]]],["nvidia geforce gts 250","250",0,[[1680,1050,53]]],["nvidia geforce gts 450","450",0,[[1360,768,60],[1680,1050,57],[1920,1080,55]]],["nvidia geforce gts 450 rev. 2","450",0,[[1920,1080,56]]],["nvidia geforce gtx 1050","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 3gb","1050",0,[[1280,1024,60]]],["nvidia geforce gtx 1050 mobile","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 opengl engine","1050",0,[[1920,1080,116]]],["nvidia geforce gtx 1050 ti","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 ti mobile","1050",0,[[1920,1080,298]]],["nvidia geforce gtx 1050 ti opengl engine","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 ti with max-q design","1050",0,[[1920,1080,268],[2560,1440,102],[3840,2160,60]]],["nvidia geforce gtx 1050 with max-q design","1050",0,[[1920,1080,60],[3840,2160,24]]],["nvidia geforce gtx 1060","1060",0,[[1920,1080,60],[3840,2160,59]]],["nvidia geforce gtx 1060 3gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 3gb opengl engine","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 5gb","1060",0,[[1920,1080,55]]],["nvidia geforce gtx 1060 6gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 6gb opengl engine","1060",0,[[1920,1080,75]]],["nvidia geforce gtx 1060 mobile","1060",0,[[1920,1080,422]]],["nvidia geforce gtx 1060 mobile 6gb","1060",0,[[1920,1080,120]]],["nvidia geforce gtx 1060 with max-q design","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060se 3gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1070","1070",0,[[1920,1080,134]]],["nvidia geforce gtx 1070 a17","1070",0,[[1920,1080,60]]],["nvidia geforce gtx 1070 mobile","1070",0,[[1920,1080,467]]],["nvidia geforce gtx 1070 opengl engine","1070",0,[[1920,1080,143]]],["nvidia geforce gtx 1070 ti","1070",0,[[1920,1080,60],[6016,3384,59]]],["nvidia geforce gtx 1070 ti opengl engine","1070",0,[[1920,1080,75]]],["nvidia geforce gtx 1070 with max-q design","1070",0,[[1920,1080,448]]],["nvidia geforce gtx 1070 with maxq design","1070",0,[[1920,1080,60],[3840,2160,59]]],["nvidia geforce gtx 1080","1080",0,[[1920,1080,119],[2560,1440,326],[3840,2160,286]]],["nvidia geforce gtx 1080 mobile","1080",0,[[1920,1080,120]]],["nvidia geforce gtx 1080 opengl engine","1080",0,[[1920,1080,79]]],["nvidia geforce gtx 1080 ti","1080",0,[[1920,1080,120]]],["nvidia geforce gtx 1080 ti opengl engine","1080",0,[[1920,1080,127]]],["nvidia geforce gtx 1080 with max-q design","1080",0,[[1920,1080,144]]],["nvidia geforce gtx 1180","1180",0,[[3440,1440,60]]],["nvidia geforce gtx 1650","1650",0,[[1920,1080,380]]],["nvidia geforce gtx 1650 mobile / max-q","1650",0,[[1920,1080,292]]],["nvidia geforce gtx 1650 super","1650",0,[[1920,1080,433]]],["nvidia geforce gtx 1650 ti","1650",0,[[1920,1080,144],[3840,2400,59]]],["nvidia geforce gtx 1650 ti mobile","1650",0,[[1920,1080,144]]],["nvidia geforce gtx 1650 ti with max-q design","1650",0,[[1920,1080,60],[3839,2160,60]]],["nvidia geforce gtx 1650 with max-q design","1650",0,[[1920,1080,142],[3000,2000,60]]],["nvidia geforce gtx 1660","1660",0,[[1920,1080,144]]],["nvidia geforce gtx 1660 super","1660",0,[[1920,1080,60]]],["nvidia geforce gtx 1660 ti","1660",0,[[1920,1080,546],[3840,2160,60]]],["nvidia geforce gtx 1660 ti mobile","1660",0,[[1920,1080,451]]],["nvidia geforce gtx 1660 ti with max-q design","1660",0,[[1920,1080,144]]],["nvidia geforce gtx 280","280",0,[[1680,1050,56]]],["nvidia geforce gtx 295","295",0,[[1920,1080,56]]],["nvidia geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia geforce gtx 460 oem","460",0,[[1360,768,60],[1920,1080,60]]],["nvidia geforce gtx 460 opengl engine","460",0,[[1920,1080,59]]],["nvidia geforce gtx 460 se","460",0,[[1920,1080,56],[1920,1200,57]]],["nvidia geforce gtx 460 v2","460",0,[[1920,1080,60],[1920,1200,60],[2560,1600,55]]],["nvidia geforce gtx 460m","460",0,[[1920,1080,46]]],["nvidia geforce gtx 465","465",0,[[1920,1080,134],[1920,1200,59]]],["nvidia geforce gtx 470","470",0,[[1680,1050,60],[1920,1080,59]]],["nvidia geforce gtx 470m","470",0,[[1920,1200,55]]],["nvidia geforce gtx 480","480",0,[[1440,900,191],[1920,1080,115],[1920,1200,60]]],["nvidia geforce gtx 480 opengl engine","480",0,[[1600,1200,60]]],["nvidia geforce gtx 550 ti","550",0,[[1280,1024,58],[1920,1080,58]]],["nvidia geforce gtx 550 ti opengl engine","550",0,[[1920,1080,55]]],["nvidia geforce gtx 555","555",0,[[1920,1080,54]]],["nvidia geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia geforce gtx 560 se","560",0,[[1680,1050,52],[1920,1080,111]]],["nvidia geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia geforce gtx 560 ti 448 cores","560",0,[[1920,1080,60],[2560,1440,60]]],["nvidia geforce gtx 560 ti oem","560",0,[[1920,1080,176]]],["nvidia geforce gtx 560 ti opengl engine","560",0,[[1920,1080,48]]],["nvidia geforce gtx 560m","560",0,[[1920,1080,55]]],["nvidia geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia geforce gtx 570 opengl engine","570",0,[[1920,1080,60]]],["nvidia geforce gtx 570 rev. 2","570",0,[[1920,1080,60],[1920,1200,60]]],["nvidia geforce gtx 570m","570",0,[[1920,1080,125],[2560,1440,8]]],["nvidia geforce gtx 580","580",0,[[1920,1080,60]]],["nvidia geforce gtx 580 opengl engine","580",0,[[1680,1050,59]]],["nvidia geforce gtx 580m","580",0,[[1920,1080,60]]],["nvidia geforce gtx 590","590",0,[[1920,1080,59]]],["nvidia geforce gtx 645","645",0,[[1920,1080,57],[1920,1200,58]]],["nvidia geforce gtx 645 opengl engine","645",0,[[1920,1200,58]]],["nvidia geforce gtx 650","650",0,[[1920,1080,72]]],["nvidia geforce gtx 650 oem","650",0,[[1366,768,59]]],["nvidia geforce gtx 650 opengl engine","650",0,[[1920,1080,59]]],["nvidia geforce gtx 650 ti","650",0,[[1920,1080,60]]],["nvidia geforce gtx 650 ti boost","650",0,[[1280,1024,60],[1600,1200,187],[1920,1080,60]]],["nvidia geforce gtx 650 ti opengl engine","650",0,[[1920,1080,60]]],["nvidia geforce gtx 660","660",0,[[1920,1080,111]]],["nvidia geforce gtx 660 oem","660",0,[[1920,1080,59]]],["nvidia geforce gtx 660 ti","660",0,[[1920,1080,60]]],["nvidia geforce gtx 660 ti opengl engine","660",0,[[1280,1024,60]]],["nvidia geforce gtx 660m","660",0,[[1680,1050,36],[1920,1080,59]]],["nvidia geforce gtx 660m mac","660",0,[[2560,1440,2]]],["nvidia geforce gtx 660m opengl engine","660",0,[[2560,1440,36]]],["nvidia geforce gtx 670","670",0,[[1920,1080,100]]],["nvidia geforce gtx 670 opengl engine","670",0,[[1920,1080,60]]],["nvidia geforce gtx 670m","670",0,[[1920,1080,66]]],["nvidia geforce gtx 670mx","670",0,[[1920,1080,60]]],["nvidia geforce gtx 675m","675",0,[[1920,1080,60]]],["nvidia geforce gtx 675mx","675",0,[[1680,1050,60],[1920,1080,60],[2560,1440,55]]],["nvidia geforce gtx 675mx mac","675",0,[[2560,1440,36]]],["nvidia geforce gtx 675mx opengl engine","675",0,[[2560,1440,60]]],["nvidia geforce gtx 680","680",0,[[1920,1080,60]]],["nvidia geforce gtx 680 opengl engine","680",0,[[1920,1080,60]]],["nvidia geforce gtx 680m","680",0,[[1920,1080,39],[1920,1200,60]]],["nvidia geforce gtx 680m opengl engine","680",0,[[1920,1080,36]]],["nvidia geforce gtx 680mx","680",0,[[2560,1440,59]]],["nvidia geforce gtx 680mx opengl engine","680",0,[[2560,1440,59]]],["nvidia geforce gtx 690","690",0,[[1920,1080,60],[3840,2160,30]]],["nvidia geforce gtx 745","745",0,[[1920,1080,60],[2560,1600,29]]],["nvidia geforce gtx 750","750",0,[[1920,1080,60]]],["nvidia geforce gtx 750 opengl engine","750",0,[[1920,1200,58]]],["nvidia geforce gtx 750 ti","750",0,[[1920,1080,97]]],["nvidia geforce gtx 760","760",0,[[1920,1080,60],[1920,1200,116]]],["nvidia geforce gtx 760 oem","760",0,[[1920,1080,60]]],["nvidia geforce gtx 760 opengl engine","760",0,[[1920,1080,52]]],["nvidia geforce gtx 760 ti","760",0,[[1920,1080,60],[1920,1200,60]]],["nvidia geforce gtx 760 ti oem","760",0,[[1920,1200,60]]],["nvidia geforce gtx 760 ti opengl engine","760",0,[[1920,1080,60]]],["nvidia geforce gtx 760a","760",0,[[2560,1080,15]]],["nvidia geforce gtx 760m","760",0,[[1920,1080,60]]],["nvidia geforce gtx 765m","765",0,[[1920,1080,53],[2560,1440,57]]],["nvidia geforce gtx 765m by nick[d]vb","765",0,[[2560,1440,58]]],["nvidia geforce gtx 765m opengl engine","765",0,[[2560,1440,57]]],["nvidia geforce gtx 770","770",0,[[1920,1080,143],[2560,1440,203]]],["nvidia geforce gtx 770 opengl engine","770",0,[[1920,1080,60]]],["nvidia geforce gtx 770m","770",0,[[1920,1080,60],[2560,1440,59]]],["nvidia geforce gtx 770m by nick[d]vb","770",0,[[2560,1440,34]]],["nvidia geforce gtx 770m opengl engine","770",0,[[2560,1440,59]]],["nvidia geforce gtx 775m by idopt mac","775",0,[[2560,1440,56]]],["nvidia geforce gtx 775m mac","775",0,[[2560,1440,59]]],["nvidia geforce gtx 775m opengl engine","775",0,[[2560,1440,60]]],["nvidia geforce gtx 780","780",0,[[1920,1080,159]]],["nvidia geforce gtx 780 by st3phl3","780",0,[[3840,2160,30]]],["nvidia geforce gtx 780 mac","780",0,[[1680,1050,60],[1920,1080,60]]],["nvidia geforce gtx 780 rev. 2","780",0,[[1920,1080,144],[2560,1440,119],[3840,2160,58],[5120,2880,58]]],["nvidia geforce gtx 780 ti","780",0,[[1280,1024,120],[1920,1080,119]]],["nvidia geforce gtx 780 ti opengl engine","780",0,[[2560,1440,60]]],["nvidia geforce gtx 780m","780",0,[[1920,1080,60],[2560,1440,59]]],["nvidia geforce gtx 780m by nick[d]vb","780",0,[[1920,1080,59],[2560,1440,60]]],["nvidia geforce gtx 780m mac","780",0,[[2560,1440,60]]],["nvidia geforce gtx 780m opengl engine","780",0,[[2560,1440,60]]],["nvidia geforce gtx 850a","850",0,[[2560,1440,48]]],["nvidia geforce gtx 850m","850",0,[[1920,1080,60]]],["nvidia geforce gtx 860m","860",0,[[1920,1080,59]]],["nvidia geforce gtx 860m opengl engine","860",0,[[2560,1440,58]]],["nvidia geforce gtx 870m","870",0,[[1920,1080,60],[2560,1440,102]]],["nvidia geforce gtx 880m","880",0,[[1920,1080,60],[2560,1440,74]]],["nvidia geforce gtx 880m opengl engine","880",0,[[2560,1440,60]]],["nvidia geforce gtx 950","950",0,[[1920,1080,98]]],["nvidia geforce gtx 950 opengl engine","950",0,[[1920,1200,60]]],["nvidia geforce gtx 950a","950",0,[[1920,1080,60],[3840,2160,38]]],["nvidia geforce gtx 950m","950",0,[[1920,1080,114]]],["nvidia geforce gtx 960","960",0,[[1920,1080,60]]],["nvidia geforce gtx 960a","960",0,[[1920,1440,128]]],["nvidia geforce gtx 960m","960",0,[[1920,1080,119],[3840,2160,37]]],["nvidia geforce gtx 965m","965",0,[[1920,1080,195],[3000,2000,59],[3840,2160,41]]],["nvidia geforce gtx 965m opengl engine","965",0,[[2880,1620,55]]],["nvidia geforce gtx 970","970",0,[[1920,1080,143]]],["nvidia geforce gtx 970 opengl engine","970",0,[[2560,1600,60]]],["nvidia geforce gtx 970m","970",0,[[1920,1080,60]]],["nvidia geforce gtx 980","980",0,[[1920,1080,60],[3440,1440,294]]],["nvidia geforce gtx 980 ti","980",0,[[1920,1080,119],[2560,1440,456]]],["nvidia geforce gtx 980 ti opengl engine","980",0,[[1920,1080,60]]],["nvidia geforce gtx 980m","980",0,[[1920,1080,60],[3840,2160,104]]],["nvidia geforce gtx titan","gtx",0,[[1920,1080,119],[1920,1200,119],[2560,1440,60]]],["nvidia geforce gtx titan black","gtx",0,[[1680,1050,60],[1920,1080,60],[1920,1200,60],[2560,1440,60]]],["nvidia geforce gtx titan black opengl engine","gtx",0,[[3840,2160,60]]],["nvidia geforce gtx titan opengl engine","gtx",0,[[2560,1440,60]]],["nvidia geforce gtx titan x","gtxx",0,[[1920,1080,144],[2560,1440,120],[2560,1600,60]]],["nvidia geforce gtx titan xp","gtxxp",0,[[2560,1440,60],[3440,1440,60]]],["nvidia geforce gtx titan z","gtxz",0,[[1440,900,59],[1920,1080,39],[3840,2160,60]]],["nvidia geforce gtx780m by nikey22","780",0,[[2560,1440,60]]],["nvidia geforce gtx870m by nikey22","870",0,[[2560,1440,60]]],["nvidia geforce gtx880m","880",0,[[1920,1080,60]]],["nvidia geforce gtx880m by nikey22","880",0,[[2560,1440,59]]],["nvidia geforce gtx880m opengl engine","880",0,[[2560,1440,59]]],["nvidia geforce mx110","110",0,[[1366,768,61],[1920,1080,57]]],["nvidia geforce mx130","130",0,[[1920,1080,60]]],["nvidia geforce mx150","150",0,[[1920,1080,113]]],["nvidia geforce mx230","230",0,[[1920,1080,60]]],["nvidia geforce mx250","250",0,[[1920,1080,60]]],["nvidia geforce mx330","330",0,[[1920,1080,60],[3840,2160,51]]],["nvidia geforce mx350","350",0,[[1920,1080,60]]],["nvidia geforce mx450","450",0,[[1920,1080,60]]],["nvidia geforce pre-release graphics device","pre",0,[[2560,1440,60]]],["nvidia geforce pre-release tesla c2075 opengl engine","2075",0,[[1600,900,59]]],["nvidia geforce pre-release titan x opengl engine","prex",0,[[1920,1080,60]]],["nvidia geforce pre-release titan xp collectors edition opengl e","prexpe",0,[[1920,1080,59]]],["nvidia geforce pre-release titan xp opengl engine","prexp",0,[[2560,1440,60]]],["nvidia geforce rtx 2060","2060",0,[[1920,1080,512]]],["nvidia geforce rtx 2060 max-q","2060",0,[[2560,1440,301]]],["nvidia geforce rtx 2060 mobile","2060",0,[[1920,1080,518]]],["nvidia geforce rtx 2060 rev. a","2060",0,[[3840,2160,257]]],["nvidia geforce rtx 2060 super","2060",0,[[1920,1080,645],[2560,1440,143]]],["nvidia geforce rtx 2060 with max-q design","2060",0,[[1920,1080,292],[1920,1200,60]]],["nvidia geforce rtx 2070","2070",0,[[1920,1080,60],[3840,2160,60]]],["nvidia geforce rtx 2070 mobile","2070",0,[[1920,1080,477]]],["nvidia geforce rtx 2070 mobile / max-q","2070",0,[[1920,1080,526]]],["nvidia geforce rtx 2070 mobile / max-q refresh","2070",0,[[1920,1080,143]]],["nvidia geforce rtx 2070 rev. a","2070",0,[[2560,1440,144]]],["nvidia geforce rtx 2070 super","2070",0,[[1920,1080,510]]],["nvidia geforce rtx 2070 super with max-q design","2070",0,[[1920,1080,300]]],["nvidia geforce rtx 2070 with max-q design","2070",0,[[1920,1080,240]]],["nvidia geforce rtx 2080","2080",0,[[1920,1080,632],[2560,1440,165]]],["nvidia geforce rtx 2080 mobile","2080",0,[[1920,1080,144]]],["nvidia geforce rtx 2080 rev. a","2080",0,[[2560,1440,143]]],["nvidia geforce rtx 2080 super","2080",0,[[1920,1080,601]]],["nvidia geforce rtx 2080 super mobile / max-q","2080",0,[[3840,2160,59]]],["nvidia geforce rtx 2080 super with max-q design","2080",0,[[1920,1080,300]]],["nvidia geforce rtx 2080 ti","2080",0,[[1920,1080,83]]],["nvidia geforce rtx 2080 ti rev. a","2080",0,[[1920,1080,403]]],["nvidia geforce rtx 2080 with max-q design","2080",0,[[1920,1080,476]]],["nvidia geforce rtx 3050","3050",0,[[1920,1080,60]]],["nvidia geforce rtx 3050 laptop gpu","3050",0,[[1920,1080,144]]],["nvidia geforce rtx 3050 ti laptop gpu","3050",0,[[1920,1080,144]]],["nvidia geforce rtx 3060","3060",0,[[1920,1080,674]]],["nvidia geforce rtx 3060 laptop gpu","3060",0,[[1920,1080,300]]],["nvidia geforce rtx 3060 lite hash rate","3060",0,[[1920,1080,60]]],["nvidia geforce rtx 3060 mobile / max-q","3060",0,[[1920,1080,435]]],["nvidia geforce rtx 3060 ti","3060",0,[[1920,1080,779]]],["nvidia geforce rtx 3070","3070",0,[[1920,1080,723],[2560,1440,294]]],["nvidia geforce rtx 3070 laptop gpu","3070",0,[[1920,1080,357]]],["nvidia geforce rtx 3070 mobile / max-q","3070",0,[[2560,1440,386]]],["nvidia geforce rtx 3070 ti","3070",0,[[1920,1080,60]]],["nvidia geforce rtx 3080","3080",0,[[1920,1080,726],[2560,1440,60],[3840,2160,60]]],["nvidia geforce rtx 3080 laptop gpu","3080",0,[[1920,1080,294],[2560,1440,244]]],["nvidia geforce rtx 3080 mobile / max-q 8gb/16gb","3080",0,[[1920,1080,293]]],["nvidia geforce rtx 3080 ti","3080",0,[[1920,1080,239],[2560,1440,60]]],["nvidia geforce rtx 3090","3090",0,[[2560,1440,60],[3840,2160,474]]],["nvidia geforce rtx t10-16","10",0,[[2560,1600,3]]],["nvidia geforce rtx t10-8","10",0,[[2560,1600,3]]],["nvidia gf100 board - 10220000","100",0,[[1920,1200,60]]],["nvidia gf117","117",0,[[1920,1080,32]]],["nvidia gigabyte geforce gt 440","440",0,[[1280,1024,34]]],["nvidia gigabyte geforce gt 610","610",0,[[1920,1080,17]]],["nvidia gigabyte geforce gt 630","630",0,[[1920,1080,34]]],["nvidia gigabyte geforce gt 730","730",0,[[1280,1024,38]]],["nvidia gigabyte geforce gts 450","450",0,[[1280,1024,37]]],["nvidia gigabyte geforce gtx 1050 ti","1050",0,[[1920,1080,30]]],["nvidia gigabyte geforce gtx 460","460",0,[[1680,1050,60]]],["nvidia gigabyte geforce gtx 550 ti","550",0,[[1920,1080,57]]],["nvidia gigabyte geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 570 hd","570",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 580","580",0,[[1920,1200,60]]],["nvidia gigabyte geforce gtx 650","650",0,[[1680,1050,55]]],["nvidia gigabyte geforce gtx 650 ti","650",0,[[2560,1440,40]]],["nvidia gigabyte geforce gtx 660","660",0,[[1920,1080,31]]],["nvidia gigabyte geforce gtx 660 ti","660",0,[[5120,2880,29]]],["nvidia gigabyte geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 750","750",0,[[1920,1080,59]]],["nvidia gigabyte geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 760","760",0,[[3440,1440,17]]],["nvidia gigabyte geforce gtx 770","770",0,[[2560,1440,59]]],["nvidia gigabyte geforce gtx 780 ti","780",0,[[1920,1080,240]]],["nvidia gigabyte geforce gtx 960","960",0,[[1920,1080,142],[1920,1200,120]]],["nvidia gigabyte geforce gtx 970","970",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 980","980",0,[[2560,1440,60]]],["nvidia gigabyte geforce gtx 980 ti","980",0,[[1920,1080,60]]],["nvidia gk104 board - 2051b502","104",0,[[2560,1440,60]]],["nvidia gk104 board - 20530501","104",0,[[2560,1440,60]]],["nvidia gk104gl [grid k2]","104",0,[[2560,1343,21]]],["nvidia gk104gl [grid k520]","104",0,[[1024,768,120]]],["nvidia gp102 [titan x]","102",0,[[3440,1440,462]]],["nvidia gp102 [titan xp]","102",0,[[1920,1080,126]]],["nvidia gp104","104",0,[[1920,1080,60]]],["nvidia gp104gl","104",0,[[2560,1343,36]]],["nvidia gp108","108",0,[[1920,1080,60]]],["nvidia graphics device","",0,[[1920,1080,60],[1920,1200,60],[3840,2160,60]]],["nvidia grid gtx p40-6","40",0,[[1440,900,153]]],["nvidia grid k1","1",0,[[1245,768,6],[1920,1080,35]]],["nvidia grid k140q vgpu","140",0,[[1920,1080,30]]],["nvidia grid k160q","160",0,[[1920,1080,34]]],["nvidia grid k180q","180",0,[[1920,1080,28]]],["nvidia grid k2","2",0,[[1245,768,6],[1920,1080,59]]],["nvidia grid k220q","220",0,[[1920,1200,34]]],["nvidia grid k240q","240",0,[[1920,1080,64]]],["nvidia grid k260q","260",0,[[2560,1440,31]]],["nvidia grid k280q","280",0,[[1920,1080,64]]],["nvidia grid k520","520",0,[[1280,720,60]]],["nvidia grid m10-1b","10",0,[[1024,768,49]]],["nvidia grid m10-2q","10",0,[[2560,1440,15]]],["nvidia grid m6-0b","6",0,[[1680,1050,33]]],["nvidia grid m60-1b","60",0,[[1680,1050,46],[1920,1080,46]]],["nvidia grid m60-1q","60",0,[[1536,864,60]]],["nvidia grid m60-2q","60",0,[[1920,1080,57]]],["nvidia grid m60-4q","60",0,[[1920,1080,59]]],["nvidia grid m60-8q","60",0,[[1920,1080,60]]],["nvidia grid p100-4q","100",0,[[2560,1440,16]]],["nvidia grid p4-4q","4",0,[[1892,932,247]]],["nvidia grid p40-4q","40",0,[[2741,1495,60]]],["nvidia grid p40-8q","40",0,[[1920,1080,60]]],["nvidia grid rtx6000-2q","6000",0,[[1024,768,60]]],["nvidia grid rtx6000p-6","6000",0,[[1280,1024,161]]],["nvidia grid t4-16q","4",0,[[1920,1080,61]]],["nvidia grid t4-1b","4",0,[[1920,1080,46]]],["nvidia grid t4-1q","4",0,[[1280,1024,48]]],["nvidia grid t4-2b4","4",0,[[1536,864,47]]],["nvidia grid t4-2q","4",0,[[1920,1080,65]]],["nvidia grid t4-8q","4",0,[[2560,1080,60]]],["nvidia grid v100-1q","100",0,[[1646,1154,59]]],["nvidia grid v100-2b","100",0,[[1440,900,45]]],["nvidia grid v100dx-16q","100",0,[[1280,1024,60]]],["nvidia grid v100dx-1q","100",0,[[1280,1024,60]]],["nvidia gtx 1060 hl","1060",0,[[3840,2160,60]]],["nvidia gtx 865m by imacgfx","865",0,[[2560,1440,60]]],["nvidia gtx 980m sli","980",0,[[1366,768,29]]],["nvidia gv-n660oc-2gd","660",0,[[1920,1200,60]]],["nvidia gv100","100",0,[[3840,2160,60]]],["nvidia gv100 [titan v]","100",0,[[2560,1440,60]]],["nvidia gv102","102",0,[[2560,1600,525]]],["nvidia hp geforce gt 730","730",0,[[1920,1080,55]]],["nvidia hp quadro 2000","2000",0,[[2560,1080,38]]],["nvidia hp quadro 4000","4000",0,[[2560,1080,52]]],["nvidia hp quadro 600","600",0,[[1360,768,41]]],["nvidia hp quadro k4000","4000",0,[[1920,1200,26]]],["nvidia hp quadro k620","620",0,[[1600,1200,94]]],["nvidia inno3d geforce gtx660","3",0,[[2560,1440,107]]],["nvidia microsoft virtual render driver","",0,[[1920,1080,59]]],["nvidia msi geforce gt 610","610",0,[[1920,1080,16]]],["nvidia msi geforce gt 630","630",0,[[1440,900,12]]],["nvidia msi geforce gt 635","635",0,[[1920,1080,30]]],["nvidia msi geforce gt 710","710",0,[[1920,1080,27]]],["nvidia msi geforce gt 730","730",0,[[1920,1080,53]]],["nvidia msi geforce gtx 1050 ti","1050",0,[[1920,1080,59]]],["nvidia msi geforce gtx 1060","1060",0,[[1920,1080,120]]],["nvidia msi geforce gtx 1070","1070",0,[[1920,1200,45]]],["nvidia msi geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia msi geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia msi geforce gtx 570 hd","570",0,[[1920,1200,60]]],["nvidia msi geforce gtx 580","580",0,[[2560,1440,60]]],["nvidia msi geforce gtx 650","650",0,[[2560,1080,52]]],["nvidia msi geforce gtx 650 ti","650",0,[[1920,1080,60]]],["nvidia msi geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia msi geforce gtx 660 ti","660",0,[[1680,1050,49]]],["nvidia msi geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia msi geforce gtx 745","745",0,[[1920,1080,55]]],["nvidia msi geforce gtx 760","760",0,[[1280,1024,30],[1920,1080,58]]],["nvidia msi geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia msi geforce gtx 950","950",0,[[1920,1080,59]]],["nvidia msi geforce gtx 960","960",0,[[1680,1050,120],[2560,1440,59]]],["nvidia msi geforce gtx 970","970",0,[[1680,1050,60]]],["nvidia msi geforce gtx 980","980",0,[[1920,1080,120],[3840,2160,60]]],["nvidia msi geforce gtx 980 ti","980",0,[[5120,2880,56]]],["nvidia n15e-gt","15",0,[[3840,2160,30]]],["nvidia null geforce 920a","920",0,[[1920,1080,25]]],["nvidia null graphics device","",0,[[1920,1080,24]]],["nvidia nvs 310","310",0,[[1280,1024,24],[1920,1080,15]]],["nvidia nvs 3100m","3100",0,[[1920,1080,10]]],["nvidia nvs 315","315",0,[[1280,1024,25],[1920,1080,15]]],["nvidia nvs 4200m","4200",0,[[1920,1080,11]]],["nvidia nvs 510","510",0,[[1920,1200,27],[2560,1080,24],[3440,1440,16]]],["nvidia nvs 5200m","5200",0,[[1366,768,55],[1600,900,33],[1920,1080,57]]],["nvidia nvs 5400m","5400",0,[[1600,900,46],[1920,1200,27]]],["nvidia p102-100","102",0,[[1600,1200,35]]],["nvidia p106-090","106",0,[[1920,1371,16]]],["nvidia p106-100","106",0,[[1920,1080,60],[3840,2160,30]]],["nvidia p106-100 custom","106",0,[[1680,1050,60]]],["nvidia palit geforce gtx 650","650",0,[[1920,1080,49]]],["nvidia palit geforce gtx 650 ti","650",0,[[1920,1080,59]]],["nvidia palit geforce gtx 660","660",0,[[1920,1080,26]]],["nvidia palit gtx 680 jetstream","680",0,[[1920,1080,60]]],["nvidia pegatron geforce gt 420","420",0,[[1400,1050,25]]],["nvidia pny geforce gt 610","610",0,[[1280,1024,19]]],["nvidia pny geforce gtx 1060","1060",0,[[1920,1080,60]]],["nvidia pny geforce gtx 460","460",0,[[1360,768,59]]],["nvidia pny geforce gtx 550 ti","550",0,[[1920,1080,55]]],["nvidia pny geforce gtx 570 hd","570",0,[[1280,1024,72]]],["nvidia pny geforce gtx 580","580",0,[[1920,1200,59]]],["nvidia pny geforce gtx 680","680",0,[[2560,1080,120]]],["nvidia pny geforce gtx 750","750",0,[[1280,1024,60]]],["nvidia pny geforce gtx 970","970",0,[[2560,1440,60]]],["nvidia pny geforce gtx 980","980",0,[[1920,1080,120]]],["nvidia point of view geforce gtx 470","470",0,[[1920,1080,59]]],["nvidia point of view geforce gtx 660 ti","660",0,[[1680,1050,59]]],["nvidia quadro 1000m","1000",0,[[1920,1080,28]]],["nvidia quadro 1000m,","1000",0,[[1920,1080,27]]],["nvidia quadro 2000","2000",0,[[1920,1080,51],[2560,1440,28]]],["nvidia quadro 2000d","2000",0,[[1280,1024,56]]],["nvidia quadro 2000m","2000",0,[[1920,1080,31]]],["nvidia quadro 3000m","3000",0,[[1920,1080,53],[2560,1440,6]]],["nvidia quadro 3000m opengl engine","3000",0,[[1920,1080,49]]],["nvidia quadro 4000","4000",0,[[1920,1080,56],[1920,1200,58]]],["nvidia quadro 4000m","4000",0,[[1920,1080,51]]],["nvidia quadro 410","410",0,[[1920,1080,23]]],["nvidia quadro 5000","5000",0,[[1920,1080,60],[2560,1080,55],[2560,1440,51]]],["nvidia quadro 5000 opengl engine","5000",0,[[1920,1200,59]]],["nvidia quadro 5000m","5000",0,[[1600,900,110]]],["nvidia quadro 600","600",0,[[1680,1050,28],[1920,1080,28],[1920,1200,26]]],["nvidia quadro 6000","6000",0,[[1920,1080,60],[1920,1200,60]]],["nvidia quadro 7000","7000",0,[[1920,1200,60]]],["nvidia quadro fx 1800m","1800",0,[[1600,900,15]]],["nvidia quadro fx 2800m","2800",0,[[1920,1200,36]]],["nvidia quadro fx grid k1","1",0,[[1920,1080,31]]],["nvidia quadro gp100","100",0,[[1920,1200,366]]],["nvidia quadro gv100","100",0,[[3840,2160,60],[4096,2160,60]]],["nvidia quadro k1000m","1000",0,[[1920,1080,28]]],["nvidia quadro k1000m by nick[d]vb","1000",0,[[1920,1080,36]]],["nvidia quadro k1100m","1100",0,[[1920,1080,56]]],["nvidia quadro k1100m by nick[d]vb","1100",0,[[1920,1080,66]]],["nvidia quadro k1100m opengl engine","1100",0,[[1920,1080,54]]],["nvidia quadro k1200","1200",0,[[1920,1080,60],[2560,1440,57],[3840,2160,28]]],["nvidia quadro k1200 opengl engine","1200",0,[[3840,2160,34]]],["nvidia quadro k2000","2000",0,[[1920,1080,55]]],["nvidia quadro k2000 opengl engine","2000",0,[[2560,1440,44]]],["nvidia quadro k2000d","2000",0,[[1280,1024,57],[1680,1050,57],[1920,1080,59]]],["nvidia quadro k2000m","2000",0,[[1920,1080,36]]],["nvidia quadro k2000m by nick[d]vb","2000",0,[[2560,1440,38]]],["nvidia quadro k2000m opengl engine","2000",0,[[1920,1080,43]]],["nvidia quadro k2100m","2100",0,[[1920,1080,58]]],["nvidia quadro k2100m by nick[d]vb","2100",0,[[2560,1440,54]]],["nvidia quadro k2100m opengl engine","2100",0,[[1920,1080,59]]],["nvidia quadro k2200","2200",0,[[1920,1080,60],[1920,1200,126],[5120,2880,25]]],["nvidia quadro k2200m","2200",0,[[1920,1080,60]]],["nvidia quadro k3000m","3000",0,[[1920,1080,59]]],["nvidia quadro k3000m by st3phl3","3000",0,[[2560,1440,50]]],["nvidia quadro k3100m","3100",0,[[1920,1080,60]]],["nvidia quadro k3100m by nikey22","3100",0,[[2560,1440,59]]],["nvidia quadro k3100m opengl engine","3100",0,[[2560,1440,58]]],["nvidia quadro k4000","4000",0,[[1920,1080,60],[1920,1200,59]]],["nvidia quadro k4000 opengl engine","4000",0,[[1920,1080,59]]],["nvidia quadro k4000m","4000",0,[[1920,1080,80]]],["nvidia quadro k4100m","4100",0,[[1920,1080,32]]],["nvidia quadro k4100m by nikey22","4100",0,[[2560,1440,60]]],["nvidia quadro k420","420",0,[[1366,768,57],[2560,1440,19],[3840,2160,10]]],["nvidia quadro k4200","4200",0,[[1920,1080,60],[2560,1440,59],[3840,2160,57]]],["nvidia quadro k5000","5000",0,[[1920,1080,60],[2560,1440,60]]],["nvidia quadro k5000 opengl engine","5000",0,[[2560,1600,59]]],["nvidia quadro k5000m","5000",0,[[1920,1080,60],[2560,1440,60]]],["nvidia quadro k5000m opengl engine","5000",0,[[2560,1440,60]]],["nvidia quadro k5100m","5100",0,[[1920,1080,60],[2560,1080,171]]],["nvidia quadro k5100m by nikey22","5100",0,[[2560,1440,60]]],["nvidia quadro k510m","510",0,[[1920,1080,33]]],["nvidia quadro k5200","5200",0,[[1920,1080,60],[1920,1200,60]]],["nvidia quadro k5200 opengl engine","5200",0,[[1920,1200,41]]],["nvidia quadro k600","600",0,[[1920,1080,28]]],["nvidia quadro k600 opengl engine","600",0,[[1920,1200,31]]],["nvidia quadro k6000","6000",0,[[1920,1080,60],[1920,1200,60],[2560,1440,60]]],["nvidia quadro k6000 opengl engine","6000",0,[[1920,1080,59]]],["nvidia quadro k610m","610",0,[[1920,1080,36]]],["nvidia quadro k610m by nick[d]vb","610",0,[[1920,1080,34]]],["nvidia quadro k620","620",0,[[1920,1080,87],[1920,1200,69],[2560,1440,44]]],["nvidia quadro k620 opengl engine","620",0,[[1920,1080,59]]],["nvidia quadro k620m","620",0,[[1920,1080,49],[2880,1620,15]]],["nvidia quadro m1000m","1000",0,[[1920,1080,60]]],["nvidia quadro m1200","1200",0,[[1920,1080,60],[3840,2160,43]]],["nvidia quadro m2000","2000",0,[[1920,1080,73],[2560,1440,59]]],["nvidia quadro m2000m","2000",0,[[1920,1080,60]]],["nvidia quadro m2000m special","2000",0,[[1920,1080,60]]],["nvidia quadro m2200","2200",0,[[1920,1080,60]]],["nvidia quadro m2200 mobile","2200",0,[[3840,2160,13]]],["nvidia quadro m3000m","3000",0,[[1920,1080,60]]],["nvidia quadro m4000","4000",0,[[1920,1080,120],[1920,1200,60],[2560,1440,60]]],["nvidia quadro m4000 opengl engine","4000",0,[[1920,1080,60]]],["nvidia quadro m4000m","4000",0,[[1920,1080,60],[3840,2160,69]]],["nvidia quadro m5000","5000",0,[[1920,1080,60],[1920,1200,60],[2560,1440,59]]],["nvidia quadro m5000m","5000",0,[[1920,1080,212],[3840,2160,60]]],["nvidia quadro m500m","500",0,[[1920,1080,58],[2880,1620,29]]],["nvidia quadro m520","520",0,[[1920,1080,59],[3840,2160,27]]],["nvidia quadro m5500","5500",0,[[3440,1440,60]]],["nvidia quadro m6000","6000",0,[[1920,1080,408],[2560,1440,60]]],["nvidia quadro m6000 24gb","6000",0,[[1680,1050,60],[1920,1200,60]]],["nvidia quadro m600m","600",0,[[1920,1080,59]]],["nvidia quadro m620","620",0,[[1920,1080,60]]],["nvidia quadro nvs 4200m","4200",0,[[1600,900,26],[1920,1080,19]]],["nvidia quadro p1000","1000",0,[[1920,1080,60],[1920,1200,60]]],["nvidia quadro p1000 mobile","1000",0,[[1920,1080,60]]],["nvidia quadro p2000","2000",0,[[1680,1050,60],[1920,1080,242],[2560,1440,60]]],["nvidia quadro p2000 mobile","2000",0,[[1920,1080,60]]],["nvidia quadro p2000 opengl engine","2000",0,[[1920,1080,59]]],["nvidia quadro p2000 with max-q design","2000",0,[[1920,1080,60],[3840,2160,67]]],["nvidia quadro p2200","2200",0,[[1920,1080,60],[3840,2160,340]]],["nvidia quadro p3000","3000",0,[[1920,1080,60]]],["nvidia quadro p3200","3200",0,[[1920,1080,60],[3840,2160,60]]],["nvidia quadro p3200 mobile","3200",0,[[3840,2160,60]]],["nvidia quadro p3200 with max-q design","3200",0,[[2560,1440,60]]],["nvidia quadro p400","400",0,[[1680,1050,46],[1920,1080,57],[1920,1200,54]]],["nvidia quadro p4000","4000",0,[[1920,1080,60],[3840,2160,167]]],["nvidia quadro p4200","4200",0,[[1920,1080,60],[3840,2160,60]]],["nvidia quadro p4200 with max-q design","4200",0,[[3839,2159,53]]],["nvidia quadro p500","500",0,[[1920,1080,60]]],["nvidia quadro p5000","5000",0,[[1920,1080,60]]],["nvidia quadro p5000 opengl engine","5000",0,[[3840,2160,58]]],["nvidia quadro p520","520",0,[[1920,1080,60]]],["nvidia quadro p5200","5200",0,[[3840,2160,100]]],["nvidia quadro p600","600",0,[[1920,1080,60]]],["nvidia quadro p6000","6000",0,[[1920,1080,60],[2560,1440,60],[2560,1600,411]]],["nvidia quadro p620","620",0,[[1920,1080,65]]],["nvidia quadro rtx 3000","3000",0,[[1920,1080,60]]],["nvidia quadro rtx 3000 mobile / max-q","3000",0,[[3840,2160,60]]],["nvidia quadro rtx 3000 with max-q design","3000",0,[[3240,2160,60]]],["nvidia quadro rtx 4000","4000",0,[[1920,1080,60]]],["nvidia quadro rtx 4000 mobile / max-q","4000",0,[[1920,1080,60]]],["nvidia quadro rtx 4000 with max-q design","4000",0,[[1920,1080,60],[3840,2160,60]]],["nvidia quadro rtx 5000","5000",0,[[1920,1080,443],[2560,1440,60]]],["nvidia quadro rtx 5000 mobile / max-q","5000",0,[[3840,2160,60]]],["nvidia quadro rtx 5000 with max-q design","5000",0,[[1920,1080,60],[3840,2160,60]]],["nvidia quadro rtx 6000","6000",0,[[1920,1080,438],[2560,1440,60]]],["nvidia quadro rtx 8000","8000",0,[[1920,1080,60],[1920,1200,60]]],["nvidia quadro t1000","1000",0,[[1920,1080,60],[2560,1440,41]]],["nvidia quadro t1000 mobile","1000",0,[[1920,1080,277]]],["nvidia quadro t1000 with max-q design","1000",0,[[1920,1080,60]]],["nvidia quadro t2000","2000",0,[[1920,1080,60]]],["nvidia quadro t2000 mobile / max-q","2000",0,[[1920,1080,302]]],["nvidia quadro t2000 with max-q design","2000",0,[[1920,1080,60],[1920,1200,60],[2560,1440,60]]],["nvidia rtx a1000 laptop gpu","1000",0,[[1920,1080,60]]],["nvidia rtx a2000","2000",0,[[3840,2160,60]]],["nvidia rtx a2000 laptop gpu","2000",0,[[2400,1600,120],[3840,2160,60]]],["nvidia rtx a3000 laptop gpu","3000",0,[[1920,1080,60],[3840,2160,60]]],["nvidia rtx a4000","4000",0,[[1920,1080,60],[3840,2160,60]]],["nvidia rtx a4000 laptop gpu","4000",0,[[1920,1080,60]]],["nvidia rtx a5000","5000",0,[[3840,2160,60]]],["nvidia rtx a5000 laptop gpu","5000",0,[[3840,2160,60]]],["nvidia rtx a6000","6000",0,[[1920,1200,60]]],["nvidia sony geforce 410m","410",0,[[1366,768,24]]],["nvidia t1000","1000",0,[[1920,1080,43],[3840,2160,60]]],["nvidia t1200 laptop gpu","1200",0,[[1920,1080,60]]],["nvidia t400","400",0,[[3840,2160,35]]],["nvidia t500","500",0,[[1920,1080,60],[3839,2159,52]]],["nvidia t600","600",0,[[1920,1080,60]]],["nvidia tesla c2050 / c2070","2050",0,[[1920,1080,105]]],["nvidia tesla c2070","2070",0,[[1920,1200,60]]],["nvidia tesla c2075","2075",0,[[1920,1080,60]]],["nvidia tesla k10","10",0,[[1920,1080,60]]],["nvidia tesla k10.g1.8gb","10",0,[[1440,900,59]]],["nvidia tesla k20m","20",0,[[1240,821,118]]],["nvidia tesla k20xm","20",0,[[3840,2400,17]]],["nvidia tesla k80","80",0,[[1664,896,66],[3840,2160,30]]],["nvidia tesla m10","10",0,[[1440,900,60],[1280,1024,60]]],["nvidia tesla m40","40",0,[[1600,1024,190]]],["nvidia tesla m6","6",0,[[1920,1080,59]]],["nvidia tesla m60","60",0,[[1366,768,60],[1920,962,61],[3840,2160,27]]],["nvidia tesla p100 pcie 16gb","100",0,[[1920,1080,60]]],["nvidia tesla p100-pcie-16gb","100",0,[[1920,1080,103]]],["nvidia tesla p4","4",0,[[1680,1050,60]]],["nvidia tesla p40","40",0,[[1546,877,62],[1920,1200,60]]],["nvidia tesla t4","4",0,[[1440,900,33],[1920,1080,60]]],["nvidia tesla v100-pcie-16gb","100",0,[[1920,997,57]]],["nvidia tesla v100-pcie-32gb","100",0,[[1920,1080,57]]],["nvidia tesla v100-sxm2-16gb","100",0,[[1920,1080,60]]],["nvidia tesla v100-sxm2-32gb","100",0,[[1920,1080,1],[2560,1440,60]]],["nvidia titan rtx","rtx",0,[[2560,1440,60],[3840,2160,680]]],["nvidia titan v","v",0,[[2560,1440,622],[3840,2160,60]]],["nvidia titan x","x",0,[[2560,1080,60],[3840,1600,75],[3840,2160,339]]],["nvidia titan xp","xp",0,[[1920,1200,60],[2560,1440,60],[3440,1440,105]]],["nvidia titan xp collectors","xp",0,[[1920,1080,60],[2560,1440,893],[5120,2880,60]]],["nvidia toshiba geforce gt 525m","525",0,[[1366,768,33]]],["nvidia tu102 [titan rtx]","102",0,[[3840,2160,60]]],["nvidia tu107","107",0,[[1920,1080,312]]],["nvidia tu117m","117",0,[[1920,1080,337]]],["nvidia unknown","",0,[[1920,1080,60]]],["nvidia zotac geforce gt 430","430",0,[[1600,900,32]]],["nvidia zotac geforce gt 610","610",0,[[1920,1080,15]]],["nvidia zotac geforce gt 630","630",0,[[1360,768,46]]],["nvidia zotac geforce gt 740","740",0,[[1280,1024,118]]],["nvidia zotac geforce gtx 460","460",0,[[1920,1080,59]]],["nvidia zotac geforce gtx 550 ti","550",0,[[1920,1080,42]]],["nvidia zotac geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 580","580",0,[[1920,1080,48]]],["nvidia zotac geforce gtx 650","650",0,[[1920,1080,44]]],["nvidia zotac geforce gtx 650 ti","650",0,[[1920,1080,58]]],["nvidia zotac geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 680","680",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 750","750",0,[[1680,1050,114],[1920,1080,60]]],["nvidia zotac geforce gtx 760","760",0,[[1920,1080,101]]],["nvidia zotac geforce gtx 770","770",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 960","960",0,[[2048,1152,60]]]]')
                            },
                            145: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["amd [amd/ati] fiji [radeon r9 fury / nano series]","9",0,[[1920,1200,162]]],["amd asus amd radeon r9-990x","9",0,[[1920,1080,60]]],["amd asus radeon r7 250","7",0,[[800,638,60]]],["amd asus radeon r7 260x","7",0,[[2560,1080,65]]],["amd asus radeon r9 270x","9",0,[[1024,768,85],[1920,1080,60]]],["amd asus radeon r9 280","9",0,[[1920,1080,60]]],["amd asus radeon rx 460","460",0,[[1360,768,104]]],["amd asus radeon rx 470","470",0,[[1920,1080,60]]],["amd asus radeon rx 480","480",0,[[1920,1080,124]]],["amd asus radeon rx 550","550",0,[[1440,900,60],[1920,1080,49]]],["amd asus radeon rx 5500 xt","5500",0,[[1920,1080,325]]],["amd asus radeon rx 560","560",0,[[1360,768,60],[1920,1080,85]]],["amd asus radeon rx 570","570",0,[[1600,900,202],[1920,1080,60]]],["amd asus radeon rx 5700","5700",0,[[1920,1080,327]]],["amd asus radeon rx 5700 xt","5700",0,[[1920,1080,224],[2560,1440,60]]],["amd asus radeon rx 580","580",0,[[1920,1080,177],[2560,1080,60]]],["amd asus radeon rx vega","rx",0,[[2560,1440,117]]],["amd ati mobility radeon hd 5870","5870",0,[[1920,1200,19]]],["amd baffin amd radeon rx 560","560",0,[[1920,1080,60]]],["amd ellesmere radeon rx 570","570",0,[[1920,1080,60]]],["amd embedded radeon e9171","9171",0,[[3840,2160,26]]],["amd embedded radeon e9173","9173",0,[[3840,2160,16]]],["amd gigabyte radeon rx 580","580",0,[[1920,1080,60]]],["amd madison [mobility radeon hd 5650 / 6530m/6550m]","5650",0,[[1366,768,43]]],["amd mobility radeon hd 4250","4250",0,[[963,722,26]]],["amd mobility radeon hd 5000","5000",0,[[1366,768,47]]],["amd mobility radeon hd 5400","5400",0,[[1366,768,24]]],["amd mobility radeon hd 5430","5430",0,[[1600,900,15],[1920,1080,60]]],["amd mobility radeon hd 5470","5470",0,[[1366,768,24]]],["amd mobility radeon hd 5570","5570",0,[[1920,1080,27]]],["amd mobility radeon hd 5730 / 6570m","5730",0,[[1366,768,58]]],["amd mobility radeon hd 5850","5850",0,[[1600,900,55]]],["amd mobility radeon hd 5870","5870",0,[[1600,900,64],[1920,1200,53]]],["amd park [mobility radeon hd 5430","5430",0,[[1280,720,11]]],["amd pitcairn pro radeon hd 7850","7850",0,[[1920,1080,60]]],["amd powercolor radeon r9 280","9",0,[[1920,1080,60]]],["amd radeon","",0,[[1920,1080,299],[3440,1440,60]]],["amd radeon 500","500",0,[[1920,1080,73]]],["amd radeon 520","520",0,[[1920,1080,35],[2560,1440,29]]],["amd radeon 530","530",0,[[1366,768,60],[1920,1080,30]]],["amd radeon 535","535",0,[[1920,1080,35]]],["amd radeon 535dx","535",0,[[1366,768,31],[1920,1080,37]]],["amd radeon 540","540",0,[[1920,1080,38]]],["amd radeon 540 / rx 540x/550/550x","540",0,[[2560,1440,88]]],["amd radeon 540x","540",0,[[1920,1080,59]]],["amd radeon 550","550",0,[[1920,1080,115]]],["amd radeon 550x","550",0,[[1920,1080,28]]],["amd radeon 610","610",0,[[1920,1080,29]]],["amd radeon 620","620",0,[[1920,1080,18]]],["amd radeon 625","625",0,[[1366,768,55],[1920,1080,47]]],["amd radeon 630","630",0,[[1920,1080,29]]],["amd radeon 6600m and 6700m","6600",0,[[1366,768,36],[1440,900,60]]],["amd radeon 6800","6800",0,[[3440,1440,100]]],["amd radeon 7500m/7600m","7500",0,[[1366,768,37]]],["amd radeon 7950 x2","7950",0,[[2560,1440,174]]],["amd radeon d700","700",0,[[2560,1440,120]]],["amd radeon e6460","6460",0,[[1600,1200,13]]],["amd radeon e6760","6760",0,[[1200,900,54],[1920,1080,42]]],["amd radeon e8860","8860",0,[[1920,1200,27],[2560,1374,88]]],["amd radeon e8870","8870",0,[[1920,1080,81]]],["amd radeon e8870mxm","8870",0,[[1920,1080,60]]],["amd radeon e9260","9260",0,[[1680,1050,60],[3840,2160,38]]],["amd radeon e9550","9550",0,[[1680,1050,60],[3840,2160,58]]],["amd radeon embedded e9560","9560",0,[[1920,1200,60]]],["amd radeon fury","",0,[[1920,1080,60]]],["amd radeon fury x","x",0,[[1920,1080,60],[2560,1440,144]]],["amd radeon hd - firepro d300","300",0,[[1920,1080,60]]],["amd radeon hd - firepro d300 opengl engine","300",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd - firepro d500 opengl engine","500",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd - firepro d700 opengl engine","700",0,[[3840,2160,52]]],["amd radeon hd 2600 xt","2600",1,[[2560,1600,-1]]],["amd radeon hd 5000","5000",0,[[1920,1080,8]]],["amd radeon hd 5400","5400",0,[[1920,1080,12]]],["amd radeon hd 5450","5450",0,[[1920,1080,13]]],["amd radeon hd 5470","5470",0,[[1280,1024,16]]],["amd radeon hd 5500","5500",0,[[1920,1080,27]]],["amd radeon hd 5570","5570",0,[[1920,1080,60],[2048,1152,31]]],["amd radeon hd 5600","5600",0,[[1920,1080,56]]],["amd radeon hd 5650","5650",0,[[1366,768,53]]],["amd radeon hd 5670","5670",1,[[1920,1080,-1],[2560,1440,-1]]],["amd radeon hd 5670 opengl engine","5670",1,[[2560,1440,-1]]],["amd radeon hd 5700","5700",0,[[1920,1080,59]]],["amd radeon hd 5730","5730",0,[[1366,768,46],[1680,1050,40]]],["amd radeon hd 5750","5750",1,[[1920,1080,-1],[1920,1200,-1],[2560,1440,-1]]],["amd radeon hd 5750 opengl engine","5750",1,[[2560,1440,-1]]],["amd radeon hd 5770","5770",0,[[1776,1000,43],[1920,1080,59]]],["amd radeon hd 5800","5800",0,[[1366,768,60],[1920,1200,102]]],["amd radeon hd 5850","5850",0,[[1920,1080,60]]],["amd radeon hd 5870","5870",0,[[1280,960,75],[1920,1080,60],[2048,1280,60]]],["amd radeon hd 5870m","5870",0,[[2560,1080,31]]],["amd radeon hd 5970","5970",0,[[1360,768,60],[1920,1080,60]]],["amd radeon hd 6230","6230",0,[[1366,768,13]]],["amd radeon hd 6250","6250",0,[[1280,800,8],[1366,768,8]]],["amd radeon hd 6290","6290",1,[[1366,768,-1]]],["amd radeon hd 6300m","6300",1,[[1366,768,-1]]],["amd radeon hd 6310","6310",1,[[1366,768,-1]]],["amd radeon hd 6320","6320",1,[[1366,768,-1]]],["amd radeon hd 6350","6350",0,[[1280,1024,18],[1920,1080,14]]],["amd radeon hd 6370d","6370",0,[[1920,1080,14]]],["amd radeon hd 6370m","6370",0,[[1366,768,25]]],["amd radeon hd 6380g","6380",0,[[1366,768,19]]],["amd radeon hd 6400","6400",0,[[1920,1080,13]]],["amd radeon hd 6400m","6400",0,[[1366,768,28]]],["amd radeon hd 6400m/7400m","6400",0,[[1366,768,28]]],["amd radeon hd 6410d","6410",0,[[1920,1080,11]]],["amd radeon hd 6450","6450",0,[[1920,1080,14]]],["amd radeon hd 6450 / r5 230","6450",0,[[1440,900,12]]],["amd radeon hd 6450 230","6450",0,[[1920,1080,15]]],["amd radeon hd 6470m","6470",0,[[1366,768,27],[1600,900,21]]],["amd radeon hd 6470m/7400m","6470",0,[[1366,768,44]]],["amd radeon hd 6480g","6480",0,[[1280,768,19],[1366,768,27],[1600,900,18]]],["amd radeon hd 6490m","6490",1,[[1366,768,-1],[1440,900,-1],[1680,1050,-1]]],["amd radeon hd 6500","6500",0,[[1920,1080,25]]],["amd radeon hd 6500m/5600","6500",0,[[1920,1080,27]]],["amd radeon hd 6510","6510",0,[[1600,900,32]]],["amd radeon hd 6520g","6520",0,[[1366,768,21],[1600,900,20]]],["amd radeon hd 6530d","6530",0,[[1366,768,31],[1440,900,36],[1920,1080,24]]],["amd radeon hd 6540","6540",0,[[1600,1200,13]]],["amd radeon hd 6550d","6550",0,[[1920,1080,28]]],["amd radeon hd 6570","6570",0,[[1920,1080,52],[2560,1440,17]]],["amd radeon hd 6620g","6620",0,[[1360,768,43],[1366,768,28]]],["amd radeon hd 6630m","6630",1,[[1366,768,-1],[1600,900,-1],[1920,1080,-1]]],["amd radeon hd 6630m/6650m/6750m/7670m/7690m","6630",1,[[1366,768,-1],[1920,1080,-1]]],["amd radeon hd 6650m","6650",0,[[1366,768,51],[1600,900,31]]],["amd radeon hd 6670","6670",0,[[1920,1080,55]]],["amd radeon hd 6700","6700",0,[[1920,1080,56]]],["amd radeon hd 6700 green","6700",0,[[1360,768,89]]],["amd radeon hd 6700m/7700m/7900m","6700",0,[[1366,768,59]]],["amd radeon hd 6730m/6770m","6730",0,[[1366,768,58],[1920,1080,46]]],["amd radeon hd 6730m/6770m/7690m xt","6730",0,[[1920,1080,48]]],["amd radeon hd 6750","6750",0,[[1440,900,72],[1920,1080,60]]],["amd radeon hd 6750m","6750",1,[[1440,900,-1],[1920,1080,-1],[1920,1200,-1]]],["amd radeon hd 6770","6770",0,[[1920,1080,60]]],["amd radeon hd 6770m","6770",1,[[1440,900,-1],[2560,1440,-1]]],["amd radeon hd 6770m opengl engine","6770",1,[[2560,1440,-1]]],["amd radeon hd 6790","6790",0,[[1920,1080,59]]],["amd radeon hd 6800","6800",0,[[1280,1024,89],[1920,1080,60]]],["amd radeon hd 6800m","6800",0,[[1600,900,18],[1920,1080,40]]],["amd radeon hd 6850","6850",0,[[1920,1080,59],[2560,1600,54]]],["amd radeon hd 6870","6870",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd 6900","6900",0,[[1920,1080,60]]],["amd radeon hd 6900m","6900",0,[[1920,1080,60]]],["amd radeon hd 6950","6950",0,[[1680,1050,60],[1920,1080,41]]],["amd radeon hd 6970","6970",0,[[1920,1080,60]]],["amd radeon hd 6970m","6970",1,[[2560,1440,-1]]],["amd radeon hd 6970m opengl engine","6970",1,[[2560,1440,-1]]],["amd radeon hd 6990","6990",0,[[1920,1080,60]]],["amd radeon hd 7000","7000",0,[[1920,1080,24]]],["amd radeon hd 7290","7290",0,[[1366,768,9]]],["amd radeon hd 7310","7310",0,[[1366,768,14]]],["amd radeon hd 7340","7340",0,[[1366,768,17],[1920,1080,10]]],["amd radeon hd 7340g","7340",0,[[1366,768,15]]],["amd radeon hd 7340m","7340",0,[[1366,768,15]]],["amd radeon hd 7350","7350",0,[[1920,1080,13]]],["amd radeon hd 7400","7400",0,[[1920,1080,18]]],["amd radeon hd 7400g","7400",0,[[963,768,31]]],["amd radeon hd 7400m","7400",0,[[1366,768,44]]],["amd radeon hd 7420g","7420",0,[[1366,768,28],[1600,900,26]]],["amd radeon hd 7450","7450",0,[[1920,1080,15]]],["amd radeon hd 7450a","7450",0,[[1920,1080,15]]],["amd radeon hd 7450m","7450",0,[[1366,768,30]]],["amd radeon hd 7470","7470",0,[[1680,1050,22],[1920,1080,144]]],["amd radeon hd 7470m","7470",0,[[1366,768,31],[1600,900,23]]],["amd radeon hd 7480d","7480",0,[[1280,1024,25],[1920,1080,24],[1920,1200,18]]],["amd radeon hd 7500","7500",0,[[1366,696,49],[1366,768,49]]],["amd radeon hd 7500g","7500",0,[[1366,768,26]]],["amd radeon hd 7500m/7600m","7500",0,[[1366,768,46]]],["amd radeon hd 7520g","7520",0,[[1366,768,33]]],["amd radeon hd 7520g + hd 7400m dual","7520",0,[[1366,768,34]]],["amd radeon hd 7520g + hd 7600m dual","7520",0,[[1366,768,31],[1600,900,41]]],["amd radeon hd 7540d","7540",0,[[1024,768,55],[1280,1024,44],[1920,1080,22]]],["amd radeon hd 7540d + hd 6670 dual","7540",0,[[1280,1024,36]]],["amd radeon hd 7550m/7650m","7550",0,[[1366,768,57]]],["amd radeon hd 7560d","7560",0,[[1920,1080,34]]],["amd radeon hd 7560d + hd 6570 dual","7560",0,[[1680,1050,44]]],["amd radeon hd 7560d + hd 6670 dual","7560",0,[[800,638,60]]],["amd radeon hd 7570","7570",0,[[1024,768,72],[1920,1080,52]]],["amd radeon hd 7570m","7570",0,[[1366,768,35]]],["amd radeon hd 7570m/hd 7670m","7570",0,[[1366,768,50],[1600,900,29]]],["amd radeon hd 7600","7600",0,[[1920,1080,60]]],["amd radeon hd 7600a","7600",0,[[1920,1080,28]]],["amd radeon hd 7600g","7600",0,[[1366,768,29]]],["amd radeon hd 7600g + 7500m/7600m dual","7600",0,[[1366,768,19]]],["amd radeon hd 7600g + hd 8670m dual","7600",0,[[1366,768,29]]],["amd radeon hd 7600g + hd dual","7600",0,[[1366,768,20]]],["amd radeon hd 7600m","7600",0,[[1366,768,56]]],["amd radeon hd 7600m/7700m","7600",0,[[1366,768,31]]],["amd radeon hd 7610m","7610",0,[[1366,768,43]]],["amd radeon hd 7620g","7620",0,[[1366,768,22],[1920,1080,19]]],["amd radeon hd 7640g","7640",0,[[1366,768,38]]],["amd radeon hd 7640g + 7470m dual","7640",0,[[1366,768,32]]],["amd radeon hd 7640g + 7600m dual","7640",0,[[1366,768,23]]],["amd radeon hd 7640g + 7670m dual","7640",0,[[1600,900,15]]],["amd radeon hd 7640g + 8500m dual","7640",0,[[1366,768,35]]],["amd radeon hd 7640g + hd 7400m dual","7640",0,[[1366,768,37]]],["amd radeon hd 7640g + hd 7500 dual","7640",0,[[1366,768,35]]],["amd radeon hd 7640g + hd 7670m dual","7640",0,[[1366,768,34]]],["amd radeon hd 7640g + hd 8500m dual","7640",0,[[1366,768,40]]],["amd radeon hd 7640g + hd 8570m dual","7640",0,[[1366,768,31]]],["amd radeon hd 7650a","7650",0,[[1680,1050,43],[1920,1080,15]]],["amd radeon hd 7650m","7650",0,[[1366,768,41],[1600,900,45]]],["amd radeon hd 7660d","7660",0,[[1680,1050,40],[1920,1008,60],[1920,1080,38]]],["amd radeon hd 7660d + hd 6570 dual","7660",0,[[1200,900,32]]],["amd radeon hd 7660d + hd 6670 dual","7660",0,[[1360,768,57],[1920,1080,53]]],["amd radeon hd 7660g","7660",0,[[1366,768,44],[1600,900,41],[1920,1080,34],[1920,1200,27]]],["amd radeon hd 7660g + 7600m dual","7660",0,[[1366,768,53],[1600,900,45]]],["amd radeon hd 7660g + 7670m dual","7660",0,[[1366,768,52]]],["amd radeon hd 7660g + 8670m dual","7660",0,[[1600,900,46]]],["amd radeon hd 7660g + hd 7600m dual","7660",0,[[1366,768,50]]],["amd radeon hd 7660g + hd 7670m dual","7660",0,[[1366,768,35]]],["amd radeon hd 7660g + hd 8600m dual","7660",0,[[1600,900,29]]],["amd radeon hd 7670","7670",0,[[1920,1080,39]]],["amd radeon hd 7670m","7670",0,[[1366,768,49],[1920,1080,36]]],["amd radeon hd 7700","7700",0,[[1400,1050,45],[1920,1080,60]]],["amd radeon hd 7700m","7700",0,[[1920,1080,54]]],["amd radeon hd 7730m","7730",0,[[1920,1080,57]]],["amd radeon hd 7750","7750",0,[[1280,1024,60],[1600,900,60],[1400,1050,98],[1920,1080,60],[3840,2160,23]]],["amd radeon hd 7750 / r7 250e","7750",0,[[2560,1080,69]]],["amd radeon hd 7750m","7750",0,[[1680,1050,57]]],["amd radeon hd 7770","7770",0,[[1920,1080,60]]],["amd radeon hd 7770 / r7 250x","7770",0,[[1680,1050,78]]],["amd radeon hd 7770 ghz","7770",0,[[1920,1080,78]]],["amd radeon hd 7790","7790",0,[[1920,1080,16]]],["amd radeon hd 7790 / r7 360 / r9 260/360","7790",0,[[1280,1024,131]]],["amd radeon hd 7800","7800",0,[[1920,1080,60]]],["amd radeon hd 7800m","7800",0,[[1920,1080,57]]],["amd radeon hd 7850","7850",0,[[1920,1080,60]]],["amd radeon hd 7850 / r7 265 / r9 270 1024sp","7850",0,[[1280,1024,87]]],["amd radeon hd 7870","7870",0,[[1920,1080,120],[2560,1440,60],[2560,1600,114],[3840,2160,30]]],["amd radeon hd 7870 ghz","7870",0,[[1920,1080,75]]],["amd radeon hd 7870 xt","7870",0,[[1920,1080,57],[3840,2160,53]]],["amd radeon hd 7870m","7870",0,[[1920,1080,22],[2732,1536,40]]],["amd radeon hd 7900","7900",0,[[2560,1600,59]]],["amd radeon hd 7950","7950",0,[[1920,1080,50]]],["amd radeon hd 7950 / r9 280","7950",0,[[1920,1080,59]]],["amd radeon hd 7950 oem / r9 280","7950",0,[[1920,1080,60]]],["amd radeon hd 7970","7970",0,[[1920,1080,60]]],["amd radeon hd 7970 / r9 280x","7970",0,[[1920,1080,193]]],["amd radeon hd 7970m","7970",0,[[1366,768,60],[1920,1080,60]]],["amd radeon hd 7970x/8970 280x","7970",0,[[1920,1080,60]]],["amd radeon hd 7990","7990",0,[[1920,1080,60],[5120,2880,63]]],["amd radeon hd 7xxx","7",0,[[1920,1080,60]]],["amd radeon hd 8180","8180",0,[[1366,768,10]]],["amd radeon hd 8200 / r3","8200",0,[[1366,768,21],[1600,900,13],[1680,1050,13]]],["amd radeon hd 8210","8210",0,[[1366,768,18]]],["amd radeon hd 8240","8240",0,[[1600,900,17]]],["amd radeon hd 8240 / r3","8240",0,[[1366,768,14]]],["amd radeon hd 8250","8250",0,[[1366,768,14],[1920,1200,10]]],["amd radeon hd 8280","8280",0,[[1600,900,60]]],["amd radeon hd 8280 / r3","8280",0,[[1366,768,22]]],["amd radeon hd 8280e","8280",0,[[2880,1620,6]]],["amd radeon hd 8330","8330",0,[[1366,768,24]]],["amd radeon hd 8350","8350",0,[[1920,1080,57]]],["amd radeon hd 8350g","8350",0,[[1366,768,18]]],["amd radeon hd 8370d","8370",0,[[1366,768,60],[1280,1024,26],[1920,1080,22]]],["amd radeon hd 8400","8400",0,[[1366,768,30],[1920,1080,16]]],["amd radeon hd 8400 / r3","8400",0,[[1360,768,19],[1366,768,22],[1920,1080,12]]],["amd radeon hd 8400e","8400",0,[[1680,1050,17],[1920,1080,16],[1920,1200,14]]],["amd radeon hd 8410g","8410",0,[[1366,768,32]]],["amd radeon hd 8450g","8450",0,[[1366,768,23]]],["amd radeon hd 8450g + hd 8750m dual","8450",0,[[1366,768,21]]],["amd radeon hd 8470","8470",0,[[1920,1080,17]]],["amd radeon hd 8470 + 7660d dual","8470",0,[[1920,1080,60]]],["amd radeon hd 8470d","8470",0,[[1280,1024,44],[1920,1080,21]]],["amd radeon hd 8470d + hd 6450 dual","8470",0,[[1600,900,37]]],["amd radeon hd 8490","8490",0,[[1920,1080,18],[1920,1200,20]]],["amd radeon hd 8500m","8500",0,[[1366,768,41],[1920,1080,19]]],["amd radeon hd 8500m/8700m","8500",0,[[1920,1080,30]]],["amd radeon hd 8510g","8510",0,[[1366,768,29],[1920,1080,17]]],["amd radeon hd 8550","8550",0,[[1920,1080,25]]],["amd radeon hd 8550g","8550",0,[[1366,768,34],[1600,900,41],[1920,1080,34]]],["amd radeon hd 8550g + 8500m dual","8550",0,[[1366,768,42]]],["amd radeon hd 8550g + 8600 dual","8550",0,[[1920,1080,27]]],["amd radeon hd 8550g + hd 8570m dual","8550",0,[[1366,768,32]]],["amd radeon hd 8550g + hd 8600 dual","8550",0,[[1366,768,60]]],["amd radeon hd 8550g + hd 8750m dual","8550",0,[[1366,768,37]]],["amd radeon hd 8550g + r5 m230 dual","8550",0,[[1366,768,29]]],["amd radeon hd 8570","8570",0,[[1280,1024,60],[1680,1050,54],[1920,1080,50]]],["amd radeon hd 8570 / r5 430 / r7 240 / radeon 520","8570",0,[[1920,1080,25]]],["amd radeon hd 8570d","8570",0,[[1920,1080,16]]],["amd radeon hd 8570d + r7 240 dual","8570",0,[[1920,1080,45]]],["amd radeon hd 8570m","8570",0,[[1366,768,40]]],["amd radeon hd 8600","8600",0,[[1366,768,41]]],["amd radeon hd 8600m","8600",0,[[1366,768,42],[1920,1080,14]]],["amd radeon hd 8610g","8610",0,[[1366,768,31],[1920,1080,16]]],["amd radeon hd 8610g + 8600m dual","8610",0,[[1366,768,22]]],["amd radeon hd 8610g + hd 8600m dual","8610",0,[[1366,768,41]]],["amd radeon hd 8610g + hd 8670m dual","8610",0,[[1366,768,33]]],["amd radeon hd 8650g","8650",0,[[1360,768,44],[1366,768,44]]],["amd radeon hd 8650g + 8500m dual","8650",0,[[1366,768,35]]],["amd radeon hd 8650g + 8600 dual","8650",0,[[1920,1080,38]]],["amd radeon hd 8650g + 8600m dual","8650",0,[[1366,768,21]]],["amd radeon hd 8650g + 8670m dual","8650",0,[[1366,768,66]]],["amd radeon hd 8650g + 8750m dual","8650",0,[[1920,1080,28]]],["amd radeon hd 8650g + hd 7600m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + hd 8500m dual","8650",0,[[1366,768,23]]],["amd radeon hd 8650g + hd 8570m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + hd 8600m dual","8650",0,[[1366,768,46],[1600,900,29]]],["amd radeon hd 8650g + hd 8750m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + r5 m200 dual","8650",0,[[1366,768,35]]],["amd radeon hd 8670 / r7 250","8670",0,[[1024,768,1]]],["amd radeon hd 8670a/8670m/8690m","8670",0,[[1366,768,47]]],["amd radeon hd 8670a/8670m/8750m","8670",0,[[1366,768,60]]],["amd radeon hd 8670d","8670",0,[[1024,768,45],[1280,1024,69],[1920,1080,38]]],["amd radeon hd 8670d + 7700 dual","8670",0,[[1680,1050,58]]],["amd radeon hd 8670d + hd 6670 dual","8670",0,[[1680,1050,33]]],["amd radeon hd 8670d + r5 200 dual","8670",0,[[2560,1080,14]]],["amd radeon hd 8670d + r7 200 dual","8670",0,[[1920,1080,37]]],["amd radeon hd 8670m","8670",0,[[1366,768,41]]],["amd radeon hd 8690a","8690",0,[[1920,1080,31]]],["amd radeon hd 8690m","8690",0,[[1600,900,35]]],["amd radeon hd 8700m","8700",0,[[1366,768,60]]],["amd radeon hd 8730m","8730",0,[[1366,768,59]]],["amd radeon hd 8750m","8750",0,[[1366,768,60]]],["amd radeon hd 8770","8770",0,[[1920,1080,111]]],["amd radeon hd 8790m","8790",0,[[1600,900,78],[1920,1080,60]]],["amd radeon hd 8800m","8800",0,[[1920,1080,60],[2880,1800,45]]],["amd radeon hd 8830m","8830",0,[[1920,1080,82]]],["amd radeon hd 8850m","8850",0,[[1366,768,45]]],["amd radeon hd 8870m","8870",0,[[1280,1024,60],[1600,900,60]]],["amd radeon hd 8950","8950",0,[[1920,1080,60],[1920,1200,59]]],["amd radeon hd 8970","8970",0,[[2560,1600,60]]],["amd radeon hd 8970m","8970",0,[[1920,1080,146],[1920,1200,60]]],["amd radeon hd 8xxx","8",0,[[1920,1080,120],[2560,1440,58]]],["amd radeon hd5450","5450",0,[[1280,720,24]]],["amd radeon hd6870","6870",0,[[1920,1080,60]]],["amd radeon hd7970m","7970",0,[[2560,1440,116]]],["amd radeon hd8530m","8530",0,[[1366,768,40]]],["amd radeon hd8730","8730",0,[[1680,1050,42]]],["amd radeon hd8970m","8970",0,[[1920,1080,74]]],["amd radeon hybrid","",0,[[1366,768,27]]],["amd radeon infoshock rx 460","460",0,[[1360,768,102]]],["amd radeon instinct mi25","25",0,[[1920,1200,26]]],["amd radeon instinct mi25 mxgpu","25",0,[[1920,1080,20],[1920,1200,32]]],["amd radeon m535dx","535",0,[[1366,768,58]]],["amd radeon navi14","14",0,[[3840,2160,60]]],["amd radeon polaris","",0,[[3840,2160,60],[5120,2880,44]]],["amd radeon polaris 10","10",0,[[1920,1200,60]]],["amd radeon pro","pro",0,[[1920,1080,114]]],["amd radeon pro 270x","270",0,[[2560,1440,74]]],["amd radeon pro 450","450",0,[[1920,1080,30],[2880,1800,43],[3360,2100,36],[5120,2880,30]]],["amd radeon pro 450 opengl engine","450",0,[[1920,1200,60]]],["amd radeon pro 455","455",0,[[2879,1800,54],[2880,1800,48],[3360,2100,37]]],["amd radeon pro 455 opengl engine","455",0,[[3360,2100,36]]],["amd radeon pro 460","460",0,[[2880,1800,50],[3360,2100,42]]],["amd radeon pro 460 opengl engine","460",0,[[5760,3240,15]]],["amd radeon pro 470","470",0,[[6016,3384,49]]],["amd radeon pro 480","480",0,[[1920,1080,60]]],["amd radeon pro 5300","5300",0,[[5120,2880,60]]],["amd radeon pro 5300m","5300",0,[[1920,1080,214],[3584,2240,130]]],["amd radeon pro 5500 xt","5500",0,[[5120,2880,51]]],["amd radeon pro 5500m","5500",0,[[3072,1920,60],[3584,2240,139]]],["amd radeon pro 555","555",0,[[2879,1800,54],[2880,1800,36],[3360,2100,40]]],["amd radeon pro 555x","555",0,[[2880,1800,42],[3360,2100,39]]],["amd radeon pro 560","560",0,[[2879,1800,56],[2880,1800,56],[3360,2100,42]]],["amd radeon pro 5600m","5600",0,[[3072,1920,60],[3584,2240,60]]],["amd radeon pro 560x","560",0,[[2879,1800,59],[2880,1800,71],[3360,2100,43]]],["amd radeon pro 570","570",0,[[5120,2880,48]]],["amd radeon pro 570 opengl engine","570",0,[[5120,2880,46]]],["amd radeon pro 5700","5700",0,[[5120,2880,60]]],["amd radeon pro 5700 xt","5700",0,[[5120,2880,60]]],["amd radeon pro 570x","570",0,[[5120,2880,50]]],["amd radeon pro 575","575",0,[[4096,2304,60],[5120,2880,50]]],["amd radeon pro 575 opengl engine","575",0,[[5120,2880,48]]],["amd radeon pro 575x","575",0,[[5120,2880,56]]],["amd radeon pro 580","580",0,[[5120,2880,54]]],["amd radeon pro 580 opengl engine","580",0,[[5120,2880,50]]],["amd radeon pro 580x","580",0,[[5120,2880,52]]],["amd radeon pro duo","pro",0,[[1920,1080,234],[1800,1350,59],[3840,2160,82],[4096,2160,60]]],["amd radeon pro rx 560","560",0,[[2560,1080,60]]],["amd radeon pro ssg","pro",0,[[3440,1440,125]]],["amd radeon pro v340","340",0,[[1920,1080,112]]],["amd radeon pro v520 mxgpu","520",0,[[1920,1080,271]]],["amd radeon pro v7350x2","7350",0,[[1920,1080,60]]],["amd radeon pro vega 16","16",0,[[2879,1800,60],[3360,2100,60]]],["amd radeon pro vega 20","20",0,[[2880,1800,120],[3360,2100,121],[3840,2160,30]]],["amd radeon pro vega 48","48",0,[[5120,2880,86]]],["amd radeon pro vega 56","56",0,[[1920,1080,60],[5120,2880,60]]],["amd radeon pro vega 56 opengl engine","56",0,[[5120,2880,60]]],["amd radeon pro vega 64","64",0,[[5120,2880,60]]],["amd radeon pro vega 64 opengl engine","64",0,[[5120,2880,60]]],["amd radeon pro vega 64x","64",0,[[2560,1440,206],[4096,2304,60],[5120,2880,60]]],["amd radeon pro vega ii","proii",0,[[3840,1600,60],[5120,2880,60]]],["amd radeon pro vega ii duo","proii",0,[[2560,1440,239],[5120,2880,60]]],["amd radeon pro w5500","5500",0,[[1920,1080,195],[3840,2160,59],[7680,3240,56]]],["amd radeon pro w5500m","5500",0,[[1920,1080,60]]],["amd radeon pro w5500x","5500",0,[[1920,1200,60]]],["amd radeon pro w5700","5700",0,[[1680,1050,253],[5120,1440,120],[3840,2160,60]]],["amd radeon pro w5700x","5700",0,[[3840,2160,60]]],["amd radeon pro w6600","6600",0,[[1920,1200,60],[3840,2160,166]]],["amd radeon pro w6600m","6600",0,[[1920,1080,60]]],["amd radeon pro w6800","6800",0,[[1920,1080,60],[3840,2160,237]]],["amd radeon pro w6800x","6800",0,[[6016,3384,60]]],["amd radeon pro w6800x duo","6800",0,[[3840,1600,60],[5120,2880,45]]],["amd radeon pro w6900x","6900",0,[[3840,2160,60]]],["amd radeon pro wx","pro",0,[[2560,1080,69]]],["amd radeon pro wx 2100","2100",0,[[1280,1024,145],[1920,1080,60]]],["amd radeon pro wx 3100","3100",0,[[1919,1080,58],[1920,1080,123],[2560,1440,82]]],["amd radeon pro wx 3200","3200",0,[[2560,1440,92]]],["amd radeon pro wx 4100","4100",0,[[1920,1080,60],[1920,1200,60],[3840,2160,30],[5120,2880,18]]],["amd radeon pro wx 4130","4130",0,[[1920,1080,60],[3840,2160,30]]],["amd radeon pro wx 4150","4150",0,[[1920,1080,56],[3840,2160,37],[4096,2160,34]]],["amd radeon pro wx 5100","5100",0,[[1920,1080,60],[2560,1440,91],[3840,2160,55]]],["amd radeon pro wx 5100 opengl engine","5100",0,[[2560,1440,60]]],["amd radeon pro wx 7100","7100",0,[[1920,1080,122],[2560,1080,58],[3840,2160,60],[5120,2880,60]]],["amd radeon pro wx 7100 mobile","7100",0,[[2560,1440,60]]],["amd radeon pro wx 7100 opengl engine","7100",0,[[3840,2160,60]]],["amd radeon pro wx 8200","8200",0,[[3440,1440,124]]],["amd radeon pro wx 9100","9100",0,[[1920,1080,60],[4096,2160,101]]],["amd radeon pro wx 9100 opengl engine","9100",0,[[1920,1080,60]]],["amd radeon pro wx vega m gl","prom",0,[[3840,2160,14]]],["amd radeon pro wx3200","3200",0,[[1920,1080,55]]],["amd radeon pro wx9100","9100",0,[[2560,1440,60]]],["amd radeon r2","2",0,[[1366,768,13],[1600,900,14]]],["amd radeon r2e","2",0,[[1366,768,16],[1920,1080,45],[3840,2160,4]]],["amd radeon r3","3",0,[[1366,768,17],[1920,1080,15]]],["amd radeon r4","4",0,[[1366,768,19],[1920,1080,13]]],["amd radeon r4e","4",0,[[3840,2160,6]]],["amd radeon r5","5",0,[[1024,768,38],[1360,768,25],[1366,768,21],[1280,1024,33],[1920,1080,14],[3200,1800,7]]],["amd radeon r5 220","5",0,[[1366,768,19],[1920,1080,12]]],["amd radeon r5 230","5",0,[[1920,1080,21]]],["amd radeon r5 235","5",0,[[1920,1080,17]]],["amd radeon r5 240","5",0,[[1280,1024,34],[1920,1080,24]]],["amd radeon r5 340","5",0,[[1920,1080,27]]],["amd radeon r5 340x","5",0,[[1920,1080,31]]],["amd radeon r5 430","5",0,[[1280,1024,31],[1680,1050,54],[1920,1080,54]]],["amd radeon r5 435","5",0,[[1920,1080,30]]],["amd radeon r5 m200","5",0,[[1600,900,45],[1920,1080,20]]],["amd radeon r5 m200 / hd 8500m","5",0,[[1366,768,31],[1920,1080,24]]],["amd radeon r5 m230","5",0,[[1366,768,37]]],["amd radeon r5 m240","5",0,[[1366,768,42],[1920,1080,23]]],["amd radeon r5 m255","5",0,[[1366,768,59],[1600,900,33]]],["amd radeon r5 m315","5",0,[[1366,768,45]]],["amd radeon r5 m320","5",0,[[1920,1080,19]]],["amd radeon r5 m330","5",0,[[1366,768,27],[1920,1080,26]]],["amd radeon r5 m335","5",0,[[1366,768,55],[1920,1080,19]]],["amd radeon r5 m420","5",0,[[1366,768,49]]],["amd radeon r5 m430","5",0,[[1366,768,36],[1920,1080,20]]],["amd radeon r5 m435","5",0,[[1920,1080,41],[2560,1440,67]]],["amd radeon r5 m445","5",0,[[1920,1080,32]]],["amd radeon r5e","5",0,[[1600,768,14],[1920,1080,16]]],["amd radeon r6","6",0,[[1366,768,30],[1280,1024,23],[1920,1080,12]]],["amd radeon r6 m255dx","6",0,[[1366,768,25]]],["amd radeon r6 m340dx","6",0,[[1366,768,31],[1920,1080,15]]],["amd radeon r6e","6",0,[[3840,2160,5]]],["amd radeon r7","7",0,[[1366,768,35],[1280,1024,31],[1680,1050,39],[1920,1080,12],[1920,1200,16],[2560,1080,15],[2560,1440,21],[3840,2160,8]]],["amd radeon r7 200","7",0,[[1280,1024,45],[1920,1080,120]]],["amd radeon r7 200 series","7",0,[[1920,1080,43]]],["amd radeon r7 240","7",0,[[1920,1080,29]]],["amd radeon r7 240 + hd 8570d dual","7",0,[[1920,1080,43]]],["amd radeon r7 250","7",0,[[1920,1080,49]]],["amd radeon r7 250e","7",0,[[1920,1080,60]]],["amd radeon r7 250x","7",0,[[1920,1080,60]]],["amd radeon r7 260x","7",0,[[1920,1080,56]]],["amd radeon r7 260x/360","7",0,[[1920,1200,102]]],["amd radeon r7 350","7",0,[[1024,768,60],[1280,1024,79],[1920,1080,59]]],["amd radeon r7 350x","7",0,[[1920,1080,50]]],["amd radeon r7 360","7",0,[[1920,1048,60],[1920,1080,102]]],["amd radeon r7 360 / r9 360","7",0,[[1920,1080,60]]],["amd radeon r7 370","7",0,[[1600,900,60],[1920,1080,75]]],["amd radeon r7 370 / r9 270","7",0,[[1920,1080,74]]],["amd radeon r7 370 / r9 270x/370","7",0,[[1600,900,115],[1920,1080,60]]],["amd radeon r7 370 / r9 270x/370x","7",0,[[1920,1080,115]]],["amd radeon r7 370 series","7",0,[[1920,1080,212],[3840,2160,60]]],["amd radeon r7 430","7",0,[[1920,1080,55],[3840,2160,10]]],["amd radeon r7 450","7",0,[[1920,1080,60]]],["amd radeon r7 a360","7",0,[[1920,1080,28]]],["amd radeon r7 graphics + hd 7700 dual","7",0,[[1600,1200,72]]],["amd radeon r7 graphics + r5 340 dual","7",0,[[1920,1080,47]]],["amd radeon r7 graphics + r7 200 dual","7",0,[[1920,1080,45],[1920,1200,47]]],["amd radeon r7 graphics + r7 350 dual","7",0,[[1919,1080,60]]],["amd radeon r7 m260","7",0,[[1600,900,44],[1920,1080,13]]],["amd radeon r7 m260dx","7",0,[[1366,768,46],[1920,1080,18]]],["amd radeon r7 m260x","7",0,[[1920,1080,29]]],["amd radeon r7 m265","7",0,[[1366,768,48],[1920,1080,27]]],["amd radeon r7 m270","7",0,[[1920,1080,31],[3840,2160,10]]],["amd radeon r7 m340","7",0,[[1366,768,60],[1920,1080,32]]],["amd radeon r7 m350","7",0,[[3840,2160,12]]],["amd radeon r7 m360","7",0,[[1366,768,40],[1920,1080,22]]],["amd radeon r7 m370","7",0,[[1920,1080,24]]],["amd radeon r7 m440","7",0,[[1920,1080,39]]],["amd radeon r7 m445","7",0,[[1920,1080,36]]],["amd radeon r7 m460","7",0,[[1919,1080,24],[1920,1080,29]]],["amd radeon r7 m520","7",0,[[1919,1080,17]]],["amd radeon r7 series / hd 9000","7",0,[[1920,1080,71],[2560,1080,59]]],["amd radeon r7e","7",0,[[1024,768,41]]],["amd radeon r8 m350dx","8",0,[[1366,768,30]]],["amd radeon r8 m365dx","8",0,[[1920,1080,28]]],["amd radeon r8 m435dx","8",0,[[1920,1080,22]]],["amd radeon r8 m445dx","8",0,[[1366,768,38],[1920,1080,27]]],["amd radeon r8 m535dx","8",0,[[1366,768,55]]],["amd radeon r9","9",0,[[1920,1080,60]]],["amd radeon r9 200","9",0,[[1920,1080,60]]],["amd radeon r9 200 / hd 7900","9",0,[[1920,1080,250]]],["amd radeon r9 255","9",0,[[1600,900,52],[1920,1080,51]]],["amd radeon r9 260","9",0,[[1920,1080,16]]],["amd radeon r9 270","9",0,[[1280,1024,60],[1920,1080,60]]],["amd radeon r9 270 1024sp","9",0,[[1920,1080,135]]],["amd radeon r9 270x","9",0,[[1920,1080,30]]],["amd radeon r9 280","9",0,[[1920,1080,75],[1920,1200,428],[2560,1440,60]]],["amd radeon r9 280,","9",0,[[5120,2880,39]]],["amd radeon r9 280x","9",0,[[1920,1080,137]]],["amd radeon r9 285","9",0,[[1920,1080,60],[1920,1200,129]]],["amd radeon r9 290","9",0,[[1920,1080,60]]],["amd radeon r9 290x","9",0,[[1920,1080,60],[2560,1440,60],[3840,2160,118]]],["amd radeon r9 300","9",0,[[1920,1080,59]]],["amd radeon r9 350","9",0,[[1920,1200,63]]],["amd radeon r9 360","9",0,[[1600,900,83],[1920,1080,60],[2560,1440,59]]],["amd radeon r9 370","9",0,[[1680,1050,205],[1920,1080,60],[3840,2160,49]]],["amd radeon r9 370x","9",0,[[1920,1080,60]]],["amd radeon r9 380","9",0,[[1920,1080,41],[2560,1440,75]]],["amd radeon r9 380x","9",0,[[2560,1600,60]]],["amd radeon r9 390","9",0,[[1920,1080,60],[2560,1440,60]]],["amd radeon r9 390x","9",0,[[2560,1440,60],[3840,2160,60]]],["amd radeon r9 a375","9",0,[[1920,1080,28]]],["amd radeon r9 fury","9",0,[[1920,1080,75],[3840,2160,133]]],["amd radeon r9 fury / nano","9",0,[[1920,1200,155]]],["amd radeon r9 m200x","9",0,[[1366,768,104],[1920,1080,60]]],["amd radeon r9 m265x","9",0,[[1920,1080,33]]],["amd radeon r9 m270x","9",0,[[1600,900,60],[1920,1080,68]]],["amd radeon r9 m275","9",0,[[1920,1080,29]]],["amd radeon r9 m275x","9",0,[[1920,1080,20]]],["amd radeon r9 m280x","9",0,[[1920,1080,60],[2560,1440,25]]],["amd radeon r9 m290","9",0,[[5120,2880,33]]],["amd radeon r9 m290x","9",0,[[1920,1080,60],[3840,2160,61],[5120,2880,33]]],["amd radeon r9 m295x","9",0,[[3840,2160,33],[5120,2880,36]]],["amd radeon r9 m295x mac","9",0,[[5120,2880,42]]],["amd radeon r9 m295x mac edition / r9 380x","9",0,[[1920,1080,128]]],["amd radeon r9 m360","9",0,[[1920,1080,60],[3840,2160,26]]],["amd radeon r9 m370x","9",0,[[2560,1440,30],[2880,1800,27]]],["amd radeon r9 m370x opengl engine","9",0,[[5120,2880,14]]],["amd radeon r9 m375","9",0,[[1920,1080,29]]],["amd radeon r9 m375x","9",0,[[1920,1080,60],[3840,2160,22]]],["amd radeon r9 m380","9",0,[[1920,1080,50],[3840,2160,8],[5120,2880,9]]],["amd radeon r9 m380 opengl engine","9",0,[[5120,2880,15]]],["amd radeon r9 m385","9",0,[[1920,1080,58]]],["amd radeon r9 m385x","9",0,[[1920,1080,60]]],["amd radeon r9 m390","9",0,[[5119,2879,29],[5120,2880,21],[5760,3240,32]]],["amd radeon r9 m390 opengl engine","9",0,[[5120,2880,27]]],["amd radeon r9 m390x","9",0,[[1920,1080,140]]],["amd radeon r9 m395","9",0,[[2560,1440,59],[5120,2880,19]]],["amd radeon r9 m395 opengl engine","9",0,[[5120,2880,38]]],["amd radeon r9 m395x","9",0,[[3840,2160,58],[5120,2880,36]]],["amd radeon r9 m395x opengl engine","9",0,[[5120,2880,35]]],["amd radeon r9 m470","9",0,[[3840,2160,29]]],["amd radeon r9 m470x","9",0,[[1920,1080,60]]],["amd radeon r9-290x","9",0,[[1920,1080,60]]],["amd radeon renoir graphics d1","1",0,[[1366,768,60]]],["amd radeon rro 580x","580",0,[[5120,2880,59]]],["amd radeon rx 460","460",0,[[1920,1080,55],[2560,1080,60],[3840,2160,31]]],["amd radeon rx 460 / pro 450/455/460/555/555x/560/560x","460",0,[[3440,1440,93]]],["amd radeon rx 460 / pro 450/455/460/560","460",0,[[1920,1080,72]]],["amd radeon rx 470","470",0,[[1280,1024,73],[1920,1080,58],[1920,1200,147],[3840,2160,51]]],["amd radeon rx 470 opengl engine","470",0,[[2560,1440,60]]],["amd radeon rx 475m","475",0,[[1920,1080,60]]],["amd radeon rx 480","480",0,[[1400,1050,267],[1920,1080,60],[2560,1080,71]]],["amd radeon rx 480 opengl engine","480",0,[[1920,1080,60]]],["amd radeon rx 5300m","5300",0,[[1920,1080,60],[3840,2160,60]]],["amd radeon rx 540","540",0,[[1919,1080,52],[1920,1080,36]]],["amd radeon rx 550","550",0,[[1280,1024,135],[1920,1080,60],[1920,1200,60],[6016,3384,15]]],["amd radeon rx 550 640sp / rx 560","550",0,[[1920,1080,60]]],["amd radeon rx 5500","5500",0,[[1920,1080,139]]],["amd radeon rx 5500 / pro 5500m","5500",0,[[1920,1080,60],[2560,1440,227]]],["amd radeon rx 5500 xt","5500",0,[[1920,1080,239]]],["amd radeon rx 5500m","5500",0,[[1920,1048,144],[1920,1080,144],[3840,2160,60]]],["amd radeon rx 550x","550",0,[[1920,1080,52]]],["amd radeon rx 560","560",0,[[1920,1080,60],[1920,1200,42],[2560,1440,60]]],["amd radeon rx 560 [baffin]","560",0,[[1920,1080,60]]],["amd radeon rx 5600 oem/5600 xt / 5700 xt","5600",0,[[1920,1080,360],[2560,1440,164]]],["amd radeon rx 5600 xt","5600",0,[[1920,1080,75]]],["amd radeon rx 5600m","5600",0,[[1920,1080,144]]],["amd radeon rx 560d","560",0,[[2560,1080,60]]],["amd radeon rx 560x","560",0,[[1920,1080,115],[3840,2160,35]]],["amd radeon rx 570","570",0,[[1920,1080,60],[3072,1728,60]]],["amd radeon rx 570 opengl engine","570",0,[[1920,1080,226]]],["amd radeon rx 5700","5700",0,[[1920,1080,144]]],["amd radeon rx 5700 / 5700 xt","5700",0,[[3840,2160,201]]],["amd radeon rx 5700 xt","5700",0,[[1920,1080,464],[3840,2160,60],[6016,3384,34]]],["amd radeon rx 5700 xt 50th anniversary","5700",0,[[2560,1440,144],[3840,1600,60],[3840,2160,222],[5120,2880,60]]],["amd radeon rx 5700xt","5700",0,[[1920,1080,369]]],["amd radeon rx 580","580",0,[[1920,1080,60],[1920,1200,97],[2560,1440,60],[3840,2160,60]]],["amd radeon rx 580 2048sp","580",0,[[1920,1080,60]]],["amd radeon rx 580 opengl engine","580",0,[[1920,1080,145]]],["amd radeon rx 580 special","580",0,[[2560,1440,60]]],["amd radeon rx 580x","580",0,[[1920,1200,60],[3840,2160,79]]],["amd radeon rx 590","590",0,[[1920,1080,75],[2560,1440,164],[3584,2240,60]]],["amd radeon rx 640","640",0,[[1920,1080,39]]],["amd radeon rx 6500 xt","6500",0,[[1920,1080,60]]],["amd radeon rx 6600","6600",0,[[1920,1080,433],[3840,2160,57]]],["amd radeon rx 6600 xt","6600",0,[[1920,1080,60]]],["amd radeon rx 6600 xt/6600m","6600",0,[[2560,1440,60]]],["amd radeon rx 6600m","6600",0,[[1920,1080,139]]],["amd radeon rx 6700 xt","6700",0,[[1920,1080,451]]],["amd radeon rx 6700 xt / 6800m","6700",0,[[2560,1440,144]]],["amd radeon rx 6700m","6700",0,[[1920,1080,240]]],["amd radeon rx 6800","6800",0,[[2560,1440,564],[3840,2160,60]]],["amd radeon rx 6800 xt","6800",0,[[2560,1440,446],[3440,1440,144],[3840,2160,60]]],["amd radeon rx 6800 xt / 6900 xt","6800",0,[[2560,1440,239]]],["amd radeon rx 6800 xt 16gb","6800",0,[[6400,2666,60]]],["amd radeon rx 6800m","6800",0,[[1920,1080,300]]],["amd radeon rx 6900 xt","6900",0,[[3840,2160,60]]],["amd radeon rx rx 560","560",0,[[1920,1080,60]]],["amd radeon rx vega","rx",0,[[1920,1080,39]]],["amd radeon rx vega 10","10",0,[[1920,1080,38]]],["amd radeon rx vega 11","11",0,[[1920,1080,35]]],["amd radeon rx vega 56","56",0,[[1920,1080,144],[3440,1440,60],[3840,2160,60]]],["amd radeon rx vega 56 8gb","56",0,[[2560,1600,60]]],["amd radeon rx vega 56 opengl engine","56",0,[[2560,1440,60]]],["amd radeon rx vega 64","64",0,[[2560,1440,518]]],["amd radeon rx vega 64 8gb","64",0,[[2560,1440,60]]],["amd radeon rx vega 64 opengl engine","64",0,[[3840,2160,119]]],["amd radeon rx vega 64.1","64",0,[[6016,3384,60]]],["amd radeon rx vega 8","8",0,[[1920,1080,53]]],["amd radeon rx vega m gh","rxm",0,[[1920,1080,60],[2560,1440,60],[3840,2160,51]]],["amd radeon rx vega m gl","rxm",0,[[2560,1440,567],[3840,2160,59]]],["amd radeon rx vega11","11",0,[[2496,1664,30]]],["amd radeon rx460","460",0,[[1920,1080,60]]],["amd radeon rx480","480",0,[[1920,1080,102],[2560,1080,71]]],["amd radeon rx540","540",0,[[2400,1800,37]]],["amd radeon rx550","550",0,[[1920,1080,60]]],["amd radeon rx560","560",0,[[1920,1080,93]]],["amd radeon rx5600","5600",0,[[3840,2160,129]]],["amd radeon rx570","570",0,[[5120,2880,59]]],["amd radeon rx5700","5700",0,[[1920,1080,60]]],["amd radeon rx580","580",0,[[1920,1080,60]]],["amd radeon rx590 gme","590",0,[[1920,1080,112]]],["amd radeon rx6600xt","6600",0,[[3840,2160,60]]],["amd radeon sky 500","500",0,[[4096,2160,34]]],["amd radeon vega","",0,[[5120,2880,32]]],["amd radeon vega 10","10",0,[[1920,1080,44]]],["amd radeon vega 10 mobile","10",0,[[1920,1080,30]]],["amd radeon vega 11","11",0,[[1280,1024,60],[1920,1080,60],[3840,2160,17]]],["amd radeon vega 2","2",0,[[1366,768,30]]],["amd radeon vega 3","3",0,[[1440,900,44],[1920,1080,29],[3840,2160,8]]],["amd radeon vega 3 mobile","3",0,[[1920,1080,30]]],["amd radeon vega 56","56",0,[[2560,1440,144]]],["amd radeon vega 6","6",0,[[1366,768,61],[1920,1080,23]]],["amd radeon vega 64","64",0,[[6016,3384,35]]],["amd radeon vega 64 lc","64",0,[[2560,1080,60]]],["amd radeon vega 8","8",0,[[1920,1080,35],[2560,1440,24],[4096,2160,15]]],["amd radeon vega 8 mobile","8",0,[[1920,1080,36]]],["amd radeon vega 9","9",0,[[2496,1663,32],[2496,1664,39]]],["amd radeon vega fe","fe",0,[[1920,1080,120],[2560,1440,60]]],["amd radeon vega frontier","",0,[[1920,1080,120],[3840,2160,60]]],["amd radeon vega frontier edition opengl engine","",0,[[3440,1440,60]]],["amd radeon vega series / radeon vega mobile","",0,[[1920,1080,67]]],["amd radeon vii","vii",0,[[1920,1080,468],[2560,1440,60],[3840,2160,60]]],["amd radeont 540x","540",0,[[1920,1080,74],[3840,2160,22]]],["amd radeont rx 5300","5300",0,[[1920,1080,60]]],["amd radeont rx 5500m","5500",0,[[1920,1080,303]]],["amd radeont rx 560x","560",0,[[1920,1080,60]]],["amd saphire radeon rx 580","580",0,[[1920,1080,57]]],["amd sapphire radeon hd6870","6870",0,[[1680,1050,60]]],["amd sapphire radeon rx 560","560",0,[[1280,1024,60]]],["amd sapphire radeon rx vega 64 8gb","64",0,[[2560,1440,144]]],["intel radeon pro vega 16","16",0,[[3360,1890,20]]],["intel radeong 0.4 on amd bonaire","0",0,[[1920,1200,92]]],["intel radeong 0.4 on amd cape verde","0",0,[[1920,1200,73]]],["intel radeong 0.4 on amd polaris10","0",0,[[3840,2160,108]]],["intel radeong 0.4 on amd tonga","0",0,[[1920,1080,124]]],["radeon 500","500",0,[[1920,1080,58]]],["radeon 550","550",0,[[1920,1080,60]]],["radeon 550x","550",0,[[1920,1080,68]]],["radeon hd 7700","7700",0,[[1920,1080,60],[1920,1200,90]]],["radeon hd 7800","7800",0,[[1920,1080,60]]],["radeon hd 7900","7900",0,[[1920,1080,60],[1920,1200,60],[2560,1440,60]]],["radeon hd 8500","8500",0,[[1920,1080,42]]],["radeon hd 8790m","8790",0,[[1600,900,60]]],["radeon hd8800","8800",0,[[1920,1080,60]]],["radeon pro wx 5100 graphics (polaris10 / drm 3.27.0 / 4.19.4-1.el7.elrepo.x86_64, llvm 6.0","5100",0,[[1920,1080,60]]],["radeon pro wx3100","3100",0,[[2560,1440,1],[3840,2160,43]]],["radeon r5 340","5",0,[[1536,864,41]]],["radeon r5 m330","5",0,[[1366,768,38]]],["radeon r7 200","7",0,[[1280,1024,60],[2560,1440,52]]],["radeon r7 300","7",0,[[1920,1080,60]]],["radeon r7 m340","7",0,[[1920,1080,32]]],["radeon r7 m360","7",0,[[1920,1080,32]]],["radeon r9 200","9",0,[[1920,1080,60],[1920,1200,60],[2560,1440,1]]],["radeon r9 380","9",0,[[2560,1440,1]]],["radeon r9 390","9",0,[[1920,1080,60],[2560,1440,60]]],["radeon r9 fury","9",0,[[1920,1080,51],[1920,1920,60]]],["radeon rx","rx",0,[[1920,1200,60]]],["radeon rx 460","460",0,[[1920,1080,60],[1920,1200,60]]],["radeon rx 470","470",0,[[1280,768,60],[1680,1050,422],[1920,1080,60],[2560,1440,60]]],["radeon rx 480","480",0,[[1920,1080,60],[1920,1200,185],[2560,1440,1]]],["radeon rx 550","550",0,[[1600,900,60],[1680,1050,60],[1920,1080,1],[1920,1200,60],[2560,1080,60],[3840,2160,30]]],["radeon rx 5500 xt","5500",0,[[1920,1080,60],[1920,1200,60],[2560,1440,60],[3840,2160,19]]],["radeon rx 560","560",0,[[1600,900,60],[1920,1080,29],[1920,1200,47],[2688,1512,60],[3440,1440,60],[3840,2160,58]]],["radeon rx 5600 xt","5600",0,[[1920,1080,60]]],["radeon rx 570","570",0,[[1440,900,60],[1280,1024,60],[1920,1080,51],[1920,1200,60],[2560,1080,60],[2560,1440,37],[3440,1440,60]]],["radeon rx 5700 xt","5700",0,[[1707,960,60],[1920,1080,60],[2560,1440,55],[3840,2160,60]]],["radeon rx 580","580",0,[[1477,831,72],[1440,900,60],[1680,1050,60],[1920,1080,4],[1920,1200,60],[2560,1080,52],[2560,1440,60],[2560,1600,60],[3840,2160,1]]],["radeon rx 580 2048sp","580",0,[[1440,900,75]]],["radeon rx 590","590",0,[[1920,1080,60],[2560,1440,60],[3840,2160,30]]],["radeon rx vega","rx",0,[[1920,1080,60],[1920,1200,60],[2194,1234,60],[2560,1080,60],[2560,1440,60],[3440,1440,75],[3840,2160,60]]],["radeon rx vega 8","8",0,[[3840,2160,23]]],["radeon rx550","550",0,[[1680,1050,60],[1920,1080,60],[3440,1440,58]]],["radeon vega 8","8",0,[[1680,1050,60]]],["radeon vega frontier","",0,[[2560,1440,144]]],["radeon vii","vii",0,[[2560,1440,60],[3440,1440,60],[3840,2160,1]]],["radeong 0.4 on amd polaris10","0",0,[[3840,2160,109]]],["radeong 0.4 on amd tahiti","0",0,[[1920,1080,223]]],["ryzen embedded r1305g with radeon vega gfx","1305",0,[[3840,2160,14]]],["ryzen embedded v1605b with radeon vega gfx","1605",0,[[3840,2160,28]]]]')
                            },
                            921: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["adreno 506","506",0,[[1512,720,18,"motorola moto g(7) play"]]],["adreno 530","530",0,[[2560,1140,27,"samsung galaxy s7 (sm-930x)"],[2392,1440,28,"google pixel xl"]]],["adreno 615","615",0,[[2088,1080,20,"google pixel 3a"]]],["adreno 618","618",0,[[2210,1080,34,"xiaomi mi 9t"]]],["adreno 620","620",0,[[2340,1080,42,"google pixel 5"]]],["adreno 630","630",0,[[2280,1080,58,"oneplus a6003"]]],["adreno 640","640",0,[[2280,1080,60,"google pixel 4"]]],["qualcomm adreno 205","205",0,[[1280,720,11,"coolpad 8675-w00 (adreno 205)"]]],["qualcomm adreno 304","304",0,[[480,320,16,"zte z353vl cymbal t"],[480,480,6,"lg watch sport"],[758,480,8,"kyocera kyf33 torque x01 s-max"],[782,480,8,"vodafone vfd 510"],[791,480,8,"acer t012"],[792,480,6,"lg k4 2017 (m151, m160, m150 phoenix 3, m153 fortune, m154 risio 2, l58vl rebel 2)"],[800,480,7,"chainway c4050-q4"],[854,480,6,"zte q302c"],[897,540,6,"kyocera c6742 hydro view"],[960,540,6,"cat s40"],[1024,552,6,"tcl 9007 pixi 3 (7)"],[1184,720,4,"micromax q4251 canvas juice a1"],[1187,720,4,"lg phoenix 2 (k37x)"],[1193,720,4,"lg x power (k210, k450)"],[1196,720,4,"obi sj2.5"],[1217,720,4,"fibo la0920"],[1224,720,4,"umax visionbook p70 lte"],[1280,720,4,"k-touch beeline fast +"],[1280,736,4,"alcatel 9022x one touch pixi 3 8.0"],[1280,752,4,"lenovo tab 10 (x103f)"]]],["qualcomm adreno 305","305",0,[[432,320,18,"sonim xp6700"],[480,320,16,"lg t480s wine smart 3g"],[400,400,0,"huawei watch"],[734,480,7,"lg l fino (d290, d295)"],[737,480,7,"acer liquid z220"],[790,480,8,"htc desire 510 (adreno 305)"],[791,480,7,"sony xperia m (c19xx, c20xx)"],[800,480,5,"cherry mobile q510"],[854,480,6,"alcatel a564c one touch pop icon"],[886,540,7,"lg g2 mini (d610, d618, d620)"],[896,540,7,"htc desire 610"],[897,540,5,"motorola xt830c moto e"],[960,540,4,"huawei c8817l"],[1024,528,5,"aurora au701"],[1024,552,4,"asus zenfone go 6.9 (l001 zb690kg)"],[982,600,4,"huawei mediapad 7 youth 2"],[1024,600,7,"samsung galaxy tab 3 7.0 (sm-t215, sm-t217)"],[1024,720,4,"ereneben eben a2"],[1024,722,5,"prestigio pmt5287 multipad ranger 8.0 4g"],[1280,648,5,"tomtom bridge"],[1184,720,5,"htc desire 650 (d650)"],[1188,720,4,"lg aka (h778, h788, f520x)"],[1196,720,3,"zte z787"],[1200,720,4,"lg g vista (d631, vs880, gx2 f430)"],[1216,720,4,"vodafone smart 4 max"],[1217,720,4,"kyocera e6790 duraforce xd"],[1220,720,4,"huawei ascend mate 2 mt2-l03"],[1196,768,4,"infocus m2"],[1280,720,3,"zuum p47"],[1280,732,4,"lg g pad 7.0 (uk410, v410, vk410)"],[1280,736,4,"zte amazing p6"],[1280,737,4,"asus memo pad hd 7 (k00s me175kg)"],[1280,739,4,"lg g pad 8.0 (v480, v49x, p490, t01)"],[1280,740,4,"qualcomm msm8926 (adreno 305, development board)"],[1280,752,4,"asus padfone e (t008 a68m)"],[1216,800,3,"huawei mediapad t1 8.0 (adreno 305)"],[1280,800,3,"samsung tn10gedlte"],[1920,1080,2,"zte s2002 star 1"],[1920,1128,2,"lenovo b8080"]]],["qualcomm adreno 306","306",0,[[734,480,9,"lg f60 (d390, d392)"],[790,480,8,"htc desire 510 (adreno 306)"],[791,480,5,"lg l21g destiny"],[800,480,8,"covia fleaz cp-l42a pop"],[854,480,8,"freetel ft151a priori2 lte"],[897,540,7,"kyocera c6740 hydro wave"],[960,540,5,"blu studio mini lte 2"],[1024,552,6,"tcl 9006w"],[1024,600,5,"samsung sm-t116ir (adreno 306)"],[1024,720,5,"ereneben eben k8s"],[1024,768,5,"samsung sm-p350 galaxy tab a plus"],[1184,720,4,"lg x screen (k500, f650)"],[1188,720,4,"lg band play (f570s)"],[1196,720,4,"fly a5042"],[1199,720,4,"lg stylus 2 (f720, k520, k540, ls775 g stylo 2, l82vl)"],[1200,720,4,"lg g4 stylus (h63x, ms631, f560, ls770 g stylo)"],[1208,720,4,"vizio xr6m10 tablet remote"],[1217,720,4,"lenovo pb1-750x phab"],[1224,720,4,"c spire ft7"],[1280,720,3,"bgh joy smart axs ii"],[1280,736,4,"vodafone smart tab 4g"],[1280,752,4,"huawei mediapad t1 10 (t1-a21)"],[1216,800,4,"huawei mediapad t1 8.0 pro, lte (adreno 306)"],[1280,800,4,"samsung galaxy tab e 8.0 (adreno 306, sm-t377p)"],[1794,1080,2,"bluebird sf550"],[1815,1080,2,"vizio xr6"],[1920,1080,2,"longcheer cc01"]]],["qualcomm adreno 308","308",0,[[800,480,13,"samsung galaxy folder 2 (sm-g160x)"],[854,480,12,"coolpad 3632"],[960,540,10,"samsung sm-j250g"],[1184,720,5,"infocus 00ww"],[1187,720,6,"lg m200"],[1193,720,6,"lg k20 plus (mp260, k20 v vs501)"],[1195,720,6,"lg x charge (x power 2, m322, l63bl fiesta)"],[1199,720,6,"lg stylo 3 (l83bl)"],[1280,720,6,"hisense f23"],[1280,736,6,"lenovo tb-8504"],[1280,752,6,"lenovo tb-x304"],[1344,720,6,"wiko view"],[1223,800,6,"huawei mediapad t3 8.0 (kob-xxx)"],[1368,720,6,"casper via g1"],[1280,800,6,"samsung galaxy tab a2 s (sm-t380, sm-t385)"]]],["qualcomm adreno 320","320",0,[[1196,720,11,"pantech im-a850 vega r3"],[1196,768,10,"google nexus 4 (lg e960)"],[1280,720,8,"blackberry z30"],[1280,752,8,"asus memo pad 10 (k01e me103k)"],[1280,768,10,"lg optimus g (e97x, ls970, e987, f180, kddi lgl21)"],[1920,1008,5,"technicolor px36"],[1794,1080,5,"sony xperia z (c66xx, so-02e, l36x)"],[1848,1080,5,"pantech im-a860 vega n6"],[1920,1080,5,"zte nubia z5 (nx501, nx50x)"],[1920,1104,5,"google nexus 7 (2nd gen, razor)"],[1920,1114,4,"lg g pad 8.3 (vk810 4g)"],[1920,1128,5,"sony xperia tablet z (sgp3xx, so-03e)"]]],["qualcomm adreno 330","330",0,[[800,480,18,"samsung sm-w2014"],[1184,720,27,"sony so-04g xperia a4"],[1196,720,21,"sony xperia j1 compact (d5788)"],[1202,720,21,"lg g flex (d95x, ls995, lgl23, f340)"],[1280,720,20,"amazon fire phone (sd4930ur)"],[1280,768,21,"samsung sm-w2015 galaxy golden 2"],[1280,960,14,"lg f300 optimus vu 3"],[1600,1152,15,"hp pro slate 12"],[1440,1308,10,"blackberry passport"],[1776,1080,11,"google nexus 5"],[1788,1080,11,"lg g3 a f410"],[1794,1080,10,"fujitsu f-01f arrows nx luge (docomo)"],[1803,1080,11,"lg g pro 2 (d838, f350)"],[1836,1080,11,"sony xperia z ultra (c68xx, xl39h, sol24, sgp412)"],[1920,1080,9,"qualcomm quanta is7"],[1920,1104,12,"ntt docomo sh-06f sharp aquos pad"],[1920,1128,12,"sony xperia z2 tablet (sgp5xx, so-05f, sot21)"],[1920,1129,10,"lg g pad ii (v935, v940 prada 3.0, v930 g pad x 10.1, uk932)"],[1920,1200,9,"amazon kindle fire hdx 7 (3rd gen, kfthwa, kfthwi)"],[2048,1440,8,"hp red"],[2392,1440,8,"fujitsu f-02g arrows nx (docomo)"],[2400,1440,6,"iuni u3"],[2560,1440,7,"vivo x520l xplay 3s"],[2560,1504,7,"ntt docomo f-03g (fujitsu arrows tab)"],[2560,1600,5,"samsung sm-t525 galaxy tab pro 10.1"]]],["qualcomm adreno 405","405",0,[[1184,720,13,"lyf ls-5015 water 8"],[1196,720,10,"alcatel 6044 one touch pop up"],[1200,720,12,"oppo a53"],[1280,720,8,"hisense c1"],[1280,736,10,"asus zenpad 8 (adreno 405, p024 z380kl)"],[1776,1080,7,"lyf ls-5505"],[1794,1080,6,"medion life x5020"],[1798,1080,7,"lg h740 g vista 2"],[1800,1080,6,"oppo r7s plus"],[1803,1080,6,"oppo r7 plus (adreno 405)"],[1812,1080,6,"ramos mos1"],[1824,1080,6,"vargo ivargo v210101"],[1836,1080,6,"lenovo pb1-770m everypad3"],[1920,1080,2,"smartisan yq607 jianguo"],[1920,1104,5,"lg vk815 g pad x8.3, p815l g pad ii 8.3"],[1920,1111,6,"lg g pad x 8.0 (v52x)"],[1794,1200,5,"qisda f80"],[1920,1128,5,"huawei mediapad t2 10.0 pro (fdr-xxx)"],[1830,1200,6,"huawei mediapad x3 (ple-xxx)"],[1836,1200,6,"huawei mediapad t2 8.0 pro (jdn-xxx)"]]],["qualcomm adreno 418","418",0,[[1280,768,28,"samsung sm-g9198"],[1776,1080,17,"sharp sh-m03 aquos mini"],[1794,1080,15,"softbank 502sh (sharp aquos xx2)"],[1920,1080,11,"smartisan t2 (sm801)"],[2368,1440,10,"fujitsu f-02h arrows nx (docomo)"],[2392,1440,10,"lg k600"],[2413,1440,10,"motorola moto x style, pure (xt1570, xt1572, xt1575)"],[2560,1440,9,"qiku q terra (8692-a00)"],[2560,1504,9,"ntt docomo f-04h arrows tab"]]],["qualcomm adreno 420","420",0,[[1280,720,32,"odg r7-w"],[1920,1080,20,"samsung galaxy s5 (adreno 420, sm-g901)"],[2392,1440,13,"lg g3 (adreno 420, f460)"],[2560,1352,7,"qualcomm apq8084 (adreno 420, development board)"],[2413,1440,12,"motorola moto x pro"],[2560,1440,8,"qualcomm liquid (adreno 420, windows, development board)"],[2560,1532,12,"samsung galaxy note edge (adreno 420, sm-n915x, scl24, sc-01g)"],[2560,1600,11,"amazon kindle fire hdx 8.9 (4th gen, kfsawa, kfsawi)"]]],["qualcomm adreno 430","430",0,[[1184,720,53,"sony xperia z5 compact (e58xx, so-02h)"],[1280,720,18,"zebra technologies mtp8994"],[1776,1080,29,"sony xperia z5 (e66xx, so-01h, sov32, 501so)"],[1794,1080,19,"vertu signature touch (2015)"],[1920,1080,9,"nokia rm-1106"],[1920,1104,21,"ntt docomo sh-05g sharp aquos pad"],[2392,1440,11,"sony e6508 vzw xperia z4v"],[2413,1440,17,"sirin labs solarin"],[2560,1440,7,"microsoft rm-1105"],[2560,1504,16,"sony xperia z4 tablet (sgp7xx, so-05g, sot31)"]]],["qualcomm adreno 505","505",0,[[728,480,29,"zebra technologies tc25"],[1184,720,15,"ivvi i3-01"],[1196,720,15,"huawei honor 6c (dig-xxx)"],[1199,720,14,"lg stylus 2 plus (ms550, k550)"],[1280,720,14,"xiaomi land"],[1344,720,14,"wiko view prime"],[1368,720,13,"micromax hs3"],[1776,1080,7,"hisense a2"],[1787,1080,7,"lg qua phone px (lgv33)"],[1794,1080,7,"pantech im-100 vega"],[1798,1080,8,"lg stylo 3 plus (tp450, mp450, m470)"],[1802,1080,7,"lg k11 (k530, k535)"],[1812,1080,7,"sugar f11"],[1920,1080,6,"lg x venture (h700, m710)"],[1920,1111,6,"lg g pad x ii 8.0 plus (v530)"],[2004,1080,7,"lg q6 (m700, x600)"],[1920,1128,7,"vodafone vfd 1400"],[1920,1132,7,"huawei mediapad t3 lite 10 (bah-xxx)"],[1839,1200,7,"huawei mediapad m3 lite 8.0 (cpn-xxx)"]]],["qualcomm adreno 506","506",0,[[1184,720,20,"fujitsu f-04j docomo"],[1280,720,20,"samsung galaxy j7 2017 (adreno 506, sm-j727x)"],[1320,720,18,"xiaomi redmi 5"],[1356,720,18,"vivo v7 plus (1716)"],[1620,1080,11,"blackberry bbb100-x (keyone, mercury)"],[1776,1080,10,"condor plume h1"],[1788,1080,10,"huawei nova (caz-xxx)"],[1794,1080,10,"nuans neo reloaded"],[1920,1080,9,"blackberry bbd100"],[1920,1104,9,"nec lavietab pc-ts508fam"],[1980,1080,10,"xiaomi redmi 5 plus"],[1920,1128,9,"zte k92 primetime"],[1920,1132,9,"vestel v tab 1090 lte"],[1920,1200,9,"i.safe is910.1"]]],["qualcomm adreno 508","508",0,[[1776,1080,15,"sonim xp8812"],[1798,1080,15,"sharp fs8010"],[1920,1080,14,"htc u11 life"],[2009,1080,14,"vestel venus z20"]]],["qualcomm adreno 509","509",0,[[2159,1080,15,"asus zenfone 5"]]],["qualcomm adreno 510","510",0,[[1184,720,31,"zebra technologies tc51"],[1208,800,27,"askey turbonet tn800a1 turbotab e1"],[1366,720,29,"sony xperia touch (g1109)"],[1776,1080,13,"agm x2"],[1794,1080,14,"qualcomm msm8952 (adreno 510, development board)"],[1920,1080,14,"coolpad r116 cool1"],[2048,1440,11,"asus zenpad 3 8.0 (p008 z581kl)"],[2160,1440,10,"jide remix pro"],[2048,1536,11,"asus zenpad z10 (p00i zt500kl)"],[2368,1440,10,"vodafone vfd 900"],[2392,1440,10,"sharp aquos z3 (fs8009)"],[2413,1440,9,"infocus m820"],[2560,1440,9,"vivo pd1522a"],[2560,1504,9,"lenovo yoga tab3 plus (yt-x703)"]]],["qualcomm adreno 512","512",0,[[782,480,59,"honeywell cn80"],[1798,1080,23,"sharp fs8016"],[1920,1080,22,"vivo td1608"],[2016,1080,22,"oppo r11s"],[2034,1080,22,"vivo x20a"],[2151,1080,20,"xiaomi redmi note 7"]]],["qualcomm adreno 530","530",0,[[1600,900,56,"keecker keecker"],[1776,1080,43,"softbank 506sh (sharp aquos phone xx3)"],[1794,1080,49,"google pixel"],[1920,1024,47,"contextmedia p-wal-107-elc-03"],[1920,1080,26,"nokia 6071w"],[2048,1536,35,"samsung galaxy tab s3 (sm-t82x)"],[2368,1440,27,"motorola xt1650 (1.8 ghz)"],[2392,1440,21,"lg q8 (h970, x800l)"],[2416,1440,31,"alcatel 6076s"],[2560,1439,17,"hp elite x3"],[2560,1440,4,"hp falcon"],[2672,1440,30,"lg g6 (g600, us997, ls993, vs988, h87x)"],[2880,1440,26,"baofeng ke-01"],[3840,2076,15,"via vt6093"]]],["qualcomm adreno 540","540",0,[[1184,720,61,"sony xperia xz1 compact (g8441)"],[1776,1080,57,"sony xperia xz1 (g834x, sov36, so-01k, 701so)"],[1794,1080,57,"google pixel 2 (walleye)"],[1920,1080,56,"zte nx595j nubia"],[1980,1080,56,"xiaomi mi mix 2"],[2034,1080,55,"oneplus 5t (a5010)"],[2276,1312,43,"essential ph-1"],[2368,1440,39,"sharp aquos r (sh-03j, shv39, 605sh)"],[2392,1440,41,"qualcomm adreno 540 (development board)"],[2416,1440,40,"razer phone"],[2560,1440,36,"htc u11 (u-3x, 2pzc100, 2pzc5, htv33, 601ht)"],[2678,1440,35,"samsung galaxy s8 active (sm-g892)"],[2768,1440,33,"samsung galaxy s8+ (adreno 540, sm-g955x, sc-03j, scv35)"],[2960,1440,33,"samsung galaxy note 8 (adreno 540, sm-n950, sc-01k, scv37)"]]],["qualcomm adreno 615","615",0,[[2560,1492,18,"samsung galaxy tab s5e sm-t720"]]],["qualcomm adreno 616","616",0,[[2047,1080,30,"meizu x8"]]],["qualcomm adreno 618","618",0,[[2183,1080,38,"samsung galaxy a71 (sm-a715f)"],[2274,1080,37,"samsung galaxy a80 sm-a805f"]]],["qualcomm adreno 630","630",0,[[2792,1440,49,"samsung galaxy s9+ (adreno 630, sm-g965)"]]],["qualcomm adreno 640","640",0,[[2020,1080,60,"samsung galaxy s10e (adreno 640, sm-g970x)"],[2064,1080,60,"samsung galaxy note 10 (adreno 640, sm-n970x)"],[2181,1080,60,"samsung galaxy s10 lite"],[2198,1080,60,"samsung galaxy a90 5g"],[2210,1080,79,"xiaomi redmi k20 pro premium edition"],[2048,1410,59,"samsung galaxy fold 5g (adreno 640, sm-f900x)"],[2723,1440,55,"samsung galaxy s10 (adreno 640, sm-g973x)"],[2730,1440,56,"samsung galaxy s10+ (adreno 640, sm-g975x)"],[2759,1440,56,"samsung galaxy note 10+ (adreno 640, sm-n975x)"],[2901,1440,55,"samsung galaxy s10 5g (adreno 640, sm-g977x)"]]],["qualcomm adreno 650","650",0,[[2274,1080,90,"asus zenfone 7"],[3101,1387,50,"samsung galaxy s20 ultra 5g (sm-g988u1)"]]]]')
                            },
                            535: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["apple a10 gpu","10",0,[[2048,1536,41,"apple ipad (6th gen)"],[2160,1620,36,"apple ipad (10.2-inch) (7th generation)"]]],["apple a10x gpu","10",0,[[2048,1536,59,"apple ipad pro (10.5-inch)"],[2224,1668,69,"apple ipad pro (10.5-inch)"],[2732,2048,46,"apple ipad pro (12.9-inch, 2nd gen)"]]],["apple a12 gpu","12",0,[[2048,1536,60,"apple ipad mini (2019)"]]],["apple a12x gpu","12",0,[[2224,1668,116,"apple ipad pro (11-inch)"],[2388,1668,115,"apple ipad pro (11-inch)"],[2732,2048,60,"apple ipad pro (12.9-inch) (3rd generation)"]]],["apple a12z gpu","12",0,[[2388,1668,115,"apple ipad pro (11-inch) (2nd generation)"],[2732,2048,60,"apple ipad pro (12.9 inch) (4th generation)"]]],["apple a13 gpu","13",0,[[2160,1620,59,"apple ipad 9th gen"]]],["apple a14 gpu","14",0,[[2388,1668,52,"apple ipad air 4th gen (wi-fi only)"]]],["apple a15 gpu","15",0,[[2388,1668,60,"apple ipad mini (6th gen)"]]],["apple a7 gpu","7",0,[[2048,1536,10,"apple ipad mini 3"]]],["apple a8 gpu","8",0,[[2048,1536,16,"apple ipad mini 4"]]],["apple a8x gpu","8",0,[[2048,1536,30,"apple ipad air 2"]]],["apple a9 gpu","9",0,[[2048,1536,29,"apple ipad 9.7 (5th gen)"]]],["apple a9x gpu","9",0,[[2048,1536,40,"apple ipad pro 9.7"],[2732,2048,35,"apple ipad pro"]]],["apple m1 gpu","1",0,[[2732,2048,60,"apple ipad pro (12.9-inch) (5th generation)"]]]]')
                            },
                            438: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["apple a10 gpu","10",0,[[1334,750,104,"apple iphone 7"],[1920,1080,60,"apple iphone 7 plus"],[2001,1125,59,"apple iphone x"]]],["apple a11 gpu","11",0,[[1334,750,64,"apple iphone 8"],[1920,1080,78,"apple iphone 8 plus"]]],["apple a12 gpu","12",0,[[1792,828,60,"apple iphone xr"],[2436,1125,57,"apple iphone xs"],[2208,1242,60,"apple iphone xs max"]]],["apple a13 gpu","13",0,[[1334,750,60,"apple iphone se (2nd gen)"],[1792,828,61,"apple iphone 11"],[2436,1125,60,"apple iphone 11 pro"],[2688,1242,61,"apple iphone 11 pro max"]]],["apple a14 gpu","14",0,[[2338,1080,60,"apple iphone 12 mini"],[2436,1125,60,"apple iphone 12"],[2778,1284,60,"apple iphone 12 pro max"]]],["apple a15 gpu","15",0,[[2338,1080,60,"apple iphone 13 mini"],[2436,1125,60,"apple iphone 13 pro"],[2688,1242,60,"apple iphone 13 pro max"]]],["apple a7 gpu","7",0,[[1136,640,32,"apple iphone 5s"]]],["apple a8 gpu","8",0,[[1136,640,40,"apple ipod touch 6"],[1334,750,36,"apple iphone 6"],[1920,1080,21,"apple iphone 6 plus"]]],["apple a9 gpu","9",0,[[1136,640,90,"apple iphone se"],[1334,750,72,"apple iphone 6s"],[1920,1080,42,"apple iphone 6s plus"]]]]')
                            },
                            283: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["intel intel hd graphics for atom x5","5",0,[[1024,600,35,"amazon aeokn"],[1024,720,13,"arbor venus 8"],[1217,720,23,"gole gole1"],[1280,736,27,"medion p850x"],[1360,704,15,"chuwi hibox hero mini pc"],[1280,752,21,"tetratab casebook 3"],[1280,759,28,"lenovo yoga a12 (yb-q501f)"],[1366,720,19,"nextbook nx16a11264 ares 11 (x5-z8300)"],[1920,996,20,"teclast x16 pro"],[1920,1008,12,"teclast tbook 16 pro"],[1920,1016,13,"teclast x16 plus"],[1920,1104,13,"medion p851x"],[1920,1116,13,"teclast x80 pro (x5-z8350)"],[1920,1128,8,"cube technology i12-y"],[1920,1133,9,"cube technology i1-tfp (x5-z8350)"],[1920,1134,11,"microtech e-tab pro lte"],[1920,1136,14,"cube technology iwork 10 ultimate (i15-t)"],[1920,1214,10,"chuwi cw-hi10 plus (x5-z8350)"],[2048,1440,8,"teclast x98 plus"],[2160,1368,10,"chuwi hi12 (x5-z8350)"],[2048,1452,10,"teclast x98 plus ii"],[2048,1536,14,"xiaomi mi pad 2"],[2560,1356,7,"baofeng a1"],[2560,1504,6,"chuwi hibook pro (z8350)"],[2560,1518,11,"lenovo yt3-x90 yoga tablet 3 pro (x5-z8550)"]]],["intel intel hd graphics for baytrail","hdfor",0,[[1024,552,13,"multilaser intel 7qc"],[1024,696,17,"thundersoft dual os tablet"],[1024,720,15,"airis onepad 785i"],[1184,720,18,"trimble tdc500"],[1280,736,12,"acer a1-840"],[1280,752,9,"imuz mupad win 10.1 ii"],[1366,720,13,"nextbook nxa116qc164"],[1366,724,10,"cube technology i10 remix"],[1440,1008,12,"teclast x89 kindow"],[1920,1008,8,"minix neo z64"],[1920,1014,9,"cube technology i7 cx remix"],[1920,1032,11,"hp slate 17"],[1920,1104,5,"jltd d630"],[1920,1128,6,"intel(r) e1008"],[1920,1133,9,"pipo w3f"],[2048,1440,6,"kruger & matz eagle 975 (km0975)"],[2048,1448,6,"jide e-tab 3g"],[2048,1464,6,"reeder a10ix air"],[2560,1344,7,"lenovo yoga tablet 2 pro-1380"],[2560,1504,5,"teclast x10hd 3g"]]],["intel mesa dri intel bay trail","dribay",0,[[1366,768,15,"google chromebook pixel (2015, n2830)"]]],["intel mesa dri intel hd","drihd",0,[[688,412,39,"hp chromebook x360 11 g1 ee"],[960,568,36,"google chromebook pixel (2015, n3450)"],[1024,561,28,"aaeon up-cht01 up board"],[1024,736,33,"google chromebook reef (n3350)"]]],["intel mesa dri intel hd graphics 400","400",0,[[688,412,41,"asus c202sa chromebook"],[768,431,45,"hp chromebook 11 g5"],[960,568,25,"acer chromebook r11 (n3050)"],[1366,768,19,"samsung chromebook 3"],[1536,832,25,"google chromebook r11 (n3160)"],[1920,1080,17,"acer chromebook 14"]]],["intel mesa dri intel hd graphics 510","510",0,[[690,378,53,"hp chromebook chell"],[688,412,60,"acer chromebook 14 for work"]]],["intel mesa dri intel hd graphics 515","515",0,[[1033,617,56,"samsung chromebook pro (m7-6y75, caroline)"],[1536,1088,32,"google chromebook pixel (2015, m3-6y30)"],[1920,980,32,"asus c302 chromebook flip"],[2400,1504,22,"samsung chromebook pro (caroline)"],[3200,1640,12,"google chromebook pixel (2015, 4405y)"]]],["intel mesa dri intel hd graphics 520","520",0,[[700,412,60,"acer chromebook 14 for work (i3-6100u)"]]],["intel mesa dri intel hd graphics 5500","5500",0,[[1080,575,59,"google chromebook pixel (2015, i3-5005u)"],[1920,1000,30,"google chromebook pixel (2015, i5-5300u)"],[2560,1700,14,"google chromebook pixel (2015, i5-5200u)"]]],["intel mesa dri intel hd graphics 615","615",0,[[1034,618,55,"google soraka (4415y)"],[1200,720,34,"google poppy (4410y, kabylake)"],[2400,1504,21,"google chromebook eve (i5-7y54)"]]],["intel mesa dri intel kabylake gt2","2",0,[[960,568,38,"google chromebook pixel (2015, m3-7y30)"]]]]')
                            },
                            327: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["arm mali-t604 mp4","604",0,[[2560,1504,4,"google nexus 10"]]],["arm mali-t622","622",0,[[1024,564,12,"telechips tcc896x (quad core, development board)"],[1280,720,7,"leadcore l1860 (mali-t622, development board)"]]],["arm mali-t624","624",0,[[1794,1080,7,"huawei grace"],[1812,1080,6,"huawei abc-ul00"],[1830,1080,10,"huawei p8 max (dav-70x)"],[1920,1080,4,"sony amai vp9"],[1920,1104,9,"huawei dtab compact d-02h (docomo)"],[1920,1128,8,"huawei dtab d-01h (docomo)"],[1824,1200,9,"huawei mediapad m2 (m2-80xx)"],[1830,1200,9,"huawei mediapad x2 (gem-701l, gem-702l, gem-703l)"]]],["arm mali-t624 mp2","624",0,[[1280,720,5,"samsung sm-g910f (mali-t624)"]]],["arm mali-t624 mp4","624",0,[[1794,1080,9,"huawei z100"]]],["arm mali-t628","628",0,[[1024,600,30,"thinkware inavi davinci"],[2560,1536,8,"meizu mx4 pro"]]],["arm mali-t628 mp2","628",0,[[1280,720,8,"leadcore l1860 (development board)"]]],["arm mali-t628 mp6","628",0,[[800,480,35,"gen2wave rp1600"],[1280,672,14,"hardkernel odroid-xu3 (development board)"],[1280,720,26,"samsung galaxy alpha (mali-t628, sm-g850)"],[1920,1080,11,"samsung galaxy note iii (mali-t628, sm-n900, sm-n9000q)"],[2560,1600,3,"samsung sm-t520 galaxy tab 10.1"]]],["arm mali-t720","720",0,[[432,240,16,"unihertz jelly pro"],[782,480,8,"mobiistar lai zoro"],[784,480,8,"lg k3 (k100)"],[791,480,6,"i-mobile i-style 812 4g"],[800,480,4,"lava iris 550"],[854,480,3,"verykool sl5009 jet"],[897,540,5,"bluboo xfire"],[960,540,3,"siswoo a5 chocolate"],[1024,552,4,"bb-mobile tq763i techno 7.0 lte"],[1024,714,9,"bluedot bnt-791 (2g)"],[1024,720,3,"zte e8qp"],[1280,624,10,"panasonic p55 novo 4g"],[1280,648,4,"tcl 9025"],[1280,656,7,"acer a1-734 iconia talk s"],[1184,720,4,"lenovo xt1700, xt1706, k10a40"],[1187,720,7,"lg k8 (k350)"],[1189,720,5,"ark impulse p2"],[1193,720,7,"lg x power (k220, f750)"],[1196,720,2,"dtac phone m2"],[1198,720,5,"dtac phone t3"],[1205,720,7,"firefly aurii passion"],[1206,720,4,"archos 50 power"],[1208,720,3,"advan i7 plus"],[1217,720,7,"energy sistem energy phone max 2+"],[1238,720,9,"vnpt technology vivas lotus s3 lte"],[1280,720,2,"archos bush spira c2 5"],[1280,736,2,"digma cs1062ml citi 1903 4g"],[1280,737,3,"waywalkers t805g"],[1280,740,3,"casper via l8"],[1280,746,3,"philips tle821l e line 4g"],[1280,752,3,"4good light at200"],[1280,755,7,"leotec letab1020 supernova qi32"],[1356,720,8,"xiaolajiao la-v11"],[1360,720,7,"tecno in5"],[1368,720,7,"tinno p100"],[1280,800,4,"samsung galaxy tab e 8.0 (sm-t375x, sm-t377x)"],[1920,936,4,"panasonic eluga note"],[1920,996,4,"cube technology u83 iplay10"],[1776,1080,4,"fly fs522 cirrus 14"],[1787,1080,5,"lg x cam (k580, f690)"],[1920,1008,6,"alcatel one touch xess (p17aa)"],[1794,1080,3,"ramos mos 1 max"],[1800,1080,4,"archos sense 55 s"],[1815,1080,4,"archos diamond plus"],[1920,1032,5,"virgin media tellytablet"],[1920,1080,2,"infocus m640"],[1920,1104,4,"vestel v tab 7030"],[1920,1116,4,"jty q101"],[1920,1128,2,"archos 80 oxygen"],[2009,1080,4,"tcl 5099"],[1920,1136,4,"asus zenpad 10 (p028 z301m)"]]],["arm mali-t760","760",0,[[854,480,14,"aux t6200l"],[897,540,13,"sony xperia e4g (e20xx)"],[960,540,12,"gionee v381"],[960,568,24,"asus c100pa chromebook flip"],[1024,552,12,"archos 70 helium"],[1024,720,10,"wiz t-8168"],[1188,720,9,"lg h520 magna, h522 prime plus"],[1196,720,9,"acer s57 liquid jade z"],[1280,720,8,"dunetek vitamin a"],[1280,736,8,"archos 80b helium"],[1280,752,8,"frael m10g 4g"],[1280,768,8,"meizu m1"],[1794,1080,6,"sugar 2 ss136 l8560"],[1920,1032,9,"qbic bxp-300 box pc"],[1920,1080,4,"byxpress mphone xone"],[1920,1104,6,"cube technology t7"],[1920,1128,5,"nec lavietab pc-te510bal"],[2048,1440,3,"teclast p98 4g"],[2560,1440,10,"samsung galaxy note 4 (mali-t760, sm-n910x, sm-n916)"]]],["arm mali-t760 mp6","760",0,[[1920,1080,17,"samsung galaxy a8 (mali-t760, sm-a800x, scv32)"],[2048,1536,12,"samsung galaxy tab s 2 8.0 (sm-t710, sm-t715)"],[2560,1532,10,"samsung galaxy note edge (mali-t760, sm-n915x)"],[2560,1600,10,"samsung galaxy tab s 10.5 (mali-t760, sm-t805s)"]]],["arm mali-t760 mp8","760",0,[[1280,768,42,"samsung sm-w2016"],[1920,1080,25,"meizu niux"],[2160,1200,17,"idealens k2"],[2560,1440,12,"le xiang deepoon m2 vr"],[2560,1504,15,"bungbungame kalos 2"]]],["arm mali-t764","764",0,[[1024,600,19,"gpd q9"],[1280,720,15,"gpd xd"],[1280,752,13,"kruger & matz 1064.1g eagle"],[1280,800,13,"pipo p7"],[1920,1008,6,"rockchip mk809 4k tv stick"],[1920,1010,8,"pipo p7 hd"],[1920,1020,5,"rockchip mk903v mini tv"],[1920,1032,7,"acooo oneboard pro+"],[1872,1080,7,"contextmedia wallboard 32 tablet (p-wal-106-yit-01)"],[1920,1080,7,"rockchip cs4k tv box"],[1920,1128,7,"archos 101 oxygen"],[2048,1437,5,"haier pad 971"],[2048,1440,5,"hisense f5281 vidaa pad"],[2560,1504,4,"teclast p90hd"]]],["arm mali-t820","820",0,[[1344,720,5,"lenovo k320t"],[1776,1080,6,"leagoo t5c"],[1920,1008,7,"probox2 ava tv box"],[1920,1080,4,"skyworth coocaa 5s32 n2"]]],["arm mali-t830","830",0,[[1280,720,9,"samsung galaxy on7 (mali-t830, sm-g600x)"],[1280,800,9,"samsung sm-t536 (mali-t830)"],[1776,1080,9,"huawei p10 lite (was-xxx)"],[1794,1080,9,"huawei honor 6x (bln-xxx)"],[1920,1080,5,"samsung galaxy on7 prime 2018 (sm-g611)"],[2033,1080,8,"huawei p smart (fig-xxx)"],[2040,1080,9,"huawei maimang 6 (rne-xxx)"],[1920,1200,5,"samsung galaxy tab a 10.1 (sm-t580, sm-t585)"]]],["arm mali-t860","860",0,[[1184,720,8,"tcl a626"],[1196,720,8,"green orange go t2"],[1280,720,14,"htc one a9s"],[1920,1024,17,"hardkernel odroid-n1 (development board)"],[1920,1032,16,"contextmedia p-wal-108-elc-02"],[1920,1080,7,"htc u play (u-2u)"],[1920,1116,15,"imuz revolution a8"],[1920,1128,15,"rockchip rk3399 (development board)"],[2400,1440,10,"samsung chromebook plus (kevin)"]]],["arm mali-t860 mp2","860",0,[[598,480,25,"cipherlab 9700a"],[1184,720,11,"vernee m5"],[1193,720,11,"lg x power 2 (u+, x500, m-x320, m320)"],[1196,720,11,"lava z25"],[1199,720,11,"lg stylus 3 (m400)"],[1212,720,11,"meeg 306"],[1280,720,10,"oppo r66"],[1336,720,13,"asus pegasus 4s (x018d zb570tl)"],[1344,720,13,"allview x4 soul infinity n"],[1776,1080,7,"benq f55"],[1794,1080,6,"alcatel 7070"],[1798,1080,7,"energy sistem energy phone pro 3"],[1806,1080,8,"tecno phantom 6"],[1807,1080,7,"covia fleaz cp-j55a g07"],[1810,1080,8,"archos 55 diamond 2 plus"],[1920,1080,4,"advan vandroid i55c"],[2004,1080,7,"asus zenfone max plus m1 (x018d zb570tl)"],[1920,1128,7,"verizon qtaxia1"]]],["arm mali-t880","880",0,[[1184,720,22,"doogee mix"],[1280,720,20,"lenovo k8"],[1344,720,18,"casper via f2"],[1776,1080,11,"alcatel 6060 (mali-t880)"],[1794,1080,20,"huawei mate 8 (nxt-xxx)"],[1824,1080,11,"meiigoo m1"],[1920,1080,10,"letv leeco lex650"],[2016,1080,9,"vernee mix 2"],[2064,1080,10,"umi s2 pro"],[2392,1440,12,"huawei honor v8 (knt-al20)"],[2434,1440,11,"huawei honor note 8 premium edition (edi-al10)"],[2560,1440,24,"meizu pro 6 plus"],[2560,1480,10,"huawei dtab compact d-01j (docomo)"],[2560,1600,10,"huawei mediapad m3 (btv-xxx)"]]],["arm mali-t880 mp12","880",0,[[1920,1080,44,"samsung galaxy s7 (sm-g930f)"],[2560,1440,27,"samsung galaxy note 7 (mali-t880, sm-n930)"]]],["arm mali-t880 mp2","880",0,[[1184,720,19,"sony pikachu"],[1376,720,17,"umi s2"],[1776,1080,10,"coolpad a9s-9"],[1800,1080,11,"infinix x603"],[1920,1080,9,"innjoo pro2"]]],["arm mali-t880 mp4","880",0,[[1280,672,18,"mediatek x20 (development board)"],[1794,1080,13,"infocus tsp"],[1800,1080,16,"infinix x602 zero 4 plus"],[1806,1080,16,"tecno phantom a9"],[1810,1080,8,"mobiistar prime x pro"],[1815,1080,16,"tecno phantom 6 plus"],[1920,1080,7,"elephone r9"],[2048,1440,12,"brown tab 1"],[2392,1440,12,"vernee apollo"],[2416,1440,11,"freetel ftj162b kiwami2"],[2560,1440,10,"ivvi i5"]]],["mali-t830","830",0,[[1480,720,10,"samsung gm-j600fn"]]]]')
                            },
                            538: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["arm mali-g31","31",0,[[1920,1080,7,"mecool km9 pro"]]],["arm mali-g51","51",0,[[1920,636,10,"telechips tcc803x_lcn"],[1920,1080,5,"skyworth 8n10 g1a"]]],["arm mali-g52 mc1","52",0,[[1280,736,25,"amazon fire hd 8 (kfonwi, 2020)"]]],["arm mali-g52 mc2","52",0,[[2110,1080,23,"xiaomi redmi 10x 4g"],[2264,1080,20,"xiaomi redmi 9 m2004j19c"],[2400,1080,20,"huawei y9a frl-l22"]]],["arm mali-g57 mc3","57",0,[[2158,1080,48,"realme rmx2173"]]],["arm mali-g71","71",0,[[1280,720,14,"samsung sm-j337"],[1812,1080,53,"huawei mate 9 (mha-xxx)"],[1920,1080,12,"sony amai vp9 (mali-g71)"],[2009,1080,11,"tcl 6062"],[2016,1080,11,"gionee s11"],[2038,1080,10,"ulefone power 3"],[2076,1080,15,"samsung galaxy a8 2018 (sm-a530x)"],[2094,1080,15,"samsung sm-a730x"],[2160,1080,9,"oukitel k6"],[2368,1440,35,"huawei honor v9 (duk-xxx)"],[2560,1440,32,"huawei mate 9 pro (lon-xxx)"],[2678,1440,41,"samsung galaxy s8 (mali-g71, sm-g950x)"],[2960,1440,39,"samsung galaxy s8+ (mali-g71, sm-g955x)"]]],["arm mali-g72","72",0,[[2041,1080,55,"huawei mate 10 pro (bla-xxx)"],[2160,1080,56,"huawei honor view 10 (v10, bkl-xxx)"],[2560,1440,43,"huawei mate 10 (alp-xxx)"],[2768,1440,47,"samsung galaxy s9 (mali-g72, sm-g960)"],[2792,1440,47,"samsung galaxy s9+ (mali-g72, sm-g965)"]]],["arm mali-g76","76",0,[[2020,1080,60,"samsung galaxy s10e (mali-g76, sm-g970x)"],[2029,1080,31,"samsung galaxy s10 plus sm-g975n"],[2064,1080,60,"samsung galaxy note 10 5g (mali-g76, sm-n971x)"],[2159,1080,47,"samsung galaxy a51 5g"],[2232,1080,59,"huawei honor 20 pro yal-l41"],[2328,1128,60,"huawei mate 30 pro (lio-lx9, lio-xl00"],[2723,1440,57,"samsung galaxy s10 (mali-g76, sm-g973x)"],[2730,1440,56,"samsung galaxy s10+ (mali-g76, sm-g975x)"],[2733,1440,56,"samsung galaxy s10 5g (mali-g76, sm-g977x)"],[2759,1440,57,"samsung galaxy note 10+ (mali-g76, sm-n975x)"]]],["arm mali-g77","77",0,[[2178,1080,60,"samsung galaxy s20 5g (sm-g981b)"],[2200,1080,67,"samsung galaxy s20 ultra 5g (sm-g988b)"],[2304,1080,55,"oppo pdcm00"]]],["arm mali-g77 mc9","77",0,[[2293,1080,59,"oppo pdsm00"]]],["arm mali-g78","78",0,[[2646,1288,90,"huawei mate 40 pro 5g"]]],["arm mali-t604 mp4","604",0,[[2560,1504,4,"google nexus 10"]]],["arm mali-t622","622",0,[[1024,564,12,"telechips tcc896x (quad core, development board)"],[1280,720,7,"leadcore l1860 (mali-t622, development board)"]]],["arm mali-t624","624",0,[[1794,1080,7,"huawei grace"],[1812,1080,6,"huawei abc-ul00"],[1830,1080,10,"huawei p8 max (dav-70x)"],[1920,1080,4,"sony amai vp9"],[1920,1104,9,"huawei dtab compact d-02h (docomo)"],[1920,1128,8,"huawei dtab d-01h (docomo)"],[1824,1200,9,"huawei mediapad m2 (m2-80xx)"],[1830,1200,9,"huawei mediapad x2 (gem-701l, gem-702l, gem-703l)"]]],["arm mali-t624 mp2","624",0,[[1280,720,5,"samsung sm-g910f (mali-t624)"]]],["arm mali-t624 mp4","624",0,[[1794,1080,9,"huawei z100"]]],["arm mali-t628","628",0,[[1024,600,30,"thinkware inavi davinci"],[2560,1536,8,"meizu mx4 pro"]]],["arm mali-t628 mp2","628",0,[[1280,720,8,"leadcore l1860 (development board)"]]],["arm mali-t628 mp6","628",0,[[800,480,35,"gen2wave rp1600"],[1280,672,14,"hardkernel odroid-xu3 (development board)"],[1280,720,26,"samsung galaxy alpha (mali-t628, sm-g850)"],[1920,1080,11,"samsung galaxy note iii (mali-t628, sm-n900, sm-n9000q)"],[2560,1600,3,"samsung sm-t520 galaxy tab 10.1"]]],["arm mali-t720","720",0,[[432,240,16,"unihertz jelly pro"],[782,480,8,"mobiistar lai zoro"],[784,480,8,"lg k3 (k100)"],[791,480,6,"i-mobile i-style 812 4g"],[800,480,4,"lava iris 550"],[854,480,3,"verykool sl5009 jet"],[897,540,5,"bluboo xfire"],[960,540,3,"siswoo a5 chocolate"],[1024,552,4,"bb-mobile tq763i techno 7.0 lte"],[1024,714,9,"bluedot bnt-791 (2g)"],[1024,720,3,"zte e8qp"],[1280,624,10,"panasonic p55 novo 4g"],[1280,648,4,"tcl 9025"],[1280,656,7,"acer a1-734 iconia talk s"],[1184,720,4,"lenovo xt1700, xt1706, k10a40"],[1187,720,7,"lg k8 (k350)"],[1189,720,5,"ark impulse p2"],[1193,720,7,"lg x power (k220, f750)"],[1196,720,2,"dtac phone m2"],[1198,720,5,"dtac phone t3"],[1205,720,7,"firefly aurii passion"],[1206,720,4,"archos 50 power"],[1208,720,3,"advan i7 plus"],[1217,720,7,"energy sistem energy phone max 2+"],[1238,720,9,"vnpt technology vivas lotus s3 lte"],[1280,720,2,"archos bush spira c2 5"],[1280,736,2,"digma cs1062ml citi 1903 4g"],[1280,737,3,"waywalkers t805g"],[1280,740,3,"casper via l8"],[1280,746,3,"philips tle821l e line 4g"],[1280,752,3,"4good light at200"],[1280,755,7,"leotec letab1020 supernova qi32"],[1356,720,8,"xiaolajiao la-v11"],[1360,720,7,"tecno in5"],[1368,720,7,"tinno p100"],[1280,800,4,"samsung galaxy tab e 8.0 (sm-t375x, sm-t377x)"],[1920,936,4,"panasonic eluga note"],[1920,996,4,"cube technology u83 iplay10"],[1776,1080,4,"fly fs522 cirrus 14"],[1787,1080,5,"lg x cam (k580, f690)"],[1920,1008,6,"alcatel one touch xess (p17aa)"],[1794,1080,3,"ramos mos 1 max"],[1800,1080,4,"archos sense 55 s"],[1815,1080,4,"archos diamond plus"],[1920,1032,5,"virgin media tellytablet"],[1920,1080,2,"infocus m640"],[1920,1104,4,"vestel v tab 7030"],[1920,1116,4,"jty q101"],[1920,1128,2,"archos 80 oxygen"],[2009,1080,4,"tcl 5099"],[1920,1136,4,"asus zenpad 10 (p028 z301m)"]]],["arm mali-t760","760",0,[[854,480,14,"aux t6200l"],[897,540,13,"sony xperia e4g (e20xx)"],[960,540,12,"gionee v381"],[960,568,24,"asus c100pa chromebook flip"],[1024,552,12,"archos 70 helium"],[1024,720,10,"wiz t-8168"],[1188,720,9,"lg h520 magna, h522 prime plus"],[1196,720,9,"acer s57 liquid jade z"],[1280,720,8,"dunetek vitamin a"],[1280,736,8,"archos 80b helium"],[1280,752,8,"frael m10g 4g"],[1280,768,8,"meizu m1"],[1794,1080,6,"sugar 2 ss136 l8560"],[1920,1032,9,"qbic bxp-300 box pc"],[1920,1080,4,"byxpress mphone xone"],[1920,1104,6,"cube technology t7"],[1920,1128,5,"nec lavietab pc-te510bal"],[2048,1440,3,"teclast p98 4g"],[2560,1440,10,"samsung galaxy note 4 (mali-t760, sm-n910x, sm-n916)"]]],["arm mali-t760 mp6","760",0,[[1920,1080,17,"samsung galaxy a8 (mali-t760, sm-a800x, scv32)"],[2048,1536,12,"samsung galaxy tab s 2 8.0 (sm-t710, sm-t715)"],[2560,1532,10,"samsung galaxy note edge (mali-t760, sm-n915x)"],[2560,1600,10,"samsung galaxy tab s 10.5 (mali-t760, sm-t805s)"]]],["arm mali-t760 mp8","760",0,[[1280,768,42,"samsung sm-w2016"],[1920,1080,25,"meizu niux"],[2160,1200,17,"idealens k2"],[2560,1440,12,"le xiang deepoon m2 vr"],[2560,1504,15,"bungbungame kalos 2"]]],["arm mali-t764","764",0,[[1024,600,19,"gpd q9"],[1280,720,15,"gpd xd"],[1280,752,13,"kruger & matz 1064.1g eagle"],[1280,800,13,"pipo p7"],[1920,1008,6,"rockchip mk809 4k tv stick"],[1920,1010,8,"pipo p7 hd"],[1920,1020,5,"rockchip mk903v mini tv"],[1920,1032,7,"acooo oneboard pro+"],[1872,1080,7,"contextmedia wallboard 32 tablet (p-wal-106-yit-01)"],[1920,1080,7,"rockchip cs4k tv box"],[1920,1128,7,"archos 101 oxygen"],[2048,1437,5,"haier pad 971"],[2048,1440,5,"hisense f5281 vidaa pad"],[2560,1504,4,"teclast p90hd"]]],["arm mali-t820","820",0,[[1344,720,5,"lenovo k320t"],[1776,1080,6,"leagoo t5c"],[1920,1008,7,"probox2 ava tv box"],[1920,1080,4,"skyworth coocaa 5s32 n2"]]],["arm mali-t830","830",0,[[1280,720,9,"samsung galaxy on7 (mali-t830, sm-g600x)"],[1280,800,9,"samsung sm-t536 (mali-t830)"],[1776,1080,9,"huawei p10 lite (was-xxx)"],[1794,1080,9,"huawei honor 6x (bln-xxx)"],[1920,1080,5,"samsung galaxy on7 prime 2018 (sm-g611)"],[2033,1080,8,"huawei p smart (fig-xxx)"],[2040,1080,9,"huawei maimang 6 (rne-xxx)"],[1920,1200,5,"samsung galaxy tab a 10.1 (sm-t580, sm-t585)"]]],["arm mali-t860","860",0,[[1184,720,8,"tcl a626"],[1196,720,8,"green orange go t2"],[1280,720,14,"htc one a9s"],[1920,1024,17,"hardkernel odroid-n1 (development board)"],[1920,1032,16,"contextmedia p-wal-108-elc-02"],[1920,1080,7,"htc u play (u-2u)"],[1920,1116,15,"imuz revolution a8"],[1920,1128,15,"rockchip rk3399 (development board)"],[2400,1440,10,"samsung chromebook plus (kevin)"]]],["arm mali-t860 mp2","860",0,[[598,480,25,"cipherlab 9700a"],[1184,720,11,"vernee m5"],[1193,720,11,"lg x power 2 (u+, x500, m-x320, m320)"],[1196,720,11,"lava z25"],[1199,720,11,"lg stylus 3 (m400)"],[1212,720,11,"meeg 306"],[1280,720,10,"oppo r66"],[1336,720,13,"asus pegasus 4s (x018d zb570tl)"],[1344,720,13,"allview x4 soul infinity n"],[1776,1080,7,"benq f55"],[1794,1080,6,"alcatel 7070"],[1798,1080,7,"energy sistem energy phone pro 3"],[1806,1080,8,"tecno phantom 6"],[1807,1080,7,"covia fleaz cp-j55a g07"],[1810,1080,8,"archos 55 diamond 2 plus"],[1920,1080,4,"advan vandroid i55c"],[2004,1080,7,"asus zenfone max plus m1 (x018d zb570tl)"],[1920,1128,7,"verizon qtaxia1"]]],["arm mali-t880","880",0,[[1184,720,22,"doogee mix"],[1280,720,20,"lenovo k8"],[1344,720,18,"casper via f2"],[1776,1080,11,"alcatel 6060 (mali-t880)"],[1794,1080,20,"huawei mate 8 (nxt-xxx)"],[1824,1080,11,"meiigoo m1"],[1920,1080,10,"letv leeco lex650"],[2016,1080,9,"vernee mix 2"],[2064,1080,10,"umi s2 pro"],[2392,1440,12,"huawei honor v8 (knt-al20)"],[2434,1440,11,"huawei honor note 8 premium edition (edi-al10)"],[2560,1440,24,"meizu pro 6 plus"],[2560,1480,10,"huawei dtab compact d-01j (docomo)"],[2560,1600,10,"huawei mediapad m3 (btv-xxx)"]]],["arm mali-t880 mp12","880",0,[[1920,1080,44,"samsung galaxy s7 (sm-g930f)"],[2560,1440,27,"samsung galaxy note 7 (mali-t880, sm-n930)"]]],["arm mali-t880 mp2","880",0,[[1184,720,19,"sony pikachu"],[1376,720,17,"umi s2"],[1776,1080,10,"coolpad a9s-9"],[1800,1080,11,"infinix x603"],[1920,1080,9,"innjoo pro2"]]],["arm mali-t880 mp4","880",0,[[1280,672,18,"mediatek x20 (development board)"],[1794,1080,13,"infocus tsp"],[1800,1080,16,"infinix x602 zero 4 plus"],[1806,1080,16,"tecno phantom a9"],[1810,1080,8,"mobiistar prime x pro"],[1815,1080,16,"tecno phantom 6 plus"],[1920,1080,7,"elephone r9"],[2048,1440,12,"brown tab 1"],[2392,1440,12,"vernee apollo"],[2416,1440,11,"freetel ftj162b kiwami2"],[2560,1440,10,"ivvi i5"]]],["mali-g71","71",0,[[2220,1080,54,"samsung s8+ sm-g955f"]]],["mali-g72","72",0,[[2220,1080,56,"samsung s9+ sm-g965f"]]],["mali-t830","830",0,[[1480,720,10,"samsung gm-j600fn"]]]]')
                            },
                            884: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["nvidia tegra","",0,[[2048,1440,23,"google nexus 9"]]],["nvidia tegra k1","1",0,[[1920,1008,32,"nvidia jetson tk1 (pm375, development board)"],[1920,1032,12,"lenovo k1 hd (2014)"],[1920,1080,28,"nvidia tegra gk20a (ardbeg, development board)"],[1920,1104,29,"google project tango"],[2048,1536,21,"xiaomi mi pad"],[3840,2088,8,"lenovo thinkvision 28"]]],["nvidia tegra x1","1",0,[[1920,1080,60,"nvidia shield android tv"],[2560,1688,33,"google pixel c"]]]]')
                            },
                            214: e => {
                                "use strict";
                                e.exports = JSON.parse('["4.0.8",["powervr rogue g6110","6110",0,[[1024,600,11,"dasaita mtcd px5 head unit"],[1280,752,8,"visual land prestige prime 10se"],[1366,720,7,"ditecma m1092r"],[1920,1008,6,"vensmile t051 tv box"],[1920,1016,5,"geekbuying geekbox tv box"],[1920,1032,4,"hannspree hsg1351"],[1920,1080,5,"10moons tv box (rogue g6110)"],[1920,1128,5,"teclast p10"]]],["powervr rogue g6200","6200",0,[[1280,720,15,"infocus m530"],[1280,736,12,"amazon kindle fire hd 8 (5th gen, kfmewi)"],[1280,752,12,"amazon kindle fire hd 10 (5th gen, kftbwi)"],[1280,800,9,"amazon kindle fire hd 7 (4th gen, kfaswi)"],[1794,1080,5,"ubik uno"],[1920,1080,6,"cherry mobile x220 cosmos one plus"],[1920,1152,8,"meizu mx4 (m460, m460a, m461)"],[2392,1440,6,"hasee hl9916004"],[2560,1440,6,"condor allure a100 pgn-607"]]],["powervr rogue g6230","6230",0,[[1920,1008,8,"rikomagic mk80 tv box (tronsmart draco aw80, fantasy a80)"],[1920,1016,7,"cubietech cubieboard 4 (cc-a80, hansen-a80, development board)"],[2048,1440,5,"teclast p98air"],[2048,1464,7,"actions gs900a (development board)"]]],["powervr rogue g6400","6400",0,[[1794,1080,8,"lg f490 liger (g6400)"],[1920,1032,8,"renesas lager"]]],["powervr rogue g6430","6430",0,[[1024,552,26,"asus fonepad 7 (k01f fe171mg)"],[1280,720,27,"asus zenfone 2 (z008 ze550ml)"],[1280,736,20,"asus fonepad 7 (k019 fe375cg)"],[1280,752,27,"asus zenpad 10 (p01t z300cl)"],[1788,1080,8,"lg f490 liger (g6430)"],[1920,1080,15,"asus zenfone zoom (intel z3560, z00xsb zx551ml)"],[1920,1104,11,"asus memo pad 8 ast21 (intel z3580, k015 me581cl)"],[2048,1440,11,"asus zenpad s 8.0 (p01m z580c)"],[2560,1504,9,"dell venue 10 7040"]]],["powervr rogue ge8100","8100",0,[[906,480,8,"tinno k600"],[1184,720,5,"mediatek mt6739 (development board, rogue ge8100)"],[1339,720,5,"vodafone vfd 720"],[1344,720,6,"gionee f205"]]],["powervr rogue ge8300","8300",0,[[1280,752,9,"acer b3-a40 iconia one 10"],[1208,800,8,"verizon qtaki1"],[1920,1128,5,"acer b3-a40 fhd iconia one 10"]]],["powervr rogue gx6250","6250",0,[[688,412,16,"lenovo n23 yoga / flex 11 chromebook"],[1280,672,25,"renesas salvator-x-r8a7796"],[1280,736,25,"mediatek mt8173 (development board)"],[1920,980,10,"google chromebook pixel (2015, rogue gx6250)"],[1920,1016,14,"peloton ruby"],[1920,1020,8,"acer chromebook r13"],[1920,1032,13,"renesas salvator-x-m3"],[1920,1080,12,"xiaomi mibox 3 pro tv box"],[1920,1128,10,"amazon kindle fire hd 10 (2017, kfsuwi)"],[2048,1536,7,"alps jdtab j01"],[2560,1504,7,"onda f109"]]],["powervr rogue gx6650","6650",0,[[1280,672,52,"renesas salvator-x"],[1920,1032,24,"renesas salvator-x (octa core)"]]],["powervr rogue han","han",0,[[1794,1080,6,"ireadygo w3d"],[1920,1080,6,"changhong x6"],[2392,1440,5,"alcatel one touch d820"],[2560,1440,4,"alcatel 6071y phantom"]]],["powervr rogue hood","",0,[[1280,736,16,"dell venue 7 3740"],[1920,1080,12,"lenovo p90"],[1920,1104,9,"dell venue 8 3840"]]],["powervr rogue lando","",0,[[1920,1080,13,"spreadtrum sp9861e (development board, rogue lando)"]]],["powervr rogue marlowe","",0,[[1920,1080,39,"meitu v6 mp1605"],[2560,1440,25,"meizu pro 7 plus"]]]]')
                            },
                            804: (e, t, n) => {
                                var i = {
                                    "./d-adreno.json": 622,
                                    "./d-amd.json": 183,
                                    "./d-apple.json": 732,
                                    "./d-geforce.json": 405,
                                    "./d-intel.json": 178,
                                    "./d-nvidia.json": 217,
                                    "./d-radeon.json": 145,
                                    "./m-adreno.json": 921,
                                    "./m-apple-ipad.json": 535,
                                    "./m-apple.json": 438,
                                    "./m-intel.json": 283,
                                    "./m-mali-t.json": 327,
                                    "./m-mali.json": 538,
                                    "./m-nvidia.json": 884,
                                    "./m-powervr.json": 214
                                };

                                function r(e) {
                                    var t = o(e);
                                    return n(t)
                                }

                                function o(e) {
                                    if (!n.o(i, e)) {
                                        var t = new Error("Cannot find module '" + e + "'");
                                        throw t.code = "MODULE_NOT_FOUND", t
                                    }
                                    return i[e]
                                }
                                r.keys = function() {
                                    return Object.keys(i)
                                }, r.resolve = o, e.exports = r, r.id = 804
                            },
                            354: (e, t, n) => {
                                var i, r = function() {
                                    function e(e, t) {
                                        if (!r[e]) {
                                            r[e] = {};
                                            for (var n = 0; n < e.length; n++) r[e][e.charAt(n)] = n
                                        }
                                        return r[e][t]
                                    }
                                    var t = String.fromCharCode,
                                        n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                                        i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",
                                        r = {},
                                        o = {
                                            compressToBase64: function(e) {
                                                if (null == e) return "";
                                                var t = o._compress(e, 6, (function(e) {
                                                    return n.charAt(e)
                                                }));
                                                switch (t.length % 4) {
                                                    default:
                                                    case 0:
                                                        return t;
                                                    case 1:
                                                        return t + "===";
                                                    case 2:
                                                        return t + "==";
                                                    case 3:
                                                        return t + "="
                                                }
                                            },
                                            decompressFromBase64: function(t) {
                                                return null == t ? "" : "" == t ? null : o._decompress(t.length, 32, (function(i) {
                                                    return e(n, t.charAt(i))
                                                }))
                                            },
                                            compressToUTF16: function(e) {
                                                return null == e ? "" : o._compress(e, 15, (function(e) {
                                                    return t(e + 32)
                                                })) + " "
                                            },
                                            decompressFromUTF16: function(e) {
                                                return null == e ? "" : "" == e ? null : o._decompress(e.length, 16384, (function(t) {
                                                    return e.charCodeAt(t) - 32
                                                }))
                                            },
                                            compressToUint8Array: function(e) {
                                                for (var t = o.compress(e), n = new Uint8Array(2 * t.length), i = 0, r = t.length; r > i; i++) {
                                                    var s = t.charCodeAt(i);
                                                    n[2 * i] = s >>> 8, n[2 * i + 1] = s % 256
                                                }
                                                return n
                                            },
                                            decompressFromUint8Array: function(e) {
                                                if (null == e) return o.decompress(e);
                                                for (var n = new Array(e.length / 2), i = 0, r = n.length; r > i; i++) n[i] = 256 * e[2 * i] + e[2 * i + 1];
                                                var s = [];
                                                return n.forEach((function(e) {
                                                    s.push(t(e))
                                                })), o.decompress(s.join(""))
                                            },
                                            compressToEncodedURIComponent: function(e) {
                                                return null == e ? "" : o._compress(e, 6, (function(e) {
                                                    return i.charAt(e)
                                                }))
                                            },
                                            decompressFromEncodedURIComponent: function(t) {
                                                return null == t ? "" : "" == t ? null : (t = t.replace(/ /g, "+"), o._decompress(t.length, 32, (function(n) {
                                                    return e(i, t.charAt(n))
                                                })))
                                            },
                                            compress: function(e) {
                                                return o._compress(e, 16, (function(e) {
                                                    return t(e)
                                                }))
                                            },
                                            _compress: function(e, t, n) {
                                                if (null == e) return "";
                                                var i, r, o, s = {},
                                                    a = {},
                                                    d = "",
                                                    c = "",
                                                    l = "",
                                                    h = 2,
                                                    u = 3,
                                                    p = 2,
                                                    m = [],
                                                    g = 0,
                                                    f = 0;
                                                for (o = 0; o < e.length; o += 1)
                                                    if (d = e.charAt(o), Object.prototype.hasOwnProperty.call(s, d) || (s[d] = u++, a[d] = !0), c = l + d, Object.prototype.hasOwnProperty.call(s, c)) l = c;
                                                    else {
                                                        if (Object.prototype.hasOwnProperty.call(a, l)) {
                                                            if (l.charCodeAt(0) < 256) {
                                                                for (i = 0; p > i; i++) g <<= 1, f == t - 1 ? (f = 0, m.push(n(g)), g = 0) : f++;
                                                                for (r = l.charCodeAt(0), i = 0; 8 > i; i++) g = g << 1 | 1 & r, f == t - 1 ? (f = 0, m.push(n(g)), g = 0) : f++, r >>= 1
                                                            } else {
                                                                for (r = 1, i = 0; p > i; i++) g = g << 1 | r, f == t - 1 ? (f = 0, m.push(n(g)), g = 0) : f++, r = 0;
                                                                for (r = l.charCodeAt(0), i = 0; 16 > i; i++) g = g << 1 | 1 & r, f == t - 1 ? (f = 0, m.push(n(g)), g = 0) : f++, r >>= 1
                                                            }
                                                            0 == --h && (h = Math.pow(2, p), p++), delete a[l]
                                                        } else
                                                            for (r = s[l], i = 0; p > i; i++) g = g << 1 | 1 & r, f == t - 1 ? (f = 0, m.push(n(g)), g = 0) : f++, r >>= 1;
                                                        0 == --h && (h = Math.pow(2, p), p++), s[c] = u++, l = String(d)
                                                    } if ("" !== l) {
                                                    if (Object.prototype.hasOwnProperty.call(a, l)) {
                                                        if (l.charCodeAt(0) < 256) {
                                                            for (i = 0; p > i; i++) g <<= 1, f == t - 1 ? (f = 0, m.push(n(g)), g = 0) : f++;
                                                            for (r = l.charCodeAt(0), i = 0; 8 > i; i++) g = g << 1 | 1 & r, f == t - 1 ? (f = 0, m.push(n(g)), g = 0) : f++, r >>= 1
                                                        } else {
                                                            for (r = 1, i = 0; p > i; i++) g = g << 1 | r, f == t - 1 ? (f = 0, m.push(n(g)), g = 0) : f++, r = 0;
                                                            for (r = l.charCodeAt(0), i = 0; 16 > i; i++) g = g << 1 | 1 & r, f == t - 1 ? (f = 0, m.push(n(g)), g = 0) : f++, r >>= 1
                                                        }
                                                        0 == --h && (h = Math.pow(2, p), p++), delete a[l]
                                                    } else
                                                        for (r = s[l], i = 0; p > i; i++) g = g << 1 | 1 & r, f == t - 1 ? (f = 0, m.push(n(g)), g = 0) : f++, r >>= 1;
                                                    0 == --h && (h = Math.pow(2, p), p++)
                                                }
                                                for (r = 2, i = 0; p > i; i++) g = g << 1 | 1 & r, f == t - 1 ? (f = 0, m.push(n(g)), g = 0) : f++, r >>= 1;
                                                for (;;) {
                                                    if (g <<= 1, f == t - 1) {
                                                        m.push(n(g));
                                                        break
                                                    }
                                                    f++
                                                }
                                                return m.join("")
                                            },
                                            decompress: function(e) {
                                                return null == e ? "" : "" == e ? null : o._decompress(e.length, 32768, (function(t) {
                                                    return e.charCodeAt(t)
                                                }))
                                            },
                                            _decompress: function(e, n, i) {
                                                var r, o, s, a, d, c, l, h = [],
                                                    u = 4,
                                                    p = 4,
                                                    m = 3,
                                                    g = "",
                                                    f = [],
                                                    v = {
                                                        val: i(0),
                                                        position: n,
                                                        index: 1
                                                    };
                                                for (r = 0; 3 > r; r += 1) h[r] = r;
                                                for (s = 0, d = Math.pow(2, 2), c = 1; c != d;) a = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = i(v.index++)), s |= (a > 0 ? 1 : 0) * c, c <<= 1;
                                                switch (s) {
                                                    case 0:
                                                        for (s = 0, d = Math.pow(2, 8), c = 1; c != d;) a = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = i(v.index++)), s |= (a > 0 ? 1 : 0) * c, c <<= 1;
                                                        l = t(s);
                                                        break;
                                                    case 1:
                                                        for (s = 0, d = Math.pow(2, 16), c = 1; c != d;) a = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = i(v.index++)), s |= (a > 0 ? 1 : 0) * c, c <<= 1;
                                                        l = t(s);
                                                        break;
                                                    case 2:
                                                        return ""
                                                }
                                                for (h[3] = l, o = l, f.push(l);;) {
                                                    if (v.index > e) return "";
                                                    for (s = 0, d = Math.pow(2, m), c = 1; c != d;) a = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = i(v.index++)), s |= (a > 0 ? 1 : 0) * c, c <<= 1;
                                                    switch (l = s) {
                                                        case 0:
                                                            for (s = 0, d = Math.pow(2, 8), c = 1; c != d;) a = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = i(v.index++)), s |= (a > 0 ? 1 : 0) * c, c <<= 1;
                                                            h[p++] = t(s), l = p - 1, u--;
                                                            break;
                                                        case 1:
                                                            for (s = 0, d = Math.pow(2, 16), c = 1; c != d;) a = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = i(v.index++)), s |= (a > 0 ? 1 : 0) * c, c <<= 1;
                                                            h[p++] = t(s), l = p - 1, u--;
                                                            break;
                                                        case 2:
                                                            return f.join("")
                                                    }
                                                    if (0 == u && (u = Math.pow(2, m), m++), h[l]) g = h[l];
                                                    else {
                                                        if (l !== p) return null;
                                                        g = o + o.charAt(0)
                                                    }
                                                    f.push(g), h[p++] = o + g.charAt(0), o = g, 0 == --u && (u = Math.pow(2, m), m++)
                                                }
                                            }
                                        };
                                    return o
                                }();
                                void 0 === (i = function() {
                                    return r
                                }.call(t, n, t, e)) || (e.exports = i)
                            }
                        },
                        t = {};

                    function n(i) {
                        if (t[i]) return t[i].exports;
                        var r = t[i] = {
                            exports: {}
                        };
                        return e[i].call(r.exports, r, r.exports, n), r.exports
                    }
                    return n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n(607)
                })().default
            },
            577: (e, t) => {
                "use strict";
                t.byteLength = function(e) {
                    var t = d(e),
                        n = t[0],
                        i = t[1];
                    return 3 * (n + i) / 4 - i
                }, t.toByteArray = function(e) {
                    var t, n, o = d(e),
                        s = o[0],
                        a = o[1],
                        c = new r(function(e, t, n) {
                            return 3 * (t + n) / 4 - n
                        }(0, s, a)),
                        l = 0,
                        h = a > 0 ? s - 4 : s;
                    for (n = 0; n < h; n += 4) t = i[e.charCodeAt(n)] << 18 | i[e.charCodeAt(n + 1)] << 12 | i[e.charCodeAt(n + 2)] << 6 | i[e.charCodeAt(n + 3)], c[l++] = t >> 16 & 255, c[l++] = t >> 8 & 255, c[l++] = 255 & t;
                    return 2 === a && (t = i[e.charCodeAt(n)] << 2 | i[e.charCodeAt(n + 1)] >> 4, c[l++] = 255 & t), 1 === a && (t = i[e.charCodeAt(n)] << 10 | i[e.charCodeAt(n + 1)] << 4 | i[e.charCodeAt(n + 2)] >> 2, c[l++] = t >> 8 & 255, c[l++] = 255 & t), c
                }, t.fromByteArray = function(e) {
                    for (var t, i = e.length, r = i % 3, o = [], s = 16383, a = 0, d = i - r; a < d; a += s) o.push(c(e, a, a + s > d ? d : a + s));
                    return 1 === r ? (t = e[i - 1], o.push(n[t >> 2] + n[t << 4 & 63] + "==")) : 2 === r && (t = (e[i - 2] << 8) + e[i - 1], o.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "=")), o.join("")
                };
                for (var n = [], i = [], r = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, a = o.length; s < a; ++s) n[s] = o[s], i[o.charCodeAt(s)] = s;

                function d(e) {
                    var t = e.length;
                    if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                    var n = e.indexOf("=");
                    return -1 === n && (n = t), [n, n === t ? 0 : 4 - n % 4]
                }

                function c(e, t, i) {
                    for (var r, o, s = [], a = t; a < i; a += 3) r = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), s.push(n[(o = r) >> 18 & 63] + n[o >> 12 & 63] + n[o >> 6 & 63] + n[63 & o]);
                    return s.join("")
                }
                i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63
            },
            799: function(e, t) {
                var n, i;
                this || window, void 0 === (i = "function" == typeof(n = function() {
                    var e = /^(interactive|loaded|complete)$/,
                        t = window.location ? window.location.href : null,
                        n = t && t.replace(/#.*$/, "").replace(/\?.*$/, "") || null,
                        i = document.getElementsByTagName("script"),
                        r = "readyState" in (i[0] || document.createElement("script")),
                        o = !window.opera || "[object Opera]" !== window.opera.toString(),
                        s = "currentScript" in document;
                    "stackTraceLimit" in Error && Error.stackTraceLimit !== 1 / 0 && (Error.stackTraceLimit, Error.stackTraceLimit = 1 / 0);
                    var a = !1,
                        d = !1;

                    function c(e, t) {
                        var n, i = null,
                            r = "number" == typeof t;
                        return t = r ? Math.round(t) : 0, "string" == typeof e && e && (r ? n = e.match(/(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/) : (n = e.match(/^(?:|[^:@]*@|.+\)@(?=data:text\/javascript|blob|http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)) && n[1] || (n = e.match(/\)@(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)), n && n[1] && (i = t > 0 ? c(e.slice(e.indexOf(n[0]) + n[0].length), t - 1) : n[1])), i
                    }

                    function l() {
                        if (0 === i.length) return null;
                        var t, h, u, p, m, g = [],
                            f = l.skipStackDepth || 1;
                        for (t = 0; t < i.length; t++) o && r ? e.test(i[t].readyState) && g.push(i[t]) : g.push(i[t]);
                        if (h = new Error, a && (u = h.stack), !u && d) try {
                            throw h
                        } catch (e) {
                            u = e.stack
                        }
                        if (u && !(m = function(e, t) {
                                var n, r = null;
                                if (t = t || i, "string" == typeof e && e)
                                    for (n = t.length; n--;)
                                        if (t[n].src === e) {
                                            r = t[n];
                                            break
                                        } return r
                            }(p = c(u, f), g)) && n && p === n && (m = function(e) {
                                var t, n, r = null;
                                for (t = 0, n = (e = e || i).length; t < n; t++)
                                    if (!e[t].hasAttribute("src")) {
                                        if (r) {
                                            r = null;
                                            break
                                        }
                                        r = e[t]
                                    } return r
                            }(g)), m || 1 === g.length && (m = g[0]), m || s && (m = document.currentScript), !m && o && r)
                            for (t = g.length; t--;)
                                if ("interactive" === g[t].readyState) {
                                    m = g[t];
                                    break
                                } return m || (m = g[g.length - 1] || null), m
                    }(function() {
                        try {
                            var e = new Error;
                            throw a = "string" == typeof e.stack && !!e.stack, e
                        } catch (e) {
                            d = "string" == typeof e.stack && !!e.stack
                        }
                    })(), l.skipStackDepth = 1;
                    var h = l;
                    return h.near = l, h.far = function() {
                        return null
                    }, h.origin = function() {
                        return null
                    }, h
                }) ? n.apply(t, []) : n) || (e.exports = i)
            },
            857: e => {
                "use strict";
                var t, n = "object" == typeof Reflect ? Reflect : null,
                    i = n && "function" == typeof n.apply ? n.apply : function(e, t, n) {
                        return Function.prototype.apply.call(e, t, n)
                    };
                t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e) {
                    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
                } : function(e) {
                    return Object.getOwnPropertyNames(e)
                };
                var r = Number.isNaN || function(e) {
                    return e != e
                };

                function o() {
                    o.init.call(this)
                }
                e.exports = o, e.exports.once = function(e, t) {
                    return new Promise((function(n, i) {
                        function r(n) {
                            e.removeListener(t, o), i(n)
                        }

                        function o() {
                            "function" == typeof e.removeListener && e.removeListener("error", r), n([].slice.call(arguments))
                        }
                        g(e, t, o, {
                            once: !0
                        }), "error" !== t && function(e, t, n) {
                            "function" == typeof e.on && g(e, "error", t, {
                                once: !0
                            })
                        }(e, r)
                    }))
                }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
                var s = 10;

                function a(e) {
                    if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
                }

                function d(e) {
                    return void 0 === e._maxListeners ? o.defaultMaxListeners : e._maxListeners
                }

                function c(e, t, n, i) {
                    var r, o, s, c;
                    if (a(n), void 0 === (o = e._events) ? (o = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== o.newListener && (e.emit("newListener", t, n.listener ? n.listener : n), o = e._events), s = o[t]), void 0 === s) s = o[t] = n, ++e._eventsCount;
                    else if ("function" == typeof s ? s = o[t] = i ? [n, s] : [s, n] : i ? s.unshift(n) : s.push(n), (r = d(e)) > 0 && s.length > r && !s.warned) {
                        s.warned = !0;
                        var l = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                        l.name = "MaxListenersExceededWarning", l.emitter = e, l.type = t, l.count = s.length, c = l, console && console.warn && console.warn(c)
                    }
                    return e
                }

                function l() {
                    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
                }

                function h(e, t, n) {
                    var i = {
                            fired: !1,
                            wrapFn: void 0,
                            target: e,
                            type: t,
                            listener: n
                        },
                        r = l.bind(i);
                    return r.listener = n, i.wrapFn = r, r
                }

                function u(e, t, n) {
                    var i = e._events;
                    if (void 0 === i) return [];
                    var r = i[t];
                    return void 0 === r ? [] : "function" == typeof r ? n ? [r.listener || r] : [r] : n ? function(e) {
                        for (var t = new Array(e.length), n = 0; n < t.length; ++n) t[n] = e[n].listener || e[n];
                        return t
                    }(r) : m(r, r.length)
                }

                function p(e) {
                    var t = this._events;
                    if (void 0 !== t) {
                        var n = t[e];
                        if ("function" == typeof n) return 1;
                        if (void 0 !== n) return n.length
                    }
                    return 0
                }

                function m(e, t) {
                    for (var n = new Array(t), i = 0; i < t; ++i) n[i] = e[i];
                    return n
                }

                function g(e, t, n, i) {
                    if ("function" == typeof e.on) i.once ? e.once(t, n) : e.on(t, n);
                    else {
                        if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
                        e.addEventListener(t, (function r(o) {
                            i.once && e.removeEventListener(t, r), n(o)
                        }))
                    }
                }
                Object.defineProperty(o, "defaultMaxListeners", {
                    enumerable: !0,
                    get: function() {
                        return s
                    },
                    set: function(e) {
                        if ("number" != typeof e || e < 0 || r(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                        s = e
                    }
                }), o.init = function() {
                    void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
                }, o.prototype.setMaxListeners = function(e) {
                    if ("number" != typeof e || e < 0 || r(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
                    return this._maxListeners = e, this
                }, o.prototype.getMaxListeners = function() {
                    return d(this)
                }, o.prototype.emit = function(e) {
                    for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
                    var r = "error" === e,
                        o = this._events;
                    if (void 0 !== o) r = r && void 0 === o.error;
                    else if (!r) return !1;
                    if (r) {
                        var s;
                        if (t.length > 0 && (s = t[0]), s instanceof Error) throw s;
                        var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
                        throw a.context = s, a
                    }
                    var d = o[e];
                    if (void 0 === d) return !1;
                    if ("function" == typeof d) i(d, this, t);
                    else {
                        var c = d.length,
                            l = m(d, c);
                        for (n = 0; n < c; ++n) i(l[n], this, t)
                    }
                    return !0
                }, o.prototype.addListener = function(e, t) {
                    return c(this, e, t, !1)
                }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e, t) {
                    return c(this, e, t, !0)
                }, o.prototype.once = function(e, t) {
                    return a(t), this.on(e, h(this, e, t)), this
                }, o.prototype.prependOnceListener = function(e, t) {
                    return a(t), this.prependListener(e, h(this, e, t)), this
                }, o.prototype.removeListener = function(e, t) {
                    var n, i, r, o, s;
                    if (a(t), void 0 === (i = this._events)) return this;
                    if (void 0 === (n = i[e])) return this;
                    if (n === t || n.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
                    else if ("function" != typeof n) {
                        for (r = -1, o = n.length - 1; o >= 0; o--)
                            if (n[o] === t || n[o].listener === t) {
                                s = n[o].listener, r = o;
                                break
                            } if (r < 0) return this;
                        0 === r ? n.shift() : function(e, t) {
                            for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                            e.pop()
                        }(n, r), 1 === n.length && (i[e] = n[0]), void 0 !== i.removeListener && this.emit("removeListener", e, s || t)
                    }
                    return this
                }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e) {
                    var t, n, i;
                    if (void 0 === (n = this._events)) return this;
                    if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[e]), this;
                    if (0 === arguments.length) {
                        var r, o = Object.keys(n);
                        for (i = 0; i < o.length; ++i) "removeListener" !== (r = o[i]) && this.removeAllListeners(r);
                        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
                    }
                    if ("function" == typeof(t = n[e])) this.removeListener(e, t);
                    else if (void 0 !== t)
                        for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
                    return this
                }, o.prototype.listeners = function(e) {
                    return u(this, e, !0)
                }, o.prototype.rawListeners = function(e) {
                    return u(this, e, !1)
                }, o.listenerCount = function(e, t) {
                    return "function" == typeof e.listenerCount ? e.listenerCount(t) : p.call(e, t)
                }, o.prototype.listenerCount = p, o.prototype.eventNames = function() {
                    return this._eventsCount > 0 ? t(this._events) : []
                }
            },
            387: function(e, t) {
                var n;
                ! function(t, n) {
                    "use strict";
                    "object" == typeof e.exports ? e.exports = t.document ? n(t, !0) : function(e) {
                        if (!e.document) throw new Error("jQuery requires a window with a document");
                        return n(e)
                    } : n(t)
                }("undefined" != typeof window ? window : this, (function(i, r) {
                    "use strict";
                    var o = [],
                        s = Object.getPrototypeOf,
                        a = o.slice,
                        d = o.flat ? function(e) {
                            return o.flat.call(e)
                        } : function(e) {
                            return o.concat.apply([], e)
                        },
                        c = o.push,
                        l = o.indexOf,
                        h = {},
                        u = h.toString,
                        p = h.hasOwnProperty,
                        m = p.toString,
                        g = m.call(Object),
                        f = {},
                        v = function(e) {
                            return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item
                        },
                        _ = function(e) {
                            return null != e && e === e.window
                        },
                        y = i.document,
                        E = {
                            type: !0,
                            src: !0,
                            nonce: !0,
                            noModule: !0
                        };

                    function S(e, t, n) {
                        var i, r, o = (n = n || y).createElement("script");
                        if (o.text = e, t)
                            for (i in E)(r = t[i] || t.getAttribute && t.getAttribute(i)) && o.setAttribute(i, r);
                        n.head.appendChild(o).parentNode.removeChild(o)
                    }

                    function b(e) {
                        return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? h[u.call(e)] || "object" : typeof e
                    }
                    var T = "3.6.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-deprecated/ajax-event-alias,-effects,-effects/Tween,-effects/animatedSelector",
                        C = function(e, t) {
                            return new C.fn.init(e, t)
                        };

                    function x(e) {
                        var t = !!e && "length" in e && e.length,
                            n = b(e);
                        return !v(e) && !_(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e)
                    }
                    C.fn = C.prototype = {
                        jquery: T,
                        constructor: C,
                        length: 0,
                        toArray: function() {
                            return a.call(this)
                        },
                        get: function(e) {
                            return null == e ? a.call(this) : e < 0 ? this[e + this.length] : this[e]
                        },
                        pushStack: function(e) {
                            var t = C.merge(this.constructor(), e);
                            return t.prevObject = this, t
                        },
                        each: function(e) {
                            return C.each(this, e)
                        },
                        map: function(e) {
                            return this.pushStack(C.map(this, (function(t, n) {
                                return e.call(t, n, t)
                            })))
                        },
                        slice: function() {
                            return this.pushStack(a.apply(this, arguments))
                        },
                        first: function() {
                            return this.eq(0)
                        },
                        last: function() {
                            return this.eq(-1)
                        },
                        even: function() {
                            return this.pushStack(C.grep(this, (function(e, t) {
                                return (t + 1) % 2
                            })))
                        },
                        odd: function() {
                            return this.pushStack(C.grep(this, (function(e, t) {
                                return t % 2
                            })))
                        },
                        eq: function(e) {
                            var t = this.length,
                                n = +e + (e < 0 ? t : 0);
                            return this.pushStack(0 <= n && n < t ? [this[n]] : [])
                        },
                        end: function() {
                            return this.prevObject || this.constructor()
                        },
                        push: c,
                        sort: o.sort,
                        splice: o.splice
                    }, C.extend = C.fn.extend = function() {
                        var e, t, n, i, r, o, s = arguments[0] || {},
                            a = 1,
                            d = arguments.length,
                            c = !1;
                        for ("boolean" == typeof s && (c = s, s = arguments[a] || {}, a++), "object" == typeof s || v(s) || (s = {}), a === d && (s = this, a--); a < d; a++)
                            if (null != (e = arguments[a]))
                                for (t in e) i = e[t], "__proto__" !== t && s !== i && (c && i && (C.isPlainObject(i) || (r = Array.isArray(i))) ? (n = s[t], o = r && !Array.isArray(n) ? [] : r || C.isPlainObject(n) ? n : {}, r = !1, s[t] = C.extend(c, o, i)) : void 0 !== i && (s[t] = i));
                        return s
                    }, C.extend({
                        expando: "jQuery" + (T + Math.random()).replace(/\D/g, ""),
                        isReady: !0,
                        error: function(e) {
                            throw new Error(e)
                        },
                        noop: function() {},
                        isPlainObject: function(e) {
                            var t, n;
                            return !(!e || "[object Object]" !== u.call(e) || (t = s(e)) && ("function" != typeof(n = p.call(t, "constructor") && t.constructor) || m.call(n) !== g))
                        },
                        isEmptyObject: function(e) {
                            var t;
                            for (t in e) return !1;
                            return !0
                        },
                        globalEval: function(e, t, n) {
                            S(e, {
                                nonce: t && t.nonce
                            }, n)
                        },
                        each: function(e, t) {
                            var n, i = 0;
                            if (x(e))
                                for (n = e.length; i < n && !1 !== t.call(e[i], i, e[i]); i++);
                            else
                                for (i in e)
                                    if (!1 === t.call(e[i], i, e[i])) break;
                            return e
                        },
                        makeArray: function(e, t) {
                            var n = t || [];
                            return null != e && (x(Object(e)) ? C.merge(n, "string" == typeof e ? [e] : e) : c.call(n, e)), n
                        },
                        inArray: function(e, t, n) {
                            return null == t ? -1 : l.call(t, e, n)
                        },
                        merge: function(e, t) {
                            for (var n = +t.length, i = 0, r = e.length; i < n; i++) e[r++] = t[i];
                            return e.length = r, e
                        },
                        grep: function(e, t, n) {
                            for (var i = [], r = 0, o = e.length, s = !n; r < o; r++) !t(e[r], r) !== s && i.push(e[r]);
                            return i
                        },
                        map: function(e, t, n) {
                            var i, r, o = 0,
                                s = [];
                            if (x(e))
                                for (i = e.length; o < i; o++) null != (r = t(e[o], o, n)) && s.push(r);
                            else
                                for (o in e) null != (r = t(e[o], o, n)) && s.push(r);
                            return d(s)
                        },
                        guid: 1,
                        support: f
                    }), "function" == typeof Symbol && (C.fn[Symbol.iterator] = o[Symbol.iterator]), C.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function(e, t) {
                        h["[object " + t + "]"] = t.toLowerCase()
                    }));
                    var R = function(e) {
                        var t, n, i, r, o, s, a, d, c, l, h, u, p, m, g, f, v, _, y, E = "sizzle" + 1 * new Date,
                            S = e.document,
                            b = 0,
                            T = 0,
                            C = de(),
                            x = de(),
                            R = de(),
                            A = de(),
                            w = function(e, t) {
                                return e === t && (h = !0), 0
                            },
                            I = {}.hasOwnProperty,
                            P = [],
                            D = P.pop,
                            O = P.push,
                            N = P.push,
                            k = P.slice,
                            M = function(e, t) {
                                for (var n = 0, i = e.length; n < i; n++)
                                    if (e[n] === t) return n;
                                return -1
                            },
                            L = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                            F = "[\\x20\\t\\r\\n\\f]",
                            j = "(?:\\\\[\\da-fA-F]{1,6}" + F + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
                            V = "\\[" + F + "*(" + j + ")(?:" + F + "*([*^$|!~]?=)" + F + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + j + "))|)" + F + "*\\]",
                            U = ":(" + j + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + V + ")*)|.*)\\)|)",
                            H = new RegExp(F + "+", "g"),
                            $ = new RegExp("^" + F + "+|((?:^|[^\\\\])(?:\\\\.)*)" + F + "+$", "g"),
                            J = new RegExp("^" + F + "*," + F + "*"),
                            B = new RegExp("^" + F + "*([>+~]|" + F + ")" + F + "*"),
                            q = new RegExp(F + "|>"),
                            G = new RegExp(U),
                            z = new RegExp("^" + j + "$"),
                            K = {
                                ID: new RegExp("^#(" + j + ")"),
                                CLASS: new RegExp("^\\.(" + j + ")"),
                                TAG: new RegExp("^(" + j + "|[*])"),
                                ATTR: new RegExp("^" + V),
                                PSEUDO: new RegExp("^" + U),
                                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + F + "*(even|odd|(([+-]|)(\\d*)n|)" + F + "*(?:([+-]|)" + F + "*(\\d+)|))" + F + "*\\)|)", "i"),
                                bool: new RegExp("^(?:" + L + ")$", "i"),
                                needsContext: new RegExp("^" + F + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + F + "*((?:-\\d)?\\d*)" + F + "*\\)|)(?=[^-]|$)", "i")
                            },
                            W = /HTML$/i,
                            X = /^(?:input|select|textarea|button)$/i,
                            Y = /^h\d$/i,
                            Q = /^[^{]+\{\s*\[native \w/,
                            Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                            ee = /[+~]/,
                            te = new RegExp("\\\\[\\da-fA-F]{1,6}" + F + "?|\\\\([^\\r\\n\\f])", "g"),
                            ne = function(e, t) {
                                var n = "0x" + e.slice(1) - 65536;
                                return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
                            },
                            ie = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                            re = function(e, t) {
                                return t ? "\0" === e ? "" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
                            },
                            oe = function() {
                                u()
                            },
                            se = Ee((function(e) {
                                return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase()
                            }), {
                                dir: "parentNode",
                                next: "legend"
                            });
                        try {
                            N.apply(P = k.call(S.childNodes), S.childNodes), P[S.childNodes.length].nodeType
                        } catch (t) {
                            N = {
                                apply: P.length ? function(e, t) {
                                    O.apply(e, k.call(t))
                                } : function(e, t) {
                                    for (var n = e.length, i = 0; e[n++] = t[i++];);
                                    e.length = n - 1
                                }
                            }
                        }

                        function ae(e, t, i, r) {
                            var o, a, c, l, h, m, v, _ = t && t.ownerDocument,
                                S = t ? t.nodeType : 9;
                            if (i = i || [], "string" != typeof e || !e || 1 !== S && 9 !== S && 11 !== S) return i;
                            if (!r && (u(t), t = t || p, g)) {
                                if (11 !== S && (h = Z.exec(e)))
                                    if (o = h[1]) {
                                        if (9 === S) {
                                            if (!(c = t.getElementById(o))) return i;
                                            if (c.id === o) return i.push(c), i
                                        } else if (_ && (c = _.getElementById(o)) && y(t, c) && c.id === o) return i.push(c), i
                                    } else {
                                        if (h[2]) return N.apply(i, t.getElementsByTagName(e)), i;
                                        if ((o = h[3]) && n.getElementsByClassName && t.getElementsByClassName) return N.apply(i, t.getElementsByClassName(o)), i
                                    } if (n.qsa && !A[e + " "] && (!f || !f.test(e)) && (1 !== S || "object" !== t.nodeName.toLowerCase())) {
                                    if (v = e, _ = t, 1 === S && (q.test(e) || B.test(e))) {
                                        for ((_ = ee.test(e) && ve(t.parentNode) || t) === t && n.scope || ((l = t.getAttribute("id")) ? l = l.replace(ie, re) : t.setAttribute("id", l = E)), a = (m = s(e)).length; a--;) m[a] = (l ? "#" + l : ":scope") + " " + ye(m[a]);
                                        v = m.join(",")
                                    }
                                    try {
                                        return N.apply(i, _.querySelectorAll(v)), i
                                    } catch (t) {
                                        A(e, !0)
                                    } finally {
                                        l === E && t.removeAttribute("id")
                                    }
                                }
                            }
                            return d(e.replace($, "$1"), t, i, r)
                        }

                        function de() {
                            var e = [];
                            return function t(n, r) {
                                return e.push(n + " ") > i.cacheLength && delete t[e.shift()], t[n + " "] = r
                            }
                        }

                        function ce(e) {
                            return e[E] = !0, e
                        }

                        function le(e) {
                            var t = p.createElement("fieldset");
                            try {
                                return !!e(t)
                            } catch (e) {
                                return !1
                            } finally {
                                t.parentNode && t.parentNode.removeChild(t), t = null
                            }
                        }

                        function he(e, t) {
                            for (var n = e.split("|"), r = n.length; r--;) i.attrHandle[n[r]] = t
                        }

                        function ue(e, t) {
                            var n = t && e,
                                i = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
                            if (i) return i;
                            if (n)
                                for (; n = n.nextSibling;)
                                    if (n === t) return -1;
                            return e ? 1 : -1
                        }

                        function pe(e) {
                            return function(t) {
                                return "input" === t.nodeName.toLowerCase() && t.type === e
                            }
                        }

                        function me(e) {
                            return function(t) {
                                var n = t.nodeName.toLowerCase();
                                return ("input" === n || "button" === n) && t.type === e
                            }
                        }

                        function ge(e) {
                            return function(t) {
                                return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && se(t) === e : t.disabled === e : "label" in t && t.disabled === e
                            }
                        }

                        function fe(e) {
                            return ce((function(t) {
                                return t = +t, ce((function(n, i) {
                                    for (var r, o = e([], n.length, t), s = o.length; s--;) n[r = o[s]] && (n[r] = !(i[r] = n[r]))
                                }))
                            }))
                        }

                        function ve(e) {
                            return e && void 0 !== e.getElementsByTagName && e
                        }
                        for (t in n = ae.support = {}, o = ae.isXML = function(e) {
                                var t = e && e.namespaceURI,
                                    n = e && (e.ownerDocument || e).documentElement;
                                return !W.test(t || n && n.nodeName || "HTML")
                            }, u = ae.setDocument = function(e) {
                                var t, r, s = e ? e.ownerDocument || e : S;
                                return s != p && 9 === s.nodeType && s.documentElement && (m = (p = s).documentElement, g = !o(p), S != p && (r = p.defaultView) && r.top !== r && (r.addEventListener ? r.addEventListener("unload", oe, !1) : r.attachEvent && r.attachEvent("onunload", oe)), n.scope = le((function(e) {
                                    return m.appendChild(e).appendChild(p.createElement("div")), void 0 !== e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length
                                })), n.attributes = le((function(e) {
                                    return e.className = "i", !e.getAttribute("className")
                                })), n.getElementsByTagName = le((function(e) {
                                    return e.appendChild(p.createComment("")), !e.getElementsByTagName("*").length
                                })), n.getElementsByClassName = Q.test(p.getElementsByClassName), n.getById = le((function(e) {
                                    return m.appendChild(e).id = E, !p.getElementsByName || !p.getElementsByName(E).length
                                })), n.getById ? (i.filter.ID = function(e) {
                                    var t = e.replace(te, ne);
                                    return function(e) {
                                        return e.getAttribute("id") === t
                                    }
                                }, i.find.ID = function(e, t) {
                                    if (void 0 !== t.getElementById && g) {
                                        var n = t.getElementById(e);
                                        return n ? [n] : []
                                    }
                                }) : (i.filter.ID = function(e) {
                                    var t = e.replace(te, ne);
                                    return function(e) {
                                        var n = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
                                        return n && n.value === t
                                    }
                                }, i.find.ID = function(e, t) {
                                    if (void 0 !== t.getElementById && g) {
                                        var n, i, r, o = t.getElementById(e);
                                        if (o) {
                                            if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
                                            for (r = t.getElementsByName(e), i = 0; o = r[i++];)
                                                if ((n = o.getAttributeNode("id")) && n.value === e) return [o]
                                        }
                                        return []
                                    }
                                }), i.find.TAG = n.getElementsByTagName ? function(e, t) {
                                    return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0
                                } : function(e, t) {
                                    var n, i = [],
                                        r = 0,
                                        o = t.getElementsByTagName(e);
                                    if ("*" === e) {
                                        for (; n = o[r++];) 1 === n.nodeType && i.push(n);
                                        return i
                                    }
                                    return o
                                }, i.find.CLASS = n.getElementsByClassName && function(e, t) {
                                    if (void 0 !== t.getElementsByClassName && g) return t.getElementsByClassName(e)
                                }, v = [], f = [], (n.qsa = Q.test(p.querySelectorAll)) && (le((function(e) {
                                    var t;
                                    m.appendChild(e).innerHTML = "<a id='" + E + "'></a><select id='" + E + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && f.push("[*^$]=" + F + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || f.push("\\[" + F + "*(?:value|" + L + ")"), e.querySelectorAll("[id~=" + E + "-]").length || f.push("~="), (t = p.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || f.push("\\[" + F + "*name" + F + "*=" + F + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || f.push(":checked"), e.querySelectorAll("a#" + E + "+*").length || f.push(".#.+[+~]"), e.querySelectorAll("\\\f"), f.push("[\\r\\n\\f]")
                                })), le((function(e) {
                                    e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                                    var t = p.createElement("input");
                                    t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && f.push("name" + F + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && f.push(":enabled", ":disabled"), m.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && f.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), f.push(",.*:")
                                }))), (n.matchesSelector = Q.test(_ = m.matches || m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) && le((function(e) {
                                    n.disconnectedMatch = _.call(e, "*"), _.call(e, "[s!='']:x"), v.push("!=", U)
                                })), f = f.length && new RegExp(f.join("|")), v = v.length && new RegExp(v.join("|")), t = Q.test(m.compareDocumentPosition), y = t || Q.test(m.contains) ? function(e, t) {
                                    var n = 9 === e.nodeType ? e.documentElement : e,
                                        i = t && t.parentNode;
                                    return e === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(i)))
                                } : function(e, t) {
                                    if (t)
                                        for (; t = t.parentNode;)
                                            if (t === e) return !0;
                                    return !1
                                }, w = t ? function(e, t) {
                                    if (e === t) return h = !0, 0;
                                    var i = !e.compareDocumentPosition - !t.compareDocumentPosition;
                                    return i || (1 & (i = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === i ? e == p || e.ownerDocument == S && y(S, e) ? -1 : t == p || t.ownerDocument == S && y(S, t) ? 1 : l ? M(l, e) - M(l, t) : 0 : 4 & i ? -1 : 1)
                                } : function(e, t) {
                                    if (e === t) return h = !0, 0;
                                    var n, i = 0,
                                        r = e.parentNode,
                                        o = t.parentNode,
                                        s = [e],
                                        a = [t];
                                    if (!r || !o) return e == p ? -1 : t == p ? 1 : r ? -1 : o ? 1 : l ? M(l, e) - M(l, t) : 0;
                                    if (r === o) return ue(e, t);
                                    for (n = e; n = n.parentNode;) s.unshift(n);
                                    for (n = t; n = n.parentNode;) a.unshift(n);
                                    for (; s[i] === a[i];) i++;
                                    return i ? ue(s[i], a[i]) : s[i] == S ? -1 : a[i] == S ? 1 : 0
                                }), p
                            }, ae.matches = function(e, t) {
                                return ae(e, null, null, t)
                            }, ae.matchesSelector = function(e, t) {
                                if (u(e), n.matchesSelector && g && !A[t + " "] && (!v || !v.test(t)) && (!f || !f.test(t))) try {
                                    var i = _.call(e, t);
                                    if (i || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return i
                                } catch (e) {
                                    A(t, !0)
                                }
                                return 0 < ae(t, p, null, [e]).length
                            }, ae.contains = function(e, t) {
                                return (e.ownerDocument || e) != p && u(e), y(e, t)
                            }, ae.attr = function(e, t) {
                                (e.ownerDocument || e) != p && u(e);
                                var r = i.attrHandle[t.toLowerCase()],
                                    o = r && I.call(i.attrHandle, t.toLowerCase()) ? r(e, t, !g) : void 0;
                                return void 0 !== o ? o : n.attributes || !g ? e.getAttribute(t) : (o = e.getAttributeNode(t)) && o.specified ? o.value : null
                            }, ae.escape = function(e) {
                                return (e + "").replace(ie, re)
                            }, ae.error = function(e) {
                                throw new Error("Syntax error, unrecognized expression: " + e)
                            }, ae.uniqueSort = function(e) {
                                var t, i = [],
                                    r = 0,
                                    o = 0;
                                if (h = !n.detectDuplicates, l = !n.sortStable && e.slice(0), e.sort(w), h) {
                                    for (; t = e[o++];) t === e[o] && (r = i.push(o));
                                    for (; r--;) e.splice(i[r], 1)
                                }
                                return l = null, e
                            }, r = ae.getText = function(e) {
                                var t, n = "",
                                    i = 0,
                                    o = e.nodeType;
                                if (o) {
                                    if (1 === o || 9 === o || 11 === o) {
                                        if ("string" == typeof e.textContent) return e.textContent;
                                        for (e = e.firstChild; e; e = e.nextSibling) n += r(e)
                                    } else if (3 === o || 4 === o) return e.nodeValue
                                } else
                                    for (; t = e[i++];) n += r(t);
                                return n
                            }, (i = ae.selectors = {
                                cacheLength: 50,
                                createPseudo: ce,
                                match: K,
                                attrHandle: {},
                                find: {},
                                relative: {
                                    ">": {
                                        dir: "parentNode",
                                        first: !0
                                    },
                                    " ": {
                                        dir: "parentNode"
                                    },
                                    "+": {
                                        dir: "previousSibling",
                                        first: !0
                                    },
                                    "~": {
                                        dir: "previousSibling"
                                    }
                                },
                                preFilter: {
                                    ATTR: function(e) {
                                        return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                                    },
                                    CHILD: function(e) {
                                        return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || ae.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && ae.error(e[0]), e
                                    },
                                    PSEUDO: function(e) {
                                        var t, n = !e[6] && e[2];
                                        return K.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && G.test(n) && (t = s(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
                                    }
                                },
                                filter: {
                                    TAG: function(e) {
                                        var t = e.replace(te, ne).toLowerCase();
                                        return "*" === e ? function() {
                                            return !0
                                        } : function(e) {
                                            return e.nodeName && e.nodeName.toLowerCase() === t
                                        }
                                    },
                                    CLASS: function(e) {
                                        var t = C[e + " "];
                                        return t || (t = new RegExp("(^|" + F + ")" + e + "(" + F + "|$)")) && C(e, (function(e) {
                                            return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "")
                                        }))
                                    },
                                    ATTR: function(e, t, n) {
                                        return function(i) {
                                            var r = ae.attr(i, e);
                                            return null == r ? "!=" === t : !t || (r += "", "=" === t ? r === n : "!=" === t ? r !== n : "^=" === t ? n && 0 === r.indexOf(n) : "*=" === t ? n && -1 < r.indexOf(n) : "$=" === t ? n && r.slice(-n.length) === n : "~=" === t ? -1 < (" " + r.replace(H, " ") + " ").indexOf(n) : "|=" === t && (r === n || r.slice(0, n.length + 1) === n + "-"))
                                        }
                                    },
                                    CHILD: function(e, t, n, i, r) {
                                        var o = "nth" !== e.slice(0, 3),
                                            s = "last" !== e.slice(-4),
                                            a = "of-type" === t;
                                        return 1 === i && 0 === r ? function(e) {
                                            return !!e.parentNode
                                        } : function(t, n, d) {
                                            var c, l, h, u, p, m, g = o !== s ? "nextSibling" : "previousSibling",
                                                f = t.parentNode,
                                                v = a && t.nodeName.toLowerCase(),
                                                _ = !d && !a,
                                                y = !1;
                                            if (f) {
                                                if (o) {
                                                    for (; g;) {
                                                        for (u = t; u = u[g];)
                                                            if (a ? u.nodeName.toLowerCase() === v : 1 === u.nodeType) return !1;
                                                        m = g = "only" === e && !m && "nextSibling"
                                                    }
                                                    return !0
                                                }
                                                if (m = [s ? f.firstChild : f.lastChild], s && _) {
                                                    for (y = (p = (c = (l = (h = (u = f)[E] || (u[E] = {}))[u.uniqueID] || (h[u.uniqueID] = {}))[e] || [])[0] === b && c[1]) && c[2], u = p && f.childNodes[p]; u = ++p && u && u[g] || (y = p = 0) || m.pop();)
                                                        if (1 === u.nodeType && ++y && u === t) {
                                                            l[e] = [b, p, y];
                                                            break
                                                        }
                                                } else if (_ && (y = p = (c = (l = (h = (u = t)[E] || (u[E] = {}))[u.uniqueID] || (h[u.uniqueID] = {}))[e] || [])[0] === b && c[1]), !1 === y)
                                                    for (;
                                                        (u = ++p && u && u[g] || (y = p = 0) || m.pop()) && ((a ? u.nodeName.toLowerCase() !== v : 1 !== u.nodeType) || !++y || (_ && ((l = (h = u[E] || (u[E] = {}))[u.uniqueID] || (h[u.uniqueID] = {}))[e] = [b, y]), u !== t)););
                                                return (y -= r) === i || y % i == 0 && 0 <= y / i
                                            }
                                        }
                                    },
                                    PSEUDO: function(e, t) {
                                        var n, r = i.pseudos[e] || i.setFilters[e.toLowerCase()] || ae.error("unsupported pseudo: " + e);
                                        return r[E] ? r(t) : 1 < r.length ? (n = [e, e, "", t], i.setFilters.hasOwnProperty(e.toLowerCase()) ? ce((function(e, n) {
                                            for (var i, o = r(e, t), s = o.length; s--;) e[i = M(e, o[s])] = !(n[i] = o[s])
                                        })) : function(e) {
                                            return r(e, 0, n)
                                        }) : r
                                    }
                                },
                                pseudos: {
                                    not: ce((function(e) {
                                        var t = [],
                                            n = [],
                                            i = a(e.replace($, "$1"));
                                        return i[E] ? ce((function(e, t, n, r) {
                                            for (var o, s = i(e, null, r, []), a = e.length; a--;)(o = s[a]) && (e[a] = !(t[a] = o))
                                        })) : function(e, r, o) {
                                            return t[0] = e, i(t, null, o, n), t[0] = null, !n.pop()
                                        }
                                    })),
                                    has: ce((function(e) {
                                        return function(t) {
                                            return 0 < ae(e, t).length
                                        }
                                    })),
                                    contains: ce((function(e) {
                                        return e = e.replace(te, ne),
                                            function(t) {
                                                return -1 < (t.textContent || r(t)).indexOf(e)
                                            }
                                    })),
                                    lang: ce((function(e) {
                                        return z.test(e || "") || ae.error("unsupported lang: " + e), e = e.replace(te, ne).toLowerCase(),
                                            function(t) {
                                                var n;
                                                do {
                                                    if (n = g ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-")
                                                } while ((t = t.parentNode) && 1 === t.nodeType);
                                                return !1
                                            }
                                    })),
                                    target: function(t) {
                                        var n = e.location && e.location.hash;
                                        return n && n.slice(1) === t.id
                                    },
                                    root: function(e) {
                                        return e === m
                                    },
                                    focus: function(e) {
                                        return e === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                                    },
                                    enabled: ge(!1),
                                    disabled: ge(!0),
                                    checked: function(e) {
                                        var t = e.nodeName.toLowerCase();
                                        return "input" === t && !!e.checked || "option" === t && !!e.selected
                                    },
                                    selected: function(e) {
                                        return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
                                    },
                                    empty: function(e) {
                                        for (e = e.firstChild; e; e = e.nextSibling)
                                            if (e.nodeType < 6) return !1;
                                        return !0
                                    },
                                    parent: function(e) {
                                        return !i.pseudos.empty(e)
                                    },
                                    header: function(e) {
                                        return Y.test(e.nodeName)
                                    },
                                    input: function(e) {
                                        return X.test(e.nodeName)
                                    },
                                    button: function(e) {
                                        var t = e.nodeName.toLowerCase();
                                        return "input" === t && "button" === e.type || "button" === t
                                    },
                                    text: function(e) {
                                        var t;
                                        return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                                    },
                                    first: fe((function() {
                                        return [0]
                                    })),
                                    last: fe((function(e, t) {
                                        return [t - 1]
                                    })),
                                    eq: fe((function(e, t, n) {
                                        return [n < 0 ? n + t : n]
                                    })),
                                    even: fe((function(e, t) {
                                        for (var n = 0; n < t; n += 2) e.push(n);
                                        return e
                                    })),
                                    odd: fe((function(e, t) {
                                        for (var n = 1; n < t; n += 2) e.push(n);
                                        return e
                                    })),
                                    lt: fe((function(e, t, n) {
                                        for (var i = n < 0 ? n + t : t < n ? t : n; 0 <= --i;) e.push(i);
                                        return e
                                    })),
                                    gt: fe((function(e, t, n) {
                                        for (var i = n < 0 ? n + t : n; ++i < t;) e.push(i);
                                        return e
                                    }))
                                }
                            }).pseudos.nth = i.pseudos.eq, {
                                radio: !0,
                                checkbox: !0,
                                file: !0,
                                password: !0,
                                image: !0
                            }) i.pseudos[t] = pe(t);
                        for (t in {
                                submit: !0,
                                reset: !0
                            }) i.pseudos[t] = me(t);

                        function _e() {}

                        function ye(e) {
                            for (var t = 0, n = e.length, i = ""; t < n; t++) i += e[t].value;
                            return i
                        }

                        function Ee(e, t, n) {
                            var i = t.dir,
                                r = t.next,
                                o = r || i,
                                s = n && "parentNode" === o,
                                a = T++;
                            return t.first ? function(t, n, r) {
                                for (; t = t[i];)
                                    if (1 === t.nodeType || s) return e(t, n, r);
                                return !1
                            } : function(t, n, d) {
                                var c, l, h, u = [b, a];
                                if (d) {
                                    for (; t = t[i];)
                                        if ((1 === t.nodeType || s) && e(t, n, d)) return !0
                                } else
                                    for (; t = t[i];)
                                        if (1 === t.nodeType || s)
                                            if (l = (h = t[E] || (t[E] = {}))[t.uniqueID] || (h[t.uniqueID] = {}), r && r === t.nodeName.toLowerCase()) t = t[i] || t;
                                            else {
                                                if ((c = l[o]) && c[0] === b && c[1] === a) return u[2] = c[2];
                                                if ((l[o] = u)[2] = e(t, n, d)) return !0
                                            } return !1
                            }
                        }

                        function Se(e) {
                            return 1 < e.length ? function(t, n, i) {
                                for (var r = e.length; r--;)
                                    if (!e[r](t, n, i)) return !1;
                                return !0
                            } : e[0]
                        }

                        function be(e, t, n, i, r) {
                            for (var o, s = [], a = 0, d = e.length, c = null != t; a < d; a++)(o = e[a]) && (n && !n(o, i, r) || (s.push(o), c && t.push(a)));
                            return s
                        }

                        function Te(e, t, n, i, r, o) {
                            return i && !i[E] && (i = Te(i)), r && !r[E] && (r = Te(r, o)), ce((function(o, s, a, d) {
                                var c, l, h, u = [],
                                    p = [],
                                    m = s.length,
                                    g = o || function(e, t, n) {
                                        for (var i = 0, r = t.length; i < r; i++) ae(e, t[i], n);
                                        return n
                                    }(t || "*", a.nodeType ? [a] : a, []),
                                    f = !e || !o && t ? g : be(g, u, e, a, d),
                                    v = n ? r || (o ? e : m || i) ? [] : s : f;
                                if (n && n(f, v, a, d), i)
                                    for (c = be(v, p), i(c, [], a, d), l = c.length; l--;)(h = c[l]) && (v[p[l]] = !(f[p[l]] = h));
                                if (o) {
                                    if (r || e) {
                                        if (r) {
                                            for (c = [], l = v.length; l--;)(h = v[l]) && c.push(f[l] = h);
                                            r(null, v = [], c, d)
                                        }
                                        for (l = v.length; l--;)(h = v[l]) && -1 < (c = r ? M(o, h) : u[l]) && (o[c] = !(s[c] = h))
                                    }
                                } else v = be(v === s ? v.splice(m, v.length) : v), r ? r(null, s, v, d) : N.apply(s, v)
                            }))
                        }

                        function Ce(e) {
                            for (var t, n, r, o = e.length, s = i.relative[e[0].type], a = s || i.relative[" "], d = s ? 1 : 0, l = Ee((function(e) {
                                    return e === t
                                }), a, !0), h = Ee((function(e) {
                                    return -1 < M(t, e)
                                }), a, !0), u = [function(e, n, i) {
                                    var r = !s && (i || n !== c) || ((t = n).nodeType ? l(e, n, i) : h(e, n, i));
                                    return t = null, r
                                }]; d < o; d++)
                                if (n = i.relative[e[d].type]) u = [Ee(Se(u), n)];
                                else {
                                    if ((n = i.filter[e[d].type].apply(null, e[d].matches))[E]) {
                                        for (r = ++d; r < o && !i.relative[e[r].type]; r++);
                                        return Te(1 < d && Se(u), 1 < d && ye(e.slice(0, d - 1).concat({
                                            value: " " === e[d - 2].type ? "*" : ""
                                        })).replace($, "$1"), n, d < r && Ce(e.slice(d, r)), r < o && Ce(e = e.slice(r)), r < o && ye(e))
                                    }
                                    u.push(n)
                                } return Se(u)
                        }
                        return _e.prototype = i.filters = i.pseudos, i.setFilters = new _e, s = ae.tokenize = function(e, t) {
                            var n, r, o, s, a, d, c, l = x[e + " "];
                            if (l) return t ? 0 : l.slice(0);
                            for (a = e, d = [], c = i.preFilter; a;) {
                                for (s in n && !(r = J.exec(a)) || (r && (a = a.slice(r[0].length) || a), d.push(o = [])), n = !1, (r = B.exec(a)) && (n = r.shift(), o.push({
                                        value: n,
                                        type: r[0].replace($, " ")
                                    }), a = a.slice(n.length)), i.filter) !(r = K[s].exec(a)) || c[s] && !(r = c[s](r)) || (n = r.shift(), o.push({
                                    value: n,
                                    type: s,
                                    matches: r
                                }), a = a.slice(n.length));
                                if (!n) break
                            }
                            return t ? a.length : a ? ae.error(e) : x(e, d).slice(0)
                        }, a = ae.compile = function(e, t) {
                            var n, r, o, a, d, l, h = [],
                                m = [],
                                f = R[e + " "];
                            if (!f) {
                                for (t || (t = s(e)), n = t.length; n--;)(f = Ce(t[n]))[E] ? h.push(f) : m.push(f);
                                (f = R(e, (r = m, a = 0 < (o = h).length, d = 0 < r.length, l = function(e, t, n, s, l) {
                                    var h, m, f, v = 0,
                                        _ = "0",
                                        y = e && [],
                                        E = [],
                                        S = c,
                                        T = e || d && i.find.TAG("*", l),
                                        C = b += null == S ? 1 : Math.random() || .1,
                                        x = T.length;
                                    for (l && (c = t == p || t || l); _ !== x && null != (h = T[_]); _++) {
                                        if (d && h) {
                                            for (m = 0, t || h.ownerDocument == p || (u(h), n = !g); f = r[m++];)
                                                if (f(h, t || p, n)) {
                                                    s.push(h);
                                                    break
                                                } l && (b = C)
                                        }
                                        a && ((h = !f && h) && v--, e && y.push(h))
                                    }
                                    if (v += _, a && _ !== v) {
                                        for (m = 0; f = o[m++];) f(y, E, t, n);
                                        if (e) {
                                            if (0 < v)
                                                for (; _--;) y[_] || E[_] || (E[_] = D.call(s));
                                            E = be(E)
                                        }
                                        N.apply(s, E), l && !e && 0 < E.length && 1 < v + o.length && ae.uniqueSort(s)
                                    }
                                    return l && (b = C, c = S), y
                                }, a ? ce(l) : l))).selector = e
                            }
                            return f
                        }, d = ae.select = function(e, t, n, r) {
                            var o, d, c, l, h, u = "function" == typeof e && e,
                                p = !r && s(e = u.selector || e);
                            if (n = n || [], 1 === p.length) {
                                if (2 < (d = p[0] = p[0].slice(0)).length && "ID" === (c = d[0]).type && 9 === t.nodeType && g && i.relative[d[1].type]) {
                                    if (!(t = (i.find.ID(c.matches[0].replace(te, ne), t) || [])[0])) return n;
                                    u && (t = t.parentNode), e = e.slice(d.shift().value.length)
                                }
                                for (o = K.needsContext.test(e) ? 0 : d.length; o-- && (c = d[o], !i.relative[l = c.type]);)
                                    if ((h = i.find[l]) && (r = h(c.matches[0].replace(te, ne), ee.test(d[0].type) && ve(t.parentNode) || t))) {
                                        if (d.splice(o, 1), !(e = r.length && ye(d))) return N.apply(n, r), n;
                                        break
                                    }
                            }
                            return (u || a(e, p))(r, t, !g, n, !t || ee.test(e) && ve(t.parentNode) || t), n
                        }, n.sortStable = E.split("").sort(w).join("") === E, n.detectDuplicates = !!h, u(), n.sortDetached = le((function(e) {
                            return 1 & e.compareDocumentPosition(p.createElement("fieldset"))
                        })), le((function(e) {
                            return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
                        })) || he("type|href|height|width", (function(e, t, n) {
                            if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
                        })), n.attributes && le((function(e) {
                            return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
                        })) || he("value", (function(e, t, n) {
                            if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue
                        })), le((function(e) {
                            return null == e.getAttribute("disabled")
                        })) || he(L, (function(e, t, n) {
                            var i;
                            if (!n) return !0 === e[t] ? t.toLowerCase() : (i = e.getAttributeNode(t)) && i.specified ? i.value : null
                        })), ae
                    }(i);
                    C.find = R, C.expr = R.selectors, C.expr[":"] = C.expr.pseudos, C.uniqueSort = C.unique = R.uniqueSort, C.text = R.getText, C.isXMLDoc = R.isXML, C.contains = R.contains, C.escapeSelector = R.escape;
                    var A = function(e, t, n) {
                            for (var i = [], r = void 0 !== n;
                                (e = e[t]) && 9 !== e.nodeType;)
                                if (1 === e.nodeType) {
                                    if (r && C(e).is(n)) break;
                                    i.push(e)
                                } return i
                        },
                        w = function(e, t) {
                            for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
                            return n
                        },
                        I = C.expr.match.needsContext;

                    function P(e, t) {
                        return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
                    }
                    var D = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

                    function O(e, t, n) {
                        return v(t) ? C.grep(e, (function(e, i) {
                            return !!t.call(e, i, e) !== n
                        })) : t.nodeType ? C.grep(e, (function(e) {
                            return e === t !== n
                        })) : "string" != typeof t ? C.grep(e, (function(e) {
                            return -1 < l.call(t, e) !== n
                        })) : C.filter(t, e, n)
                    }
                    C.filter = function(e, t, n) {
                        var i = t[0];
                        return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === i.nodeType ? C.find.matchesSelector(i, e) ? [i] : [] : C.find.matches(e, C.grep(t, (function(e) {
                            return 1 === e.nodeType
                        })))
                    }, C.fn.extend({
                        find: function(e) {
                            var t, n, i = this.length,
                                r = this;
                            if ("string" != typeof e) return this.pushStack(C(e).filter((function() {
                                for (t = 0; t < i; t++)
                                    if (C.contains(r[t], this)) return !0
                            })));
                            for (n = this.pushStack([]), t = 0; t < i; t++) C.find(e, r[t], n);
                            return 1 < i ? C.uniqueSort(n) : n
                        },
                        filter: function(e) {
                            return this.pushStack(O(this, e || [], !1))
                        },
                        not: function(e) {
                            return this.pushStack(O(this, e || [], !0))
                        },
                        is: function(e) {
                            return !!O(this, "string" == typeof e && I.test(e) ? C(e) : e || [], !1).length
                        }
                    });
                    var N, k = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
                    (C.fn.init = function(e, t, n) {
                        var i, r;
                        if (!e) return this;
                        if (n = n || N, "string" == typeof e) {
                            if (!(i = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : k.exec(e)) || !i[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
                            if (i[1]) {
                                if (t = t instanceof C ? t[0] : t, C.merge(this, C.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : y, !0)), D.test(i[1]) && C.isPlainObject(t))
                                    for (i in t) v(this[i]) ? this[i](t[i]) : this.attr(i, t[i]);
                                return this
                            }
                            return (r = y.getElementById(i[2])) && (this[0] = r, this.length = 1), this
                        }
                        return e.nodeType ? (this[0] = e, this.length = 1, this) : v(e) ? void 0 !== n.ready ? n.ready(e) : e(C) : C.makeArray(e, this)
                    }).prototype = C.fn, N = C(y);
                    var M = /^(?:parents|prev(?:Until|All))/,
                        L = {
                            children: !0,
                            contents: !0,
                            next: !0,
                            prev: !0
                        };

                    function F(e, t) {
                        for (;
                            (e = e[t]) && 1 !== e.nodeType;);
                        return e
                    }
                    C.fn.extend({
                        has: function(e) {
                            var t = C(e, this),
                                n = t.length;
                            return this.filter((function() {
                                for (var e = 0; e < n; e++)
                                    if (C.contains(this, t[e])) return !0
                            }))
                        },
                        closest: function(e, t) {
                            var n, i = 0,
                                r = this.length,
                                o = [],
                                s = "string" != typeof e && C(e);
                            if (!I.test(e))
                                for (; i < r; i++)
                                    for (n = this[i]; n && n !== t; n = n.parentNode)
                                        if (n.nodeType < 11 && (s ? -1 < s.index(n) : 1 === n.nodeType && C.find.matchesSelector(n, e))) {
                                            o.push(n);
                                            break
                                        } return this.pushStack(1 < o.length ? C.uniqueSort(o) : o)
                        },
                        index: function(e) {
                            return e ? "string" == typeof e ? l.call(C(e), this[0]) : l.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                        },
                        add: function(e, t) {
                            return this.pushStack(C.uniqueSort(C.merge(this.get(), C(e, t))))
                        },
                        addBack: function(e) {
                            return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
                        }
                    }), C.each({
                        parent: function(e) {
                            var t = e.parentNode;
                            return t && 11 !== t.nodeType ? t : null
                        },
                        parents: function(e) {
                            return A(e, "parentNode")
                        },
                        parentsUntil: function(e, t, n) {
                            return A(e, "parentNode", n)
                        },
                        next: function(e) {
                            return F(e, "nextSibling")
                        },
                        prev: function(e) {
                            return F(e, "previousSibling")
                        },
                        nextAll: function(e) {
                            return A(e, "nextSibling")
                        },
                        prevAll: function(e) {
                            return A(e, "previousSibling")
                        },
                        nextUntil: function(e, t, n) {
                            return A(e, "nextSibling", n)
                        },
                        prevUntil: function(e, t, n) {
                            return A(e, "previousSibling", n)
                        },
                        siblings: function(e) {
                            return w((e.parentNode || {}).firstChild, e)
                        },
                        children: function(e) {
                            return w(e.firstChild)
                        },
                        contents: function(e) {
                            return null != e.contentDocument && s(e.contentDocument) ? e.contentDocument : (P(e, "template") && (e = e.content || e), C.merge([], e.childNodes))
                        }
                    }, (function(e, t) {
                        C.fn[e] = function(n, i) {
                            var r = C.map(this, t, n);
                            return "Until" !== e.slice(-5) && (i = n), i && "string" == typeof i && (r = C.filter(i, r)), 1 < this.length && (L[e] || C.uniqueSort(r), M.test(e) && r.reverse()), this.pushStack(r)
                        }
                    }));
                    var j = /[^\x20\t\r\n\f]+/g;

                    function V(e) {
                        return e
                    }

                    function U(e) {
                        throw e
                    }

                    function H(e, t, n, i) {
                        var r;
                        try {
                            e && v(r = e.promise) ? r.call(e).done(t).fail(n) : e && v(r = e.then) ? r.call(e, t, n) : t.apply(void 0, [e].slice(i))
                        } catch (e) {
                            n.apply(void 0, [e])
                        }
                    }
                    C.Callbacks = function(e) {
                        var t, n;
                        e = "string" == typeof e ? (t = e, n = {}, C.each(t.match(j) || [], (function(e, t) {
                            n[t] = !0
                        })), n) : C.extend({}, e);
                        var i, r, o, s, a = [],
                            d = [],
                            c = -1,
                            l = function() {
                                for (s = s || e.once, o = i = !0; d.length; c = -1)
                                    for (r = d.shift(); ++c < a.length;) !1 === a[c].apply(r[0], r[1]) && e.stopOnFalse && (c = a.length, r = !1);
                                e.memory || (r = !1), i = !1, s && (a = r ? [] : "")
                            },
                            h = {
                                add: function() {
                                    return a && (r && !i && (c = a.length - 1, d.push(r)), function t(n) {
                                        C.each(n, (function(n, i) {
                                            v(i) ? e.unique && h.has(i) || a.push(i) : i && i.length && "string" !== b(i) && t(i)
                                        }))
                                    }(arguments), r && !i && l()), this
                                },
                                remove: function() {
                                    return C.each(arguments, (function(e, t) {
                                        for (var n; - 1 < (n = C.inArray(t, a, n));) a.splice(n, 1), n <= c && c--
                                    })), this
                                },
                                has: function(e) {
                                    return e ? -1 < C.inArray(e, a) : 0 < a.length
                                },
                                empty: function() {
                                    return a && (a = []), this
                                },
                                disable: function() {
                                    return s = d = [], a = r = "", this
                                },
                                disabled: function() {
                                    return !a
                                },
                                lock: function() {
                                    return s = d = [], r || i || (a = r = ""), this
                                },
                                locked: function() {
                                    return !!s
                                },
                                fireWith: function(e, t) {
                                    return s || (t = [e, (t = t || []).slice ? t.slice() : t], d.push(t), i || l()), this
                                },
                                fire: function() {
                                    return h.fireWith(this, arguments), this
                                },
                                fired: function() {
                                    return !!o
                                }
                            };
                        return h
                    }, C.extend({
                        Deferred: function(e) {
                            var t = [
                                    ["notify", "progress", C.Callbacks("memory"), C.Callbacks("memory"), 2],
                                    ["resolve", "done", C.Callbacks("once memory"), C.Callbacks("once memory"), 0, "resolved"],
                                    ["reject", "fail", C.Callbacks("once memory"), C.Callbacks("once memory"), 1, "rejected"]
                                ],
                                n = "pending",
                                r = {
                                    state: function() {
                                        return n
                                    },
                                    always: function() {
                                        return o.done(arguments).fail(arguments), this
                                    },
                                    catch: function(e) {
                                        return r.then(null, e)
                                    },
                                    pipe: function() {
                                        var e = arguments;
                                        return C.Deferred((function(n) {
                                            C.each(t, (function(t, i) {
                                                var r = v(e[i[4]]) && e[i[4]];
                                                o[i[1]]((function() {
                                                    var e = r && r.apply(this, arguments);
                                                    e && v(e.promise) ? e.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[i[0] + "With"](this, r ? [e] : arguments)
                                                }))
                                            })), e = null
                                        })).promise()
                                    },
                                    then: function(e, n, r) {
                                        var o = 0;

                                        function s(e, t, n, r) {
                                            return function() {
                                                var a = this,
                                                    d = arguments,
                                                    c = function() {
                                                        var i, c;
                                                        if (!(e < o)) {
                                                            if ((i = n.apply(a, d)) === t.promise()) throw new TypeError("Thenable self-resolution");
                                                            c = i && ("object" == typeof i || "function" == typeof i) && i.then, v(c) ? r ? c.call(i, s(o, t, V, r), s(o, t, U, r)) : (o++, c.call(i, s(o, t, V, r), s(o, t, U, r), s(o, t, V, t.notifyWith))) : (n !== V && (a = void 0, d = [i]), (r || t.resolveWith)(a, d))
                                                        }
                                                    },
                                                    l = r ? c : function() {
                                                        try {
                                                            c()
                                                        } catch (i) {
                                                            C.Deferred.exceptionHook && C.Deferred.exceptionHook(i, l.stackTrace), o <= e + 1 && (n !== U && (a = void 0, d = [i]), t.rejectWith(a, d))
                                                        }
                                                    };
                                                e ? l() : (C.Deferred.getStackHook && (l.stackTrace = C.Deferred.getStackHook()), i.setTimeout(l))
                                            }
                                        }
                                        return C.Deferred((function(i) {
                                            t[0][3].add(s(0, i, v(r) ? r : V, i.notifyWith)), t[1][3].add(s(0, i, v(e) ? e : V)), t[2][3].add(s(0, i, v(n) ? n : U))
                                        })).promise()
                                    },
                                    promise: function(e) {
                                        return null != e ? C.extend(e, r) : r
                                    }
                                },
                                o = {};
                            return C.each(t, (function(e, i) {
                                var s = i[2],
                                    a = i[5];
                                r[i[1]] = s.add, a && s.add((function() {
                                    n = a
                                }), t[3 - e][2].disable, t[3 - e][3].disable, t[0][2].lock, t[0][3].lock), s.add(i[3].fire), o[i[0]] = function() {
                                    return o[i[0] + "With"](this === o ? void 0 : this, arguments), this
                                }, o[i[0] + "With"] = s.fireWith
                            })), r.promise(o), e && e.call(o, o), o
                        },
                        when: function(e) {
                            var t = arguments.length,
                                n = t,
                                i = Array(n),
                                r = a.call(arguments),
                                o = C.Deferred(),
                                s = function(e) {
                                    return function(n) {
                                        i[e] = this, r[e] = 1 < arguments.length ? a.call(arguments) : n, --t || o.resolveWith(i, r)
                                    }
                                };
                            if (t <= 1 && (H(e, o.done(s(n)).resolve, o.reject, !t), "pending" === o.state() || v(r[n] && r[n].then))) return o.then();
                            for (; n--;) H(r[n], s(n), o.reject);
                            return o.promise()
                        }
                    });
                    var $ = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
                    C.Deferred.exceptionHook = function(e, t) {
                        i.console && i.console.warn && e && $.test(e.name) && i.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
                    }, C.readyException = function(e) {
                        i.setTimeout((function() {
                            throw e
                        }))
                    };
                    var J = C.Deferred();

                    function B() {
                        y.removeEventListener("DOMContentLoaded", B), i.removeEventListener("load", B), C.ready()
                    }
                    C.fn.ready = function(e) {
                        return J.then(e).catch((function(e) {
                            C.readyException(e)
                        })), this
                    }, C.extend({
                        isReady: !1,
                        readyWait: 1,
                        ready: function(e) {
                            (!0 === e ? --C.readyWait : C.isReady) || (C.isReady = !0) !== e && 0 < --C.readyWait || J.resolveWith(y, [C])
                        }
                    }), C.ready.then = J.then, "complete" === y.readyState || "loading" !== y.readyState && !y.documentElement.doScroll ? i.setTimeout(C.ready) : (y.addEventListener("DOMContentLoaded", B), i.addEventListener("load", B));
                    var q = function(e, t, n, i, r, o, s) {
                            var a = 0,
                                d = e.length,
                                c = null == n;
                            if ("object" === b(n))
                                for (a in r = !0, n) q(e, t, a, n[a], !0, o, s);
                            else if (void 0 !== i && (r = !0, v(i) || (s = !0), c && (s ? (t.call(e, i), t = null) : (c = t, t = function(e, t, n) {
                                    return c.call(C(e), n)
                                })), t))
                                for (; a < d; a++) t(e[a], n, s ? i : i.call(e[a], a, t(e[a], n)));
                            return r ? e : c ? t.call(e) : d ? t(e[0], n) : o
                        },
                        G = /^-ms-/,
                        z = /-([a-z])/g;

                    function K(e, t) {
                        return t.toUpperCase()
                    }

                    function W(e) {
                        return e.replace(G, "ms-").replace(z, K)
                    }
                    var X = function(e) {
                        return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
                    };

                    function Y() {
                        this.expando = C.expando + Y.uid++
                    }
                    Y.uid = 1, Y.prototype = {
                        cache: function(e) {
                            var t = e[this.expando];
                            return t || (t = {}, X(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                                value: t,
                                configurable: !0
                            }))), t
                        },
                        set: function(e, t, n) {
                            var i, r = this.cache(e);
                            if ("string" == typeof t) r[W(t)] = n;
                            else
                                for (i in t) r[W(i)] = t[i];
                            return r
                        },
                        get: function(e, t) {
                            return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][W(t)]
                        },
                        access: function(e, t, n) {
                            return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t)
                        },
                        remove: function(e, t) {
                            var n, i = e[this.expando];
                            if (void 0 !== i) {
                                if (void 0 !== t) {
                                    n = (t = Array.isArray(t) ? t.map(W) : (t = W(t)) in i ? [t] : t.match(j) || []).length;
                                    for (; n--;) delete i[t[n]]
                                }(void 0 === t || C.isEmptyObject(i)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
                            }
                        },
                        hasData: function(e) {
                            var t = e[this.expando];
                            return void 0 !== t && !C.isEmptyObject(t)
                        }
                    };
                    var Q = new Y,
                        Z = new Y,
                        ee = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                        te = /[A-Z]/g;

                    function ne(e, t, n) {
                        var i, r;
                        if (void 0 === n && 1 === e.nodeType)
                            if (i = "data-" + t.replace(te, "-$&").toLowerCase(), "string" == typeof(n = e.getAttribute(i))) {
                                try {
                                    n = "true" === (r = n) || "false" !== r && ("null" === r ? null : r === +r + "" ? +r : ee.test(r) ? JSON.parse(r) : r)
                                } catch (e) {}
                                Z.set(e, t, n)
                            } else n = void 0;
                        return n
                    }
                    C.extend({
                        hasData: function(e) {
                            return Z.hasData(e) || Q.hasData(e)
                        },
                        data: function(e, t, n) {
                            return Z.access(e, t, n)
                        },
                        removeData: function(e, t) {
                            Z.remove(e, t)
                        },
                        _data: function(e, t, n) {
                            return Q.access(e, t, n)
                        },
                        _removeData: function(e, t) {
                            Q.remove(e, t)
                        }
                    }), C.fn.extend({
                        data: function(e, t) {
                            var n, i, r, o = this[0],
                                s = o && o.attributes;
                            if (void 0 === e) {
                                if (this.length && (r = Z.get(o), 1 === o.nodeType && !Q.get(o, "hasDataAttrs"))) {
                                    for (n = s.length; n--;) s[n] && 0 === (i = s[n].name).indexOf("data-") && (i = W(i.slice(5)), ne(o, i, r[i]));
                                    Q.set(o, "hasDataAttrs", !0)
                                }
                                return r
                            }
                            return "object" == typeof e ? this.each((function() {
                                Z.set(this, e)
                            })) : q(this, (function(t) {
                                var n;
                                if (o && void 0 === t) return void 0 !== (n = Z.get(o, e)) || void 0 !== (n = ne(o, e)) ? n : void 0;
                                this.each((function() {
                                    Z.set(this, e, t)
                                }))
                            }), null, t, 1 < arguments.length, null, !0)
                        },
                        removeData: function(e) {
                            return this.each((function() {
                                Z.remove(this, e)
                            }))
                        }
                    }), C.extend({
                        queue: function(e, t, n) {
                            var i;
                            if (e) return t = (t || "fx") + "queue", i = Q.get(e, t), n && (!i || Array.isArray(n) ? i = Q.access(e, t, C.makeArray(n)) : i.push(n)), i || []
                        },
                        dequeue: function(e, t) {
                            t = t || "fx";
                            var n = C.queue(e, t),
                                i = n.length,
                                r = n.shift(),
                                o = C._queueHooks(e, t);
                            "inprogress" === r && (r = n.shift(), i--), r && ("fx" === t && n.unshift("inprogress"), delete o.stop, r.call(e, (function() {
                                C.dequeue(e, t)
                            }), o)), !i && o && o.empty.fire()
                        },
                        _queueHooks: function(e, t) {
                            var n = t + "queueHooks";
                            return Q.get(e, n) || Q.access(e, n, {
                                empty: C.Callbacks("once memory").add((function() {
                                    Q.remove(e, [t + "queue", n])
                                }))
                            })
                        }
                    }), C.fn.extend({
                        queue: function(e, t) {
                            var n = 2;
                            return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? C.queue(this[0], e) : void 0 === t ? this : this.each((function() {
                                var n = C.queue(this, e, t);
                                C._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && C.dequeue(this, e)
                            }))
                        },
                        dequeue: function(e) {
                            return this.each((function() {
                                C.dequeue(this, e)
                            }))
                        },
                        clearQueue: function(e) {
                            return this.queue(e || "fx", [])
                        },
                        promise: function(e, t) {
                            var n, i = 1,
                                r = C.Deferred(),
                                o = this,
                                s = this.length,
                                a = function() {
                                    --i || r.resolveWith(o, [o])
                                };
                            for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; s--;)(n = Q.get(o[s], e + "queueHooks")) && n.empty && (i++, n.empty.add(a));
                            return a(), r.promise(t)
                        }
                    });
                    var ie = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
                        re = new RegExp("^(?:([+-])=|)(" + ie + ")([a-z%]*)$", "i"),
                        oe = ["Top", "Right", "Bottom", "Left"],
                        se = y.documentElement,
                        ae = function(e) {
                            return C.contains(e.ownerDocument, e)
                        },
                        de = {
                            composed: !0
                        };
                    se.getRootNode && (ae = function(e) {
                        return C.contains(e.ownerDocument, e) || e.getRootNode(de) === e.ownerDocument
                    });
                    var ce = function(e, t) {
                            return "none" === (e = t || e).style.display || "" === e.style.display && ae(e) && "none" === C.css(e, "display")
                        },
                        le = {};

                    function he(e, t) {
                        for (var n, i, r, o, s, a, d, c = [], l = 0, h = e.length; l < h; l++)(i = e[l]).style && (n = i.style.display, t ? ("none" === n && (c[l] = Q.get(i, "display") || null, c[l] || (i.style.display = "")), "" === i.style.display && ce(i) && (c[l] = (d = s = o = void 0, s = (r = i).ownerDocument, a = r.nodeName, (d = le[a]) || (o = s.body.appendChild(s.createElement(a)), d = C.css(o, "display"), o.parentNode.removeChild(o), "none" === d && (d = "block"), le[a] = d)))) : "none" !== n && (c[l] = "none", Q.set(i, "display", n)));
                        for (l = 0; l < h; l++) null != c[l] && (e[l].style.display = c[l]);
                        return e
                    }
                    C.fn.extend({
                        show: function() {
                            return he(this, !0)
                        },
                        hide: function() {
                            return he(this)
                        },
                        toggle: function(e) {
                            return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each((function() {
                                ce(this) ? C(this).show() : C(this).hide()
                            }))
                        }
                    });
                    var ue, pe, me = /^(?:checkbox|radio)$/i,
                        ge = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
                        fe = /^$|^module$|\/(?:java|ecma)script/i;
                    ue = y.createDocumentFragment().appendChild(y.createElement("div")), (pe = y.createElement("input")).setAttribute("type", "radio"), pe.setAttribute("checked", "checked"), pe.setAttribute("name", "t"), ue.appendChild(pe), f.checkClone = ue.cloneNode(!0).cloneNode(!0).lastChild.checked, ue.innerHTML = "<textarea>x</textarea>", f.noCloneChecked = !!ue.cloneNode(!0).lastChild.defaultValue, ue.innerHTML = "<option></option>", f.option = !!ue.lastChild;
                    var ve = {
                        thead: [1, "<table>", "</table>"],
                        col: [2, "<table><colgroup>", "</colgroup></table>"],
                        tr: [2, "<table><tbody>", "</tbody></table>"],
                        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                        _default: [0, "", ""]
                    };

                    function _e(e, t) {
                        var n;
                        return n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && P(e, t) ? C.merge([e], n) : n
                    }

                    function ye(e, t) {
                        for (var n = 0, i = e.length; n < i; n++) Q.set(e[n], "globalEval", !t || Q.get(t[n], "globalEval"))
                    }
                    ve.tbody = ve.tfoot = ve.colgroup = ve.caption = ve.thead, ve.th = ve.td, f.option || (ve.optgroup = ve.option = [1, "<select multiple='multiple'>", "</select>"]);
                    var Ee = /<|&#?\w+;/;

                    function Se(e, t, n, i, r) {
                        for (var o, s, a, d, c, l, h = t.createDocumentFragment(), u = [], p = 0, m = e.length; p < m; p++)
                            if ((o = e[p]) || 0 === o)
                                if ("object" === b(o)) C.merge(u, o.nodeType ? [o] : o);
                                else if (Ee.test(o)) {
                            for (s = s || h.appendChild(t.createElement("div")), a = (ge.exec(o) || ["", ""])[1].toLowerCase(), d = ve[a] || ve._default, s.innerHTML = d[1] + C.htmlPrefilter(o) + d[2], l = d[0]; l--;) s = s.lastChild;
                            C.merge(u, s.childNodes), (s = h.firstChild).textContent = ""
                        } else u.push(t.createTextNode(o));
                        for (h.textContent = "", p = 0; o = u[p++];)
                            if (i && -1 < C.inArray(o, i)) r && r.push(o);
                            else if (c = ae(o), s = _e(h.appendChild(o), "script"), c && ye(s), n)
                            for (l = 0; o = s[l++];) fe.test(o.type || "") && n.push(o);
                        return h
                    }
                    var be = /^([^.]*)(?:\.(.+)|)/;

                    function Te() {
                        return !0
                    }

                    function Ce() {
                        return !1
                    }

                    function xe(e, t) {
                        return e === function() {
                            try {
                                return y.activeElement
                            } catch (e) {}
                        }() == ("focus" === t)
                    }

                    function Re(e, t, n, i, r, o) {
                        var s, a;
                        if ("object" == typeof t) {
                            for (a in "string" != typeof n && (i = i || n, n = void 0), t) Re(e, a, n, i, t[a], o);
                            return e
                        }
                        if (null == i && null == r ? (r = n, i = n = void 0) : null == r && ("string" == typeof n ? (r = i, i = void 0) : (r = i, i = n, n = void 0)), !1 === r) r = Ce;
                        else if (!r) return e;
                        return 1 === o && (s = r, (r = function(e) {
                            return C().off(e), s.apply(this, arguments)
                        }).guid = s.guid || (s.guid = C.guid++)), e.each((function() {
                            C.event.add(this, t, r, i, n)
                        }))
                    }

                    function Ae(e, t, n) {
                        n ? (Q.set(e, t, !1), C.event.add(e, t, {
                            namespace: !1,
                            handler: function(e) {
                                var i, r, o = Q.get(this, t);
                                if (1 & e.isTrigger && this[t]) {
                                    if (o.length)(C.event.special[t] || {}).delegateType && e.stopPropagation();
                                    else if (o = a.call(arguments), Q.set(this, t, o), i = n(this, t), this[t](), o !== (r = Q.get(this, t)) || i ? Q.set(this, t, !1) : r = {}, o !== r) return e.stopImmediatePropagation(), e.preventDefault(), r && r.value
                                } else o.length && (Q.set(this, t, {
                                    value: C.event.trigger(C.extend(o[0], C.Event.prototype), o.slice(1), this)
                                }), e.stopImmediatePropagation())
                            }
                        })) : void 0 === Q.get(e, t) && C.event.add(e, t, Te)
                    }
                    C.event = {
                        global: {},
                        add: function(e, t, n, i, r) {
                            var o, s, a, d, c, l, h, u, p, m, g, f = Q.get(e);
                            if (X(e))
                                for (n.handler && (n = (o = n).handler, r = o.selector), r && C.find.matchesSelector(se, r), n.guid || (n.guid = C.guid++), (d = f.events) || (d = f.events = Object.create(null)), (s = f.handle) || (s = f.handle = function(t) {
                                        return void 0 !== C && C.event.triggered !== t.type ? C.event.dispatch.apply(e, arguments) : void 0
                                    }), c = (t = (t || "").match(j) || [""]).length; c--;) p = g = (a = be.exec(t[c]) || [])[1], m = (a[2] || "").split(".").sort(), p && (h = C.event.special[p] || {}, p = (r ? h.delegateType : h.bindType) || p, h = C.event.special[p] || {}, l = C.extend({
                                    type: p,
                                    origType: g,
                                    data: i,
                                    handler: n,
                                    guid: n.guid,
                                    selector: r,
                                    needsContext: r && C.expr.match.needsContext.test(r),
                                    namespace: m.join(".")
                                }, o), (u = d[p]) || ((u = d[p] = []).delegateCount = 0, h.setup && !1 !== h.setup.call(e, i, m, s) || e.addEventListener && e.addEventListener(p, s)), h.add && (h.add.call(e, l), l.handler.guid || (l.handler.guid = n.guid)), r ? u.splice(u.delegateCount++, 0, l) : u.push(l), C.event.global[p] = !0)
                        },
                        remove: function(e, t, n, i, r) {
                            var o, s, a, d, c, l, h, u, p, m, g, f = Q.hasData(e) && Q.get(e);
                            if (f && (d = f.events)) {
                                for (c = (t = (t || "").match(j) || [""]).length; c--;)
                                    if (p = g = (a = be.exec(t[c]) || [])[1], m = (a[2] || "").split(".").sort(), p) {
                                        for (h = C.event.special[p] || {}, u = d[p = (i ? h.delegateType : h.bindType) || p] || [], a = a[2] && new RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)"), s = o = u.length; o--;) l = u[o], !r && g !== l.origType || n && n.guid !== l.guid || a && !a.test(l.namespace) || i && i !== l.selector && ("**" !== i || !l.selector) || (u.splice(o, 1), l.selector && u.delegateCount--, h.remove && h.remove.call(e, l));
                                        s && !u.length && (h.teardown && !1 !== h.teardown.call(e, m, f.handle) || C.removeEvent(e, p, f.handle), delete d[p])
                                    } else
                                        for (p in d) C.event.remove(e, p + t[c], n, i, !0);
                                C.isEmptyObject(d) && Q.remove(e, "handle events")
                            }
                        },
                        dispatch: function(e) {
                            var t, n, i, r, o, s, a = new Array(arguments.length),
                                d = C.event.fix(e),
                                c = (Q.get(this, "events") || Object.create(null))[d.type] || [],
                                l = C.event.special[d.type] || {};
                            for (a[0] = d, t = 1; t < arguments.length; t++) a[t] = arguments[t];
                            if (d.delegateTarget = this, !l.preDispatch || !1 !== l.preDispatch.call(this, d)) {
                                for (s = C.event.handlers.call(this, d, c), t = 0;
                                    (r = s[t++]) && !d.isPropagationStopped();)
                                    for (d.currentTarget = r.elem, n = 0;
                                        (o = r.handlers[n++]) && !d.isImmediatePropagationStopped();) d.rnamespace && !1 !== o.namespace && !d.rnamespace.test(o.namespace) || (d.handleObj = o, d.data = o.data, void 0 !== (i = ((C.event.special[o.origType] || {}).handle || o.handler).apply(r.elem, a)) && !1 === (d.result = i) && (d.preventDefault(), d.stopPropagation()));
                                return l.postDispatch && l.postDispatch.call(this, d), d.result
                            }
                        },
                        handlers: function(e, t) {
                            var n, i, r, o, s, a = [],
                                d = t.delegateCount,
                                c = e.target;
                            if (d && c.nodeType && !("click" === e.type && 1 <= e.button))
                                for (; c !== this; c = c.parentNode || this)
                                    if (1 === c.nodeType && ("click" !== e.type || !0 !== c.disabled)) {
                                        for (o = [], s = {}, n = 0; n < d; n++) void 0 === s[r = (i = t[n]).selector + " "] && (s[r] = i.needsContext ? -1 < C(r, this).index(c) : C.find(r, this, null, [c]).length), s[r] && o.push(i);
                                        o.length && a.push({
                                            elem: c,
                                            handlers: o
                                        })
                                    } return c = this, d < t.length && a.push({
                                elem: c,
                                handlers: t.slice(d)
                            }), a
                        },
                        addProp: function(e, t) {
                            Object.defineProperty(C.Event.prototype, e, {
                                enumerable: !0,
                                configurable: !0,
                                get: v(t) ? function() {
                                    if (this.originalEvent) return t(this.originalEvent)
                                } : function() {
                                    if (this.originalEvent) return this.originalEvent[e]
                                },
                                set: function(t) {
                                    Object.defineProperty(this, e, {
                                        enumerable: !0,
                                        configurable: !0,
                                        writable: !0,
                                        value: t
                                    })
                                }
                            })
                        },
                        fix: function(e) {
                            return e[C.expando] ? e : new C.Event(e)
                        },
                        special: {
                            load: {
                                noBubble: !0
                            },
                            click: {
                                setup: function(e) {
                                    var t = this || e;
                                    return me.test(t.type) && t.click && P(t, "input") && Ae(t, "click", Te), !1
                                },
                                trigger: function(e) {
                                    var t = this || e;
                                    return me.test(t.type) && t.click && P(t, "input") && Ae(t, "click"), !0
                                },
                                _default: function(e) {
                                    var t = e.target;
                                    return me.test(t.type) && t.click && P(t, "input") && Q.get(t, "click") || P(t, "a")
                                }
                            },
                            beforeunload: {
                                postDispatch: function(e) {
                                    void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                                }
                            }
                        }
                    }, C.removeEvent = function(e, t, n) {
                        e.removeEventListener && e.removeEventListener(t, n)
                    }, C.Event = function(e, t) {
                        if (!(this instanceof C.Event)) return new C.Event(e, t);
                        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Te : Ce, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && C.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[C.expando] = !0
                    }, C.Event.prototype = {
                        constructor: C.Event,
                        isDefaultPrevented: Ce,
                        isPropagationStopped: Ce,
                        isImmediatePropagationStopped: Ce,
                        isSimulated: !1,
                        preventDefault: function() {
                            var e = this.originalEvent;
                            this.isDefaultPrevented = Te, e && !this.isSimulated && e.preventDefault()
                        },
                        stopPropagation: function() {
                            var e = this.originalEvent;
                            this.isPropagationStopped = Te, e && !this.isSimulated && e.stopPropagation()
                        },
                        stopImmediatePropagation: function() {
                            var e = this.originalEvent;
                            this.isImmediatePropagationStopped = Te, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
                        }
                    }, C.each({
                        altKey: !0,
                        bubbles: !0,
                        cancelable: !0,
                        changedTouches: !0,
                        ctrlKey: !0,
                        detail: !0,
                        eventPhase: !0,
                        metaKey: !0,
                        pageX: !0,
                        pageY: !0,
                        shiftKey: !0,
                        view: !0,
                        char: !0,
                        code: !0,
                        charCode: !0,
                        key: !0,
                        keyCode: !0,
                        button: !0,
                        buttons: !0,
                        clientX: !0,
                        clientY: !0,
                        offsetX: !0,
                        offsetY: !0,
                        pointerId: !0,
                        pointerType: !0,
                        screenX: !0,
                        screenY: !0,
                        targetTouches: !0,
                        toElement: !0,
                        touches: !0,
                        which: !0
                    }, C.event.addProp), C.each({
                        focus: "focusin",
                        blur: "focusout"
                    }, (function(e, t) {
                        C.event.special[e] = {
                            setup: function() {
                                return Ae(this, e, xe), !1
                            },
                            trigger: function() {
                                return Ae(this, e), !0
                            },
                            _default: function(t) {
                                return Q.get(t.target, e)
                            },
                            delegateType: t
                        }
                    })), C.each({
                        mouseenter: "mouseover",
                        mouseleave: "mouseout",
                        pointerenter: "pointerover",
                        pointerleave: "pointerout"
                    }, (function(e, t) {
                        C.event.special[e] = {
                            delegateType: t,
                            bindType: t,
                            handle: function(e) {
                                var n, i = e.relatedTarget,
                                    r = e.handleObj;
                                return i && (i === this || C.contains(this, i)) || (e.type = r.origType, n = r.handler.apply(this, arguments), e.type = t), n
                            }
                        }
                    })), C.fn.extend({
                        on: function(e, t, n, i) {
                            return Re(this, e, t, n, i)
                        },
                        one: function(e, t, n, i) {
                            return Re(this, e, t, n, i, 1)
                        },
                        off: function(e, t, n) {
                            var i, r;
                            if (e && e.preventDefault && e.handleObj) return i = e.handleObj, C(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;
                            if ("object" == typeof e) {
                                for (r in e) this.off(r, t, e[r]);
                                return this
                            }
                            return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Ce), this.each((function() {
                                C.event.remove(this, e, n, t)
                            }))
                        }
                    });
                    var we = /<script|<style|<link/i,
                        Ie = /checked\s*(?:[^=]|=\s*.checked.)/i,
                        Pe = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

                    function De(e, t) {
                        return P(e, "table") && P(11 !== t.nodeType ? t : t.firstChild, "tr") && C(e).children("tbody")[0] || e
                    }

                    function Oe(e) {
                        return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
                    }

                    function Ne(e) {
                        return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
                    }

                    function ke(e, t) {
                        var n, i, r, o, s, a;
                        if (1 === t.nodeType) {
                            if (Q.hasData(e) && (a = Q.get(e).events))
                                for (r in Q.remove(t, "handle events"), a)
                                    for (n = 0, i = a[r].length; n < i; n++) C.event.add(t, r, a[r][n]);
                            Z.hasData(e) && (o = Z.access(e), s = C.extend({}, o), Z.set(t, s))
                        }
                    }

                    function Me(e, t, n, i) {
                        t = d(t);
                        var r, o, s, a, c, l, h = 0,
                            u = e.length,
                            p = u - 1,
                            m = t[0],
                            g = v(m);
                        if (g || 1 < u && "string" == typeof m && !f.checkClone && Ie.test(m)) return e.each((function(r) {
                            var o = e.eq(r);
                            g && (t[0] = m.call(this, r, o.html())), Me(o, t, n, i)
                        }));
                        if (u && (o = (r = Se(t, e[0].ownerDocument, !1, e, i)).firstChild, 1 === r.childNodes.length && (r = o), o || i)) {
                            for (a = (s = C.map(_e(r, "script"), Oe)).length; h < u; h++) c = r, h !== p && (c = C.clone(c, !0, !0), a && C.merge(s, _e(c, "script"))), n.call(e[h], c, h);
                            if (a)
                                for (l = s[s.length - 1].ownerDocument, C.map(s, Ne), h = 0; h < a; h++) c = s[h], fe.test(c.type || "") && !Q.access(c, "globalEval") && C.contains(l, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? C._evalUrl && !c.noModule && C._evalUrl(c.src, {
                                    nonce: c.nonce || c.getAttribute("nonce")
                                }, l) : S(c.textContent.replace(Pe, ""), c, l))
                        }
                        return e
                    }

                    function Le(e, t, n) {
                        for (var i, r = t ? C.filter(t, e) : e, o = 0; null != (i = r[o]); o++) n || 1 !== i.nodeType || C.cleanData(_e(i)), i.parentNode && (n && ae(i) && ye(_e(i, "script")), i.parentNode.removeChild(i));
                        return e
                    }
                    C.extend({
                        htmlPrefilter: function(e) {
                            return e
                        },
                        clone: function(e, t, n) {
                            var i, r, o, s, a, d, c, l = e.cloneNode(!0),
                                h = ae(e);
                            if (!(f.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || C.isXMLDoc(e)))
                                for (s = _e(l), i = 0, r = (o = _e(e)).length; i < r; i++) a = o[i], "input" === (c = (d = s[i]).nodeName.toLowerCase()) && me.test(a.type) ? d.checked = a.checked : "input" !== c && "textarea" !== c || (d.defaultValue = a.defaultValue);
                            if (t)
                                if (n)
                                    for (o = o || _e(e), s = s || _e(l), i = 0, r = o.length; i < r; i++) ke(o[i], s[i]);
                                else ke(e, l);
                            return 0 < (s = _e(l, "script")).length && ye(s, !h && _e(e, "script")), l
                        },
                        cleanData: function(e) {
                            for (var t, n, i, r = C.event.special, o = 0; void 0 !== (n = e[o]); o++)
                                if (X(n)) {
                                    if (t = n[Q.expando]) {
                                        if (t.events)
                                            for (i in t.events) r[i] ? C.event.remove(n, i) : C.removeEvent(n, i, t.handle);
                                        n[Q.expando] = void 0
                                    }
                                    n[Z.expando] && (n[Z.expando] = void 0)
                                }
                        }
                    }), C.fn.extend({
                        detach: function(e) {
                            return Le(this, e, !0)
                        },
                        remove: function(e) {
                            return Le(this, e)
                        },
                        text: function(e) {
                            return q(this, (function(e) {
                                return void 0 === e ? C.text(this) : this.empty().each((function() {
                                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
                                }))
                            }), null, e, arguments.length)
                        },
                        append: function() {
                            return Me(this, arguments, (function(e) {
                                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || De(this, e).appendChild(e)
                            }))
                        },
                        prepend: function() {
                            return Me(this, arguments, (function(e) {
                                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                                    var t = De(this, e);
                                    t.insertBefore(e, t.firstChild)
                                }
                            }))
                        },
                        before: function() {
                            return Me(this, arguments, (function(e) {
                                this.parentNode && this.parentNode.insertBefore(e, this)
                            }))
                        },
                        after: function() {
                            return Me(this, arguments, (function(e) {
                                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
                            }))
                        },
                        empty: function() {
                            for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (C.cleanData(_e(e, !1)), e.textContent = "");
                            return this
                        },
                        clone: function(e, t) {
                            return e = null != e && e, t = null == t ? e : t, this.map((function() {
                                return C.clone(this, e, t)
                            }))
                        },
                        html: function(e) {
                            return q(this, (function(e) {
                                var t = this[0] || {},
                                    n = 0,
                                    i = this.length;
                                if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                                if ("string" == typeof e && !we.test(e) && !ve[(ge.exec(e) || ["", ""])[1].toLowerCase()]) {
                                    e = C.htmlPrefilter(e);
                                    try {
                                        for (; n < i; n++) 1 === (t = this[n] || {}).nodeType && (C.cleanData(_e(t, !1)), t.innerHTML = e);
                                        t = 0
                                    } catch (e) {}
                                }
                                t && this.empty().append(e)
                            }), null, e, arguments.length)
                        },
                        replaceWith: function() {
                            var e = [];
                            return Me(this, arguments, (function(t) {
                                var n = this.parentNode;
                                C.inArray(this, e) < 0 && (C.cleanData(_e(this)), n && n.replaceChild(t, this))
                            }), e)
                        }
                    }), C.each({
                        appendTo: "append",
                        prependTo: "prepend",
                        insertBefore: "before",
                        insertAfter: "after",
                        replaceAll: "replaceWith"
                    }, (function(e, t) {
                        C.fn[e] = function(e) {
                            for (var n, i = [], r = C(e), o = r.length - 1, s = 0; s <= o; s++) n = s === o ? this : this.clone(!0), C(r[s])[t](n), c.apply(i, n.get());
                            return this.pushStack(i)
                        }
                    }));
                    var Fe = new RegExp("^(" + ie + ")(?!px)[a-z%]+$", "i"),
                        je = /^--/,
                        Ve = function(e) {
                            var t = e.ownerDocument.defaultView;
                            return t && t.opener || (t = i), t.getComputedStyle(e)
                        },
                        Ue = function(e, t, n) {
                            var i, r, o = {};
                            for (r in t) o[r] = e.style[r], e.style[r] = t[r];
                            for (r in i = n.call(e), t) e.style[r] = o[r];
                            return i
                        },
                        He = new RegExp(oe.join("|"), "i"),
                        $e = "[\\x20\\t\\r\\n\\f]",
                        Je = new RegExp("^" + $e + "+|((?:^|[^\\\\])(?:\\\\.)*)" + $e + "+$", "g");

                    function Be(e, t, n) {
                        var i, r, o, s, a = je.test(t),
                            d = e.style;
                        return (n = n || Ve(e)) && (s = n.getPropertyValue(t) || n[t], a && (s = s.replace(Je, "$1")), "" !== s || ae(e) || (s = C.style(e, t)), !f.pixelBoxStyles() && Fe.test(s) && He.test(t) && (i = d.width, r = d.minWidth, o = d.maxWidth, d.minWidth = d.maxWidth = d.width = s, s = n.width, d.width = i, d.minWidth = r, d.maxWidth = o)), void 0 !== s ? s + "" : s
                    }

                    function qe(e, t) {
                        return {
                            get: function() {
                                if (!e()) return (this.get = t).apply(this, arguments);
                                delete this.get
                            }
                        }
                    }! function() {
                        function e() {
                            if (l) {
                                c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", se.appendChild(c).appendChild(l);
                                var e = i.getComputedStyle(l);
                                n = "1%" !== e.top, d = 12 === t(e.marginLeft), l.style.right = "60%", s = 36 === t(e.right), r = 36 === t(e.width), l.style.position = "absolute", o = 12 === t(l.offsetWidth / 3), se.removeChild(c), l = null
                            }
                        }

                        function t(e) {
                            return Math.round(parseFloat(e))
                        }
                        var n, r, o, s, a, d, c = y.createElement("div"),
                            l = y.createElement("div");
                        l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", f.clearCloneStyle = "content-box" === l.style.backgroundClip, C.extend(f, {
                            boxSizingReliable: function() {
                                return e(), r
                            },
                            pixelBoxStyles: function() {
                                return e(), s
                            },
                            pixelPosition: function() {
                                return e(), n
                            },
                            reliableMarginLeft: function() {
                                return e(), d
                            },
                            scrollboxSize: function() {
                                return e(), o
                            },
                            reliableTrDimensions: function() {
                                var e, t, n, r;
                                return null == a && (e = y.createElement("table"), t = y.createElement("tr"), n = y.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", se.appendChild(e).appendChild(t).appendChild(n), r = i.getComputedStyle(t), a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, se.removeChild(e)), a
                            }
                        }))
                    }();
                    var Ge = ["Webkit", "Moz", "ms"],
                        ze = y.createElement("div").style,
                        Ke = {};

                    function We(e) {
                        return C.cssProps[e] || Ke[e] || (e in ze ? e : Ke[e] = function(e) {
                            for (var t = e[0].toUpperCase() + e.slice(1), n = Ge.length; n--;)
                                if ((e = Ge[n] + t) in ze) return e
                        }(e) || e)
                    }
                    var Xe, Ye, Qe = /^(none|table(?!-c[ea]).+)/,
                        Ze = {
                            position: "absolute",
                            visibility: "hidden",
                            display: "block"
                        },
                        et = {
                            letterSpacing: "0",
                            fontWeight: "400"
                        };

                    function tt(e, t, n) {
                        var i = re.exec(t);
                        return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : t
                    }

                    function nt(e, t, n, i, r, o) {
                        var s = "width" === t ? 1 : 0,
                            a = 0,
                            d = 0;
                        if (n === (i ? "border" : "content")) return 0;
                        for (; s < 4; s += 2) "margin" === n && (d += C.css(e, n + oe[s], !0, r)), i ? ("content" === n && (d -= C.css(e, "padding" + oe[s], !0, r)), "margin" !== n && (d -= C.css(e, "border" + oe[s] + "Width", !0, r))) : (d += C.css(e, "padding" + oe[s], !0, r), "padding" !== n ? d += C.css(e, "border" + oe[s] + "Width", !0, r) : a += C.css(e, "border" + oe[s] + "Width", !0, r));
                        return !i && 0 <= o && (d += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - d - a - .5)) || 0), d
                    }

                    function it(e, t, n) {
                        var i = Ve(e),
                            r = (!f.boxSizingReliable() || n) && "border-box" === C.css(e, "boxSizing", !1, i),
                            o = r,
                            s = Be(e, t, i),
                            a = "offset" + t[0].toUpperCase() + t.slice(1);
                        if (Fe.test(s)) {
                            if (!n) return s;
                            s = "auto"
                        }
                        return (!f.boxSizingReliable() && r || !f.reliableTrDimensions() && P(e, "tr") || "auto" === s || !parseFloat(s) && "inline" === C.css(e, "display", !1, i)) && e.getClientRects().length && (r = "border-box" === C.css(e, "boxSizing", !1, i), (o = a in e) && (s = e[a])), (s = parseFloat(s) || 0) + nt(e, t, n || (r ? "border" : "content"), o, i, s) + "px"
                    }
                    C.extend({
                        cssHooks: {
                            opacity: {
                                get: function(e, t) {
                                    if (t) {
                                        var n = Be(e, "opacity");
                                        return "" === n ? "1" : n
                                    }
                                }
                            }
                        },
                        cssNumber: {
                            animationIterationCount: !0,
                            columnCount: !0,
                            fillOpacity: !0,
                            flexGrow: !0,
                            flexShrink: !0,
                            fontWeight: !0,
                            gridArea: !0,
                            gridColumn: !0,
                            gridColumnEnd: !0,
                            gridColumnStart: !0,
                            gridRow: !0,
                            gridRowEnd: !0,
                            gridRowStart: !0,
                            lineHeight: !0,
                            opacity: !0,
                            order: !0,
                            orphans: !0,
                            widows: !0,
                            zIndex: !0,
                            zoom: !0
                        },
                        cssProps: {},
                        style: function(e, t, n, i) {
                            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                                var r, o, s, a = W(t),
                                    d = je.test(t),
                                    c = e.style;
                                if (d || (t = We(a)), s = C.cssHooks[t] || C.cssHooks[a], void 0 === n) return s && "get" in s && void 0 !== (r = s.get(e, !1, i)) ? r : c[t];
                                "string" == (o = typeof n) && (r = re.exec(n)) && r[1] && (n = function(e, t, n, i) {
                                    var r, o, s = 20,
                                        a = function() {
                                            return C.css(e, t, "")
                                        },
                                        d = a(),
                                        c = n && n[3] || (C.cssNumber[t] ? "" : "px"),
                                        l = e.nodeType && (C.cssNumber[t] || "px" !== c && +d) && re.exec(C.css(e, t));
                                    if (l && l[3] !== c) {
                                        for (d /= 2, c = c || l[3], l = +d || 1; s--;) C.style(e, t, l + c), (1 - o) * (1 - (o = a() / d || .5)) <= 0 && (s = 0), l /= o;
                                        l *= 2, C.style(e, t, l + c), n = n || []
                                    }
                                    return n && (l = +l || +d || 0, r = n[1] ? l + (n[1] + 1) * n[2] : +n[2]), r
                                }(e, t, r), o = "number"), null != n && n == n && ("number" !== o || d || (n += r && r[3] || (C.cssNumber[a] ? "" : "px")), f.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (c[t] = "inherit"), s && "set" in s && void 0 === (n = s.set(e, n, i)) || (d ? c.setProperty(t, n) : c[t] = n))
                            }
                        },
                        css: function(e, t, n, i) {
                            var r, o, s, a = W(t);
                            return je.test(t) || (t = We(a)), (s = C.cssHooks[t] || C.cssHooks[a]) && "get" in s && (r = s.get(e, !0, n)), void 0 === r && (r = Be(e, t, i)), "normal" === r && t in et && (r = et[t]), "" === n || n ? (o = parseFloat(r), !0 === n || isFinite(o) ? o || 0 : r) : r
                        }
                    }), C.each(["height", "width"], (function(e, t) {
                        C.cssHooks[t] = {
                            get: function(e, n, i) {
                                if (n) return !Qe.test(C.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? it(e, t, i) : Ue(e, Ze, (function() {
                                    return it(e, t, i)
                                }))
                            },
                            set: function(e, n, i) {
                                var r, o = Ve(e),
                                    s = !f.scrollboxSize() && "absolute" === o.position,
                                    a = (s || i) && "border-box" === C.css(e, "boxSizing", !1, o),
                                    d = i ? nt(e, t, i, a, o) : 0;
                                return a && s && (d -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(o[t]) - nt(e, t, "border", !1, o) - .5)), d && (r = re.exec(n)) && "px" !== (r[3] || "px") && (e.style[t] = n, n = C.css(e, t)), tt(0, n, d)
                            }
                        }
                    })), C.cssHooks.marginLeft = qe(f.reliableMarginLeft, (function(e, t) {
                        if (t) return (parseFloat(Be(e, "marginLeft")) || e.getBoundingClientRect().left - Ue(e, {
                            marginLeft: 0
                        }, (function() {
                            return e.getBoundingClientRect().left
                        }))) + "px"
                    })), C.each({
                        margin: "",
                        padding: "",
                        border: "Width"
                    }, (function(e, t) {
                        C.cssHooks[e + t] = {
                            expand: function(n) {
                                for (var i = 0, r = {}, o = "string" == typeof n ? n.split(" ") : [n]; i < 4; i++) r[e + oe[i] + t] = o[i] || o[i - 2] || o[0];
                                return r
                            }
                        }, "margin" !== e && (C.cssHooks[e + t].set = tt)
                    })), C.fn.extend({
                        css: function(e, t) {
                            return q(this, (function(e, t, n) {
                                var i, r, o = {},
                                    s = 0;
                                if (Array.isArray(t)) {
                                    for (i = Ve(e), r = t.length; s < r; s++) o[t[s]] = C.css(e, t[s], !1, i);
                                    return o
                                }
                                return void 0 !== n ? C.style(e, t, n) : C.css(e, t)
                            }), e, t, 1 < arguments.length)
                        }
                    }), C.fn.delay = function(e, t) {
                        return e = C.fx && C.fx.speeds[e] || e, t = t || "fx", this.queue(t, (function(t, n) {
                            var r = i.setTimeout(t, e);
                            n.stop = function() {
                                i.clearTimeout(r)
                            }
                        }))
                    }, Xe = y.createElement("input"), Ye = y.createElement("select").appendChild(y.createElement("option")), Xe.type = "checkbox", f.checkOn = "" !== Xe.value, f.optSelected = Ye.selected, (Xe = y.createElement("input")).value = "t", Xe.type = "radio", f.radioValue = "t" === Xe.value;
                    var rt, ot = C.expr.attrHandle;
                    C.fn.extend({
                        attr: function(e, t) {
                            return q(this, C.attr, e, t, 1 < arguments.length)
                        },
                        removeAttr: function(e) {
                            return this.each((function() {
                                C.removeAttr(this, e)
                            }))
                        }
                    }), C.extend({
                        attr: function(e, t, n) {
                            var i, r, o = e.nodeType;
                            if (3 !== o && 8 !== o && 2 !== o) return void 0 === e.getAttribute ? C.prop(e, t, n) : (1 === o && C.isXMLDoc(e) || (r = C.attrHooks[t.toLowerCase()] || (C.expr.match.bool.test(t) ? rt : void 0)), void 0 !== n ? null === n ? void C.removeAttr(e, t) : r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : (e.setAttribute(t, n + ""), n) : r && "get" in r && null !== (i = r.get(e, t)) ? i : null == (i = C.find.attr(e, t)) ? void 0 : i)
                        },
                        attrHooks: {
                            type: {
                                set: function(e, t) {
                                    if (!f.radioValue && "radio" === t && P(e, "input")) {
                                        var n = e.value;
                                        return e.setAttribute("type", t), n && (e.value = n), t
                                    }
                                }
                            }
                        },
                        removeAttr: function(e, t) {
                            var n, i = 0,
                                r = t && t.match(j);
                            if (r && 1 === e.nodeType)
                                for (; n = r[i++];) e.removeAttribute(n)
                        }
                    }), rt = {
                        set: function(e, t, n) {
                            return !1 === t ? C.removeAttr(e, n) : e.setAttribute(n, n), n
                        }
                    }, C.each(C.expr.match.bool.source.match(/\w+/g), (function(e, t) {
                        var n = ot[t] || C.find.attr;
                        ot[t] = function(e, t, i) {
                            var r, o, s = t.toLowerCase();
                            return i || (o = ot[s], ot[s] = r, r = null != n(e, t, i) ? s : null, ot[s] = o), r
                        }
                    }));
                    var st = /^(?:input|select|textarea|button)$/i,
                        at = /^(?:a|area)$/i;

                    function dt(e) {
                        return (e.match(j) || []).join(" ")
                    }

                    function ct(e) {
                        return e.getAttribute && e.getAttribute("class") || ""
                    }

                    function lt(e) {
                        return Array.isArray(e) ? e : "string" == typeof e && e.match(j) || []
                    }
                    C.fn.extend({
                        prop: function(e, t) {
                            return q(this, C.prop, e, t, 1 < arguments.length)
                        },
                        removeProp: function(e) {
                            return this.each((function() {
                                delete this[C.propFix[e] || e]
                            }))
                        }
                    }), C.extend({
                        prop: function(e, t, n) {
                            var i, r, o = e.nodeType;
                            if (3 !== o && 8 !== o && 2 !== o) return 1 === o && C.isXMLDoc(e) || (t = C.propFix[t] || t, r = C.propHooks[t]), void 0 !== n ? r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : e[t] = n : r && "get" in r && null !== (i = r.get(e, t)) ? i : e[t]
                        },
                        propHooks: {
                            tabIndex: {
                                get: function(e) {
                                    var t = C.find.attr(e, "tabindex");
                                    return t ? parseInt(t, 10) : st.test(e.nodeName) || at.test(e.nodeName) && e.href ? 0 : -1
                                }
                            }
                        },
                        propFix: {
                            for: "htmlFor",
                            class: "className"
                        }
                    }), f.optSelected || (C.propHooks.selected = {
                        get: function(e) {
                            var t = e.parentNode;
                            return t && t.parentNode && t.parentNode.selectedIndex, null
                        },
                        set: function(e) {
                            var t = e.parentNode;
                            t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
                        }
                    }), C.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function() {
                        C.propFix[this.toLowerCase()] = this
                    })), C.fn.extend({
                        addClass: function(e) {
                            var t, n, i, r, o, s;
                            return v(e) ? this.each((function(t) {
                                C(this).addClass(e.call(this, t, ct(this)))
                            })) : (t = lt(e)).length ? this.each((function() {
                                if (i = ct(this), n = 1 === this.nodeType && " " + dt(i) + " ") {
                                    for (o = 0; o < t.length; o++) r = t[o], n.indexOf(" " + r + " ") < 0 && (n += r + " ");
                                    s = dt(n), i !== s && this.setAttribute("class", s)
                                }
                            })) : this
                        },
                        removeClass: function(e) {
                            var t, n, i, r, o, s;
                            return v(e) ? this.each((function(t) {
                                C(this).removeClass(e.call(this, t, ct(this)))
                            })) : arguments.length ? (t = lt(e)).length ? this.each((function() {
                                if (i = ct(this), n = 1 === this.nodeType && " " + dt(i) + " ") {
                                    for (o = 0; o < t.length; o++)
                                        for (r = t[o]; - 1 < n.indexOf(" " + r + " ");) n = n.replace(" " + r + " ", " ");
                                    s = dt(n), i !== s && this.setAttribute("class", s)
                                }
                            })) : this : this.attr("class", "")
                        },
                        toggleClass: function(e, t) {
                            var n, i, r, o, s = typeof e,
                                a = "string" === s || Array.isArray(e);
                            return v(e) ? this.each((function(n) {
                                C(this).toggleClass(e.call(this, n, ct(this), t), t)
                            })) : "boolean" == typeof t && a ? t ? this.addClass(e) : this.removeClass(e) : (n = lt(e), this.each((function() {
                                if (a)
                                    for (o = C(this), r = 0; r < n.length; r++) i = n[r], o.hasClass(i) ? o.removeClass(i) : o.addClass(i);
                                else void 0 !== e && "boolean" !== s || ((i = ct(this)) && Q.set(this, "__className__", i), this.setAttribute && this.setAttribute("class", i || !1 === e ? "" : Q.get(this, "__className__") || ""))
                            })))
                        },
                        hasClass: function(e) {
                            var t, n, i = 0;
                            for (t = " " + e + " "; n = this[i++];)
                                if (1 === n.nodeType && -1 < (" " + dt(ct(n)) + " ").indexOf(t)) return !0;
                            return !1
                        }
                    });
                    var ht = /\r/g;
                    C.fn.extend({
                        val: function(e) {
                            var t, n, i, r = this[0];
                            return arguments.length ? (i = v(e), this.each((function(n) {
                                var r;
                                1 === this.nodeType && (null == (r = i ? e.call(this, n, C(this).val()) : e) ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = C.map(r, (function(e) {
                                    return null == e ? "" : e + ""
                                }))), (t = C.valHooks[this.type] || C.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, r, "value") || (this.value = r))
                            }))) : r ? (t = C.valHooks[r.type] || C.valHooks[r.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(r, "value")) ? n : "string" == typeof(n = r.value) ? n.replace(ht, "") : null == n ? "" : n : void 0
                        }
                    }), C.extend({
                        valHooks: {
                            option: {
                                get: function(e) {
                                    var t = C.find.attr(e, "value");
                                    return null != t ? t : dt(C.text(e))
                                }
                            },
                            select: {
                                get: function(e) {
                                    var t, n, i, r = e.options,
                                        o = e.selectedIndex,
                                        s = "select-one" === e.type,
                                        a = s ? null : [],
                                        d = s ? o + 1 : r.length;
                                    for (i = o < 0 ? d : s ? o : 0; i < d; i++)
                                        if (((n = r[i]).selected || i === o) && !n.disabled && (!n.parentNode.disabled || !P(n.parentNode, "optgroup"))) {
                                            if (t = C(n).val(), s) return t;
                                            a.push(t)
                                        } return a
                                },
                                set: function(e, t) {
                                    for (var n, i, r = e.options, o = C.makeArray(t), s = r.length; s--;)((i = r[s]).selected = -1 < C.inArray(C.valHooks.option.get(i), o)) && (n = !0);
                                    return n || (e.selectedIndex = -1), o
                                }
                            }
                        }
                    }), C.each(["radio", "checkbox"], (function() {
                        C.valHooks[this] = {
                            set: function(e, t) {
                                if (Array.isArray(t)) return e.checked = -1 < C.inArray(C(e).val(), t)
                            }
                        }, f.checkOn || (C.valHooks[this].get = function(e) {
                            return null === e.getAttribute("value") ? "on" : e.value
                        })
                    })), f.focusin = "onfocusin" in i;
                    var ut = /^(?:focusinfocus|focusoutblur)$/,
                        pt = function(e) {
                            e.stopPropagation()
                        };
                    C.extend(C.event, {
                        trigger: function(e, t, n, r) {
                            var o, s, a, d, c, l, h, u, m = [n || y],
                                g = p.call(e, "type") ? e.type : e,
                                f = p.call(e, "namespace") ? e.namespace.split(".") : [];
                            if (s = u = a = n = n || y, 3 !== n.nodeType && 8 !== n.nodeType && !ut.test(g + C.event.triggered) && (-1 < g.indexOf(".") && (g = (f = g.split(".")).shift(), f.sort()), c = g.indexOf(":") < 0 && "on" + g, (e = e[C.expando] ? e : new C.Event(g, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = f.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : C.makeArray(t, [e]), h = C.event.special[g] || {}, r || !h.trigger || !1 !== h.trigger.apply(n, t))) {
                                if (!r && !h.noBubble && !_(n)) {
                                    for (d = h.delegateType || g, ut.test(d + g) || (s = s.parentNode); s; s = s.parentNode) m.push(s), a = s;
                                    a === (n.ownerDocument || y) && m.push(a.defaultView || a.parentWindow || i)
                                }
                                for (o = 0;
                                    (s = m[o++]) && !e.isPropagationStopped();) u = s, e.type = 1 < o ? d : h.bindType || g, (l = (Q.get(s, "events") || Object.create(null))[e.type] && Q.get(s, "handle")) && l.apply(s, t), (l = c && s[c]) && l.apply && X(s) && (e.result = l.apply(s, t), !1 === e.result && e.preventDefault());
                                return e.type = g, r || e.isDefaultPrevented() || h._default && !1 !== h._default.apply(m.pop(), t) || !X(n) || c && v(n[g]) && !_(n) && ((a = n[c]) && (n[c] = null), C.event.triggered = g, e.isPropagationStopped() && u.addEventListener(g, pt), n[g](), e.isPropagationStopped() && u.removeEventListener(g, pt), C.event.triggered = void 0, a && (n[c] = a)), e.result
                            }
                        },
                        simulate: function(e, t, n) {
                            var i = C.extend(new C.Event, n, {
                                type: e,
                                isSimulated: !0
                            });
                            C.event.trigger(i, null, t)
                        }
                    }), C.fn.extend({
                        trigger: function(e, t) {
                            return this.each((function() {
                                C.event.trigger(e, t, this)
                            }))
                        },
                        triggerHandler: function(e, t) {
                            var n = this[0];
                            if (n) return C.event.trigger(e, t, n, !0)
                        }
                    }), f.focusin || C.each({
                        focus: "focusin",
                        blur: "focusout"
                    }, (function(e, t) {
                        var n = function(e) {
                            C.event.simulate(t, e.target, C.event.fix(e))
                        };
                        C.event.special[t] = {
                            setup: function() {
                                var i = this.ownerDocument || this.document || this,
                                    r = Q.access(i, t);
                                r || i.addEventListener(e, n, !0), Q.access(i, t, (r || 0) + 1)
                            },
                            teardown: function() {
                                var i = this.ownerDocument || this.document || this,
                                    r = Q.access(i, t) - 1;
                                r ? Q.access(i, t, r) : (i.removeEventListener(e, n, !0), Q.remove(i, t))
                            }
                        }
                    })), C.parseXML = function(e) {
                        var t, n;
                        if (!e || "string" != typeof e) return null;
                        try {
                            t = (new i.DOMParser).parseFromString(e, "text/xml")
                        } catch (e) {}
                        return n = t && t.getElementsByTagName("parsererror")[0], t && !n || C.error("Invalid XML: " + (n ? C.map(n.childNodes, (function(e) {
                            return e.textContent
                        })).join("\n") : e)), t
                    };
                    var mt, gt = /\[\]$/,
                        ft = /\r?\n/g,
                        vt = /^(?:submit|button|image|reset|file)$/i,
                        _t = /^(?:input|select|textarea|keygen)/i;

                    function yt(e, t, n, i) {
                        var r;
                        if (Array.isArray(t)) C.each(t, (function(t, r) {
                            n || gt.test(e) ? i(e, r) : yt(e + "[" + ("object" == typeof r && null != r ? t : "") + "]", r, n, i)
                        }));
                        else if (n || "object" !== b(t)) i(e, t);
                        else
                            for (r in t) yt(e + "[" + r + "]", t[r], n, i)
                    }
                    C.param = function(e, t) {
                        var n, i = [],
                            r = function(e, t) {
                                var n = v(t) ? t() : t;
                                i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n)
                            };
                        if (null == e) return "";
                        if (Array.isArray(e) || e.jquery && !C.isPlainObject(e)) C.each(e, (function() {
                            r(this.name, this.value)
                        }));
                        else
                            for (n in e) yt(n, e[n], t, r);
                        return i.join("&")
                    }, C.fn.extend({
                        serialize: function() {
                            return C.param(this.serializeArray())
                        },
                        serializeArray: function() {
                            return this.map((function() {
                                var e = C.prop(this, "elements");
                                return e ? C.makeArray(e) : this
                            })).filter((function() {
                                var e = this.type;
                                return this.name && !C(this).is(":disabled") && _t.test(this.nodeName) && !vt.test(e) && (this.checked || !me.test(e))
                            })).map((function(e, t) {
                                var n = C(this).val();
                                return null == n ? null : Array.isArray(n) ? C.map(n, (function(e) {
                                    return {
                                        name: t.name,
                                        value: e.replace(ft, "\r\n")
                                    }
                                })) : {
                                    name: t.name,
                                    value: n.replace(ft, "\r\n")
                                }
                            })).get()
                        }
                    }), C.fn.extend({
                        wrapAll: function(e) {
                            var t;
                            return this[0] && (v(e) && (e = e.call(this[0])), t = C(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map((function() {
                                for (var e = this; e.firstElementChild;) e = e.firstElementChild;
                                return e
                            })).append(this)), this
                        },
                        wrapInner: function(e) {
                            return v(e) ? this.each((function(t) {
                                C(this).wrapInner(e.call(this, t))
                            })) : this.each((function() {
                                var t = C(this),
                                    n = t.contents();
                                n.length ? n.wrapAll(e) : t.append(e)
                            }))
                        },
                        wrap: function(e) {
                            var t = v(e);
                            return this.each((function(n) {
                                C(this).wrapAll(t ? e.call(this, n) : e)
                            }))
                        },
                        unwrap: function(e) {
                            return this.parent(e).not("body").each((function() {
                                C(this).replaceWith(this.childNodes)
                            })), this
                        }
                    }), C.expr.pseudos.hidden = function(e) {
                        return !C.expr.pseudos.visible(e)
                    }, C.expr.pseudos.visible = function(e) {
                        return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
                    }, f.createHTMLDocument = ((mt = y.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === mt.childNodes.length), C.parseHTML = function(e, t, n) {
                        return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (f.createHTMLDocument ? ((i = (t = y.implementation.createHTMLDocument("")).createElement("base")).href = y.location.href, t.head.appendChild(i)) : t = y), o = !n && [], (r = D.exec(e)) ? [t.createElement(r[1])] : (r = Se([e], t, o), o && o.length && C(o).remove(), C.merge([], r.childNodes)));
                        var i, r, o
                    }, C.offset = {
                        setOffset: function(e, t, n) {
                            var i, r, o, s, a, d, c = C.css(e, "position"),
                                l = C(e),
                                h = {};
                            "static" === c && (e.style.position = "relative"), a = l.offset(), o = C.css(e, "top"), d = C.css(e, "left"), ("absolute" === c || "fixed" === c) && -1 < (o + d).indexOf("auto") ? (s = (i = l.position()).top, r = i.left) : (s = parseFloat(o) || 0, r = parseFloat(d) || 0), v(t) && (t = t.call(e, n, C.extend({}, a))), null != t.top && (h.top = t.top - a.top + s), null != t.left && (h.left = t.left - a.left + r), "using" in t ? t.using.call(e, h) : l.css(h)
                        }
                    }, C.fn.extend({
                        offset: function(e) {
                            if (arguments.length) return void 0 === e ? this : this.each((function(t) {
                                C.offset.setOffset(this, e, t)
                            }));
                            var t, n, i = this[0];
                            return i ? i.getClientRects().length ? (t = i.getBoundingClientRect(), n = i.ownerDocument.defaultView, {
                                top: t.top + n.pageYOffset,
                                left: t.left + n.pageXOffset
                            }) : {
                                top: 0,
                                left: 0
                            } : void 0
                        },
                        position: function() {
                            if (this[0]) {
                                var e, t, n, i = this[0],
                                    r = {
                                        top: 0,
                                        left: 0
                                    };
                                if ("fixed" === C.css(i, "position")) t = i.getBoundingClientRect();
                                else {
                                    for (t = this.offset(), n = i.ownerDocument, e = i.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && "static" === C.css(e, "position");) e = e.parentNode;
                                    e && e !== i && 1 === e.nodeType && ((r = C(e).offset()).top += C.css(e, "borderTopWidth", !0), r.left += C.css(e, "borderLeftWidth", !0))
                                }
                                return {
                                    top: t.top - r.top - C.css(i, "marginTop", !0),
                                    left: t.left - r.left - C.css(i, "marginLeft", !0)
                                }
                            }
                        },
                        offsetParent: function() {
                            return this.map((function() {
                                for (var e = this.offsetParent; e && "static" === C.css(e, "position");) e = e.offsetParent;
                                return e || se
                            }))
                        }
                    }), C.each({
                        scrollLeft: "pageXOffset",
                        scrollTop: "pageYOffset"
                    }, (function(e, t) {
                        var n = "pageYOffset" === t;
                        C.fn[e] = function(i) {
                            return q(this, (function(e, i, r) {
                                var o;
                                if (_(e) ? o = e : 9 === e.nodeType && (o = e.defaultView), void 0 === r) return o ? o[t] : e[i];
                                o ? o.scrollTo(n ? o.pageXOffset : r, n ? r : o.pageYOffset) : e[i] = r
                            }), e, i, arguments.length)
                        }
                    })), C.each(["top", "left"], (function(e, t) {
                        C.cssHooks[t] = qe(f.pixelPosition, (function(e, n) {
                            if (n) return n = Be(e, t), Fe.test(n) ? C(e).position()[t] + "px" : n
                        }))
                    })), C.each({
                        Height: "height",
                        Width: "width"
                    }, (function(e, t) {
                        C.each({
                            padding: "inner" + e,
                            content: t,
                            "": "outer" + e
                        }, (function(n, i) {
                            C.fn[i] = function(r, o) {
                                var s = arguments.length && (n || "boolean" != typeof r),
                                    a = n || (!0 === r || !0 === o ? "margin" : "border");
                                return q(this, (function(t, n, r) {
                                    var o;
                                    return _(t) ? 0 === i.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (o = t.documentElement, Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e])) : void 0 === r ? C.css(t, n, a) : C.style(t, n, r, a)
                                }), t, s ? r : void 0, s)
                            }
                        }))
                    })), C.fn.extend({
                        bind: function(e, t, n) {
                            return this.on(e, null, t, n)
                        },
                        unbind: function(e, t) {
                            return this.off(e, null, t)
                        },
                        delegate: function(e, t, n, i) {
                            return this.on(t, e, n, i)
                        },
                        undelegate: function(e, t, n) {
                            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
                        },
                        hover: function(e, t) {
                            return this.mouseenter(e).mouseleave(t || e)
                        }
                    }), C.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function(e, t) {
                        C.fn[t] = function(e, n) {
                            return 0 < arguments.length ? this.on(t, null, e, n) : this.trigger(t)
                        }
                    }));
                    var Et = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
                    C.proxy = function(e, t) {
                        var n, i, r;
                        if ("string" == typeof t && (n = e[t], t = e, e = n), v(e)) return i = a.call(arguments, 2), (r = function() {
                            return e.apply(t || this, i.concat(a.call(arguments)))
                        }).guid = e.guid = e.guid || C.guid++, r
                    }, C.holdReady = function(e) {
                        e ? C.readyWait++ : C.ready(!0)
                    }, C.isArray = Array.isArray, C.parseJSON = JSON.parse, C.nodeName = P, C.isFunction = v, C.isWindow = _, C.camelCase = W, C.type = b, C.now = Date.now, C.isNumeric = function(e) {
                        var t = C.type(e);
                        return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
                    }, C.trim = function(e) {
                        return null == e ? "" : (e + "").replace(Et, "$1")
                    }, void 0 === (n = function() {
                        return C
                    }.apply(t, [])) || (e.exports = n);
                    var St = i.jQuery,
                        bt = i.$;
                    return C.noConflict = function(e) {
                        return i.$ === C && (i.$ = bt), e && i.jQuery === C && (i.jQuery = St), C
                    }, void 0 === r && (i.jQuery = i.$ = C), C
                }))
            },
            478: (module, exports, __webpack_require__) => {
                var __WEBPACK_AMD_DEFINE_RESULT__;
                (function() {
                    "use strict";
                    var ERROR = "input is invalid type",
                        WINDOW = "object" == typeof window,
                        root = WINDOW ? window : {};
                    root.JS_MD5_NO_WINDOW && (WINDOW = !1);
                    var WEB_WORKER = !WINDOW && "object" == typeof self,
                        NODE_JS = !root.JS_MD5_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
                    NODE_JS ? root = __webpack_require__.g : WEB_WORKER && (root = self);
                    var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && module.exports,
                        AMD = __webpack_require__.amdO,
                        ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer,
                        HEX_CHARS = "0123456789abcdef".split(""),
                        EXTRA = [128, 32768, 8388608, -2147483648],
                        SHIFT = [0, 8, 16, 24],
                        OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"],
                        BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),
                        blocks = [],
                        buffer8;
                    if (ARRAY_BUFFER) {
                        var buffer = new ArrayBuffer(68);
                        buffer8 = new Uint8Array(buffer), blocks = new Uint32Array(buffer)
                    }!root.JS_MD5_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                        return "[object Array]" === Object.prototype.toString.call(e)
                    }), !ARRAY_BUFFER || !root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                        return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                    });
                    var createOutputMethod = function(e) {
                            return function(t) {
                                return new Md5(!0).update(t)[e]()
                            }
                        },
                        createMethod = function() {
                            var e = createOutputMethod("hex");
                            NODE_JS && (e = nodeWrap(e)), e.create = function() {
                                return new Md5
                            }, e.update = function(t) {
                                return e.create().update(t)
                            };
                            for (var t = 0; t < OUTPUT_TYPES.length; ++t) {
                                var n = OUTPUT_TYPES[t];
                                e[n] = createOutputMethod(n)
                            }
                            return e
                        },
                        nodeWrap = function(method) {
                            var crypto = eval("require('crypto')"),
                                Buffer = eval("require('buffer').Buffer"),
                                nodeMethod = function(e) {
                                    if ("string" == typeof e) return crypto.createHash("md5").update(e, "utf8").digest("hex");
                                    if (null == e) throw ERROR;
                                    return e.constructor === ArrayBuffer && (e = new Uint8Array(e)), Array.isArray(e) || ArrayBuffer.isView(e) || e.constructor === Buffer ? crypto.createHash("md5").update(new Buffer(e)).digest("hex") : method(e)
                                };
                            return nodeMethod
                        };

                    function Md5(e) {
                        if (e) blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks, this.buffer8 = buffer8;
                        else if (ARRAY_BUFFER) {
                            var t = new ArrayBuffer(68);
                            this.buffer8 = new Uint8Array(t), this.blocks = new Uint32Array(t)
                        } else this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0
                    }
                    Md5.prototype.update = function(e) {
                        if (!this.finalized) {
                            var t, n = typeof e;
                            if ("string" !== n) {
                                if ("object" !== n) throw ERROR;
                                if (null === e) throw ERROR;
                                if (ARRAY_BUFFER && e.constructor === ArrayBuffer) e = new Uint8Array(e);
                                else if (!(Array.isArray(e) || ARRAY_BUFFER && ArrayBuffer.isView(e))) throw ERROR;
                                t = !0
                            }
                            for (var i, r, o = 0, s = e.length, a = this.blocks, d = this.buffer8; o < s;) {
                                if (this.hashed && (this.hashed = !1, a[0] = a[16], a[16] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = a[9] = a[10] = a[11] = a[12] = a[13] = a[14] = a[15] = 0), t)
                                    if (ARRAY_BUFFER)
                                        for (r = this.start; o < s && r < 64; ++o) d[r++] = e[o];
                                    else
                                        for (r = this.start; o < s && r < 64; ++o) a[r >> 2] |= e[o] << SHIFT[3 & r++];
                                else if (ARRAY_BUFFER)
                                    for (r = this.start; o < s && r < 64; ++o)(i = e.charCodeAt(o)) < 128 ? d[r++] = i : i < 2048 ? (d[r++] = 192 | i >> 6, d[r++] = 128 | 63 & i) : i < 55296 || i >= 57344 ? (d[r++] = 224 | i >> 12, d[r++] = 128 | i >> 6 & 63, d[r++] = 128 | 63 & i) : (i = 65536 + ((1023 & i) << 10 | 1023 & e.charCodeAt(++o)), d[r++] = 240 | i >> 18, d[r++] = 128 | i >> 12 & 63, d[r++] = 128 | i >> 6 & 63, d[r++] = 128 | 63 & i);
                                else
                                    for (r = this.start; o < s && r < 64; ++o)(i = e.charCodeAt(o)) < 128 ? a[r >> 2] |= i << SHIFT[3 & r++] : i < 2048 ? (a[r >> 2] |= (192 | i >> 6) << SHIFT[3 & r++], a[r >> 2] |= (128 | 63 & i) << SHIFT[3 & r++]) : i < 55296 || i >= 57344 ? (a[r >> 2] |= (224 | i >> 12) << SHIFT[3 & r++], a[r >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & r++], a[r >> 2] |= (128 | 63 & i) << SHIFT[3 & r++]) : (i = 65536 + ((1023 & i) << 10 | 1023 & e.charCodeAt(++o)), a[r >> 2] |= (240 | i >> 18) << SHIFT[3 & r++], a[r >> 2] |= (128 | i >> 12 & 63) << SHIFT[3 & r++], a[r >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & r++], a[r >> 2] |= (128 | 63 & i) << SHIFT[3 & r++]);
                                this.lastByteIndex = r, this.bytes += r - this.start, r >= 64 ? (this.start = r - 64, this.hash(), this.hashed = !0) : this.start = r
                            }
                            return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this
                        }
                    }, Md5.prototype.finalize = function() {
                        if (!this.finalized) {
                            this.finalized = !0;
                            var e = this.blocks,
                                t = this.lastByteIndex;
                            e[t >> 2] |= EXTRA[3 & t], t >= 56 && (this.hashed || this.hash(), e[0] = e[16], e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.bytes << 3, e[15] = this.hBytes << 3 | this.bytes >>> 29, this.hash()
                        }
                    }, Md5.prototype.hash = function() {
                        var e, t, n, i, r, o, s = this.blocks;
                        this.first ? t = ((t = ((e = ((e = s[0] - 680876937) << 7 | e >>> 25) - 271733879 << 0) ^ (n = ((n = (-271733879 ^ (i = ((i = (-1732584194 ^ 2004318071 & e) + s[1] - 117830708) << 12 | i >>> 20) + e << 0) & (-271733879 ^ e)) + s[2] - 1126478375) << 17 | n >>> 15) + i << 0) & (i ^ e)) + s[3] - 1316259209) << 22 | t >>> 10) + n << 0 : (e = this.h0, t = this.h1, n = this.h2, t = ((t += ((e = ((e += ((i = this.h3) ^ t & (n ^ i)) + s[0] - 680876936) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + s[1] - 389564586) << 12 | i >>> 20) + e << 0) & (e ^ t)) + s[2] + 606105819) << 17 | n >>> 15) + i << 0) & (i ^ e)) + s[3] - 1044525330) << 22 | t >>> 10) + n << 0), t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + s[4] - 176418897) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + s[5] + 1200080426) << 12 | i >>> 20) + e << 0) & (e ^ t)) + s[6] - 1473231341) << 17 | n >>> 15) + i << 0) & (i ^ e)) + s[7] - 45705983) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + s[8] + 1770035416) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + s[9] - 1958414417) << 12 | i >>> 20) + e << 0) & (e ^ t)) + s[10] - 42063) << 17 | n >>> 15) + i << 0) & (i ^ e)) + s[11] - 1990404162) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + s[12] + 1804603682) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + s[13] - 40341101) << 12 | i >>> 20) + e << 0) & (e ^ t)) + s[14] - 1502002290) << 17 | n >>> 15) + i << 0) & (i ^ e)) + s[15] + 1236535329) << 22 | t >>> 10) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + s[1] - 165796510) << 5 | e >>> 27) + t << 0) ^ t)) + s[6] - 1069501632) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + s[11] + 643717713) << 14 | n >>> 18) + i << 0) ^ i)) + s[0] - 373897302) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + s[5] - 701558691) << 5 | e >>> 27) + t << 0) ^ t)) + s[10] + 38016083) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + s[15] - 660478335) << 14 | n >>> 18) + i << 0) ^ i)) + s[4] - 405537848) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + s[9] + 568446438) << 5 | e >>> 27) + t << 0) ^ t)) + s[14] - 1019803690) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + s[3] - 187363961) << 14 | n >>> 18) + i << 0) ^ i)) + s[8] + 1163531501) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + s[13] - 1444681467) << 5 | e >>> 27) + t << 0) ^ t)) + s[2] - 51403784) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + s[7] + 1735328473) << 14 | n >>> 18) + i << 0) ^ i)) + s[12] - 1926607734) << 20 | t >>> 12) + n << 0, t = ((t += ((o = (i = ((i += ((r = t ^ n) ^ (e = ((e += (r ^ i) + s[5] - 378558) << 4 | e >>> 28) + t << 0)) + s[8] - 2022574463) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (o ^ t) + s[11] + 1839030562) << 16 | n >>> 16) + i << 0)) + s[14] - 35309556) << 23 | t >>> 9) + n << 0, t = ((t += ((o = (i = ((i += ((r = t ^ n) ^ (e = ((e += (r ^ i) + s[1] - 1530992060) << 4 | e >>> 28) + t << 0)) + s[4] + 1272893353) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (o ^ t) + s[7] - 155497632) << 16 | n >>> 16) + i << 0)) + s[10] - 1094730640) << 23 | t >>> 9) + n << 0, t = ((t += ((o = (i = ((i += ((r = t ^ n) ^ (e = ((e += (r ^ i) + s[13] + 681279174) << 4 | e >>> 28) + t << 0)) + s[0] - 358537222) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (o ^ t) + s[3] - 722521979) << 16 | n >>> 16) + i << 0)) + s[6] + 76029189) << 23 | t >>> 9) + n << 0, t = ((t += ((o = (i = ((i += ((r = t ^ n) ^ (e = ((e += (r ^ i) + s[9] - 640364487) << 4 | e >>> 28) + t << 0)) + s[12] - 421815835) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (o ^ t) + s[15] + 530742520) << 16 | n >>> 16) + i << 0)) + s[2] - 995338651) << 23 | t >>> 9) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + s[0] - 198630844) << 6 | e >>> 26) + t << 0) | ~n)) + s[7] + 1126891415) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + s[14] - 1416354905) << 15 | n >>> 17) + i << 0) | ~e)) + s[5] - 57434055) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + s[12] + 1700485571) << 6 | e >>> 26) + t << 0) | ~n)) + s[3] - 1894986606) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + s[10] - 1051523) << 15 | n >>> 17) + i << 0) | ~e)) + s[1] - 2054922799) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + s[8] + 1873313359) << 6 | e >>> 26) + t << 0) | ~n)) + s[15] - 30611744) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + s[6] - 1560198380) << 15 | n >>> 17) + i << 0) | ~e)) + s[13] + 1309151649) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + s[4] - 145523070) << 6 | e >>> 26) + t << 0) | ~n)) + s[11] - 1120210379) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + s[2] + 718787259) << 15 | n >>> 17) + i << 0) | ~e)) + s[9] - 343485551) << 21 | t >>> 11) + n << 0, this.first ? (this.h0 = e + 1732584193 << 0, this.h1 = t - 271733879 << 0, this.h2 = n - 1732584194 << 0, this.h3 = i + 271733878 << 0, this.first = !1) : (this.h0 = this.h0 + e << 0, this.h1 = this.h1 + t << 0, this.h2 = this.h2 + n << 0, this.h3 = this.h3 + i << 0)
                    }, Md5.prototype.hex = function() {
                        this.finalize();
                        var e = this.h0,
                            t = this.h1,
                            n = this.h2,
                            i = this.h3;
                        return HEX_CHARS[e >> 4 & 15] + HEX_CHARS[15 & e] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[15 & t] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[15 & n] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[i >> 4 & 15] + HEX_CHARS[15 & i] + HEX_CHARS[i >> 12 & 15] + HEX_CHARS[i >> 8 & 15] + HEX_CHARS[i >> 20 & 15] + HEX_CHARS[i >> 16 & 15] + HEX_CHARS[i >> 28 & 15] + HEX_CHARS[i >> 24 & 15]
                    }, Md5.prototype.toString = Md5.prototype.hex, Md5.prototype.digest = function() {
                        this.finalize();
                        var e = this.h0,
                            t = this.h1,
                            n = this.h2,
                            i = this.h3;
                        return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255, 255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255, 255 & n, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255, 255 & i, i >> 8 & 255, i >> 16 & 255, i >> 24 & 255]
                    }, Md5.prototype.array = Md5.prototype.digest, Md5.prototype.arrayBuffer = function() {
                        this.finalize();
                        var e = new ArrayBuffer(16),
                            t = new Uint32Array(e);
                        return t[0] = this.h0, t[1] = this.h1, t[2] = this.h2, t[3] = this.h3, e
                    }, Md5.prototype.buffer = Md5.prototype.arrayBuffer, Md5.prototype.base64 = function() {
                        for (var e, t, n, i = "", r = this.array(), o = 0; o < 15;) e = r[o++], t = r[o++], n = r[o++], i += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[63 & (e << 4 | t >>> 4)] + BASE64_ENCODE_CHAR[63 & (t << 2 | n >>> 6)] + BASE64_ENCODE_CHAR[63 & n];
                        return e = r[o], i + (BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[e << 4 & 63] + "==")
                    };
                    var exports = createMethod();
                    COMMON_JS ? module.exports = exports : (root.md5 = exports, AMD && (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return exports
                    }.call(exports, __webpack_require__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))
                })()
            },
            138: (e, t, n) => {
                e = n.nmd(e);
                var i = "__lodash_hash_undefined__",
                    r = 9007199254740991,
                    o = "[object Arguments]",
                    s = "[object Boolean]",
                    a = "[object Date]",
                    d = "[object Function]",
                    c = "[object GeneratorFunction]",
                    l = "[object Map]",
                    h = "[object Number]",
                    u = "[object Object]",
                    p = "[object Promise]",
                    m = "[object RegExp]",
                    g = "[object Set]",
                    f = "[object String]",
                    v = "[object Symbol]",
                    _ = "[object WeakMap]",
                    y = "[object ArrayBuffer]",
                    E = "[object DataView]",
                    S = "[object Float32Array]",
                    b = "[object Float64Array]",
                    T = "[object Int8Array]",
                    C = "[object Int16Array]",
                    x = "[object Int32Array]",
                    R = "[object Uint8Array]",
                    A = "[object Uint8ClampedArray]",
                    w = "[object Uint16Array]",
                    I = "[object Uint32Array]",
                    P = /\w*$/,
                    D = /^\[object .+?Constructor\]$/,
                    O = /^(?:0|[1-9]\d*)$/,
                    N = {};
                N[o] = N["[object Array]"] = N[y] = N[E] = N[s] = N[a] = N[S] = N[b] = N[T] = N[C] = N[x] = N[l] = N[h] = N[u] = N[m] = N[g] = N[f] = N[v] = N[R] = N[A] = N[w] = N[I] = !0, N["[object Error]"] = N[d] = N[_] = !1;
                var k = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
                    M = "object" == typeof self && self && self.Object === Object && self,
                    L = k || M || Function("return this")(),
                    F = t && !t.nodeType && t,
                    j = F && e && !e.nodeType && e,
                    V = j && j.exports === F;

                function U(e, t) {
                    return e.set(t[0], t[1]), e
                }

                function H(e, t) {
                    return e.add(t), e
                }

                function $(e, t, n, i) {
                    var r = -1,
                        o = e ? e.length : 0;
                    for (i && o && (n = e[++r]); ++r < o;) n = t(n, e[r], r, e);
                    return n
                }

                function J(e) {
                    var t = !1;
                    if (null != e && "function" != typeof e.toString) try {
                        t = !!(e + "")
                    } catch (e) {}
                    return t
                }

                function B(e) {
                    var t = -1,
                        n = Array(e.size);
                    return e.forEach((function(e, i) {
                        n[++t] = [i, e]
                    })), n
                }

                function q(e, t) {
                    return function(n) {
                        return e(t(n))
                    }
                }

                function G(e) {
                    var t = -1,
                        n = Array(e.size);
                    return e.forEach((function(e) {
                        n[++t] = e
                    })), n
                }
                var z, K = Array.prototype,
                    W = Function.prototype,
                    X = Object.prototype,
                    Y = L["__core-js_shared__"],
                    Q = (z = /[^.]+$/.exec(Y && Y.keys && Y.keys.IE_PROTO || "")) ? "Symbol(src)_1." + z : "",
                    Z = W.toString,
                    ee = X.hasOwnProperty,
                    te = X.toString,
                    ne = RegExp("^" + Z.call(ee).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                    ie = V ? L.Buffer : void 0,
                    re = L.Symbol,
                    oe = L.Uint8Array,
                    se = q(Object.getPrototypeOf, Object),
                    ae = Object.create,
                    de = X.propertyIsEnumerable,
                    ce = K.splice,
                    le = Object.getOwnPropertySymbols,
                    he = ie ? ie.isBuffer : void 0,
                    ue = q(Object.keys, Object),
                    pe = Le(L, "DataView"),
                    me = Le(L, "Map"),
                    ge = Le(L, "Promise"),
                    fe = Le(L, "Set"),
                    ve = Le(L, "WeakMap"),
                    _e = Le(Object, "create"),
                    ye = He(pe),
                    Ee = He(me),
                    Se = He(ge),
                    be = He(fe),
                    Te = He(ve),
                    Ce = re ? re.prototype : void 0,
                    xe = Ce ? Ce.valueOf : void 0;

                function Re(e) {
                    var t = -1,
                        n = e ? e.length : 0;
                    for (this.clear(); ++t < n;) {
                        var i = e[t];
                        this.set(i[0], i[1])
                    }
                }

                function Ae(e) {
                    var t = -1,
                        n = e ? e.length : 0;
                    for (this.clear(); ++t < n;) {
                        var i = e[t];
                        this.set(i[0], i[1])
                    }
                }

                function we(e) {
                    var t = -1,
                        n = e ? e.length : 0;
                    for (this.clear(); ++t < n;) {
                        var i = e[t];
                        this.set(i[0], i[1])
                    }
                }

                function Ie(e) {
                    this.__data__ = new Ae(e)
                }

                function Pe(e, t, n) {
                    var i = e[t];
                    ee.call(e, t) && $e(i, n) && (void 0 !== n || t in e) || (e[t] = n)
                }

                function De(e, t) {
                    for (var n = e.length; n--;)
                        if ($e(e[n][0], t)) return n;
                    return -1
                }

                function Oe(e, t, n, i, r, p, _) {
                    var D;
                    if (i && (D = p ? i(e, r, p, _) : i(e)), void 0 !== D) return D;
                    if (!ze(e)) return e;
                    var O = Je(e);
                    if (O) {
                        if (D = function(e) {
                                var t = e.length,
                                    n = e.constructor(t);
                                return t && "string" == typeof e[0] && ee.call(e, "index") && (n.index = e.index, n.input = e.input), n
                            }(e), !t) return function(e, t) {
                            var n = -1,
                                i = e.length;
                            for (t || (t = Array(i)); ++n < i;) t[n] = e[n];
                            return t
                        }(e, D)
                    } else {
                        var k = je(e),
                            M = k == d || k == c;
                        if (qe(e)) return function(e, t) {
                            if (t) return e.slice();
                            var n = new e.constructor(e.length);
                            return e.copy(n), n
                        }(e, t);
                        if (k == u || k == o || M && !p) {
                            if (J(e)) return p ? e : {};
                            if (D = function(e) {
                                    return "function" != typeof e.constructor || Ue(e) ? {} : ze(t = se(e)) ? ae(t) : {};
                                    var t
                                }(M ? {} : e), !t) return function(e, t) {
                                return ke(e, Fe(e), t)
                            }(e, function(e, t) {
                                return e && ke(t, Ke(t), e)
                            }(D, e))
                        } else {
                            if (!N[k]) return p ? e : {};
                            D = function(e, t, n, i) {
                                var r, o = e.constructor;
                                switch (t) {
                                    case y:
                                        return Ne(e);
                                    case s:
                                    case a:
                                        return new o(+e);
                                    case E:
                                        return function(e, t) {
                                            var n = t ? Ne(e.buffer) : e.buffer;
                                            return new e.constructor(n, e.byteOffset, e.byteLength)
                                        }(e, i);
                                    case S:
                                    case b:
                                    case T:
                                    case C:
                                    case x:
                                    case R:
                                    case A:
                                    case w:
                                    case I:
                                        return function(e, t) {
                                            var n = t ? Ne(e.buffer) : e.buffer;
                                            return new e.constructor(n, e.byteOffset, e.length)
                                        }(e, i);
                                    case l:
                                        return function(e, t, n) {
                                            return $(t ? n(B(e), !0) : B(e), U, new e.constructor)
                                        }(e, i, n);
                                    case h:
                                    case f:
                                        return new o(e);
                                    case m:
                                        return function(e) {
                                            var t = new e.constructor(e.source, P.exec(e));
                                            return t.lastIndex = e.lastIndex, t
                                        }(e);
                                    case g:
                                        return function(e, t, n) {
                                            return $(t ? n(G(e), !0) : G(e), H, new e.constructor)
                                        }(e, i, n);
                                    case v:
                                        return r = e, xe ? Object(xe.call(r)) : {}
                                }
                            }(e, k, Oe, t)
                        }
                    }
                    _ || (_ = new Ie);
                    var L = _.get(e);
                    if (L) return L;
                    if (_.set(e, D), !O) var F = n ? function(e) {
                        return function(e, t, n) {
                            var i = t(e);
                            return Je(e) ? i : function(e, t) {
                                for (var n = -1, i = t.length, r = e.length; ++n < i;) e[r + n] = t[n];
                                return e
                            }(i, n(e))
                        }(e, Ke, Fe)
                    }(e) : Ke(e);
                    return function(e, t) {
                        for (var n = -1, i = e ? e.length : 0; ++n < i && !1 !== t(e[n], n););
                    }(F || e, (function(r, o) {
                        F && (r = e[o = r]), Pe(D, o, Oe(r, t, n, i, o, e, _))
                    })), D
                }

                function Ne(e) {
                    var t = new e.constructor(e.byteLength);
                    return new oe(t).set(new oe(e)), t
                }

                function ke(e, t, n, i) {
                    n || (n = {});
                    for (var r = -1, o = t.length; ++r < o;) {
                        var s = t[r],
                            a = i ? i(n[s], e[s], s, n, e) : void 0;
                        Pe(n, s, void 0 === a ? e[s] : a)
                    }
                    return n
                }

                function Me(e, t) {
                    var n, i, r = e.__data__;
                    return ("string" == (i = typeof(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? r["string" == typeof t ? "string" : "hash"] : r.map
                }

                function Le(e, t) {
                    var n = function(e, t) {
                        return null == e ? void 0 : e[t]
                    }(e, t);
                    return function(e) {
                        return !(!ze(e) || (t = e, Q && Q in t)) && (Ge(e) || J(e) ? ne : D).test(He(e));
                        var t
                    }(n) ? n : void 0
                }
                Re.prototype.clear = function() {
                    this.__data__ = _e ? _e(null) : {}
                }, Re.prototype.delete = function(e) {
                    return this.has(e) && delete this.__data__[e]
                }, Re.prototype.get = function(e) {
                    var t = this.__data__;
                    if (_e) {
                        var n = t[e];
                        return n === i ? void 0 : n
                    }
                    return ee.call(t, e) ? t[e] : void 0
                }, Re.prototype.has = function(e) {
                    var t = this.__data__;
                    return _e ? void 0 !== t[e] : ee.call(t, e)
                }, Re.prototype.set = function(e, t) {
                    return this.__data__[e] = _e && void 0 === t ? i : t, this
                }, Ae.prototype.clear = function() {
                    this.__data__ = []
                }, Ae.prototype.delete = function(e) {
                    var t = this.__data__,
                        n = De(t, e);
                    return !(n < 0 || (n == t.length - 1 ? t.pop() : ce.call(t, n, 1), 0))
                }, Ae.prototype.get = function(e) {
                    var t = this.__data__,
                        n = De(t, e);
                    return n < 0 ? void 0 : t[n][1]
                }, Ae.prototype.has = function(e) {
                    return De(this.__data__, e) > -1
                }, Ae.prototype.set = function(e, t) {
                    var n = this.__data__,
                        i = De(n, e);
                    return i < 0 ? n.push([e, t]) : n[i][1] = t, this
                }, we.prototype.clear = function() {
                    this.__data__ = {
                        hash: new Re,
                        map: new(me || Ae),
                        string: new Re
                    }
                }, we.prototype.delete = function(e) {
                    return Me(this, e).delete(e)
                }, we.prototype.get = function(e) {
                    return Me(this, e).get(e)
                }, we.prototype.has = function(e) {
                    return Me(this, e).has(e)
                }, we.prototype.set = function(e, t) {
                    return Me(this, e).set(e, t), this
                }, Ie.prototype.clear = function() {
                    this.__data__ = new Ae
                }, Ie.prototype.delete = function(e) {
                    return this.__data__.delete(e)
                }, Ie.prototype.get = function(e) {
                    return this.__data__.get(e)
                }, Ie.prototype.has = function(e) {
                    return this.__data__.has(e)
                }, Ie.prototype.set = function(e, t) {
                    var n = this.__data__;
                    if (n instanceof Ae) {
                        var i = n.__data__;
                        if (!me || i.length < 199) return i.push([e, t]), this;
                        n = this.__data__ = new we(i)
                    }
                    return n.set(e, t), this
                };
                var Fe = le ? q(le, Object) : function() {
                        return []
                    },
                    je = function(e) {
                        return te.call(e)
                    };

                function Ve(e, t) {
                    return !!(t = null == t ? r : t) && ("number" == typeof e || O.test(e)) && e > -1 && e % 1 == 0 && e < t
                }

                function Ue(e) {
                    var t = e && e.constructor;
                    return e === ("function" == typeof t && t.prototype || X)
                }

                function He(e) {
                    if (null != e) {
                        try {
                            return Z.call(e)
                        } catch (e) {}
                        try {
                            return e + ""
                        } catch (e) {}
                    }
                    return ""
                }

                function $e(e, t) {
                    return e === t || e != e && t != t
                }(pe && je(new pe(new ArrayBuffer(1))) != E || me && je(new me) != l || ge && je(ge.resolve()) != p || fe && je(new fe) != g || ve && je(new ve) != _) && (je = function(e) {
                    var t = te.call(e),
                        n = t == u ? e.constructor : void 0,
                        i = n ? He(n) : void 0;
                    if (i) switch (i) {
                        case ye:
                            return E;
                        case Ee:
                            return l;
                        case Se:
                            return p;
                        case be:
                            return g;
                        case Te:
                            return _
                    }
                    return t
                });
                var Je = Array.isArray;

                function Be(e) {
                    return null != e && function(e) {
                        return "number" == typeof e && e > -1 && e % 1 == 0 && e <= r
                    }(e.length) && !Ge(e)
                }
                var qe = he || function() {
                    return !1
                };

                function Ge(e) {
                    var t = ze(e) ? te.call(e) : "";
                    return t == d || t == c
                }

                function ze(e) {
                    var t = typeof e;
                    return !!e && ("object" == t || "function" == t)
                }

                function Ke(e) {
                    return Be(e) ? function(e, t) {
                        var n = Je(e) || function(e) {
                                return function(e) {
                                    return function(e) {
                                        return !!e && "object" == typeof e
                                    }(e) && Be(e)
                                }(e) && ee.call(e, "callee") && (!de.call(e, "callee") || te.call(e) == o)
                            }(e) ? function(e, t) {
                                for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
                                return i
                            }(e.length, String) : [],
                            i = n.length,
                            r = !!i;
                        for (var s in e) !t && !ee.call(e, s) || r && ("length" == s || Ve(s, i)) || n.push(s);
                        return n
                    }(e) : function(e) {
                        if (!Ue(e)) return ue(e);
                        var t = [];
                        for (var n in Object(e)) ee.call(e, n) && "constructor" != n && t.push(n);
                        return t
                    }(e)
                }
                e.exports = function(e) {
                    return Oe(e, !0, !0)
                }
            },
            509: (e, t, n) => {
                var i = NaN,
                    r = "[object Symbol]",
                    o = /^\s+|\s+$/g,
                    s = /^[-+]0x[0-9a-f]+$/i,
                    a = /^0b[01]+$/i,
                    d = /^0o[0-7]+$/i,
                    c = parseInt,
                    l = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
                    h = "object" == typeof self && self && self.Object === Object && self,
                    u = l || h || Function("return this")(),
                    p = Object.prototype.toString,
                    m = Math.max,
                    g = Math.min,
                    f = function() {
                        return u.Date.now()
                    };

                function v(e) {
                    var t = typeof e;
                    return !!e && ("object" == t || "function" == t)
                }

                function _(e) {
                    if ("number" == typeof e) return e;
                    if (function(e) {
                            return "symbol" == typeof e || function(e) {
                                return !!e && "object" == typeof e
                            }(e) && p.call(e) == r
                        }(e)) return i;
                    if (v(e)) {
                        var t = "function" == typeof e.valueOf ? e.valueOf() : e;
                        e = v(t) ? t + "" : t
                    }
                    if ("string" != typeof e) return 0 === e ? e : +e;
                    e = e.replace(o, "");
                    var n = a.test(e);
                    return n || d.test(e) ? c(e.slice(2), n ? 2 : 8) : s.test(e) ? i : +e
                }
                e.exports = function(e, t, n) {
                    var i, r, o, s, a, d, c = 0,
                        l = !1,
                        h = !1,
                        u = !0;
                    if ("function" != typeof e) throw new TypeError("Expected a function");

                    function p(t) {
                        var n = i,
                            o = r;
                        return i = r = void 0, c = t, s = e.apply(o, n)
                    }

                    function y(e) {
                        var n = e - d;
                        return void 0 === d || n >= t || n < 0 || h && e - c >= o
                    }

                    function E() {
                        var e = f();
                        if (y(e)) return S(e);
                        a = setTimeout(E, function(e) {
                            var n = t - (e - d);
                            return h ? g(n, o - (e - c)) : n
                        }(e))
                    }

                    function S(e) {
                        return a = void 0, u && i ? p(e) : (i = r = void 0, s)
                    }

                    function b() {
                        var e = f(),
                            n = y(e);
                        if (i = arguments, r = this, d = e, n) {
                            if (void 0 === a) return function(e) {
                                return c = e, a = setTimeout(E, t), l ? p(e) : s
                            }(d);
                            if (h) return a = setTimeout(E, t), p(d)
                        }
                        return void 0 === a && (a = setTimeout(E, t)), s
                    }
                    return t = _(t) || 0, v(n) && (l = !!n.leading, o = (h = "maxWait" in n) ? m(_(n.maxWait) || 0, t) : o, u = "trailing" in n ? !!n.trailing : u), b.cancel = function() {
                        void 0 !== a && clearTimeout(a), c = 0, i = d = r = a = void 0
                    }, b.flush = function() {
                        return void 0 === a ? s : S(f())
                    }, b
                }
            },
            47: (e, t, n) => {
                e = n.nmd(e);
                var i = "__lodash_hash_undefined__",
                    r = 1,
                    o = 2,
                    s = 9007199254740991,
                    a = "[object Arguments]",
                    d = "[object Array]",
                    c = "[object AsyncFunction]",
                    l = "[object Boolean]",
                    h = "[object Date]",
                    u = "[object Error]",
                    p = "[object Function]",
                    m = "[object GeneratorFunction]",
                    g = "[object Map]",
                    f = "[object Number]",
                    v = "[object Null]",
                    _ = "[object Object]",
                    y = "[object Promise]",
                    E = "[object Proxy]",
                    S = "[object RegExp]",
                    b = "[object Set]",
                    T = "[object String]",
                    C = "[object Symbol]",
                    x = "[object Undefined]",
                    R = "[object WeakMap]",
                    A = "[object ArrayBuffer]",
                    w = "[object DataView]",
                    I = /^\[object .+?Constructor\]$/,
                    P = /^(?:0|[1-9]\d*)$/,
                    D = {};
                D["[object Float32Array]"] = D["[object Float64Array]"] = D["[object Int8Array]"] = D["[object Int16Array]"] = D["[object Int32Array]"] = D["[object Uint8Array]"] = D["[object Uint8ClampedArray]"] = D["[object Uint16Array]"] = D["[object Uint32Array]"] = !0, D[a] = D[d] = D[A] = D[l] = D[w] = D[h] = D[u] = D[p] = D[g] = D[f] = D[_] = D[S] = D[b] = D[T] = D[R] = !1;
                var O = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
                    N = "object" == typeof self && self && self.Object === Object && self,
                    k = O || N || Function("return this")(),
                    M = t && !t.nodeType && t,
                    L = M && e && !e.nodeType && e,
                    F = L && L.exports === M,
                    j = F && O.process,
                    V = function() {
                        try {
                            return j && j.binding && j.binding("util")
                        } catch (e) {}
                    }(),
                    U = V && V.isTypedArray;

                function H(e, t) {
                    for (var n = -1, i = null == e ? 0 : e.length; ++n < i;)
                        if (t(e[n], n, e)) return !0;
                    return !1
                }

                function $(e) {
                    var t = -1,
                        n = Array(e.size);
                    return e.forEach((function(e, i) {
                        n[++t] = [i, e]
                    })), n
                }

                function J(e) {
                    var t = -1,
                        n = Array(e.size);
                    return e.forEach((function(e) {
                        n[++t] = e
                    })), n
                }
                var B, q, G, z = Array.prototype,
                    K = Function.prototype,
                    W = Object.prototype,
                    X = k["__core-js_shared__"],
                    Y = K.toString,
                    Q = W.hasOwnProperty,
                    Z = (B = /[^.]+$/.exec(X && X.keys && X.keys.IE_PROTO || "")) ? "Symbol(src)_1." + B : "",
                    ee = W.toString,
                    te = RegExp("^" + Y.call(Q).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                    ne = F ? k.Buffer : void 0,
                    ie = k.Symbol,
                    re = k.Uint8Array,
                    oe = W.propertyIsEnumerable,
                    se = z.splice,
                    ae = ie ? ie.toStringTag : void 0,
                    de = Object.getOwnPropertySymbols,
                    ce = ne ? ne.isBuffer : void 0,
                    le = (q = Object.keys, G = Object, function(e) {
                        return q(G(e))
                    }),
                    he = Le(k, "DataView"),
                    ue = Le(k, "Map"),
                    pe = Le(k, "Promise"),
                    me = Le(k, "Set"),
                    ge = Le(k, "WeakMap"),
                    fe = Le(Object, "create"),
                    ve = Ue(he),
                    _e = Ue(ue),
                    ye = Ue(pe),
                    Ee = Ue(me),
                    Se = Ue(ge),
                    be = ie ? ie.prototype : void 0,
                    Te = be ? be.valueOf : void 0;

                function Ce(e) {
                    var t = -1,
                        n = null == e ? 0 : e.length;
                    for (this.clear(); ++t < n;) {
                        var i = e[t];
                        this.set(i[0], i[1])
                    }
                }

                function xe(e) {
                    var t = -1,
                        n = null == e ? 0 : e.length;
                    for (this.clear(); ++t < n;) {
                        var i = e[t];
                        this.set(i[0], i[1])
                    }
                }

                function Re(e) {
                    var t = -1,
                        n = null == e ? 0 : e.length;
                    for (this.clear(); ++t < n;) {
                        var i = e[t];
                        this.set(i[0], i[1])
                    }
                }

                function Ae(e) {
                    var t = -1,
                        n = null == e ? 0 : e.length;
                    for (this.__data__ = new Re; ++t < n;) this.add(e[t])
                }

                function we(e) {
                    var t = this.__data__ = new xe(e);
                    this.size = t.size
                }

                function Ie(e, t) {
                    for (var n = e.length; n--;)
                        if (He(e[n][0], t)) return n;
                    return -1
                }

                function Pe(e) {
                    return null == e ? void 0 === e ? x : v : ae && ae in Object(e) ? function(e) {
                        var t = Q.call(e, ae),
                            n = e[ae];
                        try {
                            e[ae] = void 0;
                            var i = !0
                        } catch (e) {}
                        var r = ee.call(e);
                        return i && (t ? e[ae] = n : delete e[ae]), r
                    }(e) : function(e) {
                        return ee.call(e)
                    }(e)
                }

                function De(e) {
                    return Ke(e) && Pe(e) == a
                }

                function Oe(e, t, n, i, s) {
                    return e === t || (null == e || null == t || !Ke(e) && !Ke(t) ? e != e && t != t : function(e, t, n, i, s, c) {
                        var p = Je(e),
                            m = Je(t),
                            v = p ? d : je(e),
                            y = m ? d : je(t),
                            E = (v = v == a ? _ : v) == _,
                            x = (y = y == a ? _ : y) == _,
                            R = v == y;
                        if (R && Be(e)) {
                            if (!Be(t)) return !1;
                            p = !0, E = !1
                        }
                        if (R && !E) return c || (c = new we), p || We(e) ? Ne(e, t, n, i, s, c) : function(e, t, n, i, s, a, d) {
                            switch (n) {
                                case w:
                                    if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
                                    e = e.buffer, t = t.buffer;
                                case A:
                                    return !(e.byteLength != t.byteLength || !a(new re(e), new re(t)));
                                case l:
                                case h:
                                case f:
                                    return He(+e, +t);
                                case u:
                                    return e.name == t.name && e.message == t.message;
                                case S:
                                case T:
                                    return e == t + "";
                                case g:
                                    var c = $;
                                case b:
                                    var p = i & r;
                                    if (c || (c = J), e.size != t.size && !p) return !1;
                                    var m = d.get(e);
                                    if (m) return m == t;
                                    i |= o, d.set(e, t);
                                    var v = Ne(c(e), c(t), i, s, a, d);
                                    return d.delete(e), v;
                                case C:
                                    if (Te) return Te.call(e) == Te.call(t)
                            }
                            return !1
                        }(e, t, v, n, i, s, c);
                        if (!(n & r)) {
                            var I = E && Q.call(e, "__wrapped__"),
                                P = x && Q.call(t, "__wrapped__");
                            if (I || P) {
                                var D = I ? e.value() : e,
                                    O = P ? t.value() : t;
                                return c || (c = new we), s(D, O, n, i, c)
                            }
                        }
                        return !!R && (c || (c = new we), function(e, t, n, i, o, s) {
                            var a = n & r,
                                d = ke(e),
                                c = d.length;
                            if (c != ke(t).length && !a) return !1;
                            for (var l = c; l--;) {
                                var h = d[l];
                                if (!(a ? h in t : Q.call(t, h))) return !1
                            }
                            var u = s.get(e);
                            if (u && s.get(t)) return u == t;
                            var p = !0;
                            s.set(e, t), s.set(t, e);
                            for (var m = a; ++l < c;) {
                                var g = e[h = d[l]],
                                    f = t[h];
                                if (i) var v = a ? i(f, g, h, t, e, s) : i(g, f, h, e, t, s);
                                if (!(void 0 === v ? g === f || o(g, f, n, i, s) : v)) {
                                    p = !1;
                                    break
                                }
                                m || (m = "constructor" == h)
                            }
                            if (p && !m) {
                                var _ = e.constructor,
                                    y = t.constructor;
                                _ == y || !("constructor" in e) || !("constructor" in t) || "function" == typeof _ && _ instanceof _ && "function" == typeof y && y instanceof y || (p = !1)
                            }
                            return s.delete(e), s.delete(t), p
                        }(e, t, n, i, s, c))
                    }(e, t, n, i, Oe, s))
                }

                function Ne(e, t, n, i, s, a) {
                    var d = n & r,
                        c = e.length,
                        l = t.length;
                    if (c != l && !(d && l > c)) return !1;
                    var h = a.get(e);
                    if (h && a.get(t)) return h == t;
                    var u = -1,
                        p = !0,
                        m = n & o ? new Ae : void 0;
                    for (a.set(e, t), a.set(t, e); ++u < c;) {
                        var g = e[u],
                            f = t[u];
                        if (i) var v = d ? i(f, g, u, t, e, a) : i(g, f, u, e, t, a);
                        if (void 0 !== v) {
                            if (v) continue;
                            p = !1;
                            break
                        }
                        if (m) {
                            if (!H(t, (function(e, t) {
                                    if (r = t, !m.has(r) && (g === e || s(g, e, n, i, a))) return m.push(t);
                                    var r
                                }))) {
                                p = !1;
                                break
                            }
                        } else if (g !== f && !s(g, f, n, i, a)) {
                            p = !1;
                            break
                        }
                    }
                    return a.delete(e), a.delete(t), p
                }

                function ke(e) {
                    return function(e, t, n) {
                        var i = t(e);
                        return Je(e) ? i : function(e, t) {
                            for (var n = -1, i = t.length, r = e.length; ++n < i;) e[r + n] = t[n];
                            return e
                        }(i, n(e))
                    }(e, Xe, Fe)
                }

                function Me(e, t) {
                    var n, i, r = e.__data__;
                    return ("string" == (i = typeof(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? r["string" == typeof t ? "string" : "hash"] : r.map
                }

                function Le(e, t) {
                    var n = function(e, t) {
                        return null == e ? void 0 : e[t]
                    }(e, t);
                    return function(e) {
                        return !(!ze(e) || function(e) {
                            return !!Z && Z in e
                        }(e)) && (qe(e) ? te : I).test(Ue(e))
                    }(n) ? n : void 0
                }
                Ce.prototype.clear = function() {
                    this.__data__ = fe ? fe(null) : {}, this.size = 0
                }, Ce.prototype.delete = function(e) {
                    var t = this.has(e) && delete this.__data__[e];
                    return this.size -= t ? 1 : 0, t
                }, Ce.prototype.get = function(e) {
                    var t = this.__data__;
                    if (fe) {
                        var n = t[e];
                        return n === i ? void 0 : n
                    }
                    return Q.call(t, e) ? t[e] : void 0
                }, Ce.prototype.has = function(e) {
                    var t = this.__data__;
                    return fe ? void 0 !== t[e] : Q.call(t, e)
                }, Ce.prototype.set = function(e, t) {
                    var n = this.__data__;
                    return this.size += this.has(e) ? 0 : 1, n[e] = fe && void 0 === t ? i : t, this
                }, xe.prototype.clear = function() {
                    this.__data__ = [], this.size = 0
                }, xe.prototype.delete = function(e) {
                    var t = this.__data__,
                        n = Ie(t, e);
                    return !(n < 0 || (n == t.length - 1 ? t.pop() : se.call(t, n, 1), --this.size, 0))
                }, xe.prototype.get = function(e) {
                    var t = this.__data__,
                        n = Ie(t, e);
                    return n < 0 ? void 0 : t[n][1]
                }, xe.prototype.has = function(e) {
                    return Ie(this.__data__, e) > -1
                }, xe.prototype.set = function(e, t) {
                    var n = this.__data__,
                        i = Ie(n, e);
                    return i < 0 ? (++this.size, n.push([e, t])) : n[i][1] = t, this
                }, Re.prototype.clear = function() {
                    this.size = 0, this.__data__ = {
                        hash: new Ce,
                        map: new(ue || xe),
                        string: new Ce
                    }
                }, Re.prototype.delete = function(e) {
                    var t = Me(this, e).delete(e);
                    return this.size -= t ? 1 : 0, t
                }, Re.prototype.get = function(e) {
                    return Me(this, e).get(e)
                }, Re.prototype.has = function(e) {
                    return Me(this, e).has(e)
                }, Re.prototype.set = function(e, t) {
                    var n = Me(this, e),
                        i = n.size;
                    return n.set(e, t), this.size += n.size == i ? 0 : 1, this
                }, Ae.prototype.add = Ae.prototype.push = function(e) {
                    return this.__data__.set(e, i), this
                }, Ae.prototype.has = function(e) {
                    return this.__data__.has(e)
                }, we.prototype.clear = function() {
                    this.__data__ = new xe, this.size = 0
                }, we.prototype.delete = function(e) {
                    var t = this.__data__,
                        n = t.delete(e);
                    return this.size = t.size, n
                }, we.prototype.get = function(e) {
                    return this.__data__.get(e)
                }, we.prototype.has = function(e) {
                    return this.__data__.has(e)
                }, we.prototype.set = function(e, t) {
                    var n = this.__data__;
                    if (n instanceof xe) {
                        var i = n.__data__;
                        if (!ue || i.length < 199) return i.push([e, t]), this.size = ++n.size, this;
                        n = this.__data__ = new Re(i)
                    }
                    return n.set(e, t), this.size = n.size, this
                };
                var Fe = de ? function(e) {
                        return null == e ? [] : (e = Object(e), function(t, n) {
                            for (var i = -1, r = null == t ? 0 : t.length, o = 0, s = []; ++i < r;) {
                                var a = t[i];
                                d = a, oe.call(e, d) && (s[o++] = a)
                            }
                            var d;
                            return s
                        }(de(e)))
                    } : function() {
                        return []
                    },
                    je = Pe;

                function Ve(e, t) {
                    return !!(t = null == t ? s : t) && ("number" == typeof e || P.test(e)) && e > -1 && e % 1 == 0 && e < t
                }

                function Ue(e) {
                    if (null != e) {
                        try {
                            return Y.call(e)
                        } catch (e) {}
                        try {
                            return e + ""
                        } catch (e) {}
                    }
                    return ""
                }

                function He(e, t) {
                    return e === t || e != e && t != t
                }(he && je(new he(new ArrayBuffer(1))) != w || ue && je(new ue) != g || pe && je(pe.resolve()) != y || me && je(new me) != b || ge && je(new ge) != R) && (je = function(e) {
                    var t = Pe(e),
                        n = t == _ ? e.constructor : void 0,
                        i = n ? Ue(n) : "";
                    if (i) switch (i) {
                        case ve:
                            return w;
                        case _e:
                            return g;
                        case ye:
                            return y;
                        case Ee:
                            return b;
                        case Se:
                            return R
                    }
                    return t
                });
                var $e = De(function() {
                        return arguments
                    }()) ? De : function(e) {
                        return Ke(e) && Q.call(e, "callee") && !oe.call(e, "callee")
                    },
                    Je = Array.isArray,
                    Be = ce || function() {
                        return !1
                    };

                function qe(e) {
                    if (!ze(e)) return !1;
                    var t = Pe(e);
                    return t == p || t == m || t == c || t == E
                }

                function Ge(e) {
                    return "number" == typeof e && e > -1 && e % 1 == 0 && e <= s
                }

                function ze(e) {
                    var t = typeof e;
                    return null != e && ("object" == t || "function" == t)
                }

                function Ke(e) {
                    return null != e && "object" == typeof e
                }
                var We = U ? function(e) {
                    return function(t) {
                        return e(t)
                    }
                }(U) : function(e) {
                    return Ke(e) && Ge(e.length) && !!D[Pe(e)]
                };

                function Xe(e) {
                    return null != (t = e) && Ge(t.length) && !qe(t) ? function(e, t) {
                        var n = Je(e),
                            i = !n && $e(e),
                            r = !n && !i && Be(e),
                            o = !n && !i && !r && We(e),
                            s = n || i || r || o,
                            a = s ? function(e, t) {
                                for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
                                return i
                            }(e.length, String) : [],
                            d = a.length;
                        for (var c in e) !t && !Q.call(e, c) || s && ("length" == c || r && ("offset" == c || "parent" == c) || o && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || Ve(c, d)) || a.push(c);
                        return a
                    }(e) : function(e) {
                        if (n = (t = e) && t.constructor, t !== ("function" == typeof n && n.prototype || W)) return le(e);
                        var t, n, i = [];
                        for (var r in Object(e)) Q.call(e, r) && "constructor" != r && i.push(r);
                        return i
                    }(e);
                    var t
                }
                e.exports = function(e, t) {
                    return Oe(e, t)
                }
            },
            296: e => {
                var t = e.exports = {
                    v: [{
                        name: "version",
                        reg: /^(\d*)$/
                    }],
                    o: [{
                        name: "origin",
                        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                        names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
                        format: "%s %s %d %s IP%d %s"
                    }],
                    s: [{
                        name: "name"
                    }],
                    i: [{
                        name: "description"
                    }],
                    u: [{
                        name: "uri"
                    }],
                    e: [{
                        name: "email"
                    }],
                    p: [{
                        name: "phone"
                    }],
                    z: [{
                        name: "timezones"
                    }],
                    r: [{
                        name: "repeats"
                    }],
                    t: [{
                        name: "timing",
                        reg: /^(\d*) (\d*)/,
                        names: ["start", "stop"],
                        format: "%d %d"
                    }],
                    c: [{
                        name: "connection",
                        reg: /^IN IP(\d) (\S*)/,
                        names: ["version", "ip"],
                        format: "IN IP%d %s"
                    }],
                    b: [{
                        push: "bandwidth",
                        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                        names: ["type", "limit"],
                        format: "%s:%s"
                    }],
                    m: [{
                        reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
                        names: ["type", "port", "protocol", "payloads"],
                        format: "%s %d %s %s"
                    }],
                    a: [{
                        push: "rtp",
                        reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
                        names: ["payload", "codec", "rate", "encoding"],
                        format: function(e) {
                            return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
                        }
                    }, {
                        push: "fmtp",
                        reg: /^fmtp:(\d*) ([\S| ]*)/,
                        names: ["payload", "config"],
                        format: "fmtp:%d %s"
                    }, {
                        name: "control",
                        reg: /^control:(.*)/,
                        format: "control:%s"
                    }, {
                        name: "rtcp",
                        reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                        names: ["port", "netType", "ipVer", "address"],
                        format: function(e) {
                            return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
                        }
                    }, {
                        push: "rtcpFbTrrInt",
                        reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                        names: ["payload", "value"],
                        format: "rtcp-fb:%d trr-int %d"
                    }, {
                        push: "rtcpFb",
                        reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                        names: ["payload", "type", "subtype"],
                        format: function(e) {
                            return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
                        }
                    }, {
                        push: "ext",
                        reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
                        names: ["value", "direction", "uri", "config"],
                        format: function(e) {
                            return "extmap:%d" + (e.direction ? "/%s" : "%v") + " %s" + (e.config ? " %s" : "")
                        }
                    }, {
                        push: "crypto",
                        reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                        names: ["id", "suite", "config", "sessionConfig"],
                        format: function(e) {
                            return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
                        }
                    }, {
                        name: "setup",
                        reg: /^setup:(\w*)/,
                        format: "setup:%s"
                    }, {
                        name: "mid",
                        reg: /^mid:([^\s]*)/,
                        format: "mid:%s"
                    }, {
                        name: "msid",
                        reg: /^msid:(.*)/,
                        format: "msid:%s"
                    }, {
                        name: "ptime",
                        reg: /^ptime:(\d*)/,
                        format: "ptime:%d"
                    }, {
                        name: "maxptime",
                        reg: /^maxptime:(\d*)/,
                        format: "maxptime:%d"
                    }, {
                        name: "direction",
                        reg: /^(sendrecv|recvonly|sendonly|inactive)/
                    }, {
                        name: "icelite",
                        reg: /^(ice-lite)/
                    }, {
                        name: "iceUfrag",
                        reg: /^ice-ufrag:(\S*)/,
                        format: "ice-ufrag:%s"
                    }, {
                        name: "icePwd",
                        reg: /^ice-pwd:(\S*)/,
                        format: "ice-pwd:%s"
                    }, {
                        name: "fingerprint",
                        reg: /^fingerprint:(\S*) (\S*)/,
                        names: ["type", "hash"],
                        format: "fingerprint:%s %s"
                    }, {
                        push: "candidates",
                        reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
                        names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
                        format: function(e) {
                            var t = "candidate:%s %d %s %d %s %d typ %s";
                            return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), (t += null != e["network-id"] ? " network-id %d" : "%v") + (null != e["network-cost"] ? " network-cost %d" : "%v")
                        }
                    }, {
                        name: "endOfCandidates",
                        reg: /^(end-of-candidates)/
                    }, {
                        name: "remoteCandidates",
                        reg: /^remote-candidates:(.*)/,
                        format: "remote-candidates:%s"
                    }, {
                        name: "iceOptions",
                        reg: /^ice-options:(\S*)/,
                        format: "ice-options:%s"
                    }, {
                        push: "ssrcs",
                        reg: /^ssrc:(\d*) ([\w_]*)(?::(.*))?/,
                        names: ["id", "attribute", "value"],
                        format: function(e) {
                            var t = "ssrc:%d";
                            return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
                        }
                    }, {
                        push: "ssrcGroups",
                        reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
                        names: ["semantics", "ssrcs"],
                        format: "ssrc-group:%s %s"
                    }, {
                        name: "msidSemantic",
                        reg: /^msid-semantic:\s?(\w*) (\S*)/,
                        names: ["semantic", "token"],
                        format: "msid-semantic: %s %s"
                    }, {
                        push: "groups",
                        reg: /^group:(\w*) (.*)/,
                        names: ["type", "mids"],
                        format: "group:%s %s"
                    }, {
                        name: "rtcpMux",
                        reg: /^(rtcp-mux)/
                    }, {
                        name: "rtcpRsize",
                        reg: /^(rtcp-rsize)/
                    }, {
                        name: "sctpmap",
                        reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
                        names: ["sctpmapNumber", "app", "maxMessageSize"],
                        format: function(e) {
                            return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
                        }
                    }, {
                        name: "xGoogleFlag",
                        reg: /^x-google-flag:([^\s]*)/,
                        format: "x-google-flag:%s"
                    }, {
                        push: "rids",
                        reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
                        names: ["id", "direction", "params"],
                        format: function(e) {
                            return e.params ? "rid:%s %s %s" : "rid:%s %s"
                        }
                    }, {
                        push: "imageattrs",
                        reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
                        names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
                        format: function(e) {
                            return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
                        }
                    }, {
                        name: "simulcast",
                        reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
                        names: ["dir1", "list1", "dir2", "list2"],
                        format: function(e) {
                            return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
                        }
                    }, {
                        name: "simulcast_03",
                        reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
                        names: ["value"],
                        format: "simulcast: %s"
                    }, {
                        name: "framerate",
                        reg: /^framerate:(\d+(?:$|\.\d+))/,
                        format: "framerate:%s"
                    }, {
                        push: "invalid",
                        names: ["value"]
                    }]
                };
                Object.keys(t).forEach((function(e) {
                    t[e].forEach((function(e) {
                        e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
                    }))
                }))
            },
            310: (e, t, n) => {
                var i = n(415),
                    r = n(159);
                t.write = r, t.parse = i.parse, t.parseFmtpConfig = i.parseFmtpConfig, t.parseParams = i.parseParams, t.parsePayloads = i.parsePayloads, t.parseRemoteCandidates = i.parseRemoteCandidates, t.parseImageAttributes = i.parseImageAttributes, t.parseSimulcastStreamList = i.parseSimulcastStreamList
            },
            415: (e, t, n) => {
                var i = function(e) {
                        return String(Number(e)) === e ? Number(e) : e
                    },
                    r = function(e, t, n) {
                        var r = e.name && e.names;
                        e.push && !t[e.push] ? t[e.push] = [] : r && !t[e.name] && (t[e.name] = {});
                        var o = e.push ? {} : r ? t[e.name] : t;
                        ! function(e, t, n, r) {
                            if (r && !n) t[r] = i(e[1]);
                            else
                                for (var o = 0; o < n.length; o += 1) null != e[o + 1] && (t[n[o]] = i(e[o + 1]))
                        }(n.match(e.reg), o, e.names, e.name), e.push && t[e.push].push(o)
                    },
                    o = n(296),
                    s = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
                t.parse = function(e) {
                    var t = {},
                        n = [],
                        i = t;
                    return e.split(/(\r\n|\r|\n)/).filter(s).forEach((function(e) {
                        var t = e[0],
                            s = e.slice(2);
                        "m" === t && (n.push({
                            rtp: [],
                            fmtp: []
                        }), i = n[n.length - 1]);
                        for (var a = 0; a < (o[t] || []).length; a += 1) {
                            var d = o[t][a];
                            if (d.reg.test(s)) return r(d, i, s)
                        }
                    })), t.media = n, t
                };
                var a = function(e, t) {
                    var n = t.split(/=(.+)/, 2);
                    return 2 === n.length && (e[n[0]] = i(n[1])), e
                };
                t.parseParams = function(e) {
                    return e.split(/\;\s?/).reduce(a, {})
                }, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
                    return e.split(" ").map(Number)
                }, t.parseRemoteCandidates = function(e) {
                    for (var t = [], n = e.split(" ").map(i), r = 0; r < n.length; r += 3) t.push({
                        component: n[r],
                        ip: n[r + 1],
                        port: n[r + 2]
                    });
                    return t
                }, t.parseImageAttributes = function(e) {
                    return e.split(" ").map((function(e) {
                        return e.substring(1, e.length - 1).split(",").reduce(a, {})
                    }))
                }, t.parseSimulcastStreamList = function(e) {
                    return e.split(";").map((function(e) {
                        return e.split(",").map((function(e) {
                            var t, n = !1;
                            return "~" !== e[0] ? t = i(e) : (t = i(e.substring(1, e.length)), n = !0), {
                                scid: t,
                                paused: n
                            }
                        }))
                    }))
                }
            },
            159: (e, t, n) => {
                var i = n(296),
                    r = /%[sdv%]/g,
                    o = function(e) {
                        var t = 1,
                            n = arguments,
                            i = n.length;
                        return e.replace(r, (function(e) {
                            if (t >= i) return e;
                            var r = n[t];
                            switch (t += 1, e) {
                                case "%%":
                                    return "%";
                                case "%s":
                                    return String(r);
                                case "%d":
                                    return Number(r);
                                case "%v":
                                    return ""
                            }
                        }))
                    },
                    s = function(e, t, n) {
                        var i = [e + "=" + (t.format instanceof Function ? t.format(t.push ? n : n[t.name]) : t.format)];
                        if (t.names)
                            for (var r = 0; r < t.names.length; r += 1) {
                                var s = t.names[r];
                                t.name ? i.push(n[t.name][s]) : i.push(n[t.names[r]])
                            } else i.push(n[t.name]);
                        return o.apply(null, i)
                    },
                    a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
                    d = ["i", "c", "b", "a"];
                e.exports = function(e, t) {
                    t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
                        null == e.payloads && (e.payloads = "")
                    }));
                    var n = t.outerOrder || a,
                        r = t.innerOrder || d,
                        o = [];
                    return n.forEach((function(t) {
                        i[t].forEach((function(n) {
                            n.name in e && null != e[n.name] ? o.push(s(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                                o.push(s(t, n, e))
                            }))
                        }))
                    })), e.media.forEach((function(e) {
                        o.push(s("m", i.m[0], e)), r.forEach((function(t) {
                            i[t].forEach((function(n) {
                                n.name in e && null != e[n.name] ? o.push(s(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                                    o.push(s(t, n, e))
                                }))
                            }))
                        }))
                    })), o.join("\r\n") + "\r\n"
                }
            },
            483: e => {
                "use strict";
                const t = {
                    generateIdentifier: function() {
                        return Math.random().toString(36).substr(2, 10)
                    }
                };
                t.localCName = t.generateIdentifier(), t.splitLines = function(e) {
                    return e.trim().split("\n").map((e => e.trim()))
                }, t.splitSections = function(e) {
                    return e.split("\nm=").map(((e, t) => (t > 0 ? "m=" + e : e).trim() + "\r\n"))
                }, t.getDescription = function(e) {
                    const n = t.splitSections(e);
                    return n && n[0]
                }, t.getMediaSections = function(e) {
                    const n = t.splitSections(e);
                    return n.shift(), n
                }, t.matchPrefix = function(e, n) {
                    return t.splitLines(e).filter((e => 0 === e.indexOf(n)))
                }, t.parseCandidate = function(e) {
                    let t;
                    t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" ");
                    const n = {
                        foundation: t[0],
                        component: {
                            1: "rtp",
                            2: "rtcp"
                        } [t[1]] || t[1],
                        protocol: t[2].toLowerCase(),
                        priority: parseInt(t[3], 10),
                        ip: t[4],
                        address: t[4],
                        port: parseInt(t[5], 10),
                        type: t[7]
                    };
                    for (let e = 8; e < t.length; e += 2) switch (t[e]) {
                        case "raddr":
                            n.relatedAddress = t[e + 1];
                            break;
                        case "rport":
                            n.relatedPort = parseInt(t[e + 1], 10);
                            break;
                        case "tcptype":
                            n.tcpType = t[e + 1];
                            break;
                        case "ufrag":
                            n.ufrag = t[e + 1], n.usernameFragment = t[e + 1];
                            break;
                        default:
                            void 0 === n[t[e]] && (n[t[e]] = t[e + 1])
                    }
                    return n
                }, t.writeCandidate = function(e) {
                    const t = [];
                    t.push(e.foundation);
                    const n = e.component;
                    "rtp" === n ? t.push(1) : "rtcp" === n ? t.push(2) : t.push(n), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);
                    const i = e.type;
                    return t.push("typ"), t.push(i), "host" !== i && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ")
                }, t.parseIceOptions = function(e) {
                    return e.substr(14).split(" ")
                }, t.parseRtpMap = function(e) {
                    let t = e.substr(9).split(" ");
                    const n = {
                        payloadType: parseInt(t.shift(), 10)
                    };
                    return t = t[0].split("/"), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.channels = 3 === t.length ? parseInt(t[2], 10) : 1, n.numChannels = n.channels, n
                }, t.writeRtpMap = function(e) {
                    let t = e.payloadType;
                    void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);
                    const n = e.channels || e.numChannels || 1;
                    return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== n ? "/" + n : "") + "\r\n"
                }, t.parseExtmap = function(e) {
                    const t = e.substr(9).split(" ");
                    return {
                        id: parseInt(t[0], 10),
                        direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv",
                        uri: t[1]
                    }
                }, t.writeExtmap = function(e) {
                    return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n"
                }, t.parseFmtp = function(e) {
                    const t = {};
                    let n;
                    const i = e.substr(e.indexOf(" ") + 1).split(";");
                    for (let e = 0; e < i.length; e++) n = i[e].trim().split("="), t[n[0].trim()] = n[1];
                    return t
                }, t.writeFmtp = function(e) {
                    let t = "",
                        n = e.payloadType;
                    if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
                        const i = [];
                        Object.keys(e.parameters).forEach((t => {
                            void 0 !== e.parameters[t] ? i.push(t + "=" + e.parameters[t]) : i.push(t)
                        })), t += "a=fmtp:" + n + " " + i.join(";") + "\r\n"
                    }
                    return t
                }, t.parseRtcpFb = function(e) {
                    const t = e.substr(e.indexOf(" ") + 1).split(" ");
                    return {
                        type: t.shift(),
                        parameter: t.join(" ")
                    }
                }, t.writeRtcpFb = function(e) {
                    let t = "",
                        n = e.payloadType;
                    return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach((e => {
                        t += "a=rtcp-fb:" + n + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n"
                    })), t
                }, t.parseSsrcMedia = function(e) {
                    const t = e.indexOf(" "),
                        n = {
                            ssrc: parseInt(e.substr(7, t - 7), 10)
                        },
                        i = e.indexOf(":", t);
                    return i > -1 ? (n.attribute = e.substr(t + 1, i - t - 1), n.value = e.substr(i + 1)) : n.attribute = e.substr(t + 1), n
                }, t.parseSsrcGroup = function(e) {
                    const t = e.substr(13).split(" ");
                    return {
                        semantics: t.shift(),
                        ssrcs: t.map((e => parseInt(e, 10)))
                    }
                }, t.getMid = function(e) {
                    const n = t.matchPrefix(e, "a=mid:")[0];
                    if (n) return n.substr(6)
                }, t.parseFingerprint = function(e) {
                    const t = e.substr(14).split(" ");
                    return {
                        algorithm: t[0].toLowerCase(),
                        value: t[1].toUpperCase()
                    }
                }, t.getDtlsParameters = function(e, n) {
                    return {
                        role: "auto",
                        fingerprints: t.matchPrefix(e + n, "a=fingerprint:").map(t.parseFingerprint)
                    }
                }, t.writeDtlsParameters = function(e, t) {
                    let n = "a=setup:" + t + "\r\n";
                    return e.fingerprints.forEach((e => {
                        n += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"
                    })), n
                }, t.parseCryptoLine = function(e) {
                    const t = e.substr(9).split(" ");
                    return {
                        tag: parseInt(t[0], 10),
                        cryptoSuite: t[1],
                        keyParams: t[2],
                        sessionParams: t.slice(3)
                    }
                }, t.writeCryptoLine = function(e) {
                    return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" == typeof e.keyParams ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n"
                }, t.parseCryptoKeyParams = function(e) {
                    if (0 !== e.indexOf("inline:")) return null;
                    const t = e.substr(7).split("|");
                    return {
                        keyMethod: "inline",
                        keySalt: t[0],
                        lifeTime: t[1],
                        mkiValue: t[2] ? t[2].split(":")[0] : void 0,
                        mkiLength: t[2] ? t[2].split(":")[1] : void 0
                    }
                }, t.writeCryptoKeyParams = function(e) {
                    return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "")
                }, t.getCryptoParameters = function(e, n) {
                    return t.matchPrefix(e + n, "a=crypto:").map(t.parseCryptoLine)
                }, t.getIceParameters = function(e, n) {
                    const i = t.matchPrefix(e + n, "a=ice-ufrag:")[0],
                        r = t.matchPrefix(e + n, "a=ice-pwd:")[0];
                    return i && r ? {
                        usernameFragment: i.substr(12),
                        password: r.substr(10)
                    } : null
                }, t.writeIceParameters = function(e) {
                    let t = "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n";
                    return e.iceLite && (t += "a=ice-lite\r\n"), t
                }, t.parseRtpParameters = function(e) {
                    const n = {
                            codecs: [],
                            headerExtensions: [],
                            fecMechanisms: [],
                            rtcp: []
                        },
                        i = t.splitLines(e)[0].split(" ");
                    for (let r = 3; r < i.length; r++) {
                        const o = i[r],
                            s = t.matchPrefix(e, "a=rtpmap:" + o + " ")[0];
                        if (s) {
                            const i = t.parseRtpMap(s),
                                r = t.matchPrefix(e, "a=fmtp:" + o + " ");
                            switch (i.parameters = r.length ? t.parseFmtp(r[0]) : {}, i.rtcpFeedback = t.matchPrefix(e, "a=rtcp-fb:" + o + " ").map(t.parseRtcpFb), n.codecs.push(i), i.name.toUpperCase()) {
                                case "RED":
                                case "ULPFEC":
                                    n.fecMechanisms.push(i.name.toUpperCase())
                            }
                        }
                    }
                    return t.matchPrefix(e, "a=extmap:").forEach((e => {
                        n.headerExtensions.push(t.parseExtmap(e))
                    })), n
                }, t.writeRtpDescription = function(e, n) {
                    let i = "";
                    i += "m=" + e + " ", i += n.codecs.length > 0 ? "9" : "0", i += " UDP/TLS/RTP/SAVPF ", i += n.codecs.map((e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType)).join(" ") + "\r\n", i += "c=IN IP4 0.0.0.0\r\n", i += "a=rtcp:9 IN IP4 0.0.0.0\r\n", n.codecs.forEach((e => {
                        i += t.writeRtpMap(e), i += t.writeFmtp(e), i += t.writeRtcpFb(e)
                    }));
                    let r = 0;
                    return n.codecs.forEach((e => {
                        e.maxptime > r && (r = e.maxptime)
                    })), r > 0 && (i += "a=maxptime:" + r + "\r\n"), n.headerExtensions && n.headerExtensions.forEach((e => {
                        i += t.writeExtmap(e)
                    })), i
                }, t.parseRtpEncodingParameters = function(e) {
                    const n = [],
                        i = t.parseRtpParameters(e),
                        r = -1 !== i.fecMechanisms.indexOf("RED"),
                        o = -1 !== i.fecMechanisms.indexOf("ULPFEC"),
                        s = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute)),
                        a = s.length > 0 && s[0].ssrc;
                    let d;
                    const c = t.matchPrefix(e, "a=ssrc-group:FID").map((e => e.substr(17).split(" ").map((e => parseInt(e, 10)))));
                    c.length > 0 && c[0].length > 1 && c[0][0] === a && (d = c[0][1]), i.codecs.forEach((e => {
                        if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
                            let t = {
                                ssrc: a,
                                codecPayloadType: parseInt(e.parameters.apt, 10)
                            };
                            a && d && (t.rtx = {
                                ssrc: d
                            }), n.push(t), r && (t = JSON.parse(JSON.stringify(t)), t.fec = {
                                ssrc: a,
                                mechanism: o ? "red+ulpfec" : "red"
                            }, n.push(t))
                        }
                    })), 0 === n.length && a && n.push({
                        ssrc: a
                    });
                    let l = t.matchPrefix(e, "b=");
                    return l.length && (l = 0 === l[0].indexOf("b=TIAS:") ? parseInt(l[0].substr(7), 10) : 0 === l[0].indexOf("b=AS:") ? 1e3 * parseInt(l[0].substr(5), 10) * .95 - 16e3 : void 0, n.forEach((e => {
                        e.maxBitrate = l
                    }))), n
                }, t.parseRtcpParameters = function(e) {
                    const n = {},
                        i = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute))[0];
                    i && (n.cname = i.value, n.ssrc = i.ssrc);
                    const r = t.matchPrefix(e, "a=rtcp-rsize");
                    n.reducedSize = r.length > 0, n.compound = 0 === r.length;
                    const o = t.matchPrefix(e, "a=rtcp-mux");
                    return n.mux = o.length > 0, n
                }, t.writeRtcpParameters = function(e) {
                    let t = "";
                    return e.reducedSize && (t += "a=rtcp-rsize\r\n"), e.mux && (t += "a=rtcp-mux\r\n"), void 0 !== e.ssrc && e.cname && (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), t
                }, t.parseMsid = function(e) {
                    let n;
                    const i = t.matchPrefix(e, "a=msid:");
                    if (1 === i.length) return n = i[0].substr(7).split(" "), {
                        stream: n[0],
                        track: n[1]
                    };
                    const r = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "msid" === e.attribute));
                    return r.length > 0 ? (n = r[0].value.split(" "), {
                        stream: n[0],
                        track: n[1]
                    }) : void 0
                }, t.parseSctpDescription = function(e) {
                    const n = t.parseMLine(e),
                        i = t.matchPrefix(e, "a=max-message-size:");
                    let r;
                    i.length > 0 && (r = parseInt(i[0].substr(19), 10)), isNaN(r) && (r = 65536);
                    const o = t.matchPrefix(e, "a=sctp-port:");
                    if (o.length > 0) return {
                        port: parseInt(o[0].substr(12), 10),
                        protocol: n.fmt,
                        maxMessageSize: r
                    };
                    const s = t.matchPrefix(e, "a=sctpmap:");
                    if (s.length > 0) {
                        const e = s[0].substr(10).split(" ");
                        return {
                            port: parseInt(e[0], 10),
                            protocol: e[1],
                            maxMessageSize: r
                        }
                    }
                }, t.writeSctpDescription = function(e, t) {
                    let n = [];
                    return n = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && n.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), n.join("")
                }, t.generateSessionId = function() {
                    return Math.random().toString().substr(2, 21)
                }, t.writeSessionBoilerplate = function(e, n, i) {
                    let r;
                    const o = void 0 !== n ? n : 2;
                    return r = e || t.generateSessionId(), "v=0\r\no=" + (i || "thisisadapterortc") + " " + r + " " + o + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
                }, t.getDirection = function(e, n) {
                    const i = t.splitLines(e);
                    for (let e = 0; e < i.length; e++) switch (i[e]) {
                        case "a=sendrecv":
                        case "a=sendonly":
                        case "a=recvonly":
                        case "a=inactive":
                            return i[e].substr(2)
                    }
                    return n ? t.getDirection(n) : "sendrecv"
                }, t.getKind = function(e) {
                    return t.splitLines(e)[0].split(" ")[0].substr(2)
                }, t.isRejected = function(e) {
                    return "0" === e.split(" ", 2)[1]
                }, t.parseMLine = function(e) {
                    const n = t.splitLines(e)[0].substr(2).split(" ");
                    return {
                        kind: n[0],
                        port: parseInt(n[1], 10),
                        protocol: n[2],
                        fmt: n.slice(3).join(" ")
                    }
                }, t.parseOLine = function(e) {
                    const n = t.matchPrefix(e, "o=")[0].substr(2).split(" ");
                    return {
                        username: n[0],
                        sessionId: n[1],
                        sessionVersion: parseInt(n[2], 10),
                        netType: n[3],
                        addressType: n[4],
                        address: n[5]
                    }
                }, t.isValidSDP = function(e) {
                    if ("string" != typeof e || 0 === e.length) return !1;
                    const n = t.splitLines(e);
                    for (let e = 0; e < n.length; e++)
                        if (n[e].length < 2 || "=" !== n[e].charAt(1)) return !1;
                    return !0
                }, e.exports = t
            },
            33: function(e, t, n) {
                ! function(e) {
                    "use strict";
                    var t = void 0 !== n.g ? n.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
                    const i = function() {
                        let e = t.WebSocket;
                        if (void 0 === e) try {
                            e = n(Object(function() {
                                var e = new Error("Cannot find module 'ws'");
                                throw e.code = "MODULE_NOT_FOUND", e
                            }()))
                        } catch (e) {
                            throw new Error('You must install the "ws" package to use Strophe in nodejs.')
                        }
                        return e
                    }();
                    const r = function() {
                        let e = t.DOMParser;
                        if (void 0 === e) try {
                            e = Object(function() {
                                var e = new Error("Cannot find module '@xmldom/xmldom'");
                                throw e.code = "MODULE_NOT_FOUND", e
                            }())
                        } catch (e) {
                            throw new Error('You must install the "@xmldom/xmldom" package to use Strophe in nodejs.')
                        }
                        return e
                    }();

                    function o() {
                        if ("undefined" == typeof document) try {
                            return (new(Object(function() {
                                var e = new Error("Cannot find module '@xmldom/xmldom'");
                                throw e.code = "MODULE_NOT_FOUND", e
                            }()))).createDocument("jabber:client", "strophe", null)
                        } catch (e) {
                            throw new Error('You must install the "@xmldom/xmldom" package to use Strophe in nodejs.')
                        }
                        if (void 0 === document.implementation.createDocument || document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
                            const e = function() {
                                const e = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"];
                                for (let t = 0; t < e.length; t++) try {
                                    return new ActiveXObject(e[t])
                                } catch (e) {}
                            }();
                            return e.appendChild(e.createElement("strophe")), e
                        }
                        return document.implementation.createDocument("jabber:client", "strophe", null)
                    }
                    const s = function(e, t) {
                            const n = (65535 & e) + (65535 & t);
                            return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                        },
                        a = function(e) {
                            if ("string" != typeof e) throw new Error("str2binl was passed a non-string");
                            const t = [];
                            for (let n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << n % 32;
                            return t
                        },
                        d = function(e, t, n, i, r, o) {
                            return s((a = s(s(t, e), s(i, o))) << (d = r) | a >>> 32 - d, n);
                            var a, d
                        },
                        c = function(e, t, n, i, r, o, s) {
                            return d(t & n | ~t & i, e, t, r, o, s)
                        },
                        l = function(e, t, n, i, r, o, s) {
                            return d(t & i | n & ~i, e, t, r, o, s)
                        },
                        h = function(e, t, n, i, r, o, s) {
                            return d(t ^ n ^ i, e, t, r, o, s)
                        },
                        u = function(e, t, n, i, r, o, s) {
                            return d(n ^ (t | ~i), e, t, r, o, s)
                        },
                        p = function(e, t) {
                            e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
                            let n, i, r, o, a = 1732584193,
                                d = -271733879,
                                p = -1732584194,
                                m = 271733878;
                            for (let t = 0; t < e.length; t += 16) n = a, i = d, r = p, o = m, a = c(a, d, p, m, e[t + 0], 7, -680876936), m = c(m, a, d, p, e[t + 1], 12, -389564586), p = c(p, m, a, d, e[t + 2], 17, 606105819), d = c(d, p, m, a, e[t + 3], 22, -1044525330), a = c(a, d, p, m, e[t + 4], 7, -176418897), m = c(m, a, d, p, e[t + 5], 12, 1200080426), p = c(p, m, a, d, e[t + 6], 17, -1473231341), d = c(d, p, m, a, e[t + 7], 22, -45705983), a = c(a, d, p, m, e[t + 8], 7, 1770035416), m = c(m, a, d, p, e[t + 9], 12, -1958414417), p = c(p, m, a, d, e[t + 10], 17, -42063), d = c(d, p, m, a, e[t + 11], 22, -1990404162), a = c(a, d, p, m, e[t + 12], 7, 1804603682), m = c(m, a, d, p, e[t + 13], 12, -40341101), p = c(p, m, a, d, e[t + 14], 17, -1502002290), d = c(d, p, m, a, e[t + 15], 22, 1236535329), a = l(a, d, p, m, e[t + 1], 5, -165796510), m = l(m, a, d, p, e[t + 6], 9, -1069501632), p = l(p, m, a, d, e[t + 11], 14, 643717713), d = l(d, p, m, a, e[t + 0], 20, -373897302), a = l(a, d, p, m, e[t + 5], 5, -701558691), m = l(m, a, d, p, e[t + 10], 9, 38016083), p = l(p, m, a, d, e[t + 15], 14, -660478335), d = l(d, p, m, a, e[t + 4], 20, -405537848), a = l(a, d, p, m, e[t + 9], 5, 568446438), m = l(m, a, d, p, e[t + 14], 9, -1019803690), p = l(p, m, a, d, e[t + 3], 14, -187363961), d = l(d, p, m, a, e[t + 8], 20, 1163531501), a = l(a, d, p, m, e[t + 13], 5, -1444681467), m = l(m, a, d, p, e[t + 2], 9, -51403784), p = l(p, m, a, d, e[t + 7], 14, 1735328473), d = l(d, p, m, a, e[t + 12], 20, -1926607734), a = h(a, d, p, m, e[t + 5], 4, -378558), m = h(m, a, d, p, e[t + 8], 11, -2022574463), p = h(p, m, a, d, e[t + 11], 16, 1839030562), d = h(d, p, m, a, e[t + 14], 23, -35309556), a = h(a, d, p, m, e[t + 1], 4, -1530992060), m = h(m, a, d, p, e[t + 4], 11, 1272893353), p = h(p, m, a, d, e[t + 7], 16, -155497632), d = h(d, p, m, a, e[t + 10], 23, -1094730640), a = h(a, d, p, m, e[t + 13], 4, 681279174), m = h(m, a, d, p, e[t + 0], 11, -358537222), p = h(p, m, a, d, e[t + 3], 16, -722521979), d = h(d, p, m, a, e[t + 6], 23, 76029189), a = h(a, d, p, m, e[t + 9], 4, -640364487), m = h(m, a, d, p, e[t + 12], 11, -421815835), p = h(p, m, a, d, e[t + 15], 16, 530742520), d = h(d, p, m, a, e[t + 2], 23, -995338651), a = u(a, d, p, m, e[t + 0], 6, -198630844), m = u(m, a, d, p, e[t + 7], 10, 1126891415), p = u(p, m, a, d, e[t + 14], 15, -1416354905), d = u(d, p, m, a, e[t + 5], 21, -57434055), a = u(a, d, p, m, e[t + 12], 6, 1700485571), m = u(m, a, d, p, e[t + 3], 10, -1894986606), p = u(p, m, a, d, e[t + 10], 15, -1051523), d = u(d, p, m, a, e[t + 1], 21, -2054922799), a = u(a, d, p, m, e[t + 8], 6, 1873313359), m = u(m, a, d, p, e[t + 15], 10, -30611744), p = u(p, m, a, d, e[t + 6], 15, -1560198380), d = u(d, p, m, a, e[t + 13], 21, 1309151649), a = u(a, d, p, m, e[t + 4], 6, -145523070), m = u(m, a, d, p, e[t + 11], 10, -1120210379), p = u(p, m, a, d, e[t + 2], 15, 718787259), d = u(d, p, m, a, e[t + 9], 21, -343485551), a = s(a, n), d = s(d, i), p = s(p, r), m = s(m, o);
                            return [a, d, p, m]
                        },
                        m = {
                            hexdigest: function(e) {
                                return function(e) {
                                    const t = "0123456789abcdef";
                                    let n = "";
                                    for (let i = 0; i < 4 * e.length; i++) n += t.charAt(e[i >> 2] >> i % 4 * 8 + 4 & 15) + t.charAt(e[i >> 2] >> i % 4 * 8 & 15);
                                    return n
                                }(p(a(e), 8 * e.length))
                            },
                            hash: function(e) {
                                return function(e) {
                                    let t = "";
                                    for (let n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> n % 32 & 255);
                                    return t
                                }(p(a(e), 8 * e.length))
                            }
                        };
                    class g {
                        constructor(e, t, n) {
                            this.mechname = e, this.isClientFirst = t, this.priority = n
                        }
                        test() {
                            return !0
                        }
                        onStart(e) {
                            this._connection = e
                        }
                        onChallenge(e, t) {
                            throw new Error("You should implement challenge handling!")
                        }
                        clientChallenge(e) {
                            if (!this.isClientFirst) throw new Error("clientChallenge should not be called if isClientFirst is false!");
                            return this.onChallenge(e)
                        }
                        onFailure() {
                            this._connection = null
                        }
                        onSuccess() {
                            this._connection = null
                        }
                    }
                    const f = function(e) {
                            var t, n, i = "",
                                r = e.length;
                            for (t = 0; t < r; t++)(n = e.charCodeAt(t)) >= 0 && n <= 127 ? i += e.charAt(t) : n > 2047 ? (i += String.fromCharCode(224 | n >> 12 & 15), i += String.fromCharCode(128 | n >> 6 & 63), i += String.fromCharCode(128 | n >> 0 & 63)) : (i += String.fromCharCode(192 | n >> 6 & 31), i += String.fromCharCode(128 | n >> 0 & 63));
                            return i
                        },
                        v = function(e) {
                            e = e || {};
                            for (const t in e)
                                if (Object.prototype.hasOwnProperty.call(e, t)) {
                                    let n = "",
                                        i = "",
                                        r = "";
                                    const o = e[t],
                                        s = "object" == typeof o,
                                        a = escape(unescape(s ? o.value : o));
                                    s && (n = o.expires ? ";expires=" + o.expires : "", i = o.domain ? ";domain=" + o.domain : "", r = o.path ? ";path=" + o.path : ""), document.cookie = t + "=" + a + n + i + r
                                }
                        };

                    function _(e, t) {
                        e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;
                        var n, i, r, o, s, a, d, c, l = new Array(80),
                            h = 1732584193,
                            u = -271733879,
                            p = -1732584194,
                            m = 271733878,
                            g = -1009589776;
                        for (n = 0; n < e.length; n += 16) {
                            for (o = h, s = u, a = p, d = m, c = g, i = 0; i < 80; i++) l[i] = i < 16 ? e[n + i] : T(l[i - 3] ^ l[i - 8] ^ l[i - 14] ^ l[i - 16], 1), r = b(b(T(h, 5), y(i, u, p, m)), b(b(g, l[i]), E(i))), g = m, m = p, p = T(u, 30), u = h, h = r;
                            h = b(h, o), u = b(u, s), p = b(p, a), m = b(m, d), g = b(g, c)
                        }
                        return [h, u, p, m, g]
                    }

                    function y(e, t, n, i) {
                        return e < 20 ? t & n | ~t & i : e < 40 ? t ^ n ^ i : e < 60 ? t & n | t & i | n & i : t ^ n ^ i
                    }

                    function E(e) {
                        return e < 20 ? 1518500249 : e < 40 ? 1859775393 : e < 60 ? -1894007588 : -899497514
                    }

                    function S(e, t) {
                        var n = C(e);
                        n.length > 16 && (n = _(n, 8 * e.length));
                        for (var i = new Array(16), r = new Array(16), o = 0; o < 16; o++) i[o] = 909522486 ^ n[o], r[o] = 1549556828 ^ n[o];
                        var s = _(i.concat(C(t)), 512 + 8 * t.length);
                        return _(r.concat(s), 672)
                    }

                    function b(e, t) {
                        var n = (65535 & e) + (65535 & t);
                        return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                    }

                    function T(e, t) {
                        return e << t | e >>> 32 - t
                    }

                    function C(e) {
                        for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << 24 - n % 32;
                        return t
                    }

                    function x(e) {
                        for (var t, n, i = "", r = 0; r < 4 * e.length; r += 3)
                            for (t = (e[r >> 2] >> 8 * (3 - r % 4) & 255) << 16 | (e[r + 1 >> 2] >> 8 * (3 - (r + 1) % 4) & 255) << 8 | e[r + 2 >> 2] >> 8 * (3 - (r + 2) % 4) & 255, n = 0; n < 4; n++) 8 * r + 6 * n > 32 * e.length ? i += "=" : i += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(t >> 6 * (3 - n) & 63);
                        return i
                    }

                    function R(e) {
                        for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> 24 - n % 32 & 255);
                        return t
                    }
                    const A = {
                        b64_hmac_sha1: function(e, t) {
                            return x(S(e, t))
                        },
                        b64_sha1: function(e) {
                            return x(_(C(e), 8 * e.length))
                        },
                        binb2str: R,
                        core_hmac_sha1: S,
                        str_hmac_sha1: function(e, t) {
                            return R(S(e, t))
                        },
                        str_sha1: function(e) {
                            return R(_(C(e), 8 * e.length))
                        }
                    };
                    const w = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

                    function I(e) {
                        const t = w.indexOf(e);
                        return t < 0 ? void 0 : t
                    }
                    const P = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

                    function D(e) {
                        if (e >= 0 && e < 64) return P[e]
                    }
                    var O = {
                        atob: function(e) {
                            if (0 === arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                            if ((e = (e = `${e}`).replace(/[ \t\n\f\r]/g, "")).length % 4 == 0 && (e = e.replace(/==?$/, "")), e.length % 4 == 1 || /[^+/0-9A-Za-z]/.test(e)) return null;
                            let t = "",
                                n = 0,
                                i = 0;
                            for (let r = 0; r < e.length; r++) n <<= 6, n |= I(e[r]), i += 6, 24 === i && (t += String.fromCharCode((16711680 & n) >> 16), t += String.fromCharCode((65280 & n) >> 8), t += String.fromCharCode(255 & n), n = i = 0);
                            return 12 === i ? (n >>= 4, t += String.fromCharCode(n)) : 18 === i && (n >>= 2, t += String.fromCharCode((65280 & n) >> 8), t += String.fromCharCode(255 & n)), t
                        },
                        btoa: function(e) {
                            if (0 === arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                            let t;
                            for (e = `${e}`, t = 0; t < e.length; t++)
                                if (e.charCodeAt(t) > 255) return null;
                            let n = "";
                            for (t = 0; t < e.length; t += 3) {
                                const i = [void 0, void 0, void 0, void 0];
                                i[0] = e.charCodeAt(t) >> 2, i[1] = (3 & e.charCodeAt(t)) << 4, e.length > t + 1 && (i[1] |= e.charCodeAt(t + 1) >> 4, i[2] = (15 & e.charCodeAt(t + 1)) << 2), e.length > t + 2 && (i[2] |= e.charCodeAt(t + 2) >> 6, i[3] = 63 & e.charCodeAt(t + 2));
                                for (let e = 0; e < i.length; e++) void 0 === i[e] ? n += "=" : n += D(i[e])
                            }
                            return n
                        }
                    };

                    function N(e, t) {
                        return new F.Builder(e, t)
                    }

                    function k(e) {
                        return new F.Builder("message", e)
                    }

                    function M(e) {
                        return new F.Builder("iq", e)
                    }

                    function L(e) {
                        return new F.Builder("presence", e)
                    }
                    const F = {
                        VERSION: "1.5.0",
                        NS: {
                            HTTPBIND: "http://jabber.org/protocol/httpbind",
                            BOSH: "urn:xmpp:xbosh",
                            CLIENT: "jabber:client",
                            AUTH: "jabber:iq:auth",
                            ROSTER: "jabber:iq:roster",
                            PROFILE: "jabber:iq:profile",
                            DISCO_INFO: "http://jabber.org/protocol/disco#info",
                            DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                            MUC: "http://jabber.org/protocol/muc",
                            SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                            STREAM: "http://etherx.jabber.org/streams",
                            FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                            BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                            SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                            VERSION: "jabber:iq:version",
                            STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                            XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                            XHTML: "http://www.w3.org/1999/xhtml"
                        },
                        XHTML: {
                            tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
                            attributes: {
                                a: ["href"],
                                blockquote: ["style"],
                                br: [],
                                cite: ["style"],
                                em: [],
                                img: ["src", "alt", "style", "height", "width"],
                                li: ["style"],
                                ol: ["style"],
                                p: ["style"],
                                span: ["style"],
                                strong: [],
                                ul: ["style"],
                                body: []
                            },
                            css: ["background-color", "color", "font-family", "font-size", "font-style", "font-weight", "margin-left", "margin-right", "text-align", "text-decoration"],
                            validTag(e) {
                                for (let t = 0; t < F.XHTML.tags.length; t++)
                                    if (e === F.XHTML.tags[t]) return !0;
                                return !1
                            },
                            validAttribute(e, t) {
                                if (void 0 !== F.XHTML.attributes[e] && F.XHTML.attributes[e].length > 0)
                                    for (let n = 0; n < F.XHTML.attributes[e].length; n++)
                                        if (t === F.XHTML.attributes[e][n]) return !0;
                                return !1
                            },
                            validCSS(e) {
                                for (let t = 0; t < F.XHTML.css.length; t++)
                                    if (e === F.XHTML.css[t]) return !0;
                                return !1
                            }
                        },
                        Status: {
                            ERROR: 0,
                            CONNECTING: 1,
                            CONNFAIL: 2,
                            AUTHENTICATING: 3,
                            AUTHFAIL: 4,
                            CONNECTED: 5,
                            DISCONNECTED: 6,
                            DISCONNECTING: 7,
                            ATTACHED: 8,
                            REDIRECT: 9,
                            CONNTIMEOUT: 10,
                            BINDREQUIRED: 11,
                            ATTACHFAIL: 12
                        },
                        ErrorCondition: {
                            BAD_FORMAT: "bad-format",
                            CONFLICT: "conflict",
                            MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
                            NO_AUTH_MECH: "no-auth-mech",
                            UNKNOWN_REASON: "unknown"
                        },
                        LogLevel: {
                            DEBUG: 0,
                            INFO: 1,
                            WARN: 2,
                            ERROR: 3,
                            FATAL: 4
                        },
                        ElementType: {
                            NORMAL: 1,
                            TEXT: 3,
                            CDATA: 4,
                            FRAGMENT: 11
                        },
                        TIMEOUT: 1.1,
                        SECONDARY_TIMEOUT: .1,
                        addNamespace(e, t) {
                            F.NS[e] = t
                        },
                        forEachChild(e, t, n) {
                            for (let i = 0; i < e.childNodes.length; i++) {
                                const r = e.childNodes[i];
                                r.nodeType !== F.ElementType.NORMAL || t && !this.isTagEqual(r, t) || n(r)
                            }
                        },
                        isTagEqual: (e, t) => e.tagName === t,
                        _xmlGenerator: null,
                        xmlGenerator: () => (F._xmlGenerator || (F._xmlGenerator = o()), F._xmlGenerator),
                        xmlElement(e) {
                            if (!e) return null;
                            const t = F.xmlGenerator().createElement(e);
                            for (let e = 1; e < arguments.length; e++) {
                                const n = arguments[e];
                                if (n)
                                    if ("string" == typeof n || "number" == typeof n) t.appendChild(F.xmlTextNode(n));
                                    else if ("object" == typeof n && "function" == typeof n.sort)
                                    for (let e = 0; e < n.length; e++) {
                                        const i = n[e];
                                        "object" == typeof i && "function" == typeof i.sort && void 0 !== i[1] && null !== i[1] && t.setAttribute(i[0], i[1])
                                    } else if ("object" == typeof n)
                                        for (const e in n) Object.prototype.hasOwnProperty.call(n, e) && void 0 !== n[e] && null !== n[e] && t.setAttribute(e, n[e])
                            }
                            return t
                        },
                        xmlescape: e => (e = (e = (e = (e = e.replace(/\&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/'/g, "&apos;")).replace(/"/g, "&quot;"),
                        xmlunescape: e => (e = (e = (e = (e = e.replace(/\&amp;/g, "&")).replace(/&lt;/g, "<")).replace(/&gt;/g, ">")).replace(/&apos;/g, "'")).replace(/&quot;/g, '"'),
                        xmlTextNode: e => F.xmlGenerator().createTextNode(e),
                        xmlHtmlNode(e) {
                            let t;
                            return r ? t = (new r).parseFromString(e, "text/xml") : (t = new ActiveXObject("Microsoft.XMLDOM"), t.async = "false", t.loadXML(e)), t
                        },
                        getText(e) {
                            if (!e) return null;
                            let t = "";
                            0 === e.childNodes.length && e.nodeType === F.ElementType.TEXT && (t += e.nodeValue);
                            for (let n = 0; n < e.childNodes.length; n++) e.childNodes[n].nodeType === F.ElementType.TEXT && (t += e.childNodes[n].nodeValue);
                            return F.xmlescape(t)
                        },
                        copyElement(e) {
                            let t;
                            if (e.nodeType === F.ElementType.NORMAL) {
                                t = F.xmlElement(e.tagName);
                                for (let n = 0; n < e.attributes.length; n++) t.setAttribute(e.attributes[n].nodeName, e.attributes[n].value);
                                for (let n = 0; n < e.childNodes.length; n++) t.appendChild(F.copyElement(e.childNodes[n]))
                            } else e.nodeType === F.ElementType.TEXT && (t = F.xmlGenerator().createTextNode(e.nodeValue));
                            return t
                        },
                        createHtml(e) {
                            let t;
                            if (e.nodeType === F.ElementType.NORMAL) {
                                const n = e.nodeName.toLowerCase();
                                if (F.XHTML.validTag(n)) try {
                                    t = F.xmlElement(n);
                                    for (let i = 0; i < F.XHTML.attributes[n].length; i++) {
                                        const r = F.XHTML.attributes[n][i];
                                        let o = e.getAttribute(r);
                                        if (null != o && "" !== o && !1 !== o && 0 !== o)
                                            if ("style" === r && "object" == typeof o && void 0 !== o.cssText && (o = o.cssText), "style" === r) {
                                                const e = [],
                                                    n = o.split(";");
                                                for (let t = 0; t < n.length; t++) {
                                                    const i = n[t].split(":"),
                                                        r = i[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                                    if (F.XHTML.validCSS(r)) {
                                                        const t = i[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                                        e.push(r + ": " + t)
                                                    }
                                                }
                                                e.length > 0 && (o = e.join("; "), t.setAttribute(r, o))
                                            } else t.setAttribute(r, o)
                                    }
                                    for (let n = 0; n < e.childNodes.length; n++) t.appendChild(F.createHtml(e.childNodes[n]))
                                } catch (e) {
                                    t = F.xmlTextNode("")
                                } else {
                                    t = F.xmlGenerator().createDocumentFragment();
                                    for (let n = 0; n < e.childNodes.length; n++) t.appendChild(F.createHtml(e.childNodes[n]))
                                }
                            } else if (e.nodeType === F.ElementType.FRAGMENT) {
                                t = F.xmlGenerator().createDocumentFragment();
                                for (let n = 0; n < e.childNodes.length; n++) t.appendChild(F.createHtml(e.childNodes[n]))
                            } else e.nodeType === F.ElementType.TEXT && (t = F.xmlTextNode(e.nodeValue));
                            return t
                        },
                        escapeNode: e => "string" != typeof e ? e : e.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40"),
                        unescapeNode: e => "string" != typeof e ? e : e.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\"),
                        getNodeFromJid: e => e.indexOf("@") < 0 ? null : e.split("@")[0],
                        getDomainFromJid(e) {
                            const t = F.getBareJidFromJid(e);
                            if (t.indexOf("@") < 0) return t;
                            {
                                const e = t.split("@");
                                return e.splice(0, 1), e.join("@")
                            }
                        },
                        getResourceFromJid(e) {
                            if (!e) return null;
                            const t = e.split("/");
                            return t.length < 2 ? null : (t.splice(0, 1), t.join("/"))
                        },
                        getBareJidFromJid: e => e ? e.split("/")[0] : null,
                        _handleError(e) {
                            void 0 !== e.stack && F.fatal(e.stack), e.sourceURL ? F.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message) : e.fileName ? F.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message) : F.fatal("error: " + e.message)
                        },
                        log(e, t) {
                            var n;
                            e === this.LogLevel.FATAL && (null === (n = console) || void 0 === n || n.error(t))
                        },
                        debug(e) {
                            this.log(this.LogLevel.DEBUG, e)
                        },
                        info(e) {
                            this.log(this.LogLevel.INFO, e)
                        },
                        warn(e) {
                            this.log(this.LogLevel.WARN, e)
                        },
                        error(e) {
                            this.log(this.LogLevel.ERROR, e)
                        },
                        fatal(e) {
                            this.log(this.LogLevel.FATAL, e)
                        },
                        serialize(e) {
                            if (!e) return null;
                            "function" == typeof e.tree && (e = e.tree());
                            const t = [...Array(e.attributes.length).keys()].map((t => e.attributes[t].nodeName));
                            t.sort();
                            let n = t.reduce(((t, n) => `${t} ${n}="${F.xmlescape(e.attributes.getNamedItem(n).value)}"`), `<${e.nodeName}`);
                            if (e.childNodes.length > 0) {
                                n += ">";
                                for (let t = 0; t < e.childNodes.length; t++) {
                                    const i = e.childNodes[t];
                                    switch (i.nodeType) {
                                        case F.ElementType.NORMAL:
                                            n += F.serialize(i);
                                            break;
                                        case F.ElementType.TEXT:
                                            n += F.xmlescape(i.nodeValue);
                                            break;
                                        case F.ElementType.CDATA:
                                            n += "<![CDATA[" + i.nodeValue + "]]>"
                                    }
                                }
                                n += "</" + e.nodeName + ">"
                            } else n += "/>";
                            return n
                        },
                        _requestId: 0,
                        _connectionPlugins: {},
                        addConnectionPlugin(e, t) {
                            F._connectionPlugins[e] = t
                        },
                        Builder: class {
                            constructor(e, t) {
                                "presence" !== e && "message" !== e && "iq" !== e || (t && !t.xmlns ? t.xmlns = F.NS.CLIENT : t || (t = {
                                    xmlns: F.NS.CLIENT
                                })), this.nodeTree = F.xmlElement(e, t), this.node = this.nodeTree
                            }
                            tree() {
                                return this.nodeTree
                            }
                            toString() {
                                return F.serialize(this.nodeTree)
                            }
                            up() {
                                return this.node = this.node.parentNode, this
                            }
                            root() {
                                return this.node = this.nodeTree, this
                            }
                            attrs(e) {
                                for (const t in e) Object.prototype.hasOwnProperty.call(e, t) && (void 0 === e[t] ? this.node.removeAttribute(t) : this.node.setAttribute(t, e[t]));
                                return this
                            }
                            c(e, t, n) {
                                const i = F.xmlElement(e, t, n);
                                return this.node.appendChild(i), "string" != typeof n && "number" != typeof n && (this.node = i), this
                            }
                            cnode(e) {
                                let t;
                                const n = F.xmlGenerator();
                                try {
                                    t = void 0 !== n.importNode
                                } catch (e) {
                                    t = !1
                                }
                                const i = t ? n.importNode(e, !0) : F.copyElement(e);
                                return this.node.appendChild(i), this.node = i, this
                            }
                            t(e) {
                                const t = F.xmlTextNode(e);
                                return this.node.appendChild(t), this
                            }
                            h(e) {
                                const t = F.xmlGenerator().createElement("body");
                                t.innerHTML = e;
                                const n = F.createHtml(t);
                                for (; n.childNodes.length > 0;) this.node.appendChild(n.childNodes[0]);
                                return this
                            }
                        },
                        Handler: function(e, t, n, i, r, o, s) {
                            this.handler = e, this.ns = t, this.name = n, this.type = i, this.id = r, this.options = s || {
                                matchBareFromJid: !1,
                                ignoreNamespaceFragment: !1
                            }, this.options.matchBare && (F.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.'), this.options.matchBareFromJid = this.options.matchBare, delete this.options.matchBare), this.options.matchBareFromJid ? this.from = o ? F.getBareJidFromJid(o) : null : this.from = o, this.user = !0
                        }
                    };
                    F.Handler.prototype = {
                        getNamespace(e) {
                            let t = e.getAttribute("xmlns");
                            return t && this.options.ignoreNamespaceFragment && (t = t.split("#")[0]), t
                        },
                        namespaceMatch(e) {
                            let t = !1;
                            return !this.ns || (F.forEachChild(e, null, (e => {
                                this.getNamespace(e) === this.ns && (t = !0)
                            })), t || this.getNamespace(e) === this.ns)
                        },
                        isMatch(e) {
                            let t = e.getAttribute("from");
                            this.options.matchBareFromJid && (t = F.getBareJidFromJid(t));
                            const n = e.getAttribute("type");
                            return !(!this.namespaceMatch(e) || this.name && !F.isTagEqual(e, this.name) || this.type && (Array.isArray(this.type) ? -1 === this.type.indexOf(n) : n !== this.type) || this.id && e.getAttribute("id") !== this.id || this.from && t !== this.from)
                        },
                        run(e) {
                            let t = null;
                            try {
                                t = this.handler(e)
                            } catch (e) {
                                throw F._handleError(e), e
                            }
                            return t
                        },
                        toString() {
                            return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
                        }
                    }, F.TimedHandler = class {
                        constructor(e, t) {
                            this.period = e, this.handler = t, this.lastCalled = (new Date).getTime(), this.user = !0
                        }
                        run() {
                            return this.lastCalled = (new Date).getTime(), this.handler()
                        }
                        reset() {
                            this.lastCalled = (new Date).getTime()
                        }
                        toString() {
                            return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
                        }
                    }, F.Connection = class {
                        constructor(e, t) {
                            this.service = e, this.options = t || {}, this.setProtocol(), this.jid = "", this.domain = null, this.features = null, this._sasl_data = {}, this.do_bind = !1, this.do_session = !1, this.mechanisms = {}, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.protocolErrorHandlers = {
                                HTTP: {},
                                websocket: {}
                            }, this._idleTimeout = null, this._disconnectTimeout = null, this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.do_authentication = !0, this.paused = !1, this.restored = !1, this._data = [], this._uniqueId = 0, this._sasl_success_handler = null, this._sasl_failure_handler = null, this._sasl_challenge_handler = null, this.maxRetries = 5, this._idleTimeout = setTimeout((() => this._onIdle()), 100), v(this.options.cookies), this.registerSASLMechanisms(this.options.mechanisms), this.iqFallbackHandler = new F.Handler((e => this.send(M({
                                type: "error",
                                id: e.getAttribute("id")
                            }).c("error", {
                                type: "cancel"
                            }).c("service-unavailable", {
                                xmlns: F.NS.STANZAS
                            }))), null, "iq", ["get", "set"]);
                            for (const e in F._connectionPlugins)
                                if (Object.prototype.hasOwnProperty.call(F._connectionPlugins, e)) {
                                    const t = function() {};
                                    t.prototype = F._connectionPlugins[e], this[e] = new t, this[e].init(this)
                                }
                        }
                        setProtocol() {
                            const e = this.options.protocol || "";
                            this.options.worker ? this._proto = new F.WorkerWebsocket(this) : 0 === this.service.indexOf("ws:") || 0 === this.service.indexOf("wss:") || 0 === e.indexOf("ws") ? this._proto = new F.Websocket(this) : this._proto = new F.Bosh(this)
                        }
                        reset() {
                            this._proto._reset(), this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.restored = !1, this._data = [], this._requests = [], this._uniqueId = 0
                        }
                        pause() {
                            this.paused = !0
                        }
                        resume() {
                            this.paused = !1
                        }
                        getUniqueId(e) {
                            const t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
                                const t = 16 * Math.random() | 0;
                                return ("x" === e ? t : 3 & t | 8).toString(16)
                            }));
                            return "string" == typeof e || "number" == typeof e ? t + ":" + e : t + ""
                        }
                        addProtocolErrorHandler(e, t, n) {
                            this.protocolErrorHandlers[e][t] = n
                        }
                        connect(e, t, n, i, r, o, s) {
                            let a = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 3e3;
                            this.jid = e, this.authzid = F.getBareJidFromJid(this.jid), this.authcid = s || F.getNodeFromJid(this.jid), this.pass = t, this.connect_callback = n, this.disconnecting = !1, this.connected = !1, this.authenticated = !1, this.restored = !1, this.disconnection_timeout = a, this.domain = F.getDomainFromJid(this.jid), this._changeConnectStatus(F.Status.CONNECTING, null), this._proto._connect(i, r, o)
                        }
                        attach(e, t, n, i, r, o, s) {
                            if (this._proto._attach) return this._proto._attach(e, t, n, i, r, o, s);
                            {
                                const e = new Error('The "attach" method is not available for your connection protocol');
                                throw e.name = "StropheSessionError", e
                            }
                        }
                        restore(e, t, n, i, r) {
                            if (!this._sessionCachingSupported()) {
                                const e = new Error('The "restore" method can only be used with a BOSH connection.');
                                throw e.name = "StropheSessionError", e
                            }
                            this._proto._restore(e, t, n, i, r)
                        }
                        _sessionCachingSupported() {
                            if (this._proto instanceof F.Bosh) {
                                if (!JSON) return !1;
                                try {
                                    sessionStorage.setItem("_strophe_", "_strophe_"), sessionStorage.removeItem("_strophe_")
                                } catch (e) {
                                    return !1
                                }
                                return !0
                            }
                            return !1
                        }
                        xmlInput(e) {}
                        xmlOutput(e) {}
                        rawInput(e) {}
                        rawOutput(e) {}
                        nextValidRid(e) {}
                        send(e) {
                            if (null !== e) {
                                if ("function" == typeof e.sort)
                                    for (let t = 0; t < e.length; t++) this._queueData(e[t]);
                                else "function" == typeof e.tree ? this._queueData(e.tree()) : this._queueData(e);
                                this._proto._send()
                            }
                        }
                        flush() {
                            clearTimeout(this._idleTimeout), this._onIdle()
                        }
                        sendPresence(e, t, n, i) {
                            let r = null;
                            "function" == typeof e.tree && (e = e.tree());
                            let o = e.getAttribute("id");
                            if (o || (o = this.getUniqueId("sendPresence"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof n) {
                                const e = this.addHandler((e => {
                                    r && this.deleteTimedHandler(r), "error" === e.getAttribute("type") ? n && n(e) : t && t(e)
                                }), null, "presence", null, o);
                                i && (r = this.addTimedHandler(i, (() => (this.deleteHandler(e), n && n(null), !1))))
                            }
                            return this.send(e), o
                        }
                        sendIQ(e, t, n, i) {
                            let r = null;
                            "function" == typeof e.tree && (e = e.tree());
                            let o = e.getAttribute("id");
                            if (o || (o = this.getUniqueId("sendIQ"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof n) {
                                const e = this.addHandler((e => {
                                    r && this.deleteTimedHandler(r);
                                    const i = e.getAttribute("type");
                                    if ("result" === i) t && t(e);
                                    else {
                                        if ("error" !== i) {
                                            const e = new Error(`Got bad IQ type of ${i}`);
                                            throw e.name = "StropheError", e
                                        }
                                        n && n(e)
                                    }
                                }), null, "iq", ["error", "result"], o);
                                i && (r = this.addTimedHandler(i, (() => (this.deleteHandler(e), n && n(null), !1))))
                            }
                            return this.send(e), o
                        }
                        _queueData(e) {
                            if (null === e || !e.tagName || !e.childNodes) {
                                const e = new Error("Cannot queue non-DOMElement.");
                                throw e.name = "StropheError", e
                            }
                            this._data.push(e)
                        }
                        _sendRestart() {
                            this._data.push("restart"), this._proto._sendRestart(), this._idleTimeout = setTimeout((() => this._onIdle()), 100)
                        }
                        addTimedHandler(e, t) {
                            const n = new F.TimedHandler(e, t);
                            return this.addTimeds.push(n), n
                        }
                        deleteTimedHandler(e) {
                            this.removeTimeds.push(e)
                        }
                        addHandler(e, t, n, i, r, o, s) {
                            const a = new F.Handler(e, t, n, i, r, o, s);
                            return this.addHandlers.push(a), a
                        }
                        deleteHandler(e) {
                            this.removeHandlers.push(e);
                            const t = this.addHandlers.indexOf(e);
                            t >= 0 && this.addHandlers.splice(t, 1)
                        }
                        registerSASLMechanisms(e) {
                            this.mechanisms = {}, (e = e || [F.SASLAnonymous, F.SASLExternal, F.SASLOAuthBearer, F.SASLXOAuth2, F.SASLPlain, F.SASLSHA1]).forEach((e => this.registerSASLMechanism(e)))
                        }
                        registerSASLMechanism(e) {
                            const t = new e;
                            this.mechanisms[t.mechname] = t
                        }
                        disconnect(e) {
                            if (this._changeConnectStatus(F.Status.DISCONNECTING, e), e ? F.warn("Disconnect was called because: " + e) : F.info("Disconnect was called"), this.connected) {
                                let e = !1;
                                this.disconnecting = !0, this.authenticated && (e = L({
                                    xmlns: F.NS.CLIENT,
                                    type: "unavailable"
                                })), this._disconnectTimeout = this._addSysTimedHandler(this.disconnection_timeout, this._onDisconnectTimeout.bind(this)), this._proto._disconnect(e)
                            } else F.warn("Disconnect was called before Strophe connected to the server"), this._proto._abortAllRequests(), this._doDisconnect()
                        }
                        _changeConnectStatus(e, t, n) {
                            for (const n in F._connectionPlugins)
                                if (Object.prototype.hasOwnProperty.call(F._connectionPlugins, n)) {
                                    const i = this[n];
                                    if (i.statusChanged) try {
                                        i.statusChanged(e, t)
                                    } catch (e) {
                                        F.error(`${n} plugin caused an exception changing status: ${e}`)
                                    }
                                } if (this.connect_callback) try {
                                this.connect_callback(e, t, n)
                            } catch (e) {
                                F._handleError(e), F.error(`User connection callback caused an exception: ${e}`)
                            }
                        }
                        _doDisconnect(e) {
                            "number" == typeof this._idleTimeout && clearTimeout(this._idleTimeout), null !== this._disconnectTimeout && (this.deleteTimedHandler(this._disconnectTimeout), this._disconnectTimeout = null), F.debug("_doDisconnect was called"), this._proto._doDisconnect(), this.authenticated = !1, this.disconnecting = !1, this.restored = !1, this.handlers = [], this.timedHandlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this._changeConnectStatus(F.Status.DISCONNECTED, e), this.connected = !1
                        }
                        _dataRecv(e, t) {
                            const n = this._proto._reqToData(e);
                            if (null === n) return;
                            for (this.xmlInput !== F.Connection.prototype.xmlInput && (n.nodeName === this._proto.strip && n.childNodes.length ? this.xmlInput(n.childNodes[0]) : this.xmlInput(n)), this.rawInput !== F.Connection.prototype.rawInput && (t ? this.rawInput(t) : this.rawInput(F.serialize(n))); this.removeHandlers.length > 0;) {
                                const e = this.removeHandlers.pop(),
                                    t = this.handlers.indexOf(e);
                                t >= 0 && this.handlers.splice(t, 1)
                            }
                            for (; this.addHandlers.length > 0;) this.handlers.push(this.addHandlers.pop());
                            if (this.disconnecting && this._proto._emptyQueue()) return void this._doDisconnect();
                            const i = n.getAttribute("type");
                            if (null !== i && "terminate" === i) {
                                if (this.disconnecting) return;
                                let e = n.getAttribute("condition");
                                const t = n.getElementsByTagName("conflict");
                                return null !== e ? ("remote-stream-error" === e && t.length > 0 && (e = "conflict"), this._changeConnectStatus(F.Status.CONNFAIL, e)) : this._changeConnectStatus(F.Status.CONNFAIL, F.ErrorCondition.UNKOWN_REASON), void this._doDisconnect(e)
                            }
                            F.forEachChild(n, null, (e => {
                                const t = [];
                                this.handlers = this.handlers.reduce(((n, i) => {
                                    try {
                                        !i.isMatch(e) || !this.authenticated && i.user ? n.push(i) : (i.run(e) && n.push(i), t.push(i))
                                    } catch (e) {
                                        F.warn("Removing Strophe handlers due to uncaught exception: " + e.message)
                                    }
                                    return n
                                }), []), !t.length && this.iqFallbackHandler.isMatch(e) && this.iqFallbackHandler.run(e)
                            }))
                        }
                        _connect_cb(e, t, n) {
                            let i, r;
                            F.debug("_connect_cb was called"), this.connected = !0;
                            try {
                                i = this._proto._reqToData(e)
                            } catch (e) {
                                if (e.name !== F.ErrorCondition.BAD_FORMAT) throw e;
                                this._changeConnectStatus(F.Status.CONNFAIL, F.ErrorCondition.BAD_FORMAT), this._doDisconnect(F.ErrorCondition.BAD_FORMAT)
                            }
                            if (!i) return;
                            if (this.xmlInput !== F.Connection.prototype.xmlInput && (i.nodeName === this._proto.strip && i.childNodes.length ? this.xmlInput(i.childNodes[0]) : this.xmlInput(i)), this.rawInput !== F.Connection.prototype.rawInput && (n ? this.rawInput(n) : this.rawInput(F.serialize(i))), this._proto._connect_cb(i) === F.Status.CONNFAIL) return;
                            if (r = i.getElementsByTagNameNS ? i.getElementsByTagNameNS(F.NS.STREAM, "features").length > 0 : i.getElementsByTagName("stream:features").length > 0 || i.getElementsByTagName("features").length > 0, !r) return void this._proto._no_auth_received(t);
                            const o = Array.from(i.getElementsByTagName("mechanism")).map((e => this.mechanisms[e.textContent])).filter((e => e));
                            0 !== o.length || 0 !== i.getElementsByTagName("auth").length ? !1 !== this.do_authentication && this.authenticate(o) : this._proto._no_auth_received(t)
                        }
                        sortMechanismsByPriority(e) {
                            for (let t = 0; t < e.length - 1; ++t) {
                                let n = t;
                                for (let i = t + 1; i < e.length; ++i) e[i].priority > e[n].priority && (n = i);
                                if (n !== t) {
                                    const i = e[t];
                                    e[t] = e[n], e[n] = i
                                }
                            }
                            return e
                        }
                        authenticate(e) {
                            this._attemptSASLAuth(e) || this._attemptLegacyAuth()
                        }
                        _attemptSASLAuth(e) {
                            e = this.sortMechanismsByPriority(e || []);
                            let t = !1;
                            for (let n = 0; n < e.length; ++n) {
                                if (!e[n].test(this)) continue;
                                this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null), this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null), this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null), this._sasl_mechanism = e[n], this._sasl_mechanism.onStart(this);
                                const i = N("auth", {
                                    xmlns: F.NS.SASL,
                                    mechanism: this._sasl_mechanism.mechname
                                });
                                if (this._sasl_mechanism.isClientFirst) {
                                    const e = this._sasl_mechanism.clientChallenge(this);
                                    i.t(O.btoa(e))
                                }
                                this.send(i.tree()), t = !0;
                                break
                            }
                            return t
                        }
                        _sasl_challenge_cb(e) {
                            const t = O.atob(F.getText(e)),
                                n = this._sasl_mechanism.onChallenge(this, t),
                                i = N("response", {
                                    xmlns: F.NS.SASL
                                });
                            return "" !== n && i.t(O.btoa(n)), this.send(i.tree()), !0
                        }
                        _attemptLegacyAuth() {
                            null === F.getNodeFromJid(this.jid) ? (this._changeConnectStatus(F.Status.CONNFAIL, F.ErrorCondition.MISSING_JID_NODE), this.disconnect(F.ErrorCondition.MISSING_JID_NODE)) : (this._changeConnectStatus(F.Status.AUTHENTICATING, null), this._addSysHandler(this._onLegacyAuthIQResult.bind(this), null, null, null, "_auth_1"), this.send(M({
                                type: "get",
                                to: this.domain,
                                id: "_auth_1"
                            }).c("query", {
                                xmlns: F.NS.AUTH
                            }).c("username", {}).t(F.getNodeFromJid(this.jid)).tree()))
                        }
                        _onLegacyAuthIQResult(e) {
                            const t = M({
                                type: "set",
                                id: "_auth_2"
                            }).c("query", {
                                xmlns: F.NS.AUTH
                            }).c("username", {}).t(F.getNodeFromJid(this.jid)).up().c("password").t(this.pass);
                            return F.getResourceFromJid(this.jid) || (this.jid = F.getBareJidFromJid(this.jid) + "/strophe"), t.up().c("resource", {}).t(F.getResourceFromJid(this.jid)), this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2"), this.send(t.tree()), !1
                        }
                        _sasl_success_cb(e) {
                            if (this._sasl_data["server-signature"]) {
                                let t;
                                const n = /([a-z]+)=([^,]+)(,|$)/,
                                    i = O.atob(F.getText(e)).match(n);
                                if ("v" === i[1] && (t = i[2]), t !== this._sasl_data["server-signature"]) return this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_data = {}, this._sasl_failure_cb(null)
                            }
                            F.info("SASL authentication succeeded."), this._sasl_mechanism && this._sasl_mechanism.onSuccess(), this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null);
                            const t = [],
                                n = (e, t) => {
                                    for (; e.length;) this.deleteHandler(e.pop());
                                    return this._onStreamFeaturesAfterSASL(t), !1
                                };
                            return t.push(this._addSysHandler((e => n(t, e)), null, "stream:features", null, null)), t.push(this._addSysHandler((e => n(t, e)), F.NS.STREAM, "features", null, null)), this._sendRestart(), !1
                        }
                        _onStreamFeaturesAfterSASL(e) {
                            this.features = e;
                            for (let t = 0; t < e.childNodes.length; t++) {
                                const n = e.childNodes[t];
                                "bind" === n.nodeName && (this.do_bind = !0), "session" === n.nodeName && (this.do_session = !0)
                            }
                            return this.do_bind ? (this.options.explicitResourceBinding ? this._changeConnectStatus(F.Status.BINDREQUIRED, null) : this.bind(), !1) : (this._changeConnectStatus(F.Status.AUTHFAIL, null), !1)
                        }
                        bind() {
                            if (!this.do_bind) return void F.log(F.LogLevel.INFO, 'Strophe.Connection.prototype.bind called but "do_bind" is false');
                            this._addSysHandler(this._onResourceBindResultIQ.bind(this), null, null, null, "_bind_auth_2");
                            const e = F.getResourceFromJid(this.jid);
                            e ? this.send(M({
                                type: "set",
                                id: "_bind_auth_2"
                            }).c("bind", {
                                xmlns: F.NS.BIND
                            }).c("resource", {}).t(e).tree()) : this.send(M({
                                type: "set",
                                id: "_bind_auth_2"
                            }).c("bind", {
                                xmlns: F.NS.BIND
                            }).tree())
                        }
                        _onResourceBindResultIQ(e) {
                            if ("error" === e.getAttribute("type")) {
                                let t;
                                return F.warn("Resource binding failed."), e.getElementsByTagName("conflict").length > 0 && (t = F.ErrorCondition.CONFLICT), this._changeConnectStatus(F.Status.AUTHFAIL, t, e), !1
                            }
                            const t = e.getElementsByTagName("bind");
                            if (!(t.length > 0)) return F.warn("Resource binding failed."), this._changeConnectStatus(F.Status.AUTHFAIL, null, e), !1;
                            {
                                const e = t[0].getElementsByTagName("jid");
                                e.length > 0 && (this.authenticated = !0, this.jid = F.getText(e[0]), this.do_session ? this._establishSession() : this._changeConnectStatus(F.Status.CONNECTED, null))
                            }
                        }
                        _establishSession() {
                            if (!this.do_session) throw new Error(`Strophe.Connection.prototype._establishSession called but apparently ${F.NS.SESSION} wasn't advertised by the server`);
                            this._addSysHandler(this._onSessionResultIQ.bind(this), null, null, null, "_session_auth_2"), this.send(M({
                                type: "set",
                                id: "_session_auth_2"
                            }).c("session", {
                                xmlns: F.NS.SESSION
                            }).tree())
                        }
                        _onSessionResultIQ(e) {
                            if ("result" === e.getAttribute("type")) this.authenticated = !0, this._changeConnectStatus(F.Status.CONNECTED, null);
                            else if ("error" === e.getAttribute("type")) return this.authenticated = !1, F.warn("Session creation failed."), this._changeConnectStatus(F.Status.AUTHFAIL, null, e), !1;
                            return !1
                        }
                        _sasl_failure_cb(e) {
                            return this._sasl_success_handler && (this.deleteHandler(this._sasl_success_handler), this._sasl_success_handler = null), this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_mechanism && this._sasl_mechanism.onFailure(), this._changeConnectStatus(F.Status.AUTHFAIL, null, e), !1
                        }
                        _auth2_cb(e) {
                            return "result" === e.getAttribute("type") ? (this.authenticated = !0, this._changeConnectStatus(F.Status.CONNECTED, null)) : "error" === e.getAttribute("type") && (this._changeConnectStatus(F.Status.AUTHFAIL, null, e), this.disconnect("authentication failed")), !1
                        }
                        _addSysTimedHandler(e, t) {
                            const n = new F.TimedHandler(e, t);
                            return n.user = !1, this.addTimeds.push(n), n
                        }
                        _addSysHandler(e, t, n, i, r) {
                            const o = new F.Handler(e, t, n, i, r);
                            return o.user = !1, this.addHandlers.push(o), o
                        }
                        _onDisconnectTimeout() {
                            return F.debug("_onDisconnectTimeout was called"), this._changeConnectStatus(F.Status.CONNTIMEOUT, null), this._proto._onDisconnectTimeout(), this._doDisconnect(), !1
                        }
                        _onIdle() {
                            for (; this.addTimeds.length > 0;) this.timedHandlers.push(this.addTimeds.pop());
                            for (; this.removeTimeds.length > 0;) {
                                const e = this.removeTimeds.pop(),
                                    t = this.timedHandlers.indexOf(e);
                                t >= 0 && this.timedHandlers.splice(t, 1)
                            }
                            const e = (new Date).getTime(),
                                t = [];
                            for (let n = 0; n < this.timedHandlers.length; n++) {
                                const i = this.timedHandlers[n];
                                !this.authenticated && i.user || (i.lastCalled + i.period - e <= 0 ? i.run() && t.push(i) : t.push(i))
                            }
                            this.timedHandlers = t, clearTimeout(this._idleTimeout), this._proto._onIdle(), this.connected && (this._idleTimeout = setTimeout((() => this._onIdle()), 100))
                        }
                    }, F.SASLMechanism = g, F.SASLAnonymous = class extends g {
                        constructor() {
                            super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "ANONYMOUS", arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 20)
                        }
                        test(e) {
                            return null === e.authcid
                        }
                    }, F.SASLPlain = class extends g {
                        constructor() {
                            super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "PLAIN", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 50)
                        }
                        test(e) {
                            return null !== e.authcid
                        }
                        onChallenge(e) {
                            const {
                                authcid: t,
                                authzid: n,
                                domain: i,
                                pass: r
                            } = e;
                            if (!i) throw new Error("SASLPlain onChallenge: domain is not defined!");
                            let o = n !== `${t}@${i}` ? n : "";
                            return o += "\0", o += t, o += "\0", o += r, f(o)
                        }
                    }, F.SASLSHA1 = class extends g {
                        constructor() {
                            super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "SCRAM-SHA-1", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 60)
                        }
                        test(e) {
                            return null !== e.authcid
                        }
                        onChallenge(e, t) {
                            let n, i, r, o, s, a, d, c, l = "c=biws,",
                                h = `${e._sasl_data["client-first-message-bare"]},${t},`;
                            const u = e._sasl_data.cnonce,
                                p = /([a-z]+)=([^,]+)(,|$)/;
                            for (; t.match(p);) {
                                const e = t.match(p);
                                switch (t = t.replace(e[0], ""), e[1]) {
                                    case "r":
                                        n = e[2];
                                        break;
                                    case "s":
                                        i = e[2];
                                        break;
                                    case "i":
                                        r = e[2]
                                }
                            }
                            if (n.slice(0, u.length) !== u) return e._sasl_data = {}, e._sasl_failure_cb();
                            l += "r=" + n, h += l, i = atob(i), i += "\0\0\0";
                            const m = f(e.pass);
                            for (o = a = A.core_hmac_sha1(m, i), d = 1; d < r; d++) {
                                for (s = A.core_hmac_sha1(m, A.binb2str(a)), c = 0; c < 5; c++) o[c] ^= s[c];
                                a = s
                            }
                            o = A.binb2str(o);
                            const g = A.core_hmac_sha1(o, "Client Key"),
                                v = A.str_hmac_sha1(o, "Server Key"),
                                _ = A.core_hmac_sha1(A.str_sha1(A.binb2str(g)), h);
                            for (e._sasl_data["server-signature"] = A.b64_hmac_sha1(v, h), c = 0; c < 5; c++) g[c] ^= _[c];
                            return l += ",p=" + btoa(A.binb2str(g)), l
                        }
                        clientChallenge(e, t) {
                            const n = t || m.hexdigest("" + 1234567890 * Math.random());
                            let i = "n=" + f(e.authcid);
                            return i += ",r=", i += n, e._sasl_data.cnonce = n, e._sasl_data["client-first-message-bare"] = i, i = "n,," + i, i
                        }
                    }, F.SASLOAuthBearer = class extends g {
                        constructor() {
                            super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "OAUTHBEARER", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 40)
                        }
                        test(e) {
                            return null !== e.pass
                        }
                        onChallenge(e) {
                            let t = "n,";
                            return null !== e.authcid && (t = t + "a=" + e.authzid), t += ",", t += "", t += "auth=Bearer ", t += e.pass, t += "", t += "", f(t)
                        }
                    }, F.SASLExternal = class extends g {
                        constructor() {
                            super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "EXTERNAL", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10)
                        }
                        onChallenge(e) {
                            return e.authcid === e.authzid ? "" : e.authzid
                        }
                    }, F.SASLXOAuth2 = class extends g {
                        constructor() {
                            super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "X-OAUTH2", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 30)
                        }
                        test(e) {
                            return null !== e.pass
                        }
                        onChallenge(e) {
                            let t = "\0";
                            return null !== e.authcid && (t += e.authzid), t += "\0", t += e.pass, f(t)
                        }
                    };
                    var j = {
                        Strophe: F,
                        $build: N,
                        $iq: M,
                        $msg: k,
                        $pres: L,
                        SHA1: A,
                        MD5: m,
                        b64_hmac_sha1: A.b64_hmac_sha1,
                        b64_sha1: A.b64_sha1,
                        str_hmac_sha1: A.str_hmac_sha1,
                        str_sha1: A.str_sha1
                    };
                    F.Request = class {
                        constructor(e, t, n, i) {
                            this.id = ++F._requestId, this.xmlData = e, this.data = F.serialize(e), this.origFunc = t, this.func = t, this.rid = n, this.date = NaN, this.sends = i || 0, this.abort = !1, this.dead = null, this.age = function() {
                                return this.date ? (new Date - this.date) / 1e3 : 0
                            }, this.timeDead = function() {
                                return this.dead ? (new Date - this.dead) / 1e3 : 0
                            }, this.xhr = this._newXHR()
                        }
                        getResponse() {
                            let e = null;
                            if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                                if (e = this.xhr.responseXML.documentElement, "parsererror" === e.tagName) throw F.error("invalid response received"), F.error("responseText: " + this.xhr.responseText), F.error("responseXML: " + F.serialize(this.xhr.responseXML)), new Error("parsererror")
                            } else if (this.xhr.responseText) {
                                if (F.debug("Got responseText but no responseXML; attempting to parse it with DOMParser..."), e = (new r).parseFromString(this.xhr.responseText, "application/xml").documentElement, !e) throw new Error("Parsing produced null node");
                                if (e.querySelector("parsererror")) {
                                    F.error("invalid response received: " + e.querySelector("parsererror").textContent), F.error("responseText: " + this.xhr.responseText);
                                    const t = new Error;
                                    throw t.name = F.ErrorCondition.BAD_FORMAT, t
                                }
                            }
                            return e
                        }
                        _newXHR() {
                            let e = null;
                            return window.XMLHttpRequest ? (e = new XMLHttpRequest, e.overrideMimeType && e.overrideMimeType("text/xml; charset=utf-8")) : window.ActiveXObject && (e = new ActiveXObject("Microsoft.XMLHTTP")), e.onreadystatechange = this.func.bind(null, this), e
                        }
                    }, F.Bosh = class e {
                        constructor(e) {
                            this._conn = e, this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.hold = 1, this.wait = 60, this.window = 5, this.errors = 0, this.inactivity = null, this.lastResponseHeaders = null, this._requests = []
                        }
                        _buildBody() {
                            const e = N("body", {
                                rid: this.rid++,
                                xmlns: F.NS.HTTPBIND
                            });
                            return null !== this.sid && e.attrs({
                                sid: this.sid
                            }), this._conn.options.keepalive && this._conn._sessionCachingSupported() && this._cacheSession(), e
                        }
                        _reset() {
                            this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.errors = 0, this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                        }
                        _connect(e, t, n) {
                            this.wait = e || this.wait, this.hold = t || this.hold, this.errors = 0;
                            const i = this._buildBody().attrs({
                                to: this._conn.domain,
                                "xml:lang": "en",
                                wait: this.wait,
                                hold: this.hold,
                                content: "text/xml; charset=utf-8",
                                ver: "1.6",
                                "xmpp:version": "1.0",
                                "xmlns:xmpp": F.NS.BOSH
                            });
                            n && i.attrs({
                                route: n
                            });
                            const r = this._conn._connect_cb;
                            this._requests.push(new F.Request(i.tree(), this._onRequestStateChange.bind(this, r.bind(this._conn)), i.tree().getAttribute("rid"))), this._throttledRequestHandler()
                        }
                        _attach(e, t, n, i, r, o, s) {
                            this._conn.jid = e, this.sid = t, this.rid = n, this._conn.connect_callback = i, this._conn.domain = F.getDomainFromJid(this._conn.jid), this._conn.authenticated = !0, this._conn.connected = !0, this.wait = r || this.wait, this.hold = o || this.hold, this.window = s || this.window, this._conn._changeConnectStatus(F.Status.ATTACHED, null)
                        }
                        _restore(e, t, n, i, r) {
                            const o = JSON.parse(window.sessionStorage.getItem("strophe-bosh-session"));
                            if (!(null != o && o.rid && o.sid && o.jid && (null == e || F.getBareJidFromJid(o.jid) === F.getBareJidFromJid(e) || null === F.getNodeFromJid(e) && F.getDomainFromJid(o.jid) === e))) {
                                const e = new Error("_restore: no restoreable session.");
                                throw e.name = "StropheSessionError", e
                            }
                            this._conn.restored = !0, this._attach(o.jid, o.sid, o.rid, t, n, i, r)
                        }
                        _cacheSession() {
                            this._conn.authenticated ? this._conn.jid && this.rid && this.sid && window.sessionStorage.setItem("strophe-bosh-session", JSON.stringify({
                                jid: this._conn.jid,
                                rid: this.rid,
                                sid: this.sid
                            })) : window.sessionStorage.removeItem("strophe-bosh-session")
                        }
                        _connect_cb(e) {
                            const t = e.getAttribute("type");
                            if (null !== t && "terminate" === t) {
                                let t = e.getAttribute("condition");
                                F.error("BOSH-Connection failed: " + t);
                                const n = e.getElementsByTagName("conflict");
                                return null !== t ? ("remote-stream-error" === t && n.length > 0 && (t = "conflict"), this._conn._changeConnectStatus(F.Status.CONNFAIL, t)) : this._conn._changeConnectStatus(F.Status.CONNFAIL, "unknown"), this._conn._doDisconnect(t), F.Status.CONNFAIL
                            }
                            this.sid || (this.sid = e.getAttribute("sid"));
                            const n = e.getAttribute("requests");
                            n && (this.window = parseInt(n, 10));
                            const i = e.getAttribute("hold");
                            i && (this.hold = parseInt(i, 10));
                            const r = e.getAttribute("wait");
                            r && (this.wait = parseInt(r, 10));
                            const o = e.getAttribute("inactivity");
                            o && (this.inactivity = parseInt(o, 10))
                        }
                        _disconnect(e) {
                            this._sendTerminate(e)
                        }
                        _doDisconnect() {
                            this.sid = null, this.rid = Math.floor(4294967295 * Math.random()), this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                        }
                        _emptyQueue() {
                            return 0 === this._requests.length
                        }
                        _callProtocolErrorHandlers(t) {
                            const n = e._getRequestStatus(t),
                                i = this._conn.protocolErrorHandlers.HTTP[n];
                            i && i.call(this, n)
                        }
                        _hitError(e) {
                            this.errors++, F.warn("request errored, status: " + e + ", number of errors: " + this.errors), this.errors > 4 && this._conn._onDisconnectTimeout()
                        }
                        _no_auth_received(e) {
                            F.warn("Server did not yet offer a supported authentication mechanism. Sending a blank poll request."), e = e ? e.bind(this._conn) : this._conn._connect_cb.bind(this._conn);
                            const t = this._buildBody();
                            this._requests.push(new F.Request(t.tree(), this._onRequestStateChange.bind(this, e), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                        }
                        _onDisconnectTimeout() {
                            this._abortAllRequests()
                        }
                        _abortAllRequests() {
                            for (; this._requests.length > 0;) {
                                const e = this._requests.pop();
                                e.abort = !0, e.xhr.abort(), e.xhr.onreadystatechange = function() {}
                            }
                        }
                        _onIdle() {
                            const e = this._conn._data;
                            if (this._conn.authenticated && 0 === this._requests.length && 0 === e.length && !this._conn.disconnecting && (F.debug("no requests during idle cycle, sending blank request"), e.push(null)), !this._conn.paused) {
                                if (this._requests.length < 2 && e.length > 0) {
                                    const t = this._buildBody();
                                    for (let n = 0; n < e.length; n++) null !== e[n] && ("restart" === e[n] ? t.attrs({
                                        to: this._conn.domain,
                                        "xml:lang": "en",
                                        "xmpp:restart": "true",
                                        "xmlns:xmpp": F.NS.BOSH
                                    }) : t.cnode(e[n]).up());
                                    delete this._conn._data, this._conn._data = [], this._requests.push(new F.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                                }
                                if (this._requests.length > 0) {
                                    const e = this._requests[0].age();
                                    null !== this._requests[0].dead && this._requests[0].timeDead() > Math.floor(F.SECONDARY_TIMEOUT * this.wait) && this._throttledRequestHandler(), e > Math.floor(F.TIMEOUT * this.wait) && (F.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(F.TIMEOUT * this.wait) + " seconds since last activity"), this._throttledRequestHandler())
                                }
                            }
                        }
                        static _getRequestStatus(e, t) {
                            let n;
                            if (4 === e.xhr.readyState) try {
                                n = e.xhr.status
                            } catch (e) {
                                F.error("Caught an error while retrieving a request's status, reqStatus: " + n)
                            }
                            return void 0 === n && (n = "number" == typeof t ? t : 0), n
                        }
                        _onRequestStateChange(t, n) {
                            if (F.debug("request id " + n.id + "." + n.sends + " state changed to " + n.xhr.readyState), n.abort) return void(n.abort = !1);
                            if (4 !== n.xhr.readyState) return;
                            const i = e._getRequestStatus(n);
                            if (this.lastResponseHeaders = n.xhr.getAllResponseHeaders(), this._conn.disconnecting && i >= 400) return this._hitError(i), void this._callProtocolErrorHandlers(n);
                            const r = this._requests[0] === n,
                                o = this._requests[1] === n,
                                s = i > 0 && i < 500,
                                a = n.sends > this._conn.maxRetries;
                            (s || a) && (this._removeRequest(n), F.debug("request id " + n.id + " should now be removed")), 200 === i ? ((o || r && this._requests.length > 0 && this._requests[0].age() > Math.floor(F.SECONDARY_TIMEOUT * this.wait)) && this._restartRequest(0), this._conn.nextValidRid(Number(n.rid) + 1), F.debug("request id " + n.id + "." + n.sends + " got 200"), t(n), this.errors = 0) : 0 === i || i >= 400 && i < 600 || i >= 12e3 ? (F.error("request id " + n.id + "." + n.sends + " error " + i + " happened"), this._hitError(i), this._callProtocolErrorHandlers(n), i >= 400 && i < 500 && (this._conn._changeConnectStatus(F.Status.DISCONNECTING, null), this._conn._doDisconnect())) : F.error("request id " + n.id + "." + n.sends + " error " + i + " happened"), s || a ? a && !this._conn.connected && this._conn._changeConnectStatus(F.Status.CONNFAIL, "giving-up") : this._throttledRequestHandler()
                        }
                        _processRequest(t) {
                            let n = this._requests[t];
                            const i = e._getRequestStatus(n, -1);
                            if (n.sends > this._conn.maxRetries) return void this._conn._onDisconnectTimeout();
                            const r = n.age(),
                                o = !isNaN(r) && r > Math.floor(F.TIMEOUT * this.wait),
                                s = null !== n.dead && n.timeDead() > Math.floor(F.SECONDARY_TIMEOUT * this.wait),
                                a = 4 === n.xhr.readyState && (i < 1 || i >= 500);
                            if ((o || s || a) && (s && F.error(`Request ${this._requests[t].id} timed out (secondary), restarting`), n.abort = !0, n.xhr.abort(), n.xhr.onreadystatechange = function() {}, this._requests[t] = new F.Request(n.xmlData, n.origFunc, n.rid, n.sends), n = this._requests[t]), 0 === n.xhr.readyState) {
                                F.debug("request id " + n.id + "." + n.sends + " posting");
                                try {
                                    const e = this._conn.options.contentType || "text/xml; charset=utf-8";
                                    n.xhr.open("POST", this._conn.service, !this._conn.options.sync), void 0 !== n.xhr.setRequestHeader && n.xhr.setRequestHeader("Content-Type", e), this._conn.options.withCredentials && (n.xhr.withCredentials = !0)
                                } catch (e) {
                                    return F.error("XHR open failed: " + e.toString()), this._conn.connected || this._conn._changeConnectStatus(F.Status.CONNFAIL, "bad-service"), void this._conn.disconnect()
                                }
                                const e = () => {
                                    if (n.date = new Date, this._conn.options.customHeaders) {
                                        const e = this._conn.options.customHeaders;
                                        for (const t in e) Object.prototype.hasOwnProperty.call(e, t) && n.xhr.setRequestHeader(t, e[t])
                                    }
                                    n.xhr.send(n.data)
                                };
                                if (n.sends > 1) {
                                    const t = 1e3 * Math.min(Math.floor(F.TIMEOUT * this.wait), Math.pow(n.sends, 3));
                                    setTimeout((function() {
                                        e()
                                    }), t)
                                } else e();
                                n.sends++, this._conn.xmlOutput !== F.Connection.prototype.xmlOutput && (n.xmlData.nodeName === this.strip && n.xmlData.childNodes.length ? this._conn.xmlOutput(n.xmlData.childNodes[0]) : this._conn.xmlOutput(n.xmlData)), this._conn.rawOutput !== F.Connection.prototype.rawOutput && this._conn.rawOutput(n.data)
                            } else F.debug("_processRequest: " + (0 === t ? "first" : "second") + " request has readyState of " + n.xhr.readyState)
                        }
                        _removeRequest(e) {
                            F.debug("removing request");
                            for (let t = this._requests.length - 1; t >= 0; t--) e === this._requests[t] && this._requests.splice(t, 1);
                            e.xhr.onreadystatechange = function() {}, this._throttledRequestHandler()
                        }
                        _restartRequest(e) {
                            const t = this._requests[e];
                            null === t.dead && (t.dead = new Date), this._processRequest(e)
                        }
                        _reqToData(e) {
                            try {
                                return e.getResponse()
                            } catch (e) {
                                if ("parsererror" !== e.message) throw e;
                                this._conn.disconnect("strophe-parsererror")
                            }
                        }
                        _sendTerminate(e) {
                            F.debug("_sendTerminate was called");
                            const t = this._buildBody().attrs({
                                type: "terminate"
                            });
                            e && t.cnode(e.tree());
                            const n = new F.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"));
                            this._requests.push(n), this._throttledRequestHandler()
                        }
                        _send() {
                            clearTimeout(this._conn._idleTimeout), this._throttledRequestHandler(), this._conn._idleTimeout = setTimeout((() => this._conn._onIdle()), 100)
                        }
                        _sendRestart() {
                            this._throttledRequestHandler(), clearTimeout(this._conn._idleTimeout)
                        }
                        _throttledRequestHandler() {
                            this._requests ? F.debug("_throttledRequestHandler called with " + this._requests.length + " requests") : F.debug("_throttledRequestHandler called with undefined requests"), this._requests && 0 !== this._requests.length && (this._requests.length > 0 && this._processRequest(0), this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window && this._processRequest(1))
                        }
                    }, F.Bosh.prototype.strip = null, F.Websocket = class {
                        constructor(e) {
                            this._conn = e, this.strip = "wrapper";
                            const t = e.service;
                            if (0 !== t.indexOf("ws:") && 0 !== t.indexOf("wss:")) {
                                let n = "";
                                "ws" === e.options.protocol && "https:" !== window.location.protocol ? n += "ws" : n += "wss", n += "://" + window.location.host, 0 !== t.indexOf("/") ? n += window.location.pathname + t : n += t, e.service = n
                            }
                        }
                        _buildStream() {
                            return N("open", {
                                xmlns: F.NS.FRAMING,
                                to: this._conn.domain,
                                version: "1.0"
                            })
                        }
                        _checkStreamError(e, t) {
                            let n;
                            if (n = e.getElementsByTagNameNS ? e.getElementsByTagNameNS(F.NS.STREAM, "error") : e.getElementsByTagName("stream:error"), 0 === n.length) return !1;
                            const i = n[0];
                            let r = "",
                                o = "";
                            for (let e = 0; e < i.childNodes.length; e++) {
                                const t = i.childNodes[e];
                                if ("urn:ietf:params:xml:ns:xmpp-streams" !== t.getAttribute("xmlns")) break;
                                "text" === t.nodeName ? o = t.textContent : r = t.nodeName
                            }
                            let s = "WebSocket stream error: ";
                            return s += r || "unknown", o && (s += " - " + o), F.error(s), this._conn._changeConnectStatus(t, r), this._conn._doDisconnect(), !0
                        }
                        _reset() {}
                        _connect() {
                            this._closeSocket(), this.socket = new i(this._conn.service, "xmpp"), this.socket.onopen = () => this._onOpen(), this.socket.onerror = e => this._onError(e), this.socket.onclose = e => this._onClose(e), this.socket.onmessage = e => this._onInitialMessage(e)
                        }
                        _connect_cb(e) {
                            if (this._checkStreamError(e, F.Status.CONNFAIL)) return F.Status.CONNFAIL
                        }
                        _handleStreamStart(e) {
                            let t = !1;
                            const n = e.getAttribute("xmlns");
                            "string" != typeof n ? t = "Missing xmlns in <open />" : n !== F.NS.FRAMING && (t = "Wrong xmlns in <open />: " + n);
                            const i = e.getAttribute("version");
                            return "string" != typeof i ? t = "Missing version in <open />" : "1.0" !== i && (t = "Wrong version in <open />: " + i), !t || (this._conn._changeConnectStatus(F.Status.CONNFAIL, t), this._conn._doDisconnect(), !1)
                        }
                        _onInitialMessage(e) {
                            if (0 === e.data.indexOf("<open ") || 0 === e.data.indexOf("<?xml")) {
                                const t = e.data.replace(/^(<\?.*?\?>\s*)*/, "");
                                if ("" === t) return;
                                const n = (new r).parseFromString(t, "text/xml").documentElement;
                                this._conn.xmlInput(n), this._conn.rawInput(e.data), this._handleStreamStart(n) && this._connect_cb(n)
                            } else if (0 === e.data.indexOf("<close ")) {
                                const t = (new r).parseFromString(e.data, "text/xml").documentElement;
                                this._conn.xmlInput(t), this._conn.rawInput(e.data);
                                const n = t.getAttribute("see-other-uri");
                                if (n) {
                                    const e = this._conn.service;
                                    (e.indexOf("wss:") >= 0 && n.indexOf("wss:") >= 0 || e.indexOf("ws:") >= 0) && (this._conn._changeConnectStatus(F.Status.REDIRECT, "Received see-other-uri, resetting connection"), this._conn.reset(), this._conn.service = n, this._connect())
                                } else this._conn._changeConnectStatus(F.Status.CONNFAIL, "Received closing stream"), this._conn._doDisconnect()
                            } else {
                                this._replaceMessageHandler();
                                const t = this._streamWrap(e.data),
                                    n = (new r).parseFromString(t, "text/xml").documentElement;
                                this._conn._connect_cb(n, null, e.data)
                            }
                        }
                        _replaceMessageHandler() {
                            this.socket.onmessage = e => this._onMessage(e)
                        }
                        _disconnect(e) {
                            if (this.socket && this.socket.readyState !== i.CLOSED) {
                                e && this._conn.send(e);
                                const t = N("close", {
                                    xmlns: F.NS.FRAMING
                                });
                                this._conn.xmlOutput(t.tree());
                                const n = F.serialize(t);
                                this._conn.rawOutput(n);
                                try {
                                    this.socket.send(n)
                                } catch (e) {
                                    F.warn("Couldn't send <close /> tag.")
                                }
                            }
                            setTimeout((() => this._conn._doDisconnect()), 0)
                        }
                        _doDisconnect() {
                            F.debug("WebSockets _doDisconnect was called"), this._closeSocket()
                        }
                        _streamWrap(e) {
                            return "<wrapper>" + e + "</wrapper>"
                        }
                        _closeSocket() {
                            if (this.socket) try {
                                this.socket.onclose = null, this.socket.onerror = null, this.socket.onmessage = null, this.socket.close()
                            } catch (e) {
                                F.debug(e.message)
                            }
                            this.socket = null
                        }
                        _emptyQueue() {
                            return !0
                        }
                        _onClose(e) {
                            this._conn.connected && !this._conn.disconnecting ? (F.error("Websocket closed unexpectedly"), this._conn._doDisconnect()) : e && 1006 === e.code && !this._conn.connected && this.socket ? (F.error("Websocket closed unexcectedly"), this._conn._changeConnectStatus(F.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._conn._doDisconnect()) : F.debug("Websocket closed")
                        }
                        _no_auth_received(e) {
                            F.error("Server did not offer a supported authentication mechanism"), this._conn._changeConnectStatus(F.Status.CONNFAIL, F.ErrorCondition.NO_AUTH_MECH), e && e.call(this._conn), this._conn._doDisconnect()
                        }
                        _onDisconnectTimeout() {}
                        _abortAllRequests() {}
                        _onError(e) {
                            F.error("Websocket error " + JSON.stringify(e)), this._conn._changeConnectStatus(F.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._disconnect()
                        }
                        _onIdle() {
                            const e = this._conn._data;
                            if (e.length > 0 && !this._conn.paused) {
                                for (let t = 0; t < e.length; t++)
                                    if (null !== e[t]) {
                                        let n;
                                        n = "restart" === e[t] ? this._buildStream().tree() : e[t];
                                        const i = F.serialize(n);
                                        this._conn.xmlOutput(n), this._conn.rawOutput(i), this.socket.send(i)
                                    } this._conn._data = []
                            }
                        }
                        _onMessage(e) {
                            let t;
                            const n = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
                            if (e.data === n) return this._conn.rawInput(n), this._conn.xmlInput(e), void(this._conn.disconnecting || this._conn._doDisconnect());
                            if (0 === e.data.search("<open ")) {
                                if (t = (new r).parseFromString(e.data, "text/xml").documentElement, !this._handleStreamStart(t)) return
                            } else {
                                const n = this._streamWrap(e.data);
                                t = (new r).parseFromString(n, "text/xml").documentElement
                            }
                            return this._checkStreamError(t, F.Status.ERROR) ? void 0 : this._conn.disconnecting && "presence" === t.firstChild.nodeName && "unavailable" === t.firstChild.getAttribute("type") ? (this._conn.xmlInput(t), void this._conn.rawInput(F.serialize(t))) : void this._conn._dataRecv(t, e.data)
                        }
                        _onOpen() {
                            F.debug("Websocket open");
                            const e = this._buildStream();
                            this._conn.xmlOutput(e.tree());
                            const t = F.serialize(e);
                            this._conn.rawOutput(t), this.socket.send(t)
                        }
                        _reqToData(e) {
                            return e
                        }
                        _send() {
                            this._conn.flush()
                        }
                        _sendRestart() {
                            clearTimeout(this._conn._idleTimeout), this._conn._onIdle.bind(this._conn)()
                        }
                    };
                    const V = {};
                    V.debug = F.LogLevel.DEBUG, V.info = F.LogLevel.INFO, V.warn = F.LogLevel.WARN, V.error = F.LogLevel.ERROR, V.fatal = F.LogLevel.FATAL, F.WorkerWebsocket = class extends F.Websocket {
                        constructor(e) {
                            super(e), this._conn = e, this.worker = new SharedWorker(this._conn.options.worker, "Strophe XMPP Connection"), this.worker.onerror = e => {
                                var t;
                                null === (t = console) || void 0 === t || t.error(e), F.log(F.LogLevel.ERROR, `Shared Worker Error: ${e}`)
                            }
                        }
                        get socket() {
                            return {
                                send: e => this.worker.port.postMessage(["send", e])
                            }
                        }
                        _connect() {
                            this._messageHandler = e => this._onInitialMessage(e), this.worker.port.start(), this.worker.port.onmessage = e => this._onWorkerMessage(e), this.worker.port.postMessage(["_connect", this._conn.service, this._conn.jid])
                        }
                        _attach(e) {
                            this._messageHandler = e => this._onMessage(e), this._conn.connect_callback = e, this.worker.port.start(), this.worker.port.onmessage = e => this._onWorkerMessage(e), this.worker.port.postMessage(["_attach", this._conn.service])
                        }
                        _attachCallback(e, t) {
                            e === F.Status.ATTACHED ? (this._conn.jid = t, this._conn.authenticated = !0, this._conn.connected = !0, this._conn.restored = !0, this._conn._changeConnectStatus(F.Status.ATTACHED)) : e === F.Status.ATTACHFAIL && (this._conn.authenticated = !1, this._conn.connected = !1, this._conn.restored = !1, this._conn._changeConnectStatus(F.Status.ATTACHFAIL))
                        }
                        _disconnect(e, t) {
                            t && this._conn.send(t);
                            const n = N("close", {
                                xmlns: F.NS.FRAMING
                            });
                            this._conn.xmlOutput(n.tree());
                            const i = F.serialize(n);
                            this._conn.rawOutput(i), this.worker.port.postMessage(["send", i]), this._conn._doDisconnect()
                        }
                        _onClose(e) {
                            this._conn.connected && !this._conn.disconnecting ? (F.error("Websocket closed unexpectedly"), this._conn._doDisconnect()) : e && 1006 === e.code && !this._conn.connected ? (F.error("Websocket closed unexcectedly"), this._conn._changeConnectStatus(F.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._conn._doDisconnect()) : F.debug("Websocket closed")
                        }
                        _closeSocket() {
                            this.worker.port.postMessage(["_closeSocket"])
                        }
                        _replaceMessageHandler() {
                            this._messageHandler = e => this._onMessage(e)
                        }
                        _onWorkerMessage(e) {
                            const {
                                data: t
                            } = e, n = t[0];
                            if ("_onMessage" === n) this._messageHandler(t[1]);
                            else if (n in this) try {
                                this[n].apply(this, e.data.slice(1))
                            } catch (e) {
                                F.log(F.LogLevel.ERROR, e)
                            } else if ("log" === n) {
                                const e = t[1],
                                    n = t[2];
                                F.log(V[e], n)
                            } else F.log(F.LogLevel.ERROR, `Found unhandled service worker message: ${t}`)
                        }
                    }, t.$build = j.$build, t.$iq = j.$iq, t.$msg = j.$msg, t.$pres = j.$pres, t.Strophe = j.Strophe;
                    const {
                        b64_sha1: U
                    } = A;
                    e.$build = N, e.$iq = M, e.$msg = k, e.$pres = L, e.Strophe = F, e.b64_sha1 = U, Object.defineProperty(e, "__esModule", {
                        value: !0
                    })
                }(t)
            },
            352: function(e, t, n) {
                ! function(e) {
                    "use strict";
                    e.Strophe.addConnectionPlugin("disco", {
                        _connection: null,
                        _identities: [],
                        _features: [],
                        _items: [],
                        init: function(t) {
                            this._connection = t, this._identities = [], this._features = [], this._items = [], t.addHandler(this._onDiscoInfo.bind(this), e.Strophe.NS.DISCO_INFO, "iq", "get", null, null), t.addHandler(this._onDiscoItems.bind(this), e.Strophe.NS.DISCO_ITEMS, "iq", "get", null, null)
                        },
                        addIdentity: function(e, t, n, i) {
                            for (var r = 0; r < this._identities.length; r++)
                                if (this._identities[r].category == e && this._identities[r].type == t && this._identities[r].name == n && this._identities[r].lang == i) return !1;
                            return this._identities.push({
                                category: e,
                                type: t,
                                name: n,
                                lang: i
                            }), !0
                        },
                        addFeature: function(e) {
                            for (var t = 0; t < this._features.length; t++)
                                if (this._features[t] == e) return !1;
                            return this._features.push(e), !0
                        },
                        removeFeature: function(e) {
                            for (var t = 0; t < this._features.length; t++)
                                if (this._features[t] === e) return this._features.splice(t, 1), !0;
                            return !1
                        },
                        addItem: function(e, t, n, i) {
                            return !(n && !i || (this._items.push({
                                jid: e,
                                name: t,
                                node: n,
                                call_back: i
                            }), 0))
                        },
                        info: function(t, n, i, r, o) {
                            var s = {
                                xmlns: e.Strophe.NS.DISCO_INFO
                            };
                            n && (s.node = n);
                            var a = e.$iq({
                                from: this._connection.jid,
                                to: t,
                                type: "get"
                            }).c("query", s);
                            this._connection.sendIQ(a, i, r, o)
                        },
                        items: function(t, n, i, r, o) {
                            var s = {
                                xmlns: e.Strophe.NS.DISCO_ITEMS
                            };
                            n && (s.node = n);
                            var a = e.$iq({
                                from: this._connection.jid,
                                to: t,
                                type: "get"
                            }).c("query", s);
                            this._connection.sendIQ(a, i, r, o)
                        },
                        _buildIQResult: function(t, n) {
                            var i = t.getAttribute("id"),
                                r = t.getAttribute("from"),
                                o = e.$iq({
                                    type: "result",
                                    id: i
                                });
                            return null !== r && o.attrs({
                                to: r
                            }), o.c("query", n)
                        },
                        _onDiscoInfo: function(t) {
                            var n, i = t.getElementsByTagName("query")[0].getAttribute("node"),
                                r = {
                                    xmlns: e.Strophe.NS.DISCO_INFO
                                };
                            i && (r.node = i);
                            var o = this._buildIQResult(t, r);
                            for (n = 0; n < this._identities.length; n++) r = {
                                category: this._identities[n].category,
                                type: this._identities[n].type
                            }, this._identities[n].name && (r.name = this._identities[n].name), this._identities[n].lang && (r["xml:lang"] = this._identities[n].lang), o.c("identity", r).up();
                            for (n = 0; n < this._features.length; n++) o.c("feature", {
                                var: this._features[n]
                            }).up();
                            return this._connection.send(o.tree()), !0
                        },
                        _onDiscoItems: function(t) {
                            var n, i, r = {
                                    xmlns: e.Strophe.NS.DISCO_ITEMS
                                },
                                o = t.getElementsByTagName("query")[0].getAttribute("node");
                            if (o) {
                                for (r.node = o, n = [], i = 0; i < this._items.length; i++)
                                    if (this._items[i].node == o) {
                                        n = this._items[i].call_back(t);
                                        break
                                    }
                            } else n = this._items;
                            var s = this._buildIQResult(t, r);
                            for (i = 0; i < n.length; i++) {
                                var a = {
                                    jid: n[i].jid
                                };
                                n[i].name && (a.name = n[i].name), n[i].node && (a.node = n[i].node), s.c("item", a).up()
                            }
                            return this._connection.send(s.tree()), !0
                        }
                    })
                }(n(33))
            },
            617: function(e, t, n) {
                ! function(e) {
                    "use strict";
                    e.Strophe.addConnectionPlugin("streamManagement", {
                        logging: !1,
                        autoSendCountOnEveryIncomingStanza: !1,
                        requestResponseInterval: 5,
                        _c: null,
                        _NS: "urn:xmpp:sm:3",
                        _isStreamManagementEnabled: !1,
                        _serverProcesssedStanzasCounter: null,
                        _clientProcessedStanzasCounter: null,
                        _clientSentStanzasCounter: null,
                        _originalXMLOutput: null,
                        _requestHandler: null,
                        _incomingHandler: null,
                        _requestResponseIntervalCount: 0,
                        _isSupported: !1,
                        _unacknowledgedStanzas: [],
                        _acknowledgedStanzaListeners: [],
                        addAcknowledgedStanzaListener: function(e) {
                            this._acknowledgedStanzaListeners.push(e)
                        },
                        enable: function(t) {
                            if (!this._isSupported) throw new Error("The server doesn't support urn:xmpp:sm:3 namespace");
                            if (this._connectionStatus !== e.Strophe.Status.CONNECTED) throw new Error("enable() can only be called in the CONNECTED state");
                            this._c.send(e.$build("enable", {
                                xmlns: this._NS,
                                resume: t
                            })), this._c.flush(), this._c.pause()
                        },
                        getResumeToken: function() {
                            return this._resumeToken
                        },
                        isSupported() {
                            return this._isSupported
                        },
                        resume: function() {
                            if (!this.getResumeToken()) throw new Error("No resume token");
                            if (this._connectionStatus !== e.Strophe.Status.DISCONNECTED) throw new Error("resume() can only be called in the DISCONNECTED state");
                            this._c.options.explicitResourceBinding = !0, this._resuming = !0, this._originalConnect.apply(this._c, this._connectArgs)
                        },
                        requestAcknowledgement: function() {
                            if (this._connectionStatus !== e.Strophe.Status.CONNECTED) throw new Error("requestAcknowledgement() can only be called in the CONNECTED state");
                            this._requestResponseIntervalCount = 0, this._c.send(e.$build("r", {
                                xmlns: this._NS
                            }))
                        },
                        getOutgoingCounter: function() {
                            return this._clientSentStanzasCounter
                        },
                        getIncomingCounter: function() {
                            return this._clientProcessedStanzasCounter
                        },
                        init: function(t) {
                            this._c = t, e.Strophe.addNamespace("SM", this._NS), this._originalXMLOutput = this._c.xmlOutput, this._c.xmlOutput = this.xmlOutput.bind(this), this._originalConnect = this._c.connect, this._c.connect = this._interceptConnectArgs.bind(this), this._originalOnStreamFeaturesAfterSASL = this._c._onStreamFeaturesAfterSASL, this._c._onStreamFeaturesAfterSASL = this._onStreamFeaturesAfterSASL.bind(this), this._originalDoDisconnect = this._c._doDisconnect, this._c._doDisconnect = this._interceptDoDisconnect.bind(this), this._originalDisconnect = this._c.disconnect, this._c.disconnect = this._interceptDisconnect.bind(this)
                        },
                        _interceptDisconnect: function() {
                            this._resumeToken = void 0, this._originalDisconnect.apply(this._c, arguments)
                        },
                        _interceptDoDisconnect: function() {
                            this.getResumeToken() && !this._resuming && this._c.connected && !this._c.disconnecting && (this._resumeState = {
                                handlers: this._c.handlers,
                                timedHandlers: this._c.timedHandlers,
                                removeTimeds: this._c.removeTimeds,
                                removeHandlers: this._c.removeHandlers,
                                addTimeds: this._c.addTimeds,
                                addHandlers: this._c.addHandlers
                            }, this._storedJid = this._c.jid, this.logging && e.Strophe.debug("SM stored resume state, handler count: " + this._resumeState.handlers.length)), this._c._data = [], this._originalDoDisconnect.apply(this._c, arguments)
                        },
                        _interceptConnectArgs: function() {
                            this._connectArgs = arguments, this._originalConnect.apply(this._c, arguments)
                        },
                        _onStreamFeaturesAfterSASL: function(e) {
                            return this._isSupported = e.getElementsByTagNameNS(this._NS, "sm").length > 0, this._originalOnStreamFeaturesAfterSASL.apply(this._c, arguments)
                        },
                        statusChanged: function(t) {
                            if (this._connectionStatus = t, this.getResumeToken() || t !== e.Strophe.Status.CONNECTED && t !== e.Strophe.Status.DISCONNECTED)
                                if (t === e.Strophe.Status.BINDREQUIRED) {
                                    this._c.jid = this._storedJid;
                                    for (const e of (this._resumeState.handlers || []).concat(this._resumeState.addHandlers || [])) this._c._addSysHandler(e.handler, e.ns, e.name, e.type, e.id);
                                    for (const e of (this._resumeState.timedHandlers || []).concat(this._resumeState.addTimeds)) this._c.addTimedHandler(e.period, e.handler);
                                    for (const e of (this._resumeState.removeTimeds || []).concat(this._resumeState.removeHandlers || [])) this._c.deleteTimedHandler(e);
                                    this._c.send(e.$build("resume", {
                                        xmlns: this._NS,
                                        h: this._clientProcessedStanzasCounter,
                                        previd: this._resumeToken
                                    })), this._c.flush()
                                } else t === e.Strophe.Status.ERROR && (this.logging && e.Strophe.debug("SM cleared resume token on error"), this._resumeToken = void 0);
                            else this.logging && e.Strophe.debug("SM reset state"), this._serverProcesssedStanzasCounter = 0, this._clientProcessedStanzasCounter = 0, this._clientSentStanzasCounter = 0, this._isStreamManagementEnabled = !1, this._requestResponseIntervalCount = 0, this._resuming = !1, t === e.Strophe.Status.DISCONNECTED && (this._isSupported = !1), this._unacknowledgedStanzas = [], this._requestHandler && this._c.deleteHandler(this._requestHandler), this._incomingHandler && this._c.deleteHandler(this._incomingHandler), this._requestHandler = this._c.addHandler(this._handleServerRequestHandler.bind(this), this._NS, "r"), this._ackHandler = this._c.addHandler(this._handleServerAck.bind(this), this._NS, "a"), this._incomingHandler = this._c.addHandler(this._incomingStanzaHandler.bind(this)), this._enabledHandler = this._c._addSysHandler(this._handleEnabled.bind(this), this._NS, "enabled"), this._resumeFailedHandler = this._c._addSysHandler(this._handleResumeFailed.bind(this), this._NS, "failed"), this._resumedHandler = this._c._addSysHandler(this._handleResumed.bind(this), this._NS, "resumed")
                        },
                        xmlOutput: function(t) {
                            return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && this._increaseSentStanzasCounter(t), this._originalXMLOutput.call(this._c, t)
                        },
                        _handleEnabled: function(e) {
                            return this._isStreamManagementEnabled = !0, this._resumeToken = "true" === e.getAttribute("resume") && e.getAttribute("id"), this._c.resume(), !0
                        },
                        _handleResumeFailed: function(t) {
                            const n = t && (t.firstElementChild && t.firstElementChild.tagName || t.firstChild && t.firstChild.tagName);
                            return this._c._changeConnectStatus(e.Strophe.Status.ERROR, n, t), this._c._doDisconnect(), !0
                        },
                        _handleResumed: function(t) {
                            var n = parseInt(t.getAttribute("h"));
                            if (this._handleAcknowledgedStanzas(n, this._serverProcesssedStanzasCounter), this._resuming = !1, this._c.do_bind = !1, this._c.authenticated = !0, this._c.restored = !0, this._unacknowledgedStanzas.length > 0) {
                                this.logging && e.Strophe.debug("SM Sending unacknowledged stanzas", this._unacknowledgedStanzas);
                                for (const e of this._unacknowledgedStanzas) this._c.send(e)
                            } else this.logging && e.Strophe.debug("SM No unacknowledged stanzas", this._unacknowledgedStanzas);
                            return this._c._changeConnectStatus(e.Strophe.Status.CONNECTED, null), !0
                        },
                        _incomingStanzaHandler: function(t) {
                            return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && (this._increaseReceivedStanzasCounter(), this.autoSendCountOnEveryIncomingStanza && this._answerProcessedStanzas()), !0
                        },
                        _handleAcknowledgedStanzas: function(t, n) {
                            var i = t - n;
                            i < 0 && this._throwError("New reported stanza count lower than previous. New: " + t + " - Previous: " + n), i > this._unacknowledgedStanzas.length && this._throwError("Higher reported acknowledge count than unacknowledged stanzas. Reported Acknowledge Count: " + i + " - Unacknowledge Stanza Count: " + this._unacknowledgedStanzas.length + " - New: " + t + " - Previous: " + n);
                            for (var r = 0; r < i; r++)
                                for (var o = this._unacknowledgedStanzas.shift(), s = 0; s < this._acknowledgedStanzaListeners.length; s++) this._acknowledgedStanzaListeners[s](o);
                            this.logging && this._unacknowledgedStanzas.length > 0 && e.Strophe.warn("SM Unacknowledged stanzas", this._unacknowledgedStanzas), this._serverProcesssedStanzasCounter = t, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount = 0)
                        },
                        _handleServerRequestHandler: function() {
                            return this._answerProcessedStanzas(), !0
                        },
                        _handleServerAck: function(e) {
                            var t = parseInt(e.getAttribute("h"));
                            return this._handleAcknowledgedStanzas(t, this._serverProcesssedStanzasCounter), !0
                        },
                        _answerProcessedStanzas: function() {
                            this._isStreamManagementEnabled && this._c.send(e.$build("a", {
                                xmlns: this._NS,
                                h: this._clientProcessedStanzasCounter
                            }))
                        },
                        _increaseSentStanzasCounter: function(t) {
                            if (this._isStreamManagementEnabled) {
                                if (-1 !== this._unacknowledgedStanzas.indexOf(t)) return;
                                this._unacknowledgedStanzas.push(t), this._clientSentStanzasCounter++, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount++, this._requestResponseIntervalCount === this.requestResponseInterval && setTimeout((() => {
                                    this._connectionStatus === e.Strophe.Status.CONNECTED && this.requestAcknowledgement()
                                }), 1))
                            }
                        },
                        _increaseReceivedStanzasCounter: function() {
                            this._isStreamManagementEnabled && this._clientProcessedStanzasCounter++
                        },
                        _throwError: function(t) {
                            throw e.Strophe.error(t), new Error(t)
                        }
                    })
                }(n(33))
            },
            144: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                const n = [];
                for (let e = 0; e < 256; ++e) n.push((e + 256).toString(16).substr(1));
                t.default = function(e, t) {
                    const i = t || 0,
                        r = n;
                    return (r[e[i + 0]] + r[e[i + 1]] + r[e[i + 2]] + r[e[i + 3]] + "-" + r[e[i + 4]] + r[e[i + 5]] + "-" + r[e[i + 6]] + r[e[i + 7]] + "-" + r[e[i + 8]] + r[e[i + 9]] + "-" + r[e[i + 10]] + r[e[i + 11]] + r[e[i + 12]] + r[e[i + 13]] + r[e[i + 14]] + r[e[i + 15]]).toLowerCase()
                }
            },
            433: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "v1", {
                    enumerable: !0,
                    get: function() {
                        return i.default
                    }
                }), Object.defineProperty(t, "v3", {
                    enumerable: !0,
                    get: function() {
                        return r.default
                    }
                }), Object.defineProperty(t, "v4", {
                    enumerable: !0,
                    get: function() {
                        return o.default
                    }
                }), Object.defineProperty(t, "v5", {
                    enumerable: !0,
                    get: function() {
                        return s.default
                    }
                });
                var i = a(n(423)),
                    r = a(n(89)),
                    o = a(n(600)),
                    s = a(n(400));

                function a(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
            },
            862: (e, t) => {
                "use strict";

                function n(e) {
                    return 14 + (e + 64 >>> 9 << 4) + 1
                }

                function i(e, t) {
                    const n = (65535 & e) + (65535 & t);
                    return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                }

                function r(e, t, n, r, o, s) {
                    return i((a = i(i(t, e), i(r, s))) << (d = o) | a >>> 32 - d, n);
                    var a, d
                }

                function o(e, t, n, i, o, s, a) {
                    return r(t & n | ~t & i, e, t, o, s, a)
                }

                function s(e, t, n, i, o, s, a) {
                    return r(t & i | n & ~i, e, t, o, s, a)
                }

                function a(e, t, n, i, o, s, a) {
                    return r(t ^ n ^ i, e, t, o, s, a)
                }

                function d(e, t, n, i, o, s, a) {
                    return r(n ^ (t | ~i), e, t, o, s, a)
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                t.default = function(e) {
                    if ("string" == typeof e) {
                        const t = unescape(encodeURIComponent(e));
                        e = new Uint8Array(t.length);
                        for (let n = 0; n < t.length; ++n) e[n] = t.charCodeAt(n)
                    }
                    return function(e) {
                        const t = [],
                            n = 32 * e.length,
                            i = "0123456789abcdef";
                        for (let r = 0; r < n; r += 8) {
                            const n = e[r >> 5] >>> r % 32 & 255,
                                o = parseInt(i.charAt(n >>> 4 & 15) + i.charAt(15 & n), 16);
                            t.push(o)
                        }
                        return t
                    }(function(e, t) {
                        e[t >> 5] |= 128 << t % 32, e[n(t) - 1] = t;
                        let r = 1732584193,
                            c = -271733879,
                            l = -1732584194,
                            h = 271733878;
                        for (let t = 0; t < e.length; t += 16) {
                            const n = r,
                                u = c,
                                p = l,
                                m = h;
                            r = o(r, c, l, h, e[t], 7, -680876936), h = o(h, r, c, l, e[t + 1], 12, -389564586), l = o(l, h, r, c, e[t + 2], 17, 606105819), c = o(c, l, h, r, e[t + 3], 22, -1044525330), r = o(r, c, l, h, e[t + 4], 7, -176418897), h = o(h, r, c, l, e[t + 5], 12, 1200080426), l = o(l, h, r, c, e[t + 6], 17, -1473231341), c = o(c, l, h, r, e[t + 7], 22, -45705983), r = o(r, c, l, h, e[t + 8], 7, 1770035416), h = o(h, r, c, l, e[t + 9], 12, -1958414417), l = o(l, h, r, c, e[t + 10], 17, -42063), c = o(c, l, h, r, e[t + 11], 22, -1990404162), r = o(r, c, l, h, e[t + 12], 7, 1804603682), h = o(h, r, c, l, e[t + 13], 12, -40341101), l = o(l, h, r, c, e[t + 14], 17, -1502002290), c = o(c, l, h, r, e[t + 15], 22, 1236535329), r = s(r, c, l, h, e[t + 1], 5, -165796510), h = s(h, r, c, l, e[t + 6], 9, -1069501632), l = s(l, h, r, c, e[t + 11], 14, 643717713), c = s(c, l, h, r, e[t], 20, -373897302), r = s(r, c, l, h, e[t + 5], 5, -701558691), h = s(h, r, c, l, e[t + 10], 9, 38016083), l = s(l, h, r, c, e[t + 15], 14, -660478335), c = s(c, l, h, r, e[t + 4], 20, -405537848), r = s(r, c, l, h, e[t + 9], 5, 568446438), h = s(h, r, c, l, e[t + 14], 9, -1019803690), l = s(l, h, r, c, e[t + 3], 14, -187363961), c = s(c, l, h, r, e[t + 8], 20, 1163531501), r = s(r, c, l, h, e[t + 13], 5, -1444681467), h = s(h, r, c, l, e[t + 2], 9, -51403784), l = s(l, h, r, c, e[t + 7], 14, 1735328473), c = s(c, l, h, r, e[t + 12], 20, -1926607734), r = a(r, c, l, h, e[t + 5], 4, -378558), h = a(h, r, c, l, e[t + 8], 11, -2022574463), l = a(l, h, r, c, e[t + 11], 16, 1839030562), c = a(c, l, h, r, e[t + 14], 23, -35309556), r = a(r, c, l, h, e[t + 1], 4, -1530992060), h = a(h, r, c, l, e[t + 4], 11, 1272893353), l = a(l, h, r, c, e[t + 7], 16, -155497632), c = a(c, l, h, r, e[t + 10], 23, -1094730640), r = a(r, c, l, h, e[t + 13], 4, 681279174), h = a(h, r, c, l, e[t], 11, -358537222), l = a(l, h, r, c, e[t + 3], 16, -722521979), c = a(c, l, h, r, e[t + 6], 23, 76029189), r = a(r, c, l, h, e[t + 9], 4, -640364487), h = a(h, r, c, l, e[t + 12], 11, -421815835), l = a(l, h, r, c, e[t + 15], 16, 530742520), c = a(c, l, h, r, e[t + 2], 23, -995338651), r = d(r, c, l, h, e[t], 6, -198630844), h = d(h, r, c, l, e[t + 7], 10, 1126891415), l = d(l, h, r, c, e[t + 14], 15, -1416354905), c = d(c, l, h, r, e[t + 5], 21, -57434055), r = d(r, c, l, h, e[t + 12], 6, 1700485571), h = d(h, r, c, l, e[t + 3], 10, -1894986606), l = d(l, h, r, c, e[t + 10], 15, -1051523), c = d(c, l, h, r, e[t + 1], 21, -2054922799), r = d(r, c, l, h, e[t + 8], 6, 1873313359), h = d(h, r, c, l, e[t + 15], 10, -30611744), l = d(l, h, r, c, e[t + 6], 15, -1560198380), c = d(c, l, h, r, e[t + 13], 21, 1309151649), r = d(r, c, l, h, e[t + 4], 6, -145523070), h = d(h, r, c, l, e[t + 11], 10, -1120210379), l = d(l, h, r, c, e[t + 2], 15, 718787259), c = d(c, l, h, r, e[t + 9], 21, -343485551), r = i(r, n), c = i(c, u), l = i(l, p), h = i(h, m)
                        }
                        return [r, c, l, h]
                    }(function(e) {
                        if (0 === e.length) return [];
                        const t = 8 * e.length,
                            i = new Uint32Array(n(t));
                        for (let n = 0; n < t; n += 8) i[n >> 5] |= (255 & e[n / 8]) << n % 32;
                        return i
                    }(e), 8 * e.length))
                }
            },
            294: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function() {
                    if (!n) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                    return n(i)
                };
                const n = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto),
                    i = new Uint8Array(16)
            },
            585: (e, t) => {
                "use strict";

                function n(e, t, n, i) {
                    switch (e) {
                        case 0:
                            return t & n ^ ~t & i;
                        case 1:
                        case 3:
                            return t ^ n ^ i;
                        case 2:
                            return t & n ^ t & i ^ n & i
                    }
                }

                function i(e, t) {
                    return e << t | e >>> 32 - t
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                t.default = function(e) {
                    const t = [1518500249, 1859775393, 2400959708, 3395469782],
                        r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
                    if ("string" == typeof e) {
                        const t = unescape(encodeURIComponent(e));
                        e = [];
                        for (let n = 0; n < t.length; ++n) e.push(t.charCodeAt(n))
                    }
                    e.push(128);
                    const o = e.length / 4 + 2,
                        s = Math.ceil(o / 16),
                        a = new Array(s);
                    for (let t = 0; t < s; ++t) {
                        const n = new Uint32Array(16);
                        for (let i = 0; i < 16; ++i) n[i] = e[64 * t + 4 * i] << 24 | e[64 * t + 4 * i + 1] << 16 | e[64 * t + 4 * i + 2] << 8 | e[64 * t + 4 * i + 3];
                        a[t] = n
                    }
                    a[s - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), a[s - 1][14] = Math.floor(a[s - 1][14]), a[s - 1][15] = 8 * (e.length - 1) & 4294967295;
                    for (let e = 0; e < s; ++e) {
                        const o = new Uint32Array(80);
                        for (let t = 0; t < 16; ++t) o[t] = a[e][t];
                        for (let e = 16; e < 80; ++e) o[e] = i(o[e - 3] ^ o[e - 8] ^ o[e - 14] ^ o[e - 16], 1);
                        let s = r[0],
                            d = r[1],
                            c = r[2],
                            l = r[3],
                            h = r[4];
                        for (let e = 0; e < 80; ++e) {
                            const r = Math.floor(e / 20),
                                a = i(s, 5) + n(r, d, c, l) + h + t[r] + o[e] >>> 0;
                            h = l, l = c, c = i(d, 30) >>> 0, d = s, s = a
                        }
                        r[0] = r[0] + s >>> 0, r[1] = r[1] + d >>> 0, r[2] = r[2] + c >>> 0, r[3] = r[3] + l >>> 0, r[4] = r[4] + h >>> 0
                    }
                    return [r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, 255 & r[0], r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, 255 & r[1], r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, 255 & r[2], r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, 255 & r[3], r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, 255 & r[4]]
                }
            },
            423: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var i = o(n(294)),
                    r = o(n(144));

                function o(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                let s, a, d = 0,
                    c = 0;
                t.default = function(e, t, n) {
                    let o = t && n || 0;
                    const l = t || [];
                    let h = (e = e || {}).node || s,
                        u = void 0 !== e.clockseq ? e.clockseq : a;
                    if (null == h || null == u) {
                        const t = e.random || (e.rng || i.default)();
                        null == h && (h = s = [1 | t[0], t[1], t[2], t[3], t[4], t[5]]), null == u && (u = a = 16383 & (t[6] << 8 | t[7]))
                    }
                    let p = void 0 !== e.msecs ? e.msecs : Date.now(),
                        m = void 0 !== e.nsecs ? e.nsecs : c + 1;
                    const g = p - d + (m - c) / 1e4;
                    if (g < 0 && void 0 === e.clockseq && (u = u + 1 & 16383), (g < 0 || p > d) && void 0 === e.nsecs && (m = 0), m >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                    d = p, c = m, a = u, p += 122192928e5;
                    const f = (1e4 * (268435455 & p) + m) % 4294967296;
                    l[o++] = f >>> 24 & 255, l[o++] = f >>> 16 & 255, l[o++] = f >>> 8 & 255, l[o++] = 255 & f;
                    const v = p / 4294967296 * 1e4 & 268435455;
                    l[o++] = v >>> 8 & 255, l[o++] = 255 & v, l[o++] = v >>> 24 & 15 | 16, l[o++] = v >>> 16 & 255, l[o++] = u >>> 8 | 128, l[o++] = 255 & u;
                    for (let e = 0; e < 6; ++e) l[o + e] = h[e];
                    return t || (0, r.default)(l)
                }
            },
            89: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var i = o(n(929)),
                    r = o(n(862));

                function o(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                var s = (0, i.default)("v3", 48, r.default);
                t.default = s
            },
            929: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e, t, n) {
                    function i(e, i, o, s) {
                        const a = o && s || 0;
                        if ("string" == typeof e && (e = function(e) {
                                e = unescape(encodeURIComponent(e));
                                const t = [];
                                for (let n = 0; n < e.length; ++n) t.push(e.charCodeAt(n));
                                return t
                            }(e)), "string" == typeof i && (i = function(e) {
                                const t = [];
                                return e.replace(/[a-fA-F0-9]{2}/g, (function(e) {
                                    t.push(parseInt(e, 16))
                                })), t
                            }(i)), !Array.isArray(e)) throw TypeError("value must be an array of bytes");
                        if (!Array.isArray(i) || 16 !== i.length) throw TypeError("namespace must be uuid string or an Array of 16 byte values");
                        const d = n(i.concat(e));
                        if (d[6] = 15 & d[6] | t, d[8] = 63 & d[8] | 128, o)
                            for (let e = 0; e < 16; ++e) o[a + e] = d[e];
                        return o || (0, r.default)(d)
                    }
                    try {
                        i.name = e
                    } catch (e) {}
                    return i.DNS = o, i.URL = s, i
                }, t.URL = t.DNS = void 0;
                var i, r = (i = n(144)) && i.__esModule ? i : {
                    default: i
                };
                const o = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
                t.DNS = o;
                const s = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
                t.URL = s
            },
            600: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var i = o(n(294)),
                    r = o(n(144));

                function o(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                t.default = function(e, t, n) {
                    "string" == typeof e && (t = "binary" === e ? new Uint8Array(16) : null, e = null);
                    const o = (e = e || {}).random || (e.rng || i.default)();
                    if (o[6] = 15 & o[6] | 64, o[8] = 63 & o[8] | 128, t) {
                        const e = n || 0;
                        for (let n = 0; n < 16; ++n) t[e + n] = o[n];
                        return t
                    }
                    return (0, r.default)(o)
                }
            },
            400: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var i = o(n(929)),
                    r = o(n(585));

                function o(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                var s = (0, i.default)("v5", 80, r.default);
                t.default = s
            },
            987: (e, t, n) => {
                "use strict";
                let i;
                n.r(t), n.d(t, {
                        AUDIO_OUTPUT_DEVICE_CHANGED: () => T,
                        AUDIO_SSRCS_REMAPPED: () => O,
                        CREATE_ANSWER_FAILED: () => r,
                        CREATE_OFFER_FAILED: () => o,
                        DATA_CHANNEL_CLOSED: () => a,
                        DATA_CHANNEL_OPEN: () => s,
                        DEVICE_LIST_AVAILABLE: () => R,
                        DEVICE_LIST_CHANGED: () => C,
                        DEVICE_LIST_WILL_CHANGE: () => x,
                        DOMINANT_SPEAKER_CHANGED: () => c,
                        ENDPOINT_CONN_STATUS_CHANGED: () => d,
                        ENDPOINT_MESSAGE_RECEIVED: () => A,
                        ENDPOINT_STATS_RECEIVED: () => w,
                        FORWARDED_SOURCES_CHANGED: () => l,
                        LASTN_VALUE_CHANGED: () => p,
                        LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED: () => g,
                        LOCAL_TRACK_SSRC_UPDATED: () => m,
                        LOCAL_UFRAG_CHANGED: () => I,
                        PERMISSIONS_CHANGED: () => h,
                        REMOTE_TRACK_ADDED: () => v,
                        REMOTE_TRACK_MUTE: () => _,
                        REMOTE_TRACK_REMOVED: () => y,
                        REMOTE_TRACK_UNMUTE: () => E,
                        REMOTE_UFRAG_CHANGED: () => P,
                        RTCEvents: () => i,
                        SENDER_VIDEO_CONSTRAINTS_CHANGED: () => u,
                        SET_LOCAL_DESCRIPTION_FAILED: () => S,
                        SET_REMOTE_DESCRIPTION_FAILED: () => b,
                        TRACK_ATTACHED: () => f,
                        VIDEO_SSRCS_REMAPPED: () => D,
                        default: () => N
                    }),
                    function(e) {
                        e.CREATE_ANSWER_FAILED = "rtc.create_answer_failed", e.CREATE_OFFER_FAILED = "rtc.create_offer_failed", e.DATA_CHANNEL_OPEN = "rtc.data_channel_open", e.DATA_CHANNEL_CLOSED = "rtc.data_channel_closed", e.ENDPOINT_CONN_STATUS_CHANGED = "rtc.endpoint_conn_status_changed", e.DOMINANT_SPEAKER_CHANGED = "rtc.dominant_speaker_changed", e.FORWARDED_SOURCES_CHANGED = "rtc.forwarded_sources_changed", e.PERMISSIONS_CHANGED = "rtc.permissions_changed", e.SENDER_VIDEO_CONSTRAINTS_CHANGED = "rtc.sender_video_constraints_changed", e.LASTN_VALUE_CHANGED = "rtc.lastn_value_changed", e.LOCAL_TRACK_SSRC_UPDATED = "rtc.local_track_ssrc_updated", e.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED = "rtc.local_track_max_enabled_resolution_changed", e.TRACK_ATTACHED = "rtc.track_attached", e.REMOTE_TRACK_ADDED = "rtc.remote_track_added", e.REMOTE_TRACK_MUTE = "rtc.remote_track_mute", e.REMOTE_TRACK_REMOVED = "rtc.remote_track_removed", e.REMOTE_TRACK_UNMUTE = "rtc.remote_track_unmute", e.SET_LOCAL_DESCRIPTION_FAILED = "rtc.set_local_description_failed", e.SET_REMOTE_DESCRIPTION_FAILED = "rtc.set_remote_description_failed", e.AUDIO_OUTPUT_DEVICE_CHANGED = "rtc.audio_output_device_changed", e.DEVICE_LIST_CHANGED = "rtc.device_list_changed", e.DEVICE_LIST_WILL_CHANGE = "rtc.device_list_will_change", e.DEVICE_LIST_AVAILABLE = "rtc.device_list_available", e.ENDPOINT_MESSAGE_RECEIVED = "rtc.endpoint_message_received", e.ENDPOINT_STATS_RECEIVED = "rtc.endpoint_stats_received", e.LOCAL_UFRAG_CHANGED = "rtc.local_ufrag_changed", e.REMOTE_UFRAG_CHANGED = "rtc.remote_ufrag_changed", e.VIDEO_SSRCS_REMAPPED = "rtc.video_ssrcs_remapped", e.AUDIO_SSRCS_REMAPPED = "rtc.audio_ssrcs_remapped"
                    }(i || (i = {}));
                const r = i.CREATE_ANSWER_FAILED,
                    o = i.CREATE_OFFER_FAILED,
                    s = i.DATA_CHANNEL_OPEN,
                    a = i.DATA_CHANNEL_CLOSED,
                    d = i.ENDPOINT_CONN_STATUS_CHANGED,
                    c = i.DOMINANT_SPEAKER_CHANGED,
                    l = i.FORWARDED_SOURCES_CHANGED,
                    h = i.PERMISSIONS_CHANGED,
                    u = i.SENDER_VIDEO_CONSTRAINTS_CHANGED,
                    p = i.LASTN_VALUE_CHANGED,
                    m = i.LOCAL_TRACK_SSRC_UPDATED,
                    g = i.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED,
                    f = i.TRACK_ATTACHED,
                    v = i.REMOTE_TRACK_ADDED,
                    _ = i.REMOTE_TRACK_MUTE,
                    y = i.REMOTE_TRACK_REMOVED,
                    E = i.REMOTE_TRACK_UNMUTE,
                    S = i.SET_LOCAL_DESCRIPTION_FAILED,
                    b = i.SET_REMOTE_DESCRIPTION_FAILED,
                    T = i.AUDIO_OUTPUT_DEVICE_CHANGED,
                    C = i.DEVICE_LIST_CHANGED,
                    x = i.DEVICE_LIST_WILL_CHANGE,
                    R = i.DEVICE_LIST_AVAILABLE,
                    A = i.ENDPOINT_MESSAGE_RECEIVED,
                    w = i.ENDPOINT_STATS_RECEIVED,
                    I = i.LOCAL_UFRAG_CHANGED,
                    P = i.REMOTE_UFRAG_CHANGED,
                    D = i.VIDEO_SSRCS_REMAPPED,
                    O = i.AUDIO_SSRCS_REMAPPED,
                    N = i
            },
            125: e => {
                e.exports = {
                    2160: {
                        width: 3840,
                        height: 2160
                    },
                    "4k": {
                        width: 3840,
                        height: 2160
                    },
                    1080: {
                        width: 1920,
                        height: 1080
                    },
                    fullhd: {
                        width: 1920,
                        height: 1080
                    },
                    720: {
                        width: 1280,
                        height: 720
                    },
                    hd: {
                        width: 1280,
                        height: 720
                    },
                    540: {
                        width: 960,
                        height: 540
                    },
                    qhd: {
                        width: 960,
                        height: 540
                    },
                    480: {
                        width: 640,
                        height: 480
                    },
                    vga: {
                        width: 640,
                        height: 480
                    },
                    360: {
                        width: 640,
                        height: 360
                    },
                    240: {
                        width: 320,
                        height: 240
                    },
                    180: {
                        width: 320,
                        height: 180
                    }
                }
            },
            408: (e, t, n) => {
                "use strict";
                let i;
                n.r(t), n.d(t, {
                        VideoType: () => i
                    }),
                    function(e) {
                        e.CAMERA = "camera", e.DESKTOP = "desktop"
                    }(i || (i = {}))
            },
            514: e => {
                e.exports = {
                    IDENTITY_UPDATED: "authentication.identity_updated"
                }
            },
            680: (e, t, n) => {
                "use strict";
                n.d(t, {
                    D: () => i
                });
                const i = "local"
            },
            609: (e, t, n) => {
                "use strict";
                let i;
                n.r(t), n.d(t, {
                        XMPPEvents: () => i
                    }),
                    function(e) {
                        e.ADD_ICE_CANDIDATE_FAILED = "xmpp.add_ice_candidate_failed", e.AUDIO_MUTED_BY_FOCUS = "xmpp.audio_muted_by_focus", e.VIDEO_MUTED_BY_FOCUS = "xmpp.video_muted_by_focus", e.AUTHENTICATION_REQUIRED = "xmpp.authentication_required", e.BRIDGE_DOWN = "xmpp.bridge_down", e.CALL_ACCEPTED = "xmpp.callaccepted.jingle", e.CALL_INCOMING = "xmpp.callincoming.jingle", e.CALL_ENDED = "xmpp.callended.jingle", e.CHAT_ERROR_RECEIVED = "xmpp.chat_error_received", e.SETTINGS_ERROR_RECEIVED = "xmpp.settings_error_received", e.CONFERENCE_PROPERTIES_CHANGED = "xmpp.conference_properties_changed", e.CONNECTION_ESTABLISHED = "xmpp.connection.connected", e.CONNECTION_FAILED = "xmpp.connection.failed", e.CONNECTION_INTERRUPTED = "xmpp.connection.interrupted", e.CONNECTION_RESTORED = "xmpp.connection.restored", e.CONNECTION_ICE_FAILED = "xmpp.connection.ice.failed", e.CONNECTION_RESTARTED = "xmpp.connection.restart", e.CONNECTION_STATUS_CHANGED = "xmpp.connection.status.changed", e.DISPLAY_NAME_CHANGED = "xmpp.display_name_changed", e.DISPLAY_NAME_REQUIRED = "xmpp.display_name_required", e.EMUC_ROOM_ADDED = "xmpp.emuc_room_added", e.EMUC_ROOM_REMOVED = "xmpp.emuc_room_removed", e.ETHERPAD = "xmpp.etherpad", e.FOCUS_DISCONNECTED = "xmpp.focus_disconnected", e.FOCUS_LEFT = "xmpp.focus_left", e.GRACEFUL_SHUTDOWN = "xmpp.graceful_shutdown", e.ICE_RESTARTING = "rtc.ice_restarting", e.ICE_RESTART_SUCCESS = "rtc.ice_restart_success", e.KICKED = "xmpp.kicked", e.LOCAL_ROLE_CHANGED = "xmpp.localrole_changed", e.MEETING_ID_SET = "xmpp.meeting_id_set", e.MESSAGE_RECEIVED = "xmpp.message_received", e.INVITE_MESSAGE_RECEIVED = "xmpp.invite_message_received", e.PRIVATE_MESSAGE_RECEIVED = "xmpp.private_message_received", e.MUC_MEMBER_BOT_TYPE_CHANGED = "xmpp.muc_member_bot_type_changed", e.MUC_DESTROYED = "xmpp.muc_destroyed", e.MUC_JOIN_IN_PROGRESS = "xmpp.muc_join_in_progress", e.MUC_JOINED = "xmpp.muc_joined", e.MUC_MEMBER_JOINED = "xmpp.muc_member_joined", e.MUC_MEMBER_LEFT = "xmpp.muc_member_left", e.MUC_LOBBY_MEMBER_JOINED = "xmpp.muc_lobby_member_joined", e.MUC_LOBBY_MEMBER_UPDATED = "xmpp.muc_lobby_member_updated", e.MUC_LOBBY_MEMBER_LEFT = "xmpp.muc_lobby_member_left", e.MUC_DENIED_ACCESS = "xmpp.muc_denied access", e.MUC_LEFT = "xmpp.muc_left", e.MUC_ROLE_CHANGED = "xmpp.muc_role_changed", e.MUC_LOCK_CHANGED = "xmpp.muc_lock_changed", e.MUC_MEMBERS_ONLY_CHANGED = "xmpp.muc_members_only_changed", e.MUC_VISITORS_SUPPORTED_CHANGED = "xmpp.muc_visitors_supported_changed", e.PARTICIPANT_AUDIO_MUTED = "xmpp.audio_muted", e.PARTICIPANT_VIDEO_MUTED = "xmpp.video_muted", e.PARTICIPANT_VIDEO_TYPE_CHANGED = "xmpp.video_type", e.PARTICIPANT_FEATURES_CHANGED = "xmpp.participant_features_changed", e.PASSWORD_REQUIRED = "xmpp.password_required", e.PHONE_NUMBER_CHANGED = "conference.phoneNumberChanged", e.PRESENCE_RECEIVED = "xmpp.presence_received", e.PRESENCE_STATUS = "xmpp.presence_status", e.PROMPT_FOR_LOGIN = "xmpp.prompt_for_login", e.READY_TO_JOIN = "xmpp.ready_to_join", e.RECORDER_STATE_CHANGED = "xmpp.recorderStateChanged", e.REMOTE_STATS = "xmpp.remote_stats", e.RENEGOTIATION_FAILED = "xmpp.renegotiation_failed", e.RESERVATION_ERROR = "xmpp.room_reservation_error", e.ROOM_CONNECT_ERROR = "xmpp.room_connect_error", e.ROOM_CONNECT_NOT_ALLOWED_ERROR = "xmpp.room_connect_error.not_allowed", e.ROOM_JOIN_ERROR = "xmpp.room_join_error", e.ROOM_CONNECT_MEMBERS_ONLY_ERROR = "xmpp.room_connect_error.members_only", e.ROOM_DISCO_INFO_UPDATED = "xmpp.room_disco_info_updated", e.ROOM_DISCO_INFO_FAILED = "xmpp.room_disco_info_failed", e.ROOM_MAX_USERS_ERROR = "xmpp.room_max_users_error", e.SENDING_CHAT_MESSAGE = "xmpp.sending_chat_message", e.SENDING_PRIVATE_CHAT_MESSAGE = "xmpp.sending_private_chat_message", e.SESSION_ACCEPT = "xmpp.session_accept", e.SESSION_ACCEPT_ERROR = "xmpp.session_accept_error", e.SESSION_ACCEPT_TIMEOUT = "xmpp.session_accept_timeout", e.SOURCE_ADD = "xmpp.source_add", e.SOURCE_ADD_ERROR = "xmpp.source_add_error", e.SOURCE_REMOVE = "xmpp.source_remove", e.SOURCE_REMOVE_ERROR = "xmpp.source_remove_error", e.SPEAKER_STATS_RECEIVED = "xmpp.speaker_stats_received", e.CONFERENCE_TIMESTAMP_RECEIVED = "xmpp.conference_timestamp_received", e.AV_MODERATION_APPROVED = "xmpp.av_moderation.approved", e.AV_MODERATION_REJECTED = "xmpp.av_moderation.rejected", e.AV_MODERATION_RECEIVED = "xmpp.av_moderation.received", e.AV_MODERATION_CHANGED = "xmpp.av_moderation.changed", e.AV_MODERATION_PARTICIPANT_APPROVED = "xmpp.av_moderation.participant.approved", e.AV_MODERATION_PARTICIPANT_REJECTED = "xmpp.av_moderation.participant.rejected", e.BREAKOUT_ROOMS_MOVE_TO_ROOM = "xmpp.breakout-rooms.move-to-room", e.BREAKOUT_ROOMS_EVENT = "xmpp.breakout-rooms.event", e.BREAKOUT_ROOMS_UPDATED = "xmpp.breakout-rooms.updated", e.ROOM_METADATA_EVENT = "xmpp.room-metadata.event", e.ROOM_METADATA_UPDATED = "xmpp.room-metadata.updated", e.START_MUTED_FROM_FOCUS = "xmpp.start_muted_from_focus", e.SUBJECT_CHANGED = "xmpp.subject_changed", e.SUSPEND_DETECTED = "xmpp.suspend_detected", e.TRANSCRIPTION_STATUS_CHANGED = "xmpp.transcription_status_changed", e.TRANSPORT_INFO = "xmpp.transportinfo.jingle", e.VIDEO_SIP_GW_AVAILABILITY_CHANGED = "xmpp.videoSIPGWAvailabilityChanged", e.VIDEO_SIP_GW_SESSION_STATE_CHANGED = "xmpp.videoSIPGWSessionStateChanged", e.VISITORS_MESSAGE = "xmpp.visitors_message", e.VISITORS_REJECTION = "xmpp.visitors_rejection", e.ICE_CONNECTION_STATE_CHANGED = "xmpp.ice_connection_state_changed", e.JSON_MESSAGE_RECEIVED = "xmmp.json_message_received"
                    }(i || (i = {}))
            },
            972: (e, t, n) => {
                "use strict";
                n.d(t, {
                    Z: () => pu
                });
                var i = {};
                n.r(i), n.d(i, {
                    AUTHENTICATION_REQUIRED: () => T,
                    CHAT_ERROR: () => C,
                    CONFERENCE_ACCESS_DENIED: () => O,
                    CONFERENCE_DESTROYED: () => R,
                    CONFERENCE_MAX_USERS: () => A,
                    CONFERENCE_RESTARTED: () => I,
                    CONNECTION_ERROR: () => w,
                    DISPLAY_NAME_REQUIRED: () => N,
                    FOCUS_DISCONNECTED: () => k,
                    FOCUS_LEFT: () => M,
                    GRACEFUL_SHUTDOWN: () => L,
                    ICE_FAILED: () => F,
                    INCOMPATIBLE_SERVER_VERSIONS: () => j,
                    JitsiConferenceErrors: () => b,
                    MEMBERS_ONLY_ERROR: () => D,
                    NOT_ALLOWED_ERROR: () => P,
                    OFFER_ANSWER_FAILED: () => V,
                    PASSWORD_NOT_SUPPORTED: () => U,
                    PASSWORD_REQUIRED: () => H,
                    RESERVATION_ERROR: () => $,
                    SETTINGS_ERROR: () => x,
                    VIDEOBRIDGE_NOT_AVAILABLE: () => J
                });
                var r = {};
                n.r(r), n.d(r, {
                    AUDIO_INPUT_STATE_CHANGE: () => z,
                    AUDIO_UNMUTE_PERMISSIONS_CHANGED: () => K,
                    AUTH_STATUS_CHANGED: () => W,
                    AV_MODERATION_APPROVED: () => X,
                    AV_MODERATION_CHANGED: () => Y,
                    AV_MODERATION_PARTICIPANT_APPROVED: () => Q,
                    AV_MODERATION_PARTICIPANT_REJECTED: () => Z,
                    AV_MODERATION_REJECTED: () => ee,
                    BEFORE_STATISTICS_DISPOSED: () => te,
                    BOT_TYPE_CHANGED: () => ne,
                    BREAKOUT_ROOMS_MOVE_TO_ROOM: () => ie,
                    BREAKOUT_ROOMS_UPDATED: () => re,
                    CONFERENCE_CREATED_TIMESTAMP: () => oe,
                    CONFERENCE_ERROR: () => se,
                    CONFERENCE_FAILED: () => ae,
                    CONFERENCE_JOINED: () => ce,
                    CONFERENCE_JOIN_IN_PROGRESS: () => de,
                    CONFERENCE_LEFT: () => le,
                    CONFERENCE_UNIQUE_ID_SET: () => he,
                    CONFERENCE_VISITOR_CODECS_CHANGED: () => ue,
                    CONNECTION_ESTABLISHED: () => pe,
                    CONNECTION_INTERRUPTED: () => me,
                    CONNECTION_RESTORED: () => ge,
                    DATA_CHANNEL_CLOSED: () => fe,
                    DATA_CHANNEL_OPENED: () => ve,
                    DISPLAY_NAME_CHANGED: () => _e,
                    DOMINANT_SPEAKER_CHANGED: () => ye,
                    DTMF_SUPPORT_CHANGED: () => Ee,
                    E2EE_VERIFICATION_AVAILABLE: () => Se,
                    E2EE_VERIFICATION_COMPLETED: () => be,
                    E2EE_VERIFICATION_READY: () => Te,
                    ENDPOINT_MESSAGE_RECEIVED: () => Ce,
                    ENDPOINT_STATS_RECEIVED: () => xe,
                    FORWARDED_SOURCES_CHANGED: () => Re,
                    JVB121_STATUS: () => Ae,
                    JitsiConferenceEvents: () => B,
                    KICKED: () => we,
                    LAST_N_ENDPOINTS_CHANGED: () => Ie,
                    LOBBY_USER_JOINED: () => Pe,
                    LOBBY_USER_LEFT: () => De,
                    LOBBY_USER_UPDATED: () => Oe,
                    LOCK_STATE_CHANGED: () => Ne,
                    MEMBERS_ONLY_CHANGED: () => ke,
                    MESSAGE_RECEIVED: () => Me,
                    METADATA_UPDATED: () => Le,
                    NOISY_MIC: () => je,
                    NON_PARTICIPANT_MESSAGE_RECEIVED: () => Ve,
                    NO_AUDIO_INPUT: () => Fe,
                    P2P_STATUS: () => Ue,
                    PARTCIPANT_FEATURES_CHANGED: () => Be,
                    PARTICIPANT_KICKED: () => He,
                    PARTICIPANT_PROPERTY_CHANGED: () => qe,
                    PARTICIPANT_SOURCE_UPDATED: () => $e,
                    PHONE_NUMBER_CHANGED: () => Ge,
                    PRIVATE_MESSAGE_RECEIVED: () => Je,
                    PROPERTIES_CHANGED: () => ze,
                    RECORDER_STATE_CHANGED: () => Ke,
                    SERVER_REGION_CHANGED: () => We,
                    STARTED_MUTED: () => Ye,
                    START_MUTED_POLICY_CHANGED: () => Xe,
                    SUBJECT_CHANGED: () => Qe,
                    SUSPEND_DETECTED: () => Ze,
                    TALK_WHILE_MUTED: () => et,
                    TRACK_ADDED: () => tt,
                    TRACK_AUDIO_LEVEL_CHANGED: () => nt,
                    TRACK_MUTE_CHANGED: () => it,
                    TRACK_REMOVED: () => rt,
                    TRACK_UNMUTE_REJECTED: () => ot,
                    TRANSCRIPTION_STATUS_CHANGED: () => st,
                    USER_JOINED: () => at,
                    USER_LEFT: () => dt,
                    USER_ROLE_CHANGED: () => ct,
                    USER_STATUS_CHANGED: () => lt,
                    VIDEO_SIP_GW_AVAILABILITY_CHANGED: () => ht,
                    VIDEO_SIP_GW_SESSION_STATE_CHANGED: () => ut,
                    VIDEO_UNMUTE_PERMISSIONS_CHANGED: () => pt,
                    VISITORS_MESSAGE: () => gt,
                    VISITORS_REJECTION: () => ft,
                    VISITORS_SUPPORTED_CHANGED: () => mt,
                    _MEDIA_SESSION_ACTIVE_CHANGED: () => G,
                    _MEDIA_SESSION_STARTED: () => q
                });
                var o = {};
                n.r(o), n.d(o, {
                    JitsiTrackEvents: () => bt,
                    LOCAL_TRACK_STOPPED: () => Tt,
                    NO_AUDIO_INPUT: () => It,
                    NO_DATA_FROM_SOURCE: () => wt,
                    TRACK_AUDIO_LEVEL_CHANGED: () => Ct,
                    TRACK_AUDIO_OUTPUT_CHANGED: () => xt,
                    TRACK_MUTE_CHANGED: () => Rt,
                    TRACK_OWNER_CHANGED: () => Dt,
                    TRACK_REMOVED: () => Ot,
                    TRACK_STREAMING_STATUS_CHANGED: () => Pt,
                    TRACK_VIDEOTYPE_CHANGED: () => At
                });
                var s = {};
                n.r(s), n.d(s, {
                    RTCStatsEvents: () => Zn,
                    RTC_STATS_PC_EVENT: () => ti,
                    RTC_STATS_WC_DISCONNECTED: () => ei
                });
                var a = {};
                n.r(a), n.d(a, {
                    CONSTRAINT_FAILED: () => Gi,
                    ELECTRON_DESKTOP_PICKER_ERROR: () => zi,
                    ELECTRON_DESKTOP_PICKER_NOT_FOUND: () => Ki,
                    GENERAL: () => Wi,
                    JitsiTrackErrors: () => qi,
                    NOT_FOUND: () => Xi,
                    PERMISSION_DENIED: () => Yi,
                    SCREENSHARING_GENERIC_ERROR: () => Qi,
                    SCREENSHARING_USER_CANCELED: () => Zi,
                    TIMEOUT: () => er,
                    TRACK_IS_DISPOSED: () => tr,
                    TRACK_NO_STREAM_FOUND: () => nr,
                    TRACK_NO_STREAM_TRACKS_FOUND: () => or,
                    TRACK_TOO_MANY_TRACKS_IN_STREAM: () => rr,
                    UNSUPPORTED_RESOLUTION: () => ir
                });
                var d = {};
                n.r(d), n.d(d, {
                    CONNECTION_DISCONNECTED: () => lr,
                    CONNECTION_ESTABLISHED: () => hr,
                    CONNECTION_FAILED: () => ur,
                    CONNECTION_REDIRECTED: () => pr,
                    DISPLAY_NAME_REQUIRED: () => gr,
                    JitsiConnectionEvents: () => cr,
                    WRONG_STATE: () => mr
                });
                var c = {};
                n.r(c), n.d(c, {
                    CONNECTION_DROPPED_ERROR: () => yr,
                    JitsiConnectionErrors: () => _r,
                    OTHER_ERROR: () => Er,
                    PASSWORD_REQUIRED: () => Sr,
                    SERVER_ERROR: () => br
                });
                var l = {};
                n.r(l), n.d(l, {
                    JitsiTranscriptionStatus: () => Ko,
                    OFF: () => Xo,
                    ON: () => Wo
                });
                var h = {};
                n.r(h), n.d(h, {
                    fixNegotiationNeeded: () => dd,
                    shimAddTrackRemoveTrack: () => sd,
                    shimAddTrackRemoveTrackWithNative: () => od,
                    shimGetDisplayMedia: () => Za,
                    shimGetSendersWithDtmf: () => nd,
                    shimGetStats: () => id,
                    shimGetUserMedia: () => Qa,
                    shimMediaStream: () => ed,
                    shimOnTrack: () => td,
                    shimPeerConnection: () => ad,
                    shimSenderReceiverGetStats: () => rd
                });
                var u = {};
                n.r(u), n.d(u, {
                    shimAddTransceiver: () => vd,
                    shimCreateAnswer: () => Ed,
                    shimCreateOffer: () => yd,
                    shimGetDisplayMedia: () => ld,
                    shimGetParameters: () => _d,
                    shimGetUserMedia: () => cd,
                    shimOnTrack: () => hd,
                    shimPeerConnection: () => ud,
                    shimRTCDataChannel: () => fd,
                    shimReceiverGetStats: () => md,
                    shimRemoveStream: () => gd,
                    shimSenderGetStats: () => pd
                });
                var p = {};
                n.r(p), n.d(p, {
                    shimAudioContext: () => Id,
                    shimCallbacksAPI: () => Td,
                    shimConstraints: () => xd,
                    shimCreateOfferLegacy: () => wd,
                    shimGetUserMedia: () => Cd,
                    shimLocalStreamsAPI: () => Sd,
                    shimRTCIceServerUrls: () => Rd,
                    shimRemoteStreamsAPI: () => bd,
                    shimTrackEventTransceiver: () => Ad
                });
                var m = {};
                n.r(m), n.d(m, {
                    removeExtmapAllowMixed: () => kd,
                    shimAddIceCandidateNullOrEmpty: () => Md,
                    shimConnectionState: () => Nd,
                    shimMaxMessageSize: () => Dd,
                    shimParameterlessSetLocalDescription: () => Ld,
                    shimRTCIceCandidate: () => Pd,
                    shimSendThrowTypeError: () => Od
                });
                var g = {};
                n.r(g), n.d(g, {
                    ConnectionQualityEvents: () => dl,
                    LOCAL_STATS_UPDATED: () => pl,
                    REMOTE_STATS_UPDATED: () => ml
                });
                var f = {};
                n.r(f), n.d(f, {
                    AUDIO_INPUT_STATE_CHANGE: () => xl,
                    DETECTOR_STATE_CHANGE: () => Cl,
                    DetectionEvents: () => Tl,
                    NO_AUDIO_INPUT: () => Rl,
                    VAD_NOISY_DEVICE: () => Al,
                    VAD_REPORT_PUBLISHED: () => wl,
                    VAD_SCORE_PUBLISHED: () => Il,
                    VAD_TALK_WHILE_MUTED: () => Pl
                });
                var v = {};
                n.r(v), n.d(v, {
                    E2E_RTT_CHANGED: () => Ul,
                    E2ePingEvents: () => Vl
                });
                var _ = {};
                n.r(_), n.d(_, {
                    ERROR_NO_CONNECTION: () => Ih,
                    ERROR_SESSION_EXISTS: () => Ph,
                    STATE_FAILED: () => wh,
                    STATE_OFF: () => xh,
                    STATE_ON: () => Ch,
                    STATE_PENDING: () => Rh,
                    STATE_RETRYING: () => Ah,
                    STATUS_AVAILABLE: () => Sh,
                    STATUS_BUSY: () => Th,
                    STATUS_UNDEFINED: () => bh,
                    VideoSIPGWErrorConstants: () => Eh,
                    VideoSIPGWStateConstants: () => yh,
                    VideoSIPGWStatusConstants: () => _h
                });
                var y = {};
                n.r(y), n.d(y, {
                    DEVICE_LIST_CHANGED: () => qh,
                    JitsiMediaDevicesEvents: () => Bh,
                    PERMISSIONS_CHANGED: () => Gh,
                    PERMISSION_PROMPT_IS_SHOWN: () => zh,
                    SLOW_GET_USER_MEDIA: () => Kh
                });
                var E = n(810),
                    S = n.n(E);
                let b;
                ! function(e) {
                    e.AUTHENTICATION_REQUIRED = "conference.authenticationRequired", e.CHAT_ERROR = "conference.chatError", e.SETTINGS_ERROR = "conference.settingsError", e.CONFERENCE_DESTROYED = "conference.destroyed", e.CONFERENCE_MAX_USERS = "conference.max_users", e.CONNECTION_ERROR = "conference.connectionError", e.CONFERENCE_RESTARTED = "conference.restarted", e.NOT_ALLOWED_ERROR = "conference.connectionError.notAllowed", e.MEMBERS_ONLY_ERROR = "conference.connectionError.membersOnly", e.CONFERENCE_ACCESS_DENIED = "conference.connectionError.accessDenied", e.DISPLAY_NAME_REQUIRED = "conference.display_name_required", e.FOCUS_DISCONNECTED = "conference.focusDisconnected", e.FOCUS_LEFT = "conference.focusLeft", e.GRACEFUL_SHUTDOWN = "conference.gracefulShutdown", e.ICE_FAILED = "conference.iceFailed", e.INCOMPATIBLE_SERVER_VERSIONS = "conference.incompatible_server_versions", e.OFFER_ANSWER_FAILED = "conference.offerAnswerFailed", e.PASSWORD_NOT_SUPPORTED = "conference.passwordNotSupported", e.PASSWORD_REQUIRED = "conference.passwordRequired", e.RESERVATION_ERROR = "conference.reservationError", e.VIDEOBRIDGE_NOT_AVAILABLE = "conference.videobridgeNotAvailable"
                }(b || (b = {}));
                const T = b.AUTHENTICATION_REQUIRED,
                    C = b.CHAT_ERROR,
                    x = b.SETTINGS_ERROR,
                    R = b.CONFERENCE_DESTROYED,
                    A = b.CONFERENCE_MAX_USERS,
                    w = b.CONNECTION_ERROR,
                    I = b.CONFERENCE_RESTARTED,
                    P = b.NOT_ALLOWED_ERROR,
                    D = b.MEMBERS_ONLY_ERROR,
                    O = b.CONFERENCE_ACCESS_DENIED,
                    N = b.DISPLAY_NAME_REQUIRED,
                    k = b.FOCUS_DISCONNECTED,
                    M = b.FOCUS_LEFT,
                    L = b.GRACEFUL_SHUTDOWN,
                    F = b.ICE_FAILED,
                    j = b.INCOMPATIBLE_SERVER_VERSIONS,
                    V = b.OFFER_ANSWER_FAILED,
                    U = b.PASSWORD_NOT_SUPPORTED,
                    H = b.PASSWORD_REQUIRED,
                    $ = b.RESERVATION_ERROR,
                    J = b.VIDEOBRIDGE_NOT_AVAILABLE;
                let B;
                ! function(e) {
                    e._MEDIA_SESSION_ACTIVE_CHANGED = "conference.media_session.active_changed", e._MEDIA_SESSION_STARTED = "conference.media_session.started", e.AUDIO_INPUT_STATE_CHANGE = "conference.audio_input_state_changed", e.AUDIO_UNMUTE_PERMISSIONS_CHANGED = "conference.audio_unmute_permissions_changed", e.AUTH_STATUS_CHANGED = "conference.auth_status_changed", e.AV_MODERATION_APPROVED = "conference.av_moderation.approved", e.AV_MODERATION_CHANGED = "conference.av_moderation.changed", e.AV_MODERATION_PARTICIPANT_APPROVED = "conference.av_moderation.participant.approved", e.AV_MODERATION_PARTICIPANT_REJECTED = "conference.av_moderation.participant.rejected", e.AV_MODERATION_REJECTED = "conference.av_moderation.rejected", e.BEFORE_STATISTICS_DISPOSED = "conference.beforeStatisticsDisposed", e.BOT_TYPE_CHANGED = "conference.bot_type_changed", e.BREAKOUT_ROOMS_MOVE_TO_ROOM = "conference.breakout-rooms.move-to-room", e.BREAKOUT_ROOMS_UPDATED = "conference.breakout-rooms.updated", e.CONFERENCE_CREATED_TIMESTAMP = "conference.createdTimestamp", e.CONFERENCE_ERROR = "conference.error", e.CONFERENCE_FAILED = "conference.failed", e.CONFERENCE_JOIN_IN_PROGRESS = "conference.join_in_progress", e.CONFERENCE_JOINED = "conference.joined", e.CONFERENCE_LEFT = "conference.left", e.CONFERENCE_UNIQUE_ID_SET = "conference.unique_id_set", e.CONFERENCE_VISITOR_CODECS_CHANGED = "conference.visitor_codecs_changed", e.CONNECTION_ESTABLISHED = "conference.connectionEstablished", e.CONNECTION_INTERRUPTED = "conference.connectionInterrupted", e.CONNECTION_RESTORED = "conference.connectionRestored", e.DATA_CHANNEL_CLOSED = "conference.dataChannelClosed", e.DATA_CHANNEL_OPENED = "conference.dataChannelOpened", e.DISPLAY_NAME_CHANGED = "conference.displayNameChanged", e.DOMINANT_SPEAKER_CHANGED = "conference.dominantSpeaker", e.DTMF_SUPPORT_CHANGED = "conference.dtmfSupportChanged", e.E2EE_VERIFICATION_AVAILABLE = "conference.e2ee.verification.available", e.E2EE_VERIFICATION_COMPLETED = "conference.e2ee.verification.completed", e.E2EE_VERIFICATION_READY = "conference.e2ee.verification.ready", e.ENDPOINT_MESSAGE_RECEIVED = "conference.endpoint_message_received", e.ENDPOINT_STATS_RECEIVED = "conference.endpoint_stats_received", e.FORWARDED_SOURCES_CHANGED = "conference.forwardedSourcesChanged", e.JVB121_STATUS = "conference.jvb121Status", e.KICKED = "conference.kicked", e.LAST_N_ENDPOINTS_CHANGED = "conference.lastNEndpointsChanged", e.LOBBY_USER_JOINED = "conference.lobby.userJoined", e.LOBBY_USER_LEFT = "conference.lobby.userLeft", e.LOBBY_USER_UPDATED = "conference.lobby.userUpdated", e.LOCK_STATE_CHANGED = "conference.lock_state_changed", e.MEMBERS_ONLY_CHANGED = "conference.membersOnlyChanged", e.MESSAGE_RECEIVED = "conference.messageReceived", e.METADATA_UPDATED = "conference.metadata.updated", e.NO_AUDIO_INPUT = "conference.no_audio_input", e.NOISY_MIC = "conference.noisy_mic", e.NON_PARTICIPANT_MESSAGE_RECEIVED = "conference.non_participant_message_received", e.P2P_STATUS = "conference.p2pStatus", e.PARTCIPANT_FEATURES_CHANGED = "conference.partcipant_features_changed", e.PARTICIPANT_KICKED = "conference.participant_kicked", e.PARTICIPANT_PROPERTY_CHANGED = "conference.participant_property_changed", e.PARTICIPANT_SOURCE_UPDATED = "conference.participant_source_updated", e.PHONE_NUMBER_CHANGED = "conference.phoneNumberChanged", e.PRIVATE_MESSAGE_RECEIVED = "conference.privateMessageReceived", e.PROPERTIES_CHANGED = "conference.propertiesChanged", e.RECORDER_STATE_CHANGED = "conference.recorderStateChanged", e.SERVER_REGION_CHANGED = "conference.server_region_changed", e.START_MUTED_POLICY_CHANGED = "conference.start_muted_policy_changed", e.STARTED_MUTED = "conference.started_muted", e.SUBJECT_CHANGED = "conference.subjectChanged", e.SUSPEND_DETECTED = "conference.suspendDetected", e.TALK_WHILE_MUTED = "conference.talk_while_muted", e.TRACK_ADDED = "conference.trackAdded", e.TRACK_AUDIO_LEVEL_CHANGED = "conference.audioLevelsChanged", e.TRACK_MUTE_CHANGED = "conference.trackMuteChanged", e.TRACK_REMOVED = "conference.trackRemoved", e.TRACK_UNMUTE_REJECTED = "conference.trackUnmuteRejected", e.TRANSCRIPTION_STATUS_CHANGED = "conference.transcriptionStatusChanged", e.USER_JOINED = "conference.userJoined", e.USER_LEFT = "conference.userLeft", e.USER_ROLE_CHANGED = "conference.roleChanged", e.USER_STATUS_CHANGED = "conference.statusChanged", e.VIDEO_SIP_GW_AVAILABILITY_CHANGED = "conference.videoSIPGWAvailabilityChanged", e.VIDEO_SIP_GW_SESSION_STATE_CHANGED = "conference.videoSIPGWSessionStateChanged", e.VIDEO_UNMUTE_PERMISSIONS_CHANGED = "conference.video_unmute_permissions_changed", e.VISITORS_SUPPORTED_CHANGED = "conference.visitorsSupported", e.VISITORS_MESSAGE = "conference.visitors_message", e.VISITORS_REJECTION = "conference.visitors_rejection"
                }(B || (B = {}));
                const q = B._MEDIA_SESSION_STARTED,
                    G = B._MEDIA_SESSION_ACTIVE_CHANGED,
                    z = B.AUDIO_INPUT_STATE_CHANGE,
                    K = B.AUDIO_UNMUTE_PERMISSIONS_CHANGED,
                    W = B.AUTH_STATUS_CHANGED,
                    X = B.AV_MODERATION_APPROVED,
                    Y = B.AV_MODERATION_CHANGED,
                    Q = B.AV_MODERATION_PARTICIPANT_APPROVED,
                    Z = B.AV_MODERATION_PARTICIPANT_REJECTED,
                    ee = B.AV_MODERATION_REJECTED,
                    te = B.BEFORE_STATISTICS_DISPOSED,
                    ne = B.BOT_TYPE_CHANGED,
                    ie = B.BREAKOUT_ROOMS_MOVE_TO_ROOM,
                    re = B.BREAKOUT_ROOMS_UPDATED,
                    oe = B.CONFERENCE_CREATED_TIMESTAMP,
                    se = B.CONFERENCE_ERROR,
                    ae = B.CONFERENCE_FAILED,
                    de = B.CONFERENCE_JOIN_IN_PROGRESS,
                    ce = B.CONFERENCE_JOINED,
                    le = B.CONFERENCE_LEFT,
                    he = B.CONFERENCE_UNIQUE_ID_SET,
                    ue = B.CONFERENCE_VISITOR_CODECS_CHANGED,
                    pe = B.CONNECTION_ESTABLISHED,
                    me = B.CONNECTION_INTERRUPTED,
                    ge = B.CONNECTION_RESTORED,
                    fe = B.DATA_CHANNEL_CLOSED,
                    ve = B.DATA_CHANNEL_OPENED,
                    _e = B.DISPLAY_NAME_CHANGED,
                    ye = B.DOMINANT_SPEAKER_CHANGED,
                    Ee = B.DTMF_SUPPORT_CHANGED,
                    Se = B.E2EE_VERIFICATION_AVAILABLE,
                    be = B.E2EE_VERIFICATION_COMPLETED,
                    Te = B.E2EE_VERIFICATION_READY,
                    Ce = B.ENDPOINT_MESSAGE_RECEIVED,
                    xe = B.ENDPOINT_STATS_RECEIVED,
                    Re = B.FORWARDED_SOURCES_CHANGED,
                    Ae = B.JVB121_STATUS,
                    we = B.KICKED,
                    Ie = B.LAST_N_ENDPOINTS_CHANGED,
                    Pe = B.LOBBY_USER_JOINED,
                    De = B.LOBBY_USER_LEFT,
                    Oe = B.LOBBY_USER_UPDATED,
                    Ne = B.LOCK_STATE_CHANGED,
                    ke = B.MEMBERS_ONLY_CHANGED,
                    Me = B.MESSAGE_RECEIVED,
                    Le = B.METADATA_UPDATED,
                    Fe = B.NO_AUDIO_INPUT,
                    je = B.NOISY_MIC,
                    Ve = B.NON_PARTICIPANT_MESSAGE_RECEIVED,
                    Ue = B.P2P_STATUS,
                    He = B.PARTICIPANT_KICKED,
                    $e = B.PARTICIPANT_SOURCE_UPDATED,
                    Je = B.PRIVATE_MESSAGE_RECEIVED,
                    Be = B.PARTCIPANT_FEATURES_CHANGED,
                    qe = B.PARTICIPANT_PROPERTY_CHANGED,
                    Ge = B.PHONE_NUMBER_CHANGED,
                    ze = B.PROPERTIES_CHANGED,
                    Ke = B.RECORDER_STATE_CHANGED,
                    We = B.SERVER_REGION_CHANGED,
                    Xe = B.START_MUTED_POLICY_CHANGED,
                    Ye = B.STARTED_MUTED,
                    Qe = B.SUBJECT_CHANGED,
                    Ze = B.SUSPEND_DETECTED,
                    et = B.TALK_WHILE_MUTED,
                    tt = B.TRACK_ADDED,
                    nt = B.TRACK_AUDIO_LEVEL_CHANGED,
                    it = B.TRACK_MUTE_CHANGED,
                    rt = B.TRACK_REMOVED,
                    ot = B.TRACK_UNMUTE_REJECTED,
                    st = B.TRANSCRIPTION_STATUS_CHANGED,
                    at = B.USER_JOINED,
                    dt = B.USER_LEFT,
                    ct = B.USER_ROLE_CHANGED,
                    lt = B.USER_STATUS_CHANGED,
                    ht = B.VIDEO_SIP_GW_AVAILABILITY_CHANGED,
                    ut = B.VIDEO_SIP_GW_SESSION_STATE_CHANGED,
                    pt = B.VIDEO_UNMUTE_PERMISSIONS_CHANGED,
                    mt = B.VISITORS_SUPPORTED_CHANGED,
                    gt = B.VISITORS_MESSAGE,
                    ft = B.VISITORS_REJECTION;
                var vt = n(387),
                    _t = n.n(vt),
                    yt = n(47),
                    Et = n.n(yt),
                    St = n(33);
                let bt;
                ! function(e) {
                    e.LOCAL_TRACK_STOPPED = "track.stopped", e.TRACK_AUDIO_LEVEL_CHANGED = "track.audioLevelsChanged", e.TRACK_AUDIO_OUTPUT_CHANGED = "track.audioOutputChanged", e.TRACK_MUTE_CHANGED = "track.trackMuteChanged", e.TRACK_VIDEOTYPE_CHANGED = "track.videoTypeChanged", e.NO_DATA_FROM_SOURCE = "track.no_data_from_source", e.NO_AUDIO_INPUT = "track.no_audio_input", e.TRACK_STREAMING_STATUS_CHANGED = "track.streaming_status_changed", e.TRACK_OWNER_CHANGED = "track.owner_changed", e.TRACK_REMOVED = "track.removed"
                }(bt || (bt = {}));
                const Tt = bt.LOCAL_TRACK_STOPPED,
                    Ct = bt.TRACK_AUDIO_LEVEL_CHANGED,
                    xt = bt.TRACK_AUDIO_OUTPUT_CHANGED,
                    Rt = bt.TRACK_MUTE_CHANGED,
                    At = bt.TRACK_VIDEOTYPE_CHANGED,
                    wt = bt.NO_DATA_FROM_SOURCE,
                    It = bt.NO_AUDIO_INPUT,
                    Pt = bt.TRACK_STREAMING_STATUS_CHANGED,
                    Dt = bt.TRACK_OWNER_CHANGED,
                    Ot = bt.TRACK_REMOVED;
                let Nt;
                ! function(e) {
                    e.TYPE_OPERATIONAL = "operational", e.TYPE_PAGE = "page", e.TYPE_TRACK = "track", e.TYPE_UI = "ui", e.ACTION_JINGLE_RESTART = "restart", e.ACTION_JINGLE_SA_TIMEOUT = "session-accept.timeout", e.ACTION_JINGLE_SI_RECEIVED = "session-initiate.received", e.ACTION_JINGLE_SI_TIMEOUT = "session-initiate.timeout", e.ACTION_JINGLE_TERMINATE = "terminate", e.ACTION_JINGLE_TR_RECEIVED = "transport-replace.received", e.ACTION_JINGLE_TR_SUCCESS = "transport-replace.success", e.ACTION_P2P_DECLINED = "decline", e.ACTION_P2P_ESTABLISHED = "established", e.ACTION_P2P_FAILED = "failed", e.ACTION_P2P_SWITCH_TO_JVB = "switch.to.jvb", e.AVAILABLE_DEVICE = "available.device", e.CONNECTION_DISCONNECTED = "connection.disconnected", e.FEEDBACK = "feedback", e.ICE_DURATION = "ice.duration", e.ICE_ESTABLISHMENT_DURATION_DIFF = "ice.establishment.duration.diff", e.ICE_STATE_CHANGED = "ice.state.changed", e.NO_BYTES_SENT = "track.no-bytes-sent", e.TRACK_UNMUTED = "track.unmuted"
                }(Nt || (Nt = {}));
                const kt = Nt.TYPE_OPERATIONAL,
                    Mt = Nt.TYPE_PAGE,
                    Lt = Nt.TYPE_TRACK,
                    Ft = Nt.TYPE_UI,
                    jt = Nt.ACTION_JINGLE_RESTART,
                    Vt = Nt.ACTION_JINGLE_SA_TIMEOUT,
                    Ut = Nt.ACTION_JINGLE_SI_RECEIVED,
                    Ht = Nt.ACTION_JINGLE_SI_TIMEOUT,
                    $t = Nt.ACTION_JINGLE_TERMINATE,
                    Jt = Nt.ACTION_JINGLE_TR_RECEIVED,
                    Bt = Nt.ACTION_JINGLE_TR_SUCCESS,
                    qt = Nt.ACTION_P2P_DECLINED,
                    Gt = Nt.ACTION_P2P_ESTABLISHED,
                    zt = Nt.ACTION_P2P_FAILED,
                    Kt = Nt.ACTION_P2P_SWITCH_TO_JVB,
                    Wt = Nt.AVAILABLE_DEVICE,
                    Xt = Nt.CONNECTION_DISCONNECTED,
                    Yt = Nt.FEEDBACK,
                    Qt = Nt.ICE_DURATION,
                    Zt = Nt.ICE_ESTABLISHMENT_DURATION_DIFF,
                    en = Nt.ICE_STATE_CHANGED,
                    tn = Nt.NO_BYTES_SENT,
                    nn = Nt.TRACK_UNMUTED,
                    rn = (e, t, n) => ({
                        type: Nt.TYPE_OPERATIONAL,
                        action: "connection.failed",
                        attributes: {
                            error_type: e,
                            error_message: t,
                            ...n
                        }
                    }),
                    on = (e, t) => ({
                        action: e,
                        attributes: t,
                        source: "conference",
                        type: Nt.TYPE_OPERATIONAL
                    }),
                    sn = (e, t) => ({
                        action: "connection.stage.reached",
                        actionSubject: e,
                        attributes: t,
                        source: "connection.stage.reached",
                        type: Nt.TYPE_OPERATIONAL
                    }),
                    an = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        return {
                            type: Nt.TYPE_OPERATIONAL,
                            source: "get.user.media",
                            action: e,
                            attributes: t
                        }
                    },
                    dn = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        return {
                            type: Nt.TYPE_OPERATIONAL,
                            action: e,
                            source: "jingle",
                            attributes: t
                        }
                    },
                    cn = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        return {
                            type: Nt.TYPE_OPERATIONAL,
                            action: e,
                            source: "p2p",
                            attributes: t
                        }
                    },
                    ln = e => ({
                        type: Nt.TYPE_OPERATIONAL,
                        action: "remotely.muted",
                        mediaType: e
                    }),
                    hn = e => ({
                        type: Nt.TYPE_OPERATIONAL,
                        action: "rtp.stats",
                        attributes: e
                    });
                let un;
                ! function(e) {
                    e.AUDIO_LEVEL = "statistics.audioLevel", e.BEFORE_DISPOSED = "statistics.before_disposed", e.BYTE_SENT_STATS = "statistics.byte_sent_stats", e.CONNECTION_STATS = "statistics.connectionstats", e.LONG_TASKS_STATS = "statistics.long_tasks_stats"
                }(un || (un = {}));
                const pn = un.AUDIO_LEVEL,
                    mn = un.BEFORE_DISPOSED,
                    gn = un.BYTE_SENT_STATS,
                    fn = un.CONNECTION_STATS,
                    vn = un.LONG_TASKS_STATS;
                var _n = n(122);
                const yn = "chrome",
                    En = "safari",
                    Sn = "electron",
                    bn = "react-native",
                    Tn = {
                        Chrome: yn,
                        Firefox: "firefox",
                        Safari: En,
                        Electron: Sn
                    },
                    Cn = "blink",
                    xn = "webkit",
                    Rn = "gecko",
                    An = {
                        Blink: Cn,
                        WebKit: xn,
                        Gecko: Rn
                    };

                function wn(e) {
                    return {
                        name: Tn[e.name],
                        version: e.version,
                        engine: An[e.engine],
                        engineVersion: e.engineVersion
                    }
                }
                class In {
                    constructor(e) {
                        this._parser = new _n.UAParser(navigator.userAgent);
                        const {
                            name: t,
                            version: n,
                            engine: i,
                            engineVersion: r
                        } = e ? wn(e) : function(e) {
                            const t = function() {
                                const e = navigator.userAgent.match(/\b(react[ \t_-]*native)(?:\/(\S+))?/i);
                                let t;
                                if (e || "ReactNative" === navigator.product) {
                                    let n;
                                    return e && e.length > 2 && (n = e[1], t = e[2]), n || (n = "react-native"), t || (t = "unknown"), {
                                        name: bn,
                                        version: t
                                    }
                                }
                            }();
                            if (t) return t;
                            const {
                                name: n,
                                version: i
                            } = e.getBrowser(), {
                                name: r,
                                version: o
                            } = e.getEngine();
                            return wn({
                                name: n,
                                version: i,
                                engine: r,
                                engineVersion: o
                            })
                        }(this._parser);
                        this._name = t, this._version = n, this._engine = i, this._engineVersion = r
                    }
                    isChrome() {
                        return this._name === yn || this._engine === Cn
                    }
                    isFirefox() {
                        return this._engine === Rn
                    }
                    isSafari() {
                        return this._name === En
                    }
                    isElectron() {
                        return this._name === Sn
                    }
                    isReactNative() {
                        return this._name === bn
                    }
                    isChromiumBased() {
                        return this._engine === Cn
                    }
                    isWebKitBased() {
                        return this._engine === xn
                    }
                    getName() {
                        return this._name ? this._name : this._parser.getBrowser().name
                    }
                    getVersion() {
                        return this._version ? this._version : this._parser.getBrowser().version
                    }
                    getEngine() {
                        return this._engine
                    }
                    getEngineVersion() {
                        return this._engineVersion
                    }
                    getOS() {
                        return this._parser.getOS().name
                    }
                    getOSVersion() {
                        return this._parser.getOS().version
                    }
                    isVersionGreaterThan(e) {
                        if (this._version) return parseInt(this._version, 10) > parseInt(e, 10)
                    }
                    isVersionLessThan(e) {
                        if (this._version) return parseInt(this._version, 10) < parseInt(e, 10)
                    }
                    isVersionEqualTo(e) {
                        if (this._version) return parseInt(this._version, 10) === parseInt(e, 10)
                    }
                    isEngineVersionGreaterThan(e) {
                        if (this._engineVersion) return parseInt(this._engineVersion, 10) > parseInt(e, 10)
                    }
                    isEngineVersionLessThan(e) {
                        if (this._engineVersion) return parseInt(this._engineVersion, 10) < parseInt(e, 10)
                    }
                    isEngineVersionEqualTo(e) {
                        if (this._engineVersion) return parseInt(this._engineVersion, 10) === parseInt(e, 10)
                    }
                }
                const Pn = (0, E.getLogger)("rtctstats");

                function Dn(e, t) {
                    const n = JSON.parse(JSON.stringify(t));
                    Object.keys(n).forEach((t => {
                        const i = n[t];
                        delete i.id, e[t] && Object.keys(i).forEach((r => {
                            i[r] === e[t][r] && delete n[t][r]
                        }))
                    }));
                    let i = -1 / 0;
                    return Object.keys(n).forEach((e => {
                        const t = n[e];
                        t.timestamp > i && (i = t.timestamp)
                    })), Object.keys(n).forEach((e => {
                        const t = n[e];
                        t.timestamp === i && (t.timestamp = 0)
                    })), n.timestamp = i, n
                }

                function On(e) {
                    return {
                        id: e.id,
                        tracks: e.getTracks().map((e => ({
                            id: e.id,
                            kind: e.kind,
                            label: e.label,
                            enabled: e.enabled,
                            muted: e.muted,
                            readyState: e.readyState
                        })))
                    }
                }
                var Nn, kn = new Uint8Array(16);

                function Mn() {
                    if (!Nn && !(Nn = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                    return Nn(kn)
                }
                const Ln = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
                for (var Fn = [], jn = 0; jn < 256; ++jn) Fn.push((jn + 256).toString(16).substr(1));
                const Vn = function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = (Fn[e[t + 0]] + Fn[e[t + 1]] + Fn[e[t + 2]] + Fn[e[t + 3]] + "-" + Fn[e[t + 4]] + Fn[e[t + 5]] + "-" + Fn[e[t + 6]] + Fn[e[t + 7]] + "-" + Fn[e[t + 8]] + Fn[e[t + 9]] + "-" + Fn[e[t + 10]] + Fn[e[t + 11]] + Fn[e[t + 12]] + Fn[e[t + 13]] + Fn[e[t + 14]] + Fn[e[t + 15]]).toLowerCase();
                        if (! function(e) {
                                return "string" == typeof e && Ln.test(e)
                            }(n)) throw TypeError("Stringified UUID is invalid");
                        return n
                    },
                    Un = function(e, t, n) {
                        var i = (e = e || {}).random || (e.rng || Mn)();
                        if (i[6] = 15 & i[6] | 64, i[8] = 63 & i[8] | 128, t) {
                            n = n || 0;
                            for (var r = 0; r < 16; ++r) t[n + r] = i[r];
                            return t
                        }
                        return Vn(i)
                    },
                    Hn = "3.1",
                    $n = 6e5,
                    Jn = {
                        SequenceNumber: "sn"
                    },
                    Bn = 3001,
                    qn = 3002,
                    Gn = [Bn, qn],
                    zn = 1e3;
                var Kn = n(483),
                    Wn = n.n(Kn);

                function Xn(e) {
                    return 0 === e.indexOf("[") || -1 !== e.indexOf(":") ? "x:x:x:x:x:x:x:x" : "x.x.x.x"
                }

                function Yn(e) {
                    const t = Wn().parseCandidate(e);
                    return "relay" !== t.type && "ssltcp" !== t.protocol && (t.ip = Xn(t.ip), t.address = Xn(t.address)), t.relatedAddress && (t.relatedAddress = Xn(t.relatedAddress)), Wn().writeCandidate(t)
                }

                function Qn(e) {
                    let t, n, i, r, {
                            endpoint: o,
                            meetingFqn: s,
                            onCloseCallback: a,
                            useLegacy: d,
                            obfuscate: c = !0,
                            pingInterval: l = 3e4
                        } = e,
                        h = [],
                        u = Un(),
                        p = 0,
                        m = !1,
                        g = 1;
                    const f = d ? `${Hn}_LEGACY` : `${Hn}_STANDARD`,
                        v = e => {
                            e.push((new Date).getTime()), e.push(g++)
                        },
                        _ = e => {
                            const t = Object.assign({}, e);
                            "identity" !== t.type && t.data && (t.data = JSON.stringify(t.data)), n && n.readyState === WebSocket.OPEN && m && n.send(JSON.stringify(t))
                        },
                        y = function(e) {
                            _(e), h.length < zn && e.data && h.push(e)
                        };
                    return y.isConnected = function() {
                        if (!n) return !1;
                        const {
                            readyState: e
                        } = n;
                        return e === WebSocket.OPEN
                    }, y.isClosed = function() {
                        if (!n) return !0;
                        const {
                            readyState: e
                        } = n;
                        return e === WebSocket.CLOSED
                    }, y.identity = function() {
                        for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                        v(n), t && (n[2].parentStatsSessionId = t), y({
                            statsSessionId: u,
                            type: "identity",
                            data: n
                        })
                    }, y.statsEntry = function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        let i = t;
                        if (c) {
                            switch (t[0]) {
                                case "addIceCandidate":
                                case "onicecandidate":
                                case "setLocalDescription":
                                case "setRemoteDescription":
                                    i = JSON.parse(JSON.stringify(i))
                            }! function(e) {
                                switch (e[0]) {
                                    case "addIceCandidate":
                                    case "onicecandidate":
                                        if (e[2] && e[2].candidate) {
                                            const t = e[2];
                                            t.candidate = Yn(t.candidate), e[2] = t
                                        }
                                        break;
                                    case "setLocalDescription":
                                    case "setRemoteDescription":
                                    case "createOfferOnSuccess":
                                    case "createAnswerOnSuccess":
                                        e[2] && e[2].sdp && (e[2].sdp = (n = e[2].sdp, `${Wn().splitLines(n).map((e=>0===e.indexOf("a=candidate:")?`a=${Yn(e)}`:0===e.indexOf("c=")?"c=IN IP4 0.0.0.0":0===e.indexOf("a=rtcp:")?"a=rtcp:9 IN IP4 0.0.0.0":e)).join("\r\n").trim()}\r\n`));
                                        break;
                                    case "getStats":
                                    case "getstats":
                                        e[2] && (t = e[2], Object.keys(t).forEach((e => {
                                            const n = t[e];
                                            n && (["ipAddress", "ip", "address"].forEach((e => {
                                                n[e] && "relay" !== n.candidateType && (n[e] = Xn(n[e]))
                                            })), ["googLocalAddress", "googRemoteAddress"].forEach((e => {
                                                let t, i, r;
                                                n[e] && (r = "[" === n[e][0] ? "]:" : ":", [i, t] = n[e].split(r), n[e] = `${Xn(i)}:${t}`)
                                            })))
                                        })))
                                }
                                var t, n
                            }(i)
                        }
                        v(i), y({
                            statsSessionId: u,
                            type: "stats-entry",
                            data: i
                        })
                    }, y.keepAlive = function() {
                        y({
                            statsSessionId: u,
                            type: "keepalive"
                        })
                    }, y.close = function() {
                        n && n.close(Bn)
                    }, y.connect = function(e) {
                        let d = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        e && !t && (t = u), t && (u = Un(), h.forEach((e => {
                            e.statsSessionId = u
                        }))), n && n.close(), n = new WebSocket(`${o}/${s}?statsSessionId=${u}&isReconnect=${d}`, f, {
                            headers: {
                                "User-Agent": navigator.userAgent
                            }
                        }), n.onclose = function(t) {
                            if (i && clearInterval(i), m && (m = !1), a({
                                    code: t.code,
                                    reason: t.reason
                                }), !Gn.includes(t.code) && p < $n) {
                                const t = 2 ** p * 1e3 + Math.floor(1e4 * Math.random()),
                                    n = p + t < $n ? t : $n - p;
                                p += n, r = setTimeout((() => y.connect(e, !0)), n)
                            }
                        }, n.onopen = function() {
                            i = setInterval(y.keepAlive, l)
                        }, n.onmessage = async function(e) {
                            const {
                                type: t,
                                body: i
                            } = JSON.parse(e.data);
                            if (t === Jn.SequenceNumber) {
                                const {
                                    value: e,
                                    state: t
                                } = i;
                                if (h.length) {
                                    const t = h[0].data[4],
                                        i = h[h.length - 1].data[4];
                                    if (e < t - 1 && e > i) return void(n && n.close(qn));
                                    const r = h.findIndex((t => t.data[4] === e));
                                    h = h.slice(r + 1)
                                }
                                if ("initial" === t) {
                                    r && clearTimeout(r), p = 0, m = !0;
                                    for (let e = 0; e < h.length; e++) _(h[e])
                                }
                            }
                        }
                    }, y
                }
                let Zn;
                ! function(e) {
                    e.RTC_STATS_WC_DISCONNECTED = "rtcstats_ws_disconnected", e.RTC_STATS_PC_EVENT = "rtstats_pc_event"
                }(Zn || (Zn = {}));
                const ei = Zn.RTC_STATS_WC_DISCONNECTED,
                    ti = Zn.RTC_STATS_PC_EVENT;
                var ni = n(857);
                class ii extends ni.EventEmitter {
                    constructor() {
                        super(), this.addEventListener = this.addListener, this.removeEventListener = this.removeListener
                    }
                }

                function ri(e, t, n) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = n, e
                }
                const oi = (0, E.getLogger)("modules/RTCStats/RTCStats.ts"),
                    si = new class {
                        constructor() {
                            ri(this, "_initialized", !1), ri(this, "_trace", null), ri(this, "events", new ii)
                        }
                        init(e) {
                            const {
                                analytics: {
                                    rtcstatsUseLegacy: t = !1,
                                    rtcstatsPollInterval: n = 1e4,
                                    rtcstatsSendSdp: i = !1,
                                    rtcstatsEnabled: r = !1
                                } = {}
                            } = e;
                            r && !this._initialized && (function(e, t) {
                                let {
                                    statsEntry: n
                                } = e, {
                                    connectionFilter: i,
                                    pollInterval: r,
                                    useLegacy: o,
                                    sendSdp: s = !1,
                                    prefixesToWrap: a = [""],
                                    eventCallback: d
                                } = t, c = 0;
                                const l = new In,
                                    h = l.isFirefox(),
                                    u = l.isChromiumBased(),
                                    p = l.isWebKitBased(),
                                    m = l.isReactNative();
                                if (h || u || p || m) {
                                    if (a.forEach((e => {
                                            if (!window[`${e}RTCPeerConnection`]) return;
                                            const t = window[`${e}RTCPeerConnection`],
                                                a = function(e) {
                                                    let s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                                    const a = {
                                                            ...e
                                                        },
                                                        {
                                                            optional: l = []
                                                        } = s;
                                                    let g = !1;
                                                    try {
                                                        l.some((e => !0 === e.rtcStatsSFUP2P)) && (g = !0);
                                                        const a = new t(e, s);
                                                        if (i && i(e)) return a;
                                                        const f = "PC_" + c++;
                                                        a.__rtcStatsId = f, e || (e = {
                                                            nullConfig: !0
                                                        }), ((e = JSON.parse(JSON.stringify(e))) && e.iceServers || []).forEach((e => {
                                                            delete e.credential
                                                        })), e.browserType = h ? "moz" : "webkit", n("create", f, e), a.__dtlsTransport = null, n("constraints", f, s), a.addEventListener("icecandidate", (e => {
                                                            n("onicecandidate", f, e.candidate)
                                                        })), a.addEventListener("addstream", (e => {
                                                            n("onaddstream", f, `${e.stream.id} ${e.stream.getTracks().map((e=>`${e.kind}:${e.id}`))}`)
                                                        })), a.addEventListener("track", (e => {
                                                            n("ontrack", f, `${e.track.kind}:${e.track.id} ${e.streams.map((e=>`stream:${e.id}`))}`)
                                                        })), a.addEventListener("removestream", (e => {
                                                            n("onremovestream", f, `${e.stream.id} ${e.stream.getTracks().map((e=>`${e.kind}:${e.id}`))}`)
                                                        })), a.addEventListener("signalingstatechange", (() => {
                                                            n("onsignalingstatechange", f, a.signalingState)
                                                        })), a.addEventListener("iceconnectionstatechange", (() => {
                                                            const {
                                                                iceConnectionState: e
                                                            } = a;
                                                            n("oniceconnectionstatechange", f, e), null == d || d({
                                                                type: "iceconnectionstatechange",
                                                                body: {
                                                                    pcId: f,
                                                                    isP2P: g,
                                                                    state: e
                                                                }
                                                            })
                                                        })), a.addEventListener("icegatheringstatechange", (() => {
                                                            n("onicegatheringstatechange", f, a.iceGatheringState)
                                                        })), a.addEventListener("connectionstatechange", (() => {
                                                            const {
                                                                connectionState: e
                                                            } = a;
                                                            n("onconnectionstatechange", f, a.connectionState), null == d || d({
                                                                type: "connectionstatechange",
                                                                body: {
                                                                    pcId: f,
                                                                    isP2P: g,
                                                                    state: e
                                                                }
                                                            })
                                                        })), a.addEventListener("negotiationneeded", (() => {
                                                            n("onnegotiationneeded", f, void 0)
                                                        })), a.addEventListener("datachannel", (e => {
                                                            n("ondatachannel", f, [e.channel.id, e.channel.label])
                                                        }));
                                                        let v = {};
                                                        const _ = function() {
                                                            h || p || m || u && !o ? a.getStats(null).then((e => {
                                                                const t = function(e) {
                                                                        if (!e.entries) return e;
                                                                        const t = {};
                                                                        return e.forEach(((e, n) => {
                                                                            t[n] = e
                                                                        })), t
                                                                    }(e),
                                                                    i = JSON.parse(JSON.stringify(t));
                                                                n("getstats", f, Dn(v, t)), v = i
                                                            })) : u && a.getStats((e => {
                                                                const t = function(e, t) {
                                                                        const n = {};
                                                                        return t.result().forEach((e => {
                                                                            const t = {
                                                                                id: e.id,
                                                                                timestamp: e.timestamp.getTime(),
                                                                                type: e.type
                                                                            };
                                                                            e.names().forEach((n => {
                                                                                t[n] = e.stat(n)
                                                                            })), n[t.id] = t
                                                                        })), n
                                                                    }(0, e),
                                                                    i = JSON.parse(JSON.stringify(t));
                                                                n("getstats", f, Dn(v, t)), v = i
                                                            }))
                                                        };
                                                        if (r) {
                                                            const e = window.setInterval((() => {
                                                                "closed" !== a.signalingState && "closed" !== a.iceConnectionState ? _() : window.clearInterval(e)
                                                            }), r)
                                                        }
                                                        return a.addEventListener("connectionstatechange", (() => {
                                                            ["connected", "failed"].includes(a.connectionState) && _()
                                                        })), a
                                                    } catch (e) {
                                                        return console.error("RTCStats PeerConnection bind failed: ", e), new t(a, s)
                                                    }
                                                };
                                            ["createDataChannel", "close"].forEach((e => {
                                                const i = t.prototype[e];
                                                i && (t.prototype[e] = function() {
                                                    try {
                                                        n(e, this.__rtcStatsId, arguments)
                                                    } catch (t) {
                                                        console.error(`RTCStats ${e} bind failed: `, t)
                                                    }
                                                    return i.apply(this, arguments)
                                                })
                                            })), ["addStream", "removeStream"].forEach((e => {
                                                const i = t.prototype[e];
                                                i && (t.prototype[e] = function() {
                                                    try {
                                                        const t = arguments[0],
                                                            i = t.getTracks().map((e => `${e.kind}:${e.id}`)).join(",");
                                                        n(e, this.__rtcStatsId, `${t.id} ${i}`)
                                                    } catch (t) {
                                                        console.error(`RTCStats ${e} bind failed: `, t)
                                                    }
                                                    return i.apply(this, arguments)
                                                })
                                            })), ["addTrack"].forEach((e => {
                                                const i = t.prototype[e];
                                                i && (t.prototype[e] = function() {
                                                    try {
                                                        const t = arguments[0],
                                                            i = [].slice.call(arguments, 1);
                                                        n(e, this.__rtcStatsId, `${t.kind}:${t.id} ${i.map((e=>`stream:${e.id}`)).join(";")||"-"}`)
                                                    } catch (t) {
                                                        console.error(`RTCStats ${e} bind failed: `, t)
                                                    }
                                                    return i.apply(this, arguments)
                                                })
                                            })), ["removeTrack"].forEach((e => {
                                                const i = t.prototype[e];
                                                i && (t.prototype[e] = function() {
                                                    try {
                                                        const t = arguments[0].track;
                                                        n(e, this.__rtcStatsId, t ? `${t.kind}:${t.id}` : "null")
                                                    } catch (t) {
                                                        console.error(`RTCStats ${e} bind failed: `, t)
                                                    }
                                                    return i.apply(this, arguments)
                                                })
                                            })), ["addTransceiver"].forEach((e => {
                                                const i = t.prototype[e];
                                                i && (t.prototype[e] = function() {
                                                    try {
                                                        const t = arguments[0];
                                                        let i;
                                                        i = "string" == typeof t ? t : `${t.kind}:${t.id}`, 2 === arguments.length && "object" == typeof arguments[1] && (i += ` ${JSON.stringify(arguments[1])}`), n(e, this.__rtcStatsId, i)
                                                    } catch (t) {
                                                        console.error(`RTCStats ${e} bind failed: `, t)
                                                    }
                                                    return i.apply(this, arguments)
                                                })
                                            })), ["createOffer", "createAnswer"].forEach((e => {
                                                const i = t.prototype[e];
                                                i && (t.prototype[e] = function() {
                                                    const t = this.__rtcStatsId,
                                                        r = arguments;
                                                    let o;
                                                    1 === arguments.length && "object" == typeof arguments[0] ? o = arguments[0] : 3 === arguments.length && "object" == typeof arguments[2] && (o = arguments[2]);
                                                    try {
                                                        n(e, this.__rtcStatsId, o)
                                                    } catch (t) {
                                                        console.error(`RTCStats ${e} bind failed: `, t)
                                                    }
                                                    return i.apply(this, o ? [o] : void 0).then((i => {
                                                        try {
                                                            n(`${e}OnSuccess`, t, s ? i : "")
                                                        } catch (t) {
                                                            console.error(`RTCStats ${e} promise success bind failed: `, t)
                                                        }
                                                        if (!(r.length > 0 && "function" == typeof r[0])) return i;
                                                        r[0].apply(null, [i])
                                                    }), (i => {
                                                        try {
                                                            n(`${e}OnFailure`, t, i.toString())
                                                        } catch (t) {
                                                            console.error(`RTCStats ${e} promise failure bind failed: `, t)
                                                        }
                                                        if (!(r.length > 1 && "function" == typeof r[1])) throw i;
                                                        r[1].apply(null, [i])
                                                    }))
                                                })
                                            })), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((e => {
                                                const i = t.prototype[e];
                                                i && (t.prototype[e] = function() {
                                                    const t = this.__rtcStatsId,
                                                        r = arguments;
                                                    try {
                                                        const t = s ? r[0] : "";
                                                        n(e, this.__rtcStatsId, t)
                                                    } catch (t) {
                                                        console.error(`RTCStats ${e} bind failed: `, t)
                                                    }
                                                    return i.apply(this, [r[0]]).then((() => {
                                                        try {
                                                            n(`${e}OnSuccess`, t, void 0)
                                                        } catch (t) {
                                                            console.error(`RTCStats ${e} promise success bind failed: `, t)
                                                        }
                                                        this.__dtlsTransport || !e.endsWith("Description") || m || this.getSenders().forEach((e => {
                                                            !this.__dtlsTransport && e.transport && (this.__dtlsTransport = e.transport, e.transport.addEventListener("error", (e => {
                                                                n("ondtlserror", t, e)
                                                            })), e.transport.addEventListener("statechange", (() => {
                                                                const i = e.transport.state;
                                                                n("ondtlsstatechange", t, i)
                                                            })))
                                                        })), r.length >= 2 && "function" == typeof r[1] && r[1].apply(null, [])
                                                    }), (i => {
                                                        try {
                                                            n(`${e}OnFailure`, t, i.toString())
                                                        } catch (t) {
                                                            console.error(`RTCStats ${e} promise failure bind failed: `, t)
                                                        }
                                                        if (!(r.length >= 3 && "function" == typeof r[2])) throw i;
                                                        r[2].apply(null, [i])
                                                    }))
                                                })
                                            })), t.generateCertificate && Object.defineProperty(a, "generateCertificate", {
                                                get() {
                                                    return arguments.length ? t.generateCertificate.apply(null, arguments) : t.generateCertificate
                                                }
                                            }), window[`${e}RTCPeerConnection`] = a, window[`${e}RTCPeerConnection`].prototype = t.prototype
                                        })), a.forEach((e => {
                                            const t = e + (e.length ? "GetUserMedia" : "getUserMedia");
                                            if (!navigator[t]) return;
                                            const i = navigator[t].bind(navigator);
                                            navigator[t] = function() {
                                                try {
                                                    n("getUserMedia", null, arguments[0])
                                                } catch (e) {
                                                    console.error("RTCStats getUserMedia bind failed: ", e)
                                                }
                                                const e = arguments[1],
                                                    t = arguments[2];
                                                i(arguments[0], (t => {
                                                    try {
                                                        n("getUserMediaOnSuccess", null, On(t))
                                                    } catch (e) {
                                                        console.error("RTCStats getUserMediaOnSuccess bind failed: ", e)
                                                    }
                                                    e && e(t)
                                                }), (e => {
                                                    try {
                                                        n("getUserMediaOnFailure", null, e.name)
                                                    } catch (e) {
                                                        console.error("RTCStats getUserMediaOnFailure bind failed: ", e)
                                                    }
                                                    t && t(e)
                                                }))
                                            }.bind(navigator)
                                        })), navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                                        const e = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices),
                                            t = function() {
                                                try {
                                                    n("navigator.mediaDevices.getUserMedia", null, arguments[0])
                                                } catch (e) {
                                                    console.error("RTCStats navigator.mediaDevices.getUserMedia bind failed: ", e)
                                                }
                                                return e.apply(navigator.mediaDevices, arguments).then((e => {
                                                    try {
                                                        n("navigator.mediaDevices.getUserMediaOnSuccess", null, On(e))
                                                    } catch (e) {
                                                        console.error("RTCStats navigator.mediaDevices.getUserMediaOnSuccess bind failed: ", e)
                                                    }
                                                    return e
                                                }), (e => {
                                                    try {
                                                        n("navigator.mediaDevices.getUserMediaOnFailure", null, e.name)
                                                    } catch (e) {
                                                        console.error("RTCStats navigator.mediaDevices.getUserMediaOnFailure bind failed: ", e)
                                                    }
                                                    return Promise.reject(e)
                                                }))
                                            };
                                        navigator.mediaDevices.getUserMedia = t.bind(navigator.mediaDevices)
                                    }
                                    if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                                        const e = navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices),
                                            t = function() {
                                                try {
                                                    n("navigator.mediaDevices.getDisplayMedia", null, arguments[0])
                                                } catch (e) {
                                                    console.error("RTCStats navigator.mediaDevices.getDisplayMedia bind failed: ", e)
                                                }
                                                return e.apply(navigator.mediaDevices, arguments).then((e => {
                                                    try {
                                                        n("navigator.mediaDevices.getDisplayMediaOnSuccess", null, On(e))
                                                    } catch (e) {
                                                        console.error("RTCStats navigator.mediaDevices.getDisplayMediaOnSuccess bind failed: ", e)
                                                    }
                                                    return e
                                                }), (e => {
                                                    try {
                                                        n("navigator.mediaDevices.getDisplayMediaOnFailure", null, e.name)
                                                    } catch (e) {
                                                        console.error("RTCStats navigator.mediaDevices.getDisplayMediaOnFailure bind failed: ", e)
                                                    }
                                                    return Promise.reject(e)
                                                }))
                                            };
                                        navigator.mediaDevices.getDisplayMedia = t.bind(navigator.mediaDevices)
                                    }
                                } else Pn.warn("RTCStats unsupported browser.")
                            }({
                                statsEntry: this.sendStatsEntry.bind(this)
                            }, {
                                pollInterval: n,
                                useLegacy: t,
                                sendSdp: i,
                                eventCallback: e => this.events.emit(ti, e)
                            }), this._initialized = !0)
                        }
                        start(e) {
                            const {
                                options: {
                                    config: t = {},
                                    name: n = ""
                                } = {},
                                _statsCurrentId: i = ""
                            } = e, {
                                analytics: {
                                    rtcstatsEnabled: r = !1,
                                    rtcstatsEndpoint: o = "",
                                    rtcstatsUseLegacy: s = !1
                                } = {}
                            } = t;
                            this.reset(), r && (this._initialized ? (e.once(ce, (() => {
                                var r;
                                const a = {
                                        endpoint: o,
                                        meetingFqn: n,
                                        onCloseCallback: e => this.events.emit(ei, e),
                                        useLegacy: s
                                    },
                                    d = Boolean(null === (r = e.getBreakoutRooms()) || void 0 === r ? void 0 : r.isBreakoutRoom()),
                                    c = e.myUserId(),
                                    l = e.getMeetingUniqueId();
                                this._trace = Qn(a), this._trace.connect(d);
                                const h = {
                                    ...t,
                                    endpointId: c,
                                    confName: n,
                                    displayName: i,
                                    meetingUniqueId: l,
                                    isBreakoutRoom: d
                                };
                                this.sendIdentity(h)
                            })), e.once(he, (e => {
                                this.sendIdentity({
                                    meetingUniqueId: e
                                })
                            })), e.once(le, (() => {
                                this.reset()
                            }))) : oi.error("Calling start before RTCStats proxy module is initialized."))
                        }
                        sendIdentity(e) {
                            var t;
                            null === (t = this._trace) || void 0 === t || t.identity("identity", null, e)
                        }
                        reset() {
                            var e;
                            null === (e = this._trace) || void 0 === e || e.close(), this._trace = null
                        }
                        sendStatsEntry(e, t, n) {
                            var i;
                            null === (i = this._trace) || void 0 === i || i.statsEntry(e, t, n)
                        }
                    };
                n(478);
                class ai extends ni {
                    constructor() {
                        var e, t;
                        super(...arguments), t = {}, (e = "_storage") in this ? Object.defineProperty(this, e, {
                            value: t,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : this[e] = t
                    }
                    clear() {
                        this._storage = {}
                    }
                    get length() {
                        return Object.keys(this._storage).length
                    }
                    getItem(e) {
                        return this._storage[e]
                    }
                    setItem(e, t) {
                        this._storage[e] = t
                    }
                    removeItem(e) {
                        delete this._storage[e]
                    }
                    key(e) {
                        const t = Object.keys(this._storage);
                        if (!(t.length <= e)) return t[e]
                    }
                    serialize() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        if (0 === e.length) return JSON.stringify(this._storage);
                        const t = {
                            ...this._storage
                        };
                        return e.forEach((e => {
                            delete t[e]
                        })), JSON.stringify(t)
                    }
                }
                const di = new class extends ni {
                        constructor() {
                            super();
                            try {
                                this._storage = window.localStorage, this._localStorageDisabled = !1
                            } catch (e) {}
                            this._storage || (console.warn("Local storage is disabled."), this._storage = new ai, this._localStorageDisabled = !0)
                        }
                        isLocalStorageDisabled() {
                            return this._localStorageDisabled
                        }
                        setLocalStorageDisabled(e) {
                            this._localStorageDisabled = e;
                            try {
                                this._storage = e ? new ai : window.localStorage
                            } catch (e) {}
                            this._storage || (this._storage = new ai)
                        }
                        clear() {
                            this._storage.clear(), this.emit("changed")
                        }
                        get length() {
                            return this._storage.length
                        }
                        getItem(e) {
                            return this._storage.getItem(e)
                        }
                        setItem(e, t) {
                            let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                            this._storage.setItem(e, t), n || this.emit("changed")
                        }
                        removeItem(e) {
                            this._storage.removeItem(e), this.emit("changed")
                        }
                        key(e) {
                            return this._storage.key(e)
                        }
                        serialize() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                            if (this.isLocalStorageDisabled()) return this._storage.serialize(e);
                            const t = this._storage.length,
                                n = {};
                            for (let i = 0; i < t; i++) {
                                const t = this._storage.key(i);
                                e.includes(t) || (n[t] = this._storage.getItem(t))
                            }
                            return JSON.stringify(n)
                        }
                    },
                    ci = new class extends In {
                        doesVideoMuteByStreamRemove() {
                            return this.isChromiumBased() || this.isWebKitBased() || this.isFirefox()
                        }
                        isAndroidBrowser() {
                            return !this.isReactNative() && "Android" === this.getOS()
                        }
                        isIosBrowser() {
                            return !this.isReactNative() && "iOS" === this.getOS()
                        }
                        isMobileDevice() {
                            return this.isAndroidBrowser() || this.isIosBrowser() || this.isReactNative()
                        }
                        isTwa() {
                            return "matchMedia" in window && window.matchMedia("(display-mode:standalone)").matches
                        }
                        isSupported() {
                            return !(this.isSafari() && this._getSafariVersion() < 14) && (this.isChromiumBased() && this.isEngineVersionGreaterThan(71) || this.isFirefox() && this.isVersionGreaterThan(90) || this.isReactNative() || this.isWebKitBased())
                        }
                        isSupportedAndroidBrowser() {
                            return this.isChromiumBased() || this.isFirefox()
                        }
                        isSupportedIOSBrowser() {
                            return this._getSafariVersion() >= 14 || this._getIOSVersion() >= 14
                        }
                        isUserInteractionRequiredForUnmute() {
                            return this.isFirefox() && this.isVersionLessThan("68")
                        }
                        supportsVideoMuteOnConnInterrupted() {
                            return this.isChromiumBased() || this.isReactNative()
                        }
                        supportsBandwidthStatistics() {
                            return !this.isFirefox() && !this.isWebKitBased()
                        }
                        supportsCodecPreferences() {
                            return Boolean(window.RTCRtpTransceiver && "setCodecPreferences" in window.RTCRtpTransceiver.prototype && window.RTCRtpReceiver && void 0 !== window.RTCRtpReceiver.getCapabilities) && !this.isWebKitBased()
                        }
                        supportsDDExtHeaders() {
                            return !this.isFirefox()
                        }
                        supportsDeviceChangeEvent() {
                            return navigator.mediaDevices && void 0 !== navigator.mediaDevices.ondevicechange && void 0 !== navigator.mediaDevices.addEventListener
                        }
                        supportsPerformanceObserver() {
                            return void 0 !== window.PerformanceObserver && PerformanceObserver.supportedEntryTypes.indexOf("longtask") > -1
                        }
                        supportsReceiverStats() {
                            return void 0 !== window.RTCRtpReceiver && Object.keys(RTCRtpReceiver.prototype).indexOf("getSynchronizationSources") > -1
                        }
                        supportsRTTStatistics() {
                            return !this.isFirefox()
                        }
                        supportsScalabilityModeAPI() {
                            return this.isChromiumBased() && this.isEngineVersionGreaterThan(112)
                        }
                        supportsTrackBasedStats() {
                            return this.isChromiumBased() && this.isEngineVersionLessThan(112)
                        }
                        supportsVP9() {
                            return this.isChromiumBased() || this.isReactNative()
                        }
                        usesSdpMungingForSimulcast() {
                            return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased()
                        }
                        usesRidsForSimulcast() {
                            return !1
                        }
                        supportsGetDisplayMedia() {
                            return void 0 !== navigator.getDisplayMedia || void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getDisplayMedia
                        }
                        supportsEncodedTransform() {
                            return Boolean(window.RTCRtpScriptTransform)
                        }
                        supportsInsertableStreams() {
                            if (void 0 === window.RTCRtpSender || !window.RTCRtpSender.prototype.createEncodedStreams) return !1;
                            const e = new ReadableStream;
                            try {
                                return window.postMessage(e, "*", [e]), !0
                            } catch {
                                return !1
                            }
                        }
                        supportsAudioRed() {
                            return Boolean(window.RTCRtpSender && window.RTCRtpSender.getCapabilities && window.RTCRtpSender.getCapabilities("audio").codecs.some((e => "audio/red" === e.mimeType)) && window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("audio").codecs.some((e => "audio/red" === e.mimeType)))
                        }
                        supportsVADDetection() {
                            return this.isChromiumBased()
                        }
                        supportsRTX() {
                            return !(this.isFirefox() && this.isVersionLessThan("96"))
                        }
                        _getSafariVersion() {
                            return this.isSafari() ? Number.parseInt(this.getVersion(), 10) : -1
                        }
                        _getIOSVersion() {
                            return this.isWebKitBased() ? Number.parseInt(this.getOSVersion(), 10) : -1
                        }
                    };
                var li = n(803),
                    hi = n.n(li);
                const ui = S().getLogger("modules/watchRTC/WatchRTC.ts"),
                    pi = new class {
                        init(e) {
                            if (function(e) {
                                    var t;
                                    const {
                                        analytics: n
                                    } = e;
                                    return null !== (t = null == n ? void 0 : n.watchRTCEnabled) && void 0 !== t && t
                                }(e)) {
                                if (! function(e) {
                                        const {
                                            analytics: t,
                                            disableThirdPartyRequests: n
                                        } = e;
                                        return !(null != t && t.disabled || n)
                                    }(e)) return void ui.error("Cannot initialize WatchRTC when analytics or third party requests are disabled.");
                                try {
                                    var t;
                                    null != e && null !== (t = e.watchRTCConfigParams) && void 0 !== t && t.rtcApiKey ? (hi().init({
                                        rtcApiKey: e.watchRTCConfigParams.rtcApiKey
                                    }), this.options = e.watchRTCConfigParams, ui.info("WatchRTC initialized.")) : ui.error("WatchRTC is enabled but missing API key.")
                                } catch (e) {
                                    ui.error("Failed to initialize WatchRTC: ", e)
                                }
                            }
                        }
                        start(e, t) {
                            try {
                                this.options && (this.options.rtcRoomId = this.options.rtcRoomId ? this.options.rtcRoomId : e, this.options.rtcPeerId = this.options.rtcPeerId ? this.options.rtcPeerId : t, hi().persistentEnd(), hi().setConfig(this.options), ui.info("WatchRTC setConfig."))
                            } catch (e) {
                                ui.error("Failed to start WatchRTC session: ", e)
                            }
                        }
                    },
                    mi = (0, E.getLogger)("modules/statistics/AnalyticsAdapter.js"),
                    gi = new class {
                        constructor() {
                            this.reset()
                        }
                        reset() {
                            this.disposed = !1, this.analyticsHandlers = new Set, this.cache = [], this.permanentProperties = {}, this.conferenceName = "", this.addPermanentProperties({
                                user_agent: navigator.userAgent,
                                browser_name: ci.getName()
                            })
                        }
                        dispose() {
                            mi.debug("Disposing of analytics adapter."), this.analyticsHandlers && this.analyticsHandlers.size > 0 && this.analyticsHandlers.forEach((e => {
                                "function" == typeof e.dispose && e.dispose()
                            })), this.setAnalyticsHandlers([]), this.disposed = !0
                        }
                        setAnalyticsHandlers(e) {
                            if (this.disposed) return;
                            this.analyticsHandlers = new Set(e), this._setUserProperties();
                            const t = this.cache;
                            this.cache = null, t && t.forEach((e => this._sendEvent(e)))
                        }
                        _setUserProperties() {
                            this.analyticsHandlers.forEach((e => {
                                try {
                                    e.setUserProperties(this.permanentProperties)
                                } catch (e) {
                                    mi.warn(`Error in setUserProperties method of one of the analytics handlers: ${e}`)
                                }
                            }))
                        }
                        addPermanentProperties(e) {
                            this.permanentProperties = {
                                ...this.permanentProperties,
                                ...e
                            }, this._setUserProperties()
                        }
                        setConferenceName(e) {
                            this.conferenceName = e, this.addPermanentProperties({
                                conference_name: e
                            })
                        }
                        sendEvent(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            if (this.disposed) return;
                            let n = null;
                            "string" == typeof e ? n = {
                                type: kt,
                                action: e,
                                actionSubject: e,
                                source: e,
                                attributes: t
                            } : "object" == typeof e && (n = e), this._verifyRequiredFields(n) ? this._sendEvent(n) : mi.error(`Dropping a mis-formatted event: ${JSON.stringify(n)}`)
                        }
                        _verifyRequiredFields(e) {
                            if (!e) return !1;
                            e.type || (e.type = kt);
                            const t = e.type;
                            return t !== kt && t !== Mt && t !== Ft && t !== Lt ? (mi.error(`Unknown event type: ${t}`), !1) : t === Mt ? Boolean(e.name) : (e.action = e.action || e.name || e.actionSubject, e.actionSubject = e.actionSubject || e.name || e.action, e.source = e.source || e.name || e.action || e.actionSubject, e.action && e.actionSubject && e.source ? !!(t !== Lt || (e.objectType = e.objectType || "generic-object-type", e.containerType = e.containerType || "conference", "conference" !== e.containerType || e.containerId || (e.containerId = this.conferenceName), e.objectType && e.objectId && e.containerType && e.containerId)) || (mi.error("Required field missing (containerId, containerType, objectId or objectType)"), !1) : (mi.error("Required field missing (action, actionSubject or source)"), !1))
                        }
                        _maybeCacheEvent(e) {
                            return !!this.cache && (this.cache.push(e), this.cache.length > 100 && this.cache.splice(0, 1), !0)
                        }
                        _sendEvent(e) {
                            this._maybeCacheEvent(e) || this.analyticsHandlers.forEach((t => {
                                try {
                                    t.sendEvent(e)
                                } catch (e) {
                                    mi.warn(`Error sending analytics event: ${e}`)
                                }
                            }))
                        }
                    },
                    fi = n(810).getLogger("modules/statistics/LocalStatsCollector.js");
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                let vi = null;

                function _i(e, t, n) {
                    this.stream = e, this.intervalId = null, this.intervalMilis = t, this.audioLevel = 0, this.callback = n, this.source = null, this.analyser = null
                }

                function yi(e) {
                    let t = e;
                    return e >= Number.MAX_SAFE_INTEGER && (t = 0), t + 1
                }

                function Ei(e) {
                    return e.length > 0 ? e.reduce(((e, t) => e + t)) / e.length : 0
                }

                function Si(e) {
                    return e.filter((e => e >= 0))
                }
                _i.prototype.start = function() {
                    _i.isLocalStatsSupported() && (vi.resume(), this.analyser = vi.createAnalyser(), this.analyser.smoothingTimeConstant = .8, this.analyser.fftSize = 2048, this.source = vi.createMediaStreamSource(this.stream), this.source.connect(this.analyser), this.intervalId = setInterval((() => {
                        const e = new Uint8Array(this.analyser.frequencyBinCount);
                        this.analyser.getByteTimeDomainData(e);
                        const t = function(e) {
                            let t = 0;
                            const n = e.length;
                            for (let i = 0; i < n; i++) t < e[i] && (t = e[i]);
                            return parseFloat(((t - 127) / 128).toFixed(3))
                        }(e);
                        this.audioLevel = function(e, t) {
                            let n = 0;
                            const i = t - e;
                            return n = i > .2 ? t - .2 : i < -.4 ? t + .4 : e, parseFloat(n.toFixed(3))
                        }(t, this.audioLevel), this.callback(this.audioLevel)
                    }), this.intervalMilis))
                }, _i.prototype.stop = function() {
                    var e, t;
                    this.intervalId && (clearInterval(this.intervalId), this.intervalId = null), null === (e = this.analyser) || void 0 === e || e.disconnect(), this.analyser = null, null === (t = this.source) || void 0 === t || t.disconnect(), this.source = null
                }, _i.isLocalStatsSupported = function() {
                    var e;
                    return Boolean(null === (e = window) || void 0 === e ? void 0 : e.AudioContext)
                }, _i.disconnectAudioContext = async function() {
                    vi && (fi.info("Disconnecting audio context"), await vi.close(), vi = null)
                }, _i.connectAudioContext = function() {
                    _i.isLocalStatsSupported() && (fi.info("Connecting audio context"), vi = new AudioContext, vi.suspend())
                }, _i.connectAudioContext();
                class bi {
                    constructor() {
                        this.average = 0, this.n = 0
                    }
                    addNext(e) {
                        "number" == typeof e && (this.n += 1, this.average = this.average + (e - this.average) / this.n)
                    }
                    getAverage() {
                        return this.average
                    }
                }

                function Ti(e, t) {
                    return isNaN(e) || isNaN(t) ? 0 : e - t
                }
                const Ci = (0, E.getLogger)("modules/statistics/PerformanceObserverStats.js");
                class xi {
                    constructor(e, t) {
                        this.eventEmitter = e, this.longTasks = 0, this.maxDuration = 0, this.performanceStatsInterval = t, this.stats = new bi
                    }
                    getLongTasksStats() {
                        return {
                            avgRatePerMinute: (60 * this.stats.getAverage()).toFixed(2),
                            maxDurationMs: this.maxDuration
                        }
                    }
                    startObserver() {
                        this.longTaskEventHandler = e => {
                            const t = e.getEntries();
                            for (const e of t) this.longTasks++, this.maxDuration = Math.max(this.maxDuration, e.duration).toFixed(3)
                        }, Ci.info("Creating a Performance Observer for monitoring Long Tasks"), this.observer = new PerformanceObserver(this.longTaskEventHandler), this.observer.observe({
                            type: "longtask",
                            buffered: !0
                        });
                        const e = Date.now();
                        this.longTasksIntervalId = setInterval((() => {
                            const t = Date.now(),
                                n = this._lastTimeStamp ? (t - this._lastTimeStamp) / 1e3 : (t - e) / 1e3,
                                i = this.longTasks / n;
                            this.stats.addNext(i), this.eventEmitter.emit(vn, this.getLongTasksStats()), this.longTasks = 0, this._lastTimeStamp = Date.now()
                        }), this.performanceStatsInterval)
                    }
                    stopObserver() {
                        this.observer && this.observer.disconnect(), this.longTaskEventHandler = null, this.longTasksIntervalId && (clearInterval(this.longTasksIntervalId), this.longTasksIntervalId = null)
                    }
                }
                let Ri;
                ! function(e) {
                    e.AUDIO = "audio", e.VIDEO = "video"
                }(Ri || (Ri = {}));
                const Ai = new class {
                        init(e) {
                            var t, n;
                            this._runInLiteMode = Boolean(e.runInLiteMode), this._ssrcRewriting = null === (t = e.ssrcRewritingEnabled) || void 0 === t || t, this._joinAsVisitor = Boolean(null === (n = e.enableJoinAsVisitor) || void 0 === n || n)
                        }
                        isRunInLiteModeEnabled() {
                            return this._runInLiteMode && ci.supportsInsertableStreams()
                        }
                        isSsrcRewritingSupported() {
                            return this._ssrcRewriting
                        }
                        isJoinAsVisitorSupported() {
                            return this._joinAsVisitor
                        }
                    },
                    wi = (0, E.getLogger)("modules/statistics/RTPStatsCollector.js");

                function Ii(e, t) {
                    return e > 0 && t > 0 ? Math.round(e / t * 100) : 0
                }

                function Pi() {
                    this.loss = {}, this.bitrate = {
                        download: 0,
                        upload: 0
                    }, this.resolution = {}, this.framerate = 0, this.codec = ""
                }

                function Di() {
                    this.bandwidth = {}, this.bitrate = {}, this.packetLoss = null, this.transport = []
                }

                function Oi(e, t, n, i) {
                    this.peerconnection = e, this.currentStatsReport = null, this.previousStatsReport = null, this.audioLevelReportHistory = {}, this.audioLevelsIntervalId = null, this.eventEmitter = i, this.conferenceStats = new Di, this.audioLevelsIntervalMilis = t, this.speakerList = [], this.statsIntervalId = null, this.statsIntervalMilis = n, this.ssrc2stats = new Map
                }
                Pi.prototype.setLoss = function(e) {
                    this.loss = e || {}
                }, Pi.prototype.setResolution = function(e) {
                    this.resolution = e || {}
                }, Pi.prototype.addBitrate = function(e) {
                    this.bitrate.download += e.download, this.bitrate.upload += e.upload
                }, Pi.prototype.resetBitrate = function() {
                    this.bitrate.download = 0, this.bitrate.upload = 0
                }, Pi.prototype.setFramerate = function(e) {
                    this.framerate = e || 0
                }, Pi.prototype.setCodec = function(e) {
                    this.codec = e || ""
                }, Oi.prototype.setSpeakerList = function(e) {
                    this.speakerList = e
                }, Oi.prototype.stop = function() {
                    this.audioLevelsIntervalId && (clearInterval(this.audioLevelsIntervalId), this.audioLevelsIntervalId = null), this.statsIntervalId && (clearInterval(this.statsIntervalId), this.statsIntervalId = null)
                }, Oi.prototype.errorCallback = function(e) {
                    wi.error("Get stats error", e), this.stop()
                }, Oi.prototype.start = function(e) {
                    e && ci.supportsReceiverStats() && (this.audioLevelsIntervalId = setInterval((() => {
                        const e = this.peerconnection.getAudioLevels(this.speakerList);
                        for (const t in e)
                            if (e.hasOwnProperty(t)) {
                                const n = 2.5 * e[t];
                                this.eventEmitter.emit(pn, this.peerconnection, Number.parseInt(t, 10), n, !1)
                            }
                    }), this.audioLevelsIntervalMilis));
                    const t = () => {
                        this.peerconnection.getStats().then((e => {
                            this.currentStatsReport = "function" == typeof(null == e ? void 0 : e.result) ? e.result() : e;
                            try {
                                this.processStatsReport()
                            } catch (e) {
                                wi.error("Processing of RTP stats failed:", e)
                            }
                            this.previousStatsReport = this.currentStatsReport
                        })).catch((e => this.errorCallback(e)))
                    };
                    t(), this.statsIntervalId = setInterval(t, this.statsIntervalMilis)
                }, Oi.prototype._processAndEmitReport = function() {
                    const e = {
                            download: 0,
                            upload: 0
                        },
                        t = {
                            download: 0,
                            upload: 0
                        };
                    let n = 0,
                        i = 0;
                    const r = {},
                        o = {},
                        s = {};
                    let a = 0,
                        d = 0,
                        c = 0,
                        l = 0;
                    for (const [p, m] of this.ssrc2stats) {
                        var h;
                        const g = m.loss,
                            f = g.isDownloadStream ? "download" : "upload";
                        e[f] += g.packetsTotal, t[f] += g.packetsLost;
                        const v = m.bitrate.download,
                            _ = m.bitrate.upload;
                        n += v, i += _, m.resetBitrate();
                        const y = this.peerconnection.getTrackBySSRC(p);
                        if (!y) continue;
                        let E, S;
                        y.isAudioTrack() ? (a += v, d += _, E = m.codec) : (c += v, l += _, S = m.codec);
                        const b = y.getParticipantId();
                        if (!b) {
                            Ai.isSsrcRewritingSupported() || wi.error(`No participant ID returned by ${y}`);
                            continue
                        }
                        const T = null !== (h = s[b]) && void 0 !== h ? h : {};
                        T[p] = {
                            audio: E,
                            video: S
                        }, s[b] = T;
                        const {
                            resolution: C
                        } = m;
                        if (!y.isVideoTrack() || isNaN(null == C ? void 0 : C.height) || isNaN(null == C ? void 0 : C.width) || -1 === C.height || -1 === C.width) continue;
                        const x = r[b] || {};
                        if (y.isLocal() && !ci.supportsTrackBasedStats() && this.peerconnection.doesTrueSimulcast()) {
                            const e = this.peerconnection.getLocalVideoSSRCs(y);
                            for (const t of e) {
                                var u;
                                const e = null === (u = this.ssrc2stats.get(t)) || void 0 === u ? void 0 : u.resolution;
                                null != e && e.height && null != e && e.width && (C.height = Math.max(C.height, e.height), C.width = Math.max(C.width, e.width))
                            }
                        }
                        if (x[p] = C, r[b] = x, m.framerate > 0) {
                            const e = o[b] || {};
                            e[p] = m.framerate, o[b] = e
                        }
                    }
                    this.conferenceStats.bitrate = {
                        upload: i,
                        download: n
                    }, this.conferenceStats.bitrate.audio = {
                        upload: d,
                        download: a
                    }, this.conferenceStats.bitrate.video = {
                        upload: l,
                        download: c
                    }, this.conferenceStats.packetLoss = {
                        total: Ii(t.download + t.upload, e.download + e.upload),
                        download: Ii(t.download, e.download),
                        upload: Ii(t.upload, e.upload)
                    };
                    const p = {};
                    let m;
                    Object.keys(this.audioLevelReportHistory).forEach((e => {
                        const {
                            data: t,
                            isLocal: n
                        } = this.audioLevelReportHistory[e], i = t.reduce(((e, t) => e + t)) / t.length;
                        if (n) m = i;
                        else {
                            const t = this.peerconnection.getTrackBySSRC(Number(e));
                            if (t) {
                                const e = t.getParticipantId();
                                e && (p[e] = i)
                            }
                        }
                    })), this.audioLevelReportHistory = {}, this.eventEmitter.emit(fn, this.peerconnection, {
                        bandwidth: this.conferenceStats.bandwidth,
                        bitrate: this.conferenceStats.bitrate,
                        packetLoss: this.conferenceStats.packetLoss,
                        resolution: r,
                        framerate: o,
                        codec: s,
                        transport: this.conferenceStats.transport,
                        localAvgAudioLevels: m,
                        avgAudioLevels: p
                    }), this.conferenceStats.transport = []
                }, Oi.prototype.getNonNegativeValue = function(e) {
                    let t = e;
                    return "number" != typeof t && (t = Number(t)), isNaN(t) ? 0 : Math.max(0, t)
                }, Oi.prototype._calculateBitrate = function(e, t, n) {
                    const i = this.getNonNegativeValue(e[n]),
                        r = this.getNonNegativeValue(t[n]),
                        o = Math.max(0, i - r),
                        s = e.timestamp - t.timestamp;
                    let a = 0;
                    return s > 0 && (a = Math.round(8 * o / s)), a
                }, Oi.prototype._calculateFps = function(e, t, n) {
                    const i = e.timestamp - t.timestamp;
                    let r = 0;
                    return i > 0 && e[n] && (r = (e[n] - t[n]) / i * 1e3), r
                }, Oi.prototype.processStatsReport = function() {
                    const e = {};
                    this.currentStatsReport.forEach((t => {
                        const n = this.previousStatsReport ? this.previousStatsReport.get(t.id) : null;
                        if ("candidate-pair" === t.type && t.nominated && "succeeded" === t.state) {
                            const e = t.availableIncomingBitrate,
                                n = t.availableOutgoingBitrate;
                            (e || n) && (this.conferenceStats.bandwidth = {
                                download: Math.round(e / 1e3),
                                upload: Math.round(n / 1e3)
                            });
                            const i = this.currentStatsReport.get(t.remoteCandidateId),
                                r = this.currentStatsReport.get(t.localCandidateId);
                            if (i && r) {
                                const e = `${ci.isChromiumBased()?i.ip:i.address}:${i.port}`,
                                    n = `${ci.isChromiumBased()?r.ip:r.address}:${r.port}`,
                                    o = i.protocol,
                                    s = this.conferenceStats.transport;
                                s.some((t => t.ip === e && t.type === o && t.localip === n)) || s.push({
                                    ip: e,
                                    type: o,
                                    localip: n,
                                    p2p: this.peerconnection.isP2P,
                                    localCandidateType: r.candidateType,
                                    remoteCandidateType: i.candidateType,
                                    networkType: r.networkType,
                                    rtt: 1e3 * t.currentRoundTripTime
                                })
                            }
                        } else if ("inbound-rtp" === t.type || "outbound-rtp" === t.type) {
                            const r = this.getNonNegativeValue(t.ssrc);
                            if (!r) return;
                            let o = this.ssrc2stats.get(r);
                            o || (o = new Pi, this.ssrc2stats.set(r, o));
                            let s = !0,
                                a = "packetsReceived";
                            "outbound-rtp" === t.type && (s = !1, a = "packetsSent");
                            let d, c = t[a];
                            if ((!c || c < 0) && (c = 0), n) {
                                const e = this.getNonNegativeValue(n[a]),
                                    i = Math.max(0, c - e),
                                    r = this.getNonNegativeValue(t.packetsLost),
                                    d = this.getNonNegativeValue(n.packetsLost),
                                    l = Math.max(0, r - d);
                                o.setLoss({
                                    packetsTotal: i + l,
                                    packetsLost: l,
                                    isDownloadStream: s
                                })
                            }
                            if (void 0 !== t.frameHeight && void 0 !== t.frameWidth) {
                                var i;
                                const e = null === (i = t.active) || void 0 === i || i;
                                ("inbound-rtp" === t.type || !ci.supportsTrackBasedStats() && e) && (d = {
                                    height: t.frameHeight,
                                    width: t.frameWidth
                                })
                            }
                            o.setResolution(d);
                            let l = t.framesPerSecond;
                            !l && n && (l = this._calculateFps(t, n, "framesSent")), o.setFramerate(Math.round(l || 0)), "inbound-rtp" === t.type && n ? o.addBitrate({
                                download: this._calculateBitrate(t, n, "bytesReceived"),
                                upload: 0
                            }) : n && (e[r] = this.getNonNegativeValue(t.bytesSent), o.addBitrate({
                                download: 0,
                                upload: this._calculateBitrate(t, n, "bytesSent")
                            }));
                            const h = this.currentStatsReport.get(t.codecId);
                            if (h) {
                                const e = h.mimeType.split("/")[1];
                                e && o.setCodec(e)
                            }
                        } else if (ci.supportsTrackBasedStats() && "track" === t.type && t.kind === Ri.VIDEO && !t.remoteSource) {
                            const e = {
                                    height: t.frameHeight,
                                    width: t.frameWidth
                                },
                                i = this.peerconnection.getLocalTracks(Ri.VIDEO);
                            if (null == i || !i.length) return;
                            const r = this.peerconnection.getSsrcByTrackId(t.trackIdentifier);
                            if (!r) return;
                            let o = this.ssrc2stats.get(r);
                            o || (o = new Pi, this.ssrc2stats.set(r, o)), e.height && e.width && o.setResolution(e);
                            let s = t.framesPerSecond;
                            !s && n && (s = this._calculateFps(t, n, "framesSent")), o.setFramerate(s)
                        }
                    })), Object.keys(e).length && this.eventEmitter.emit(gn, this.peerconnection, e), this._processAndEmitReport()
                };
                const Ni = n(810).getLogger("modules/statistics/statistics.js");
                let ki;

                function Mi(e, t) {
                    this.rtpStatsMap = new Map, this.eventEmitter = new ii, this.conference = e, this.xmpp = null == e ? void 0 : e.xmpp, this.options = t || {}, Mi.instances.add(this), si.start(this.conference), ci.isReactNative() || pi.start(this.options.roomName, this.options.userName)
                }
                Mi.init = function(e) {
                    Mi.audioLevelsEnabled = !e.disableAudioLevels, "number" == typeof e.pcStatsInterval && (Mi.pcStatsInterval = e.pcStatsInterval), "number" == typeof e.audioLevelsInterval && (Mi.audioLevelsInterval = e.audioLevelsInterval), "number" == typeof e.longTasksStatsInterval && (Mi.longTasksStatsInterval = e.longTasksStatsInterval), Mi.disableThirdPartyRequests = e.disableThirdPartyRequests, ci.isReactNative() ? Ni.warn("Cannot initialize WatchRTC in a react native environment!") : pi.init(e), si.init(e)
                }, Mi.audioLevelsEnabled = !1, Mi.audioLevelsInterval = 200, Mi.pcStatsInterval = 1e4, Mi.disableThirdPartyRequests = !1, Mi.analytics = gi, Object.defineProperty(Mi, "instances", {
                    get: () => (ki || (ki = new Set), ki)
                }), Mi.prototype.startRemoteStats = function(e) {
                    this.stopRemoteStats(e);
                    try {
                        const t = new Oi(e, Mi.audioLevelsInterval, Mi.pcStatsInterval, this.eventEmitter);
                        t.start(Mi.audioLevelsEnabled), this.rtpStatsMap.set(e.id, t)
                    } catch (e) {
                        Ni.error(`Failed to start collecting remote statistics: ${e}`)
                    }
                }, Mi.localStats = [], Mi.startLocalStats = function(e, t) {
                    if (ci.isIosBrowser() && e.addEventListener(bt.NO_DATA_FROM_SOURCE, (async e => {
                            if (e) {
                                for (const e of Mi.localStats) e.stop();
                                await _i.disconnectAudioContext()
                            } else {
                                _i.connectAudioContext();
                                for (const e of Mi.localStats) e.start()
                            }
                        })), !Mi.audioLevelsEnabled) return;
                    e.addEventListener(bt.LOCAL_TRACK_STOPPED, (() => {
                        Mi.stopLocalStats(e)
                    }));
                    const n = new _i(e.getOriginalStream(), Mi.audioLevelsInterval, t);
                    this.localStats.push(n), n.start()
                }, Mi.prototype.addAudioLevelListener = function(e) {
                    Mi.audioLevelsEnabled && this.eventEmitter.on(pn, e)
                }, Mi.prototype.removeAudioLevelListener = function(e) {
                    Mi.audioLevelsEnabled && this.eventEmitter.removeListener(pn, e)
                }, Mi.prototype.addBeforeDisposedListener = function(e) {
                    this.eventEmitter.on(mn, e)
                }, Mi.prototype.removeBeforeDisposedListener = function(e) {
                    this.eventEmitter.removeListener(mn, e)
                }, Mi.prototype.addConnectionStatsListener = function(e) {
                    this.eventEmitter.on(fn, e)
                }, Mi.prototype.removeConnectionStatsListener = function(e) {
                    this.eventEmitter.removeListener(fn, e)
                }, Mi.prototype.addByteSentStatsListener = function(e) {
                    this.eventEmitter.on(gn, e)
                }, Mi.prototype.removeByteSentStatsListener = function(e) {
                    this.eventEmitter.removeListener(gn, e)
                }, Mi.prototype.addLongTasksStatsListener = function(e) {
                    this.eventEmitter.on(vn, e)
                }, Mi.prototype.attachLongTasksStats = function() {
                    ci.supportsPerformanceObserver() ? (this.performanceObserverStats = new xi(this.eventEmitter, Mi.longTasksStatsInterval), this.conference.on(ce, (() => this.performanceObserverStats.startObserver())), this.conference.on(le, (() => this.performanceObserverStats.stopObserver()))) : Ni.warn("Performance observer for long tasks not supported by browser!")
                }, Mi.prototype.getLongTasksStats = function() {
                    return this.performanceObserverStats ? this.performanceObserverStats.getLongTasksStats() : null
                }, Mi.prototype.removeLongTasksStatsListener = function(e) {
                    this.eventEmitter.removeListener(vn, e)
                }, Mi.prototype.setSpeakerList = function(e) {
                    for (const t of Array.from(this.rtpStatsMap.values())) t.peerconnection.isP2P || t.setSpeakerList(e)
                }, Mi.prototype.dispose = function() {
                    try {
                        this.eventEmitter.emit(mn);
                        for (const e of this.rtpStatsMap.keys()) this._stopRemoteStats(e);
                        this.eventEmitter && this.eventEmitter.removeAllListeners()
                    } finally {
                        Mi.instances.delete(this)
                    }
                }, Mi.stopLocalStats = function(e) {
                    if (!Mi.audioLevelsEnabled) return;
                    const t = e.getOriginalStream();
                    for (let e = 0; e < Mi.localStats.length; e++)
                        if (Mi.localStats[e].stream === t) {
                            Mi.localStats.splice(e, 1)[0].stop();
                            break
                        }
                }, Mi.prototype._stopRemoteStats = function(e) {
                    const t = this.rtpStatsMap.get(e);
                    t && (t.stop(), this.rtpStatsMap.delete(e))
                }, Mi.prototype.stopRemoteStats = function(e) {
                    this._stopRemoteStats(e.id)
                }, Mi.prototype.sendFeedback = function(e, t) {
                    return Mi.analytics.sendEvent(Yt, {
                        rating: e,
                        comment: t
                    }), Promise.resolve()
                }, Mi.LOCAL_JID = n(680).D, Mi.sendAnalyticsAndLog = function(e) {
                    let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    e ? (t = "object" == typeof e ? e : {
                        name: e,
                        properties: n
                    }, Ni.log(JSON.stringify(t)), this.analytics.sendEvent(e, n)) : Ni.warn("No event or event name given.")
                }, Mi.sendAnalytics = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    this.analytics.sendEvent(e, t)
                };
                var Li = n(832),
                    Fi = n.n(Li),
                    ji = n(987),
                    Vi = n(514),
                    Ui = n.n(Vi),
                    Hi = n(609);
                const $i = (0, E.getLogger)("JitsiConferenceEventManager.js");

                function Ji(e) {
                    this.conference = e, this.xmppListeners = {}
                }
                Ji.prototype.setupChatRoomListeners = function() {
                    const e = this.conference,
                        t = e.room;
                    this.chatRoomForwarder = new(Fi())(t, this.conference.eventEmitter), t.addListener(Hi.XMPPEvents.ICE_RESTARTING, (t => {
                        t.isP2P || e.rtc.closeBridgeChannel()
                    })), t.addListener(Hi.XMPPEvents.PARTICIPANT_FEATURES_CHANGED, ((t, n) => {
                        const i = e.getParticipantById(St.Strophe.getResourceFromJid(t));
                        i && (i.setFeatures(n), e.eventEmitter.emit(Be, i))
                    })), t.addListener(Hi.XMPPEvents.ICE_RESTART_SUCCESS, ((t, n) => {
                        !t.isP2P && e._setBridgeChannel(n, t.peerconnection)
                    })), t.addListener(Hi.XMPPEvents.AUDIO_MUTED_BY_FOCUS, (t => {
                        Mi.sendAnalytics(ln(Ri.AUDIO)), e.mutedByFocusActor = t, e.rtc.setAudioMute(!0).then((() => {
                            e.isMutedByFocus = !0, e.mutedByFocusActor = null
                        })).catch((t => {
                            e.mutedByFocusActor = null, $i.warn("Error while audio muting due to focus request", t)
                        }))
                    })), t.addListener(Hi.XMPPEvents.VIDEO_MUTED_BY_FOCUS, (t => {
                        Mi.sendAnalytics(ln(Ri.VIDEO)), e.mutedVideoByFocusActor = t, e.rtc.setVideoMute(!0).then((() => {
                            e.isVideoMutedByFocus = !0, e.mutedVideoByFocusActor = null
                        })).catch((t => {
                            e.mutedVideoByFocusActor = null, $i.warn("Error while video muting due to focus request", t)
                        }))
                    })), this.chatRoomForwarder.forward(Hi.XMPPEvents.SUBJECT_CHANGED, Qe), this.chatRoomForwarder.forward(Hi.XMPPEvents.MUC_JOINED, ce), this.chatRoomForwarder.forward(Hi.XMPPEvents.MUC_JOIN_IN_PROGRESS, de), this.chatRoomForwarder.forward(Hi.XMPPEvents.MEETING_ID_SET, he), this.chatRoomForwarder.forward(Hi.XMPPEvents.CONFERENCE_TIMESTAMP_RECEIVED, oe), t.addListener(Hi.XMPPEvents.MUC_JOINED, (() => {
                        this.conference._onMucJoined(), this.conference.isJvbConnectionInterrupted = !1, Object.keys(t.connectionTimes).forEach((e => {
                            const n = sn(`conference_${e}`, {
                                value: t.connectionTimes[e]
                            });
                            Mi.sendAnalytics(n)
                        })), Object.keys(t.xmpp.connectionTimes).forEach((e => {
                            const n = sn(`xmpp_${e}`, {
                                value: t.xmpp.connectionTimes[e]
                            });
                            Mi.sendAnalytics(n)
                        }))
                    })), t.addListener(Hi.XMPPEvents.RENEGOTIATION_FAILED, ((t, n) => {
                        n.isP2P || e.eventEmitter.emit(ae, V, t)
                    })), t.addListener(Ot, (t => {
                        e.eventEmitter.emit(rt, t)
                    })), this.chatRoomForwarder.forward(Hi.XMPPEvents.ROOM_JOIN_ERROR, ae, w), this.chatRoomForwarder.forward(Hi.XMPPEvents.DISPLAY_NAME_REQUIRED, ae, N), this.chatRoomForwarder.forward(Hi.XMPPEvents.ROOM_CONNECT_ERROR, ae, w), this.chatRoomForwarder.forward(Hi.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR, ae, P), this.chatRoomForwarder.forward(Hi.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, ae, D), this.chatRoomForwarder.forward(Hi.XMPPEvents.ROOM_MAX_USERS_ERROR, ae, A), this.chatRoomForwarder.forward(Hi.XMPPEvents.PASSWORD_REQUIRED, ae, H), this.chatRoomForwarder.forward(Hi.XMPPEvents.AUTHENTICATION_REQUIRED, ae, T), this.chatRoomForwarder.forward(Hi.XMPPEvents.BRIDGE_DOWN, ae, J), t.addListener(Hi.XMPPEvents.BRIDGE_DOWN, (() => Mi.sendAnalytics({
                        action: "bridge.down",
                        actionSubject: "bridge.down",
                        type: kt
                    }))), t.addListener(Hi.XMPPEvents.CONNECTION_RESTARTED, (t => {
                        e._onConferenceRestarted(t)
                    })), this.chatRoomForwarder.forward(Hi.XMPPEvents.RESERVATION_ERROR, ae, $), this.chatRoomForwarder.forward(Hi.XMPPEvents.GRACEFUL_SHUTDOWN, ae, L), t.addListener(Hi.XMPPEvents.CONNECTION_ICE_FAILED, (t => {
                        e._onIceConnectionFailed(t)
                    })), this.chatRoomForwarder.forward(Hi.XMPPEvents.MUC_DESTROYED, ae, R), this.chatRoomForwarder.forward(Hi.XMPPEvents.CHAT_ERROR_RECEIVED, se, C), this.chatRoomForwarder.forward(Hi.XMPPEvents.SETTINGS_ERROR_RECEIVED, se, x), this.chatRoomForwarder.forward(Hi.XMPPEvents.FOCUS_DISCONNECTED, ae, k), t.addListener(Hi.XMPPEvents.FOCUS_LEFT, (() => {
                        Mi.sendAnalytics({
                            action: "focus.left",
                            actionSubject: "focus.left",
                            type: Nt.TYPE_OPERATIONAL
                        }), e.eventEmitter.emit(ae, M)
                    })), t.addListener(Hi.XMPPEvents.SESSION_ACCEPT_TIMEOUT, (e => {
                        Mi.sendAnalyticsAndLog(dn(Vt, {
                            p2p: e.isP2P
                        }))
                    })), t.addListener(Hi.XMPPEvents.RECORDER_STATE_CHANGED, ((t, n) => {
                        if (n) {
                            const i = St.Strophe.getResourceFromJid(n),
                                r = e.getParticipantById(i) || i;
                            "off" === t.getStatus() ? t.setTerminator(r) : "on" === t.getStatus() && t.setInitiator(r)
                        }
                        e.eventEmitter.emit(Ke, t)
                    })), this.chatRoomForwarder.forward(Hi.XMPPEvents.TRANSCRIPTION_STATUS_CHANGED, st), this.chatRoomForwarder.forward(Hi.XMPPEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED, ht), this.chatRoomForwarder.forward(Hi.XMPPEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED, ut), this.chatRoomForwarder.forward(Hi.XMPPEvents.PHONE_NUMBER_CHANGED, Ge), t.setParticipantPropertyListener(((t, n) => {
                        const i = e.getParticipantById(n);
                        i && i.setProperty(t.tagName.substring("jitsi_participant_".length), t.value)
                    })), t.addListener(Hi.XMPPEvents.KICKED, e.onMemberKicked.bind(e)), t.addListener(Hi.XMPPEvents.SUSPEND_DETECTED, e.onSuspendDetected.bind(e)), this.chatRoomForwarder.forward(Hi.XMPPEvents.MUC_LOCK_CHANGED, Ne), this.chatRoomForwarder.forward(Hi.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, ke), this.chatRoomForwarder.forward(Hi.XMPPEvents.MUC_VISITORS_SUPPORTED_CHANGED, mt), t.addListener(Hi.XMPPEvents.MUC_MEMBER_JOINED, e.onMemberJoined.bind(e)), this.chatRoomForwarder.forward(Hi.XMPPEvents.MUC_LOBBY_MEMBER_JOINED, Pe), this.chatRoomForwarder.forward(Hi.XMPPEvents.MUC_LOBBY_MEMBER_UPDATED, Oe), this.chatRoomForwarder.forward(Hi.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, De), t.addListener(Hi.XMPPEvents.MUC_MEMBER_BOT_TYPE_CHANGED, e._onMemberBotTypeChanged.bind(e)), t.addListener(Hi.XMPPEvents.MUC_MEMBER_LEFT, e.onMemberLeft.bind(e)), this.chatRoomForwarder.forward(Hi.XMPPEvents.MUC_LEFT, le), this.chatRoomForwarder.forward(Hi.XMPPEvents.MUC_DENIED_ACCESS, ae, O), t.addListener(Hi.XMPPEvents.DISPLAY_NAME_CHANGED, e.onDisplayNameChanged.bind(e)), t.addListener(Hi.XMPPEvents.LOCAL_ROLE_CHANGED, (t => {
                        e.onLocalRoleChanged(t)
                    })), t.addListener(Hi.XMPPEvents.MUC_ROLE_CHANGED, e.onUserRoleChanged.bind(e)), t.addListener(Ui().IDENTITY_UPDATED, ((t, n) => {
                        e.authEnabled = t, e.authIdentity = n, e.eventEmitter.emit(W, t, n)
                    })), t.addListener(Hi.XMPPEvents.MESSAGE_RECEIVED, ((t, n, i, r, o, s) => {
                        const a = St.Strophe.getResourceFromJid(t);
                        e.eventEmitter.emit(Me, a, n, r, o, s)
                    })), t.addListener(Hi.XMPPEvents.PRIVATE_MESSAGE_RECEIVED, ((t, n, i, r) => {
                        const o = St.Strophe.getResourceFromJid(t);
                        e.eventEmitter.emit(Je, o, n, r)
                    })), t.addListener(Hi.XMPPEvents.PRESENCE_STATUS, ((t, n) => {
                        const i = St.Strophe.getResourceFromJid(t),
                            r = e.getParticipantById(i);
                        r && r._status !== n && (r._status = n, e.eventEmitter.emit(lt, i, n))
                    })), t.addListener(Hi.XMPPEvents.JSON_MESSAGE_RECEIVED, ((t, n) => {
                        const i = St.Strophe.getResourceFromJid(t),
                            r = e.getParticipantById(i);
                        r ? e.eventEmitter.emit(Ce, r, n) : e.eventEmitter.emit(Ve, i, n)
                    })), t.addPresenceListener("startmuted", ((t, n) => {
                        if (e.myUserId() === n) return;
                        const i = e.getParticipantById(n);
                        if (!i || !i.isModerator()) return;
                        const r = "true" === t.attributes.audio,
                            o = "true" === t.attributes.video;
                        let s = !1;
                        r !== e.startMutedPolicy.audio && (e.startMutedPolicy.audio = r, s = !0), o !== e.startMutedPolicy.video && (e.startMutedPolicy.video = o, s = !0), s && e.eventEmitter.emit(Xe, e.startMutedPolicy)
                    })), this.chatRoomForwarder.forward(Hi.XMPPEvents.BREAKOUT_ROOMS_MOVE_TO_ROOM, ie), this.chatRoomForwarder.forward(Hi.XMPPEvents.BREAKOUT_ROOMS_UPDATED, re), this.chatRoomForwarder.forward(Hi.XMPPEvents.ROOM_METADATA_UPDATED, Le)
                }, Ji.prototype.setupRTCListeners = function() {
                    const e = this.conference,
                        t = e.rtc;
                    t.addListener(ji.default.REMOTE_TRACK_ADDED, e.onRemoteTrackAdded.bind(e)), t.addListener(ji.default.REMOTE_TRACK_REMOVED, e.onRemoteTrackRemoved.bind(e)), t.addListener(ji.default.DOMINANT_SPEAKER_CHANGED, ((t, n, i) => {
                        if ((e.lastDominantSpeaker !== t || e.dominantSpeakerIsSilent !== i) && e.room && (e.lastDominantSpeaker = t, e.dominantSpeakerIsSilent = i, e.eventEmitter.emit(ye, t, n, i), e.statistics && e.myUserId() === t && e.xmpp.sendDominantSpeakerEvent(e.room.roomjid, i), e.lastDominantSpeaker !== t && n && n.length)) {
                            const i = n.slice(0);
                            e.myUserId !== t && i.splice(0, 0, t), i.length > 5 && i.splice(5, i.length - 5), e.statistics && e.statistics.setSpeakerList(i)
                        }
                    })), t.addListener(ji.default.DATA_CHANNEL_OPEN, (() => {
                        const t = window.performance.now(),
                            n = "data.channel.opened";
                        $i.log(`(TIME) ${n}:\t`, t), e.room.connectionTimes[n] = t, Mi.sendAnalytics(sn(n, {
                            value: t
                        })), e.eventEmitter.emit(ve)
                    })), t.addListener(ji.default.DATA_CHANNEL_CLOSED, (t => {
                        e.eventEmitter.emit(fe, t)
                    })), t.addListener(ji.default.VIDEO_SSRCS_REMAPPED, (e => {
                        for (const t of this.conference.getMediaSessions()) t.processSourceMap(e, Ri.VIDEO)
                    })), t.addListener(ji.default.AUDIO_SSRCS_REMAPPED, (e => {
                        for (const t of this.conference.getMediaSessions()) t.processSourceMap(e, Ri.AUDIO)
                    })), t.addListener(ji.default.ENDPOINT_MESSAGE_RECEIVED, ((t, n) => {
                        const i = e.getParticipantById(t);
                        i ? e.eventEmitter.emit(Ce, i, n) : $i.warn(`Ignored ENDPOINT_MESSAGE_RECEIVED for not existing participant: ${t}`, n)
                    })), t.addListener(ji.default.ENDPOINT_STATS_RECEIVED, ((t, n) => {
                        const i = e.getParticipantById(t);
                        i ? e.eventEmitter.emit(xe, i, n) : $i.warn(`Ignoring ENDPOINT_STATS_RECEIVED for a non-existant participant: ${t}`)
                    })), t.addListener(ji.default.CREATE_ANSWER_FAILED, ((t, n) => {
                        n.isP2P || e.eventEmitter.emit(ae, V, t)
                    })), t.addListener(ji.default.CREATE_OFFER_FAILED, ((t, n) => {
                        n.isP2P || e.eventEmitter.emit(ae, V, t)
                    })), t.addListener(ji.default.SET_LOCAL_DESCRIPTION_FAILED, ((t, n) => {
                        n.isP2P || e.eventEmitter.emit(ae, V, t)
                    })), t.addListener(ji.default.SET_REMOTE_DESCRIPTION_FAILED, ((t, n) => {
                        n.isP2P || e.eventEmitter.emit(ae, V, t)
                    }))
                }, Ji.prototype.removeXMPPListeners = function() {
                    const e = this.conference;
                    Object.keys(this.xmppListeners).forEach((t => {
                        e.xmpp.removeListener(t, this.xmppListeners[t])
                    })), this.xmppListeners = {}
                }, Ji.prototype.setupXMPPListeners = function() {
                    const e = this.conference;
                    this._addConferenceXMPPListener(Hi.XMPPEvents.CALL_INCOMING, e.onIncomingCall.bind(e)), this._addConferenceXMPPListener(Hi.XMPPEvents.CALL_ACCEPTED, e.onCallAccepted.bind(e)), this._addConferenceXMPPListener(Hi.XMPPEvents.TRANSPORT_INFO, e.onTransportInfo.bind(e)), this._addConferenceXMPPListener(Hi.XMPPEvents.CALL_ENDED, e.onCallEnded.bind(e)), this._addConferenceXMPPListener(Hi.XMPPEvents.START_MUTED_FROM_FOCUS, ((t, n) => {
                        e.options.config.ignoreStartMuted || (e.startAudioMuted = t, e.startVideoMuted = n, t && (e.isMutedByFocus = !0), n && (e.isVideoMutedByFocus = !0), e.getLocalTracks().forEach((t => {
                            switch (t.getType()) {
                                case Ri.AUDIO:
                                    e.startAudioMuted && t.mute();
                                    break;
                                case Ri.VIDEO:
                                    e.startVideoMuted && t.mute()
                            }
                        })), e.eventEmitter.emit(Ye))
                    })), this._addConferenceXMPPListener(Hi.XMPPEvents.AV_MODERATION_CHANGED, ((t, n, i) => {
                        const r = e.getParticipants().find((e => e.getJid() === i));
                        e.eventEmitter.emit(Y, {
                            enabled: t,
                            mediaType: n,
                            actor: r
                        })
                    })), this._addConferenceXMPPListener(Hi.XMPPEvents.AV_MODERATION_PARTICIPANT_APPROVED, ((t, n) => {
                        const i = e.getParticipantById(St.Strophe.getResourceFromJid(n));
                        i && e.eventEmitter.emit(Q, {
                            participant: i,
                            mediaType: t
                        })
                    })), this._addConferenceXMPPListener(Hi.XMPPEvents.AV_MODERATION_PARTICIPANT_REJECTED, ((t, n) => {
                        const i = e.getParticipantById(St.Strophe.getResourceFromJid(n));
                        i && e.eventEmitter.emit(Z, {
                            participant: i,
                            mediaType: t
                        })
                    })), this._addConferenceXMPPListener(Hi.XMPPEvents.AV_MODERATION_APPROVED, (t => e.eventEmitter.emit(X, {
                        mediaType: t
                    }))), this._addConferenceXMPPListener(Hi.XMPPEvents.AV_MODERATION_REJECTED, (t => {
                        e.eventEmitter.emit(ee, {
                            mediaType: t
                        })
                    })), this._addConferenceXMPPListener(Hi.XMPPEvents.VISITORS_MESSAGE, (t => e.eventEmitter.emit(gt, t))), this._addConferenceXMPPListener(Hi.XMPPEvents.VISITORS_REJECTION, (() => e.eventEmitter.emit(ft)))
                }, Ji.prototype._addConferenceXMPPListener = function(e, t) {
                    this.xmppListeners[e] = t, this.conference.xmpp.addListener(e, t)
                }, Ji.prototype.setupStatisticsListeners = function() {
                    const e = this.conference;
                    e.statistics && (e.statistics.addAudioLevelListener(((t, n, i, r) => {
                        e.rtc.setAudioLevel(t, n, i, r)
                    })), e.statistics.addBeforeDisposedListener((() => {
                        e.eventEmitter.emit(te)
                    })), e.options.config.startSilent || e.statistics.addByteSentStatsListener(((t, n) => {
                        e.getLocalTracks(Ri.AUDIO).forEach((e => {
                            const i = t.getLocalSSRC(e);
                            i && n.hasOwnProperty(i) && e.onByteSentStatsReceived(t, n[i])
                        }))
                    })))
                };
                class Bi {
                    constructor(e, t, n, i, r, o, s, a, d) {
                        this._jid = e, this._id = St.Strophe.getResourceFromJid(e), this._conference = t, this._displayName = n, this._supportsDTMF = !1, this._tracks = [], this._role = "none", this._status = o, this._hidden = i, this._statsID = r, this._properties = {}, this._identity = s, this._isReplacing = a, this._isReplaced = d, this._features = new Set, this._sources = new Map
                    }
                    _isMediaTypeMuted(e) {
                        return this.getTracks().reduce(((t, n) => t && (n.getType() !== e || n.isMuted())), !0)
                    }
                    _setSources(e, t, n, i) {
                        var r;
                        let o = this._sources.get(e);
                        const s = {
                            muted: t,
                            videoType: i
                        };
                        null !== (r = o) && void 0 !== r && r.size ? o.set(n, s) : (o = new Map, o.set(n, s), this._sources.set(e, o))
                    }
                    getBotType() {
                        return this._botType
                    }
                    getConference() {
                        return this._conference
                    }
                    getConnectionJid() {
                        return this._connectionJid
                    }
                    getDisplayName() {
                        return this._displayName
                    }
                    getFeatures() {
                        return Promise.resolve(this._features)
                    }
                    getId() {
                        return this._id
                    }
                    getIdentity() {
                        return this._identity
                    }
                    getJid() {
                        return this._jid
                    }
                    getProperty(e) {
                        return this._properties[e]
                    }
                    getRole() {
                        return this._role
                    }
                    getSources() {
                        return this._sources
                    }
                    getStatsID() {
                        return this._statsID
                    }
                    getStatus() {
                        return this._status
                    }
                    getTracks() {
                        return this._tracks.slice()
                    }
                    getTracksByMediaType(e) {
                        return this.getTracks().filter((t => t.getType() === e))
                    }
                    hasFeature(e) {
                        return this._features.has(e)
                    }
                    isAudioMuted() {
                        return this._isMediaTypeMuted(Ri.AUDIO)
                    }
                    isHidden() {
                        return this._hidden
                    }
                    isHiddenFromRecorder() {
                        var e, t;
                        return "true" === (null === (e = this._identity) || void 0 === e || null === (t = e.user) || void 0 === t ? void 0 : t["hidden-from-recorder"])
                    }
                    isModerator() {
                        return "moderator" === this._role
                    }
                    isReplaced() {
                        return this._isReplaced
                    }
                    isReplacing() {
                        return this._isReplacing
                    }
                    isVideoMuted() {
                        return this._isMediaTypeMuted(Ri.VIDEO)
                    }
                    setBotType(e) {
                        this._botType = e
                    }
                    setConnectionJid(e) {
                        this._connectionJid = e
                    }
                    setFeatures(e) {
                        this._features = e || new Set
                    }
                    setIsReplaced(e) {
                        this._isReplaced = e
                    }
                    setIsReplacing(e) {
                        this._isReplacing = e
                    }
                    setProperty(e, t) {
                        const n = this._properties[e];
                        t !== n && (this._properties[e] = t, this._conference.eventEmitter.emit(qe, this, e, n, t))
                    }
                    setRole(e) {
                        this._role = e
                    }
                    supportsDTMF() {
                        return this._supportsDTMF
                    }
                }
                let qi;
                ! function(e) {
                    e.CONSTRAINT_FAILED = "gum.constraint_failed", e.ELECTRON_DESKTOP_PICKER_ERROR = "gum.electron_desktop_picker_error", e.ELECTRON_DESKTOP_PICKER_NOT_FOUND = "gum.electron_desktop_picker_not_found", e.GENERAL = "gum.general", e.NOT_FOUND = "gum.not_found", e.PERMISSION_DENIED = "gum.permission_denied", e.SCREENSHARING_GENERIC_ERROR = "gum.screensharing_generic_error", e.SCREENSHARING_USER_CANCELED = "gum.screensharing_user_canceled", e.TIMEOUT = "gum.timeout", e.TRACK_IS_DISPOSED = "track.track_is_disposed", e.TRACK_NO_STREAM_FOUND = "track.no_stream_found", e.UNSUPPORTED_RESOLUTION = "gum.unsupported_resolution", e.TRACK_TOO_MANY_TRACKS_IN_STREAM = "track.too_many_tracks_in_stream", e.TRACK_NO_STREAM_TRACKS_FOUND = "track.no_stream_tracks_found"
                }(qi || (qi = {}));
                const Gi = qi.CONSTRAINT_FAILED,
                    zi = qi.ELECTRON_DESKTOP_PICKER_ERROR,
                    Ki = qi.ELECTRON_DESKTOP_PICKER_NOT_FOUND,
                    Wi = qi.GENERAL,
                    Xi = qi.NOT_FOUND,
                    Yi = qi.PERMISSION_DENIED,
                    Qi = qi.SCREENSHARING_GENERIC_ERROR,
                    Zi = qi.SCREENSHARING_USER_CANCELED,
                    er = qi.TIMEOUT,
                    tr = qi.TRACK_IS_DISPOSED,
                    nr = qi.TRACK_NO_STREAM_FOUND,
                    ir = qi.UNSUPPORTED_RESOLUTION,
                    rr = qi.TRACK_TOO_MANY_TRACKS_IN_STREAM,
                    or = qi.TRACK_NO_STREAM_TRACKS_FOUND,
                    sr = {};

                function ar(e, t, n) {
                    if ("object" == typeof e && void 0 !== e.name) switch (this.gum = {
                            error: e,
                            constraints: t,
                            devices: n && Array.isArray(n) ? n.slice(0) : void 0
                        }, e.name) {
                        case "NotAllowedError":
                        case "PermissionDeniedError":
                        case "SecurityError":
                            this.name = Yi, this.message = sr[this.name] + (this.gum.devices || []).join(", ");
                            break;
                        case "DevicesNotFoundError":
                        case "NotFoundError":
                            this.name = Xi, this.message = sr[this.name] + (this.gum.devices || []).join(", ");
                            break;
                        case "ConstraintNotSatisfiedError":
                        case "OverconstrainedError": {
                            const i = e.constraintName || e.constraint;
                            t && t.video && (!n || n.indexOf("video") > -1) && ("minWidth" === i || "maxWidth" === i || "minHeight" === i || "maxHeight" === i || "width" === i || "height" === i || "deviceId" === i) ? (this.name = ir, this.message = sr[this.name] + function(e, t) {
                                if (t && t.video && t.video.mandatory) switch (e) {
                                    case "width":
                                        return t.video.mandatory.minWidth;
                                    case "height":
                                        return t.video.mandatory.minHeight;
                                    default:
                                        return t.video.mandatory[e] || ""
                                }
                                return ""
                            }(i, t)) : (this.name = Gi, this.message = sr[this.name] + e.constraintName);
                            break
                        }
                        default:
                            this.name = Wi, this.message = e.message || sr[this.name]
                    } else {
                        if ("string" != typeof e) throw new Error("Invalid arguments");
                        sr[e] ? (this.name = e, this.message = t || sr[e]) : this.message = e
                    }
                    this.stack = e.stack || (new Error).stack
                }
                sr[ir] = "Video resolution is not supported: ", sr[Zi] = "User canceled screen sharing prompt", sr[Qi] = "Unknown error from screensharing", sr[zi] = "Unkown error from desktop picker", sr[Ki] = "Failed to detect desktop picker", sr[Wi] = "Generic getUserMedia error", sr[Yi] = "User denied permission to use device(s): ", sr[Xi] = "Requested device(s) was/were not found: ", sr[Gi] = "Constraint could not be satisfied: ", sr[er] = "Could not start media source. Timeout occured!", sr[tr] = "Track has been already disposed", sr[nr] = "Track does not have an associated Media Stream", ar.prototype = Object.create(Error.prototype), ar.prototype.constructor = ar;
                const dr = ar;
                let cr;
                ! function(e) {
                    e.CONNECTION_DISCONNECTED = "connection.connectionDisconnected", e.CONNECTION_ESTABLISHED = "connection.connectionEstablished", e.CONNECTION_FAILED = "connection.connectionFailed", e.CONNECTION_REDIRECTED = "connection.redirected", e.WRONG_STATE = "connection.wrongState", e.DISPLAY_NAME_REQUIRED = "connection.display_name_required"
                }(cr || (cr = {}));
                const lr = cr.CONNECTION_DISCONNECTED,
                    hr = cr.CONNECTION_ESTABLISHED,
                    ur = cr.CONNECTION_FAILED,
                    pr = cr.CONNECTION_REDIRECTED,
                    mr = cr.WRONG_STATE,
                    gr = cr.DISPLAY_NAME_REQUIRED;
                var fr = n(32);

                function vr(e) {
                    return fr.parse(e)
                }
                let _r;
                n(352),
                    function(e) {
                        e.CONNECTION_DROPPED_ERROR = "connection.droppedError", e.OTHER_ERROR = "connection.otherError", e.PASSWORD_REQUIRED = "connection.passwordRequired", e.SERVER_ERROR = "connection.serverError"
                    }(_r || (_r = {}));
                const yr = _r.CONNECTION_DROPPED_ERROR,
                    Er = _r.OTHER_ERROR,
                    Sr = _r.PASSWORD_REQUIRED,
                    br = _r.SERVER_ERROR;
                class Tr {
                    constructor() {
                        var e = this;
                        this.promise = new Promise(((t, n) => {
                            this.resolve = function() {
                                e.clearRejectTimeout(), t(...arguments)
                            }, this.reject = function() {
                                e.clearRejectTimeout(), n(...arguments)
                            }
                        })), this.then = this.promise.then.bind(this.promise), this.catch = this.promise.catch.bind(this.promise)
                    }
                    clearRejectTimeout() {
                        clearTimeout(this._timeout)
                    }
                    setRejectTimeout(e) {
                        this._timeout = setTimeout((() => {
                            this.reject(new Error("timeout"))
                        }), e)
                    }
                }
                class Cr {
                    constructor() {
                        this.eventEmitter = new ii, this.addEventListener = this.on = this.addListener, this.removeEventListener = this.off = this.removeListener
                    }
                    addCancellableListener(e, t) {
                        return this.addListener(e, t), () => this.removeListener(e, t)
                    }
                    addListener(e, t) {
                        return this.eventEmitter.addListener(e, t)
                    }
                    removeListener(e, t) {
                        return this.eventEmitter.removeListener(e, t)
                    }
                    emit(e) {
                        for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                        this.eventEmitter.emit(e, ...n)
                    }
                }
                const xr = (0, E.getLogger)("modules/e2ee/E2EEContext.js"),
                    Rr = Symbol("kJitsiE2EE");
                class Ar {
                    constructor() {
                        let {
                            sharedKey: e
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = "";
                        const n = document.querySelector('script[src*="lib-jitsi-meet"]');
                        if (n) {
                            const e = n.src.lastIndexOf("/");
                            t = `${n.src.substring(0,e)}/`
                        }
                        let i = `${t}lib-jitsi-meet.e2ee-worker.js`;
                        if (t && "/" !== t) {
                            const e = new Blob([`importScripts("${i}");`], {
                                type: "application/javascript"
                            });
                            i = window.URL.createObjectURL(e)
                        }
                        this._worker = new Worker(i, {
                            name: "E2EE Worker"
                        }), this._worker.onerror = e => xr.error(e), this._worker.postMessage({
                            operation: "initialize",
                            sharedKey: e
                        })
                    }
                    cleanup(e) {
                        this._worker.postMessage({
                            operation: "cleanup",
                            participantId: e
                        })
                    }
                    cleanupAll() {
                        this._worker.postMessage({
                            operation: "cleanupAll"
                        })
                    }
                    handleReceiver(e, t, n) {
                        if (!e[Rr])
                            if (e[Rr] = !0, window.RTCRtpScriptTransform) {
                                const t = {
                                    operation: "decode",
                                    participantId: n
                                };
                                e.transform = new RTCRtpScriptTransform(this._worker, t)
                            } else {
                                const t = e.createEncodedStreams();
                                this._worker.postMessage({
                                    operation: "decode",
                                    readableStream: t.readable,
                                    writableStream: t.writable,
                                    participantId: n
                                }, [t.readable, t.writable])
                            }
                    }
                    handleSender(e, t, n) {
                        if (!e[Rr])
                            if (e[Rr] = !0, window.RTCRtpScriptTransform) {
                                const t = {
                                    operation: "encode",
                                    participantId: n
                                };
                                e.transform = new RTCRtpScriptTransform(this._worker, t)
                            } else {
                                const t = e.createEncodedStreams();
                                this._worker.postMessage({
                                    operation: "encode",
                                    readableStream: t.readable,
                                    writableStream: t.writable,
                                    participantId: n
                                }, [t.readable, t.writable])
                            }
                    }
                    setKey(e, t, n) {
                        this._worker.postMessage({
                            operation: "setKey",
                            key: t,
                            keyIndex: n,
                            participantId: e
                        })
                    }
                }
                const wr = (0, E.getLogger)("modules/e2ee/KeyHandler.js");
                class Ir extends Cr {
                    constructor(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        super(), this.conference = e, this.e2eeCtx = new Ar(t), this.enabled = !1, this._enabling = void 0, this.conference.on(q, this._onMediaSessionStarted.bind(this)), this.conference.on(tt, (e => e.isLocal() && this._onLocalTrackAdded(e))), this.conference.rtc.on(ji.default.REMOTE_TRACK_ADDED, ((e, t) => this._setupReceiverE2EEForTrack(t, e))), this.conference.on(it, this._trackMuteChanged.bind(this))
                    }
                    isEnabled() {
                        return this.enabled
                    }
                    async setEnabled(e) {
                        this._enabling && await this._enabling, e !== this.enabled && (this._enabling = new Tr, this.enabled = e, e || this.e2eeCtx.cleanupAll(), this._setEnabled && await this._setEnabled(e), this.conference.setLocalParticipantProperty("e2ee.enabled", e), this.conference._restartMediaSessions(), this._enabling.resolve())
                    }
                    setEncryptionKey() {
                        throw new Error("Not implemented by subclass")
                    }
                    _onLocalTrackAdded(e) {
                        for (const t of this.conference.getMediaSessions()) this._setupSenderE2EEForTrack(t, e)
                    }
                    _onMediaSessionStarted(e) {
                        const t = this.conference.getLocalTracks();
                        for (const n of t) this._setupSenderE2EEForTrack(e, n)
                    }
                    _setupReceiverE2EEForTrack(e, t) {
                        if (!this.enabled) return;
                        const n = e.findReceiverForTrack(t.track);
                        n ? this.e2eeCtx.handleReceiver(n, t.getType(), t.getParticipantId()) : wr.warn(`Could not handle E2EE for ${t}: receiver not found in: ${e}`)
                    }
                    _setupSenderE2EEForTrack(e, t) {
                        if (!this.enabled) return;
                        const n = e.peerconnection,
                            i = n && n.findSenderForTrack(t.track);
                        i ? this.e2eeCtx.handleSender(i, t.getType(), t.getParticipantId()) : wr.warn(`Could not handle E2EE for ${t}: sender not found in ${n}`)
                    }
                    _trackMuteChanged(e) {
                        if (ci.doesVideoMuteByStreamRemove() && e.isLocal() && e.isVideoTrack() && !e.isMuted())
                            for (const t of this.conference.getMediaSessions()) this._setupSenderE2EEForTrack(t, e)
                    }
                }
                class Pr extends Ir {
                    constructor(e) {
                        super(e, {
                            sharedKey: !0
                        })
                    }
                    setKey(e) {
                        this.e2eeCtx.setKey(void 0, {
                            encryptionKey: e.encryptionKey
                        }, e.index)
                    }
                }
                var Dr = n(509),
                    Or = n.n(Dr),
                    Nr = n(577),
                    kr = n(433);
                kr.v1, kr.v3;
                const Mr = kr.v4;
                let Lr;
                kr.v5,
                    function(e) {
                        e.E2EE_SAS_KEYS_MAC_MISMATCH = "e2ee.sas.keys-mac-mismatch", e.E2EE_SAS_MAC_MISMATCH = "e2ee.sas.mac-mismatch", e.E2EE_SAS_MISSING_KEY = "e2ee.sas.missing-key", e.E2EE_SAS_COMMITMENT_MISMATCHED = "e2ee.sas.commitment-mismatched", e.E2EE_SAS_CHANNEL_VERIFICATION_FAILED = "e2ee.sas.channel-verification-failed", e.E2EE_SAS_INVALID_SAS_VERIFICATION = "e2ee.sas.invalid-sas-verification"
                    }(Lr || (Lr = {}));
                const Fr = [
                        ["", "dog"],
                        ["", "cat"],
                        ["", "lion"],
                        ["", "horse"],
                        ["", "unicorn"],
                        ["", "pig"],
                        ["", "elephant"],
                        ["", "rabbit"],
                        ["", "panda"],
                        ["", "rooster"],
                        ["", "penguin"],
                        ["", "turtle"],
                        ["", "fish"],
                        ["", "octopus"],
                        ["", "butterfly"],
                        ["", "flower"],
                        ["", "tree"],
                        ["", "cactus"],
                        ["", "mushroom"],
                        ["", "globe"],
                        ["", "moon"],
                        ["", "cloud"],
                        ["", "fire"],
                        ["", "banana"],
                        ["", "apple"],
                        ["", "strawberry"],
                        ["", "corn"],
                        ["", "pizza"],
                        ["", "cake"],
                        ["", "heart"],
                        ["", "smiley"],
                        ["", "robot"],
                        ["", "hat"],
                        ["", "glasses"],
                        ["", "spanner"],
                        ["", "santa"],
                        ["", "thumbs up"],
                        ["", "umbrella"],
                        ["", "hourglass"],
                        ["", "clock"],
                        ["", "gift"],
                        ["", "light bulb"],
                        ["", "book"],
                        ["", "pencil"],
                        ["", "paperclip"],
                        ["", "scissors"],
                        ["", "lock"],
                        ["", "key"],
                        ["", "hammer"],
                        ["", "telephone"],
                        ["", "flag"],
                        ["", "train"],
                        ["", "bicycle"],
                        ["", "aeroplane"],
                        ["", "rocket"],
                        ["", "trophy"],
                        ["", "ball"],
                        ["", "guitar"],
                        ["", "trumpet"],
                        ["", "bell"],
                        ["", "anchor"],
                        ["", "headphones"],
                        ["", "folder"],
                        ["", "pin"]
                    ],
                    jr = {
                        decimal: function(e) {
                            return [1e3 + (e[0] << 5 | e[1] >> 3), 1e3 + ((7 & e[1]) << 10 | e[2] << 2 | e[3] >> 6), 1e3 + ((63 & e[3]) << 7 | e[4] >> 1)]
                        },
                        emoji: function(e) {
                            return [e[0] >> 2, (3 & e[0]) << 4 | e[1] >> 4, (15 & e[1]) << 2 | e[2] >> 6, 63 & e[2], e[3] >> 2, (3 & e[3]) << 4 | e[4] >> 4, (15 & e[4]) << 2 | e[5] >> 6].map((e => Fr[e]))
                        }
                    },
                    Vr = (0, E.getLogger)("modules/e2ee/OlmAdapter.js"),
                    Ur = 5e3,
                    Hr = "olm",
                    $r = "error",
                    Jr = "key-info",
                    Br = "key-info-ack",
                    qr = "session-ack",
                    Gr = "session-init",
                    zr = "sas-start",
                    Kr = "sas-accept",
                    Wr = "sas-key",
                    Xr = "sas-mac",
                    Yr = "Jitsi-KEY_VERIFICATION_MAC",
                    Qr = "Jitsi-KEY_IDS",
                    Zr = Symbol("OlmData"),
                    eo = {
                        PARTICIPANT_E2EE_CHANNEL_READY: "olm.participant_e2ee_channel_ready",
                        PARTICIPANT_SAS_AVAILABLE: "olm.participant_sas_available",
                        PARTICIPANT_SAS_READY: "olm.participant_sas_ready",
                        PARTICIPANT_KEY_UPDATED: "olm.partitipant_key_updated",
                        PARTICIPANT_VERIFICATION_COMPLETED: "olm.participant_verification_completed"
                    };
                class to extends Cr {
                    constructor(e) {
                        super(), this._conf = e, this._init = new Tr, this._mediaKey = void 0, this._mediaKeyIndex = -1, this._reqs = new Map, this._sessionInitialization = void 0, to.isSupported() ? (this._bootstrapOlm(), this._conf.on(Ce, this._onEndpointMessageReceived.bind(this)), this._conf.on(le, this._onConferenceLeft.bind(this)), this._conf.on(dt, this._onParticipantLeft.bind(this)), this._conf.on(qe, this._onParticipantPropertyChanged.bind(this))) : this._init.reject(new Error("Olm not supported"))
                    }
                    get myId() {
                        return this._conf.myUserId()
                    }
                    async initSessions() {
                        if (this._sessionInitialization) throw new Error("OlmAdapter initSessions called multiple times");
                        {
                            this._sessionInitialization = new Tr, await this._init;
                            const e = [],
                                t = this._conf.myUserId();
                            for (const n of this._conf.getParticipants()) n.hasFeature(wa) && t < n.getId() && e.push(this._sendSessionInit(n));
                            await Promise.allSettled(e), this._sessionInitialization.resolve(), this._sessionInitialization = void 0
                        }
                    }
                    static isSupported() {
                        return void 0 !== window.Olm
                    }
                    async updateKey(e) {
                        this._mediaKey = e, this._mediaKeyIndex++;
                        const t = [];
                        for (const e of this._conf.getParticipants()) {
                            const n = e.getId(),
                                i = this._getParticipantOlmData(e);
                            if (!i.session) {
                                Vr.warn(`Tried to send key to participant ${n} but we have no session`);
                                continue
                            }
                            const r = Mr(),
                                o = {
                                    [Ra]: Hr,
                                    olm: {
                                        type: Jr,
                                        data: {
                                            ciphertext: this._encryptKeyInfo(i.session),
                                            uuid: r
                                        }
                                    }
                                },
                                s = new Tr;
                            s.setRejectTimeout(Ur), s.catch((() => {
                                this._reqs.delete(r)
                            })), this._reqs.set(r, s), t.push(s), this._sendMessage(o, n)
                        }
                        return await Promise.allSettled(t), this._mediaKeyIndex
                    }
                    updateCurrentMediaKey(e) {
                        return this._mediaKey = e, this._mediaKeyIndex
                    }
                    clearParticipantSession(e) {
                        const t = this._getParticipantOlmData(e);
                        t.session && (t.session.free(), t.session = void 0)
                    }
                    clearAllParticipantsSessions() {
                        for (const e of this._conf.getParticipants()) this.clearParticipantSession(e)
                    }
                    markParticipantVerified(e, t) {
                        const n = this._getParticipantOlmData(e),
                            i = e.getId();
                        if (!t) return n.sasVerification = void 0, Vr.warn(`Verification failed for participant ${i}`), void this.eventEmitter.emit(eo.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, Lr.E2EE_SAS_CHANNEL_VERIFICATION_FAILED);
                        if (!n.sasVerification) return Vr.warn(`Participant ${i} does not have valid sasVerification`), void this.eventEmitter.emit(eo.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, Lr.E2EE_SAS_INVALID_SAS_VERIFICATION);
                        const {
                            sas: r,
                            sasMacSent: o
                        } = n.sasVerification;
                        r && r.is_their_key_set() && !o && (this._sendSasMac(e), n.sasVerification.sasMacSent = !0)
                    }
                    async _bootstrapOlm() {
                        Vr.debug("Initializing Olm...");
                        try {
                            await Olm.init(), this._olmAccount = new Olm.Account, this._olmAccount.create(), this._idKeys = vr(this._olmAccount.identity_keys()), Vr.debug(`Olm ${Olm.get_library_version().join(".")} initialized`), this._init.resolve(), this._onIdKeysReady(this._idKeys)
                        } catch (e) {
                            Vr.error("Failed to initialize Olm", e), this._init.reject(e)
                        }
                    }
                    startVerification(e) {
                        const t = e.getId(),
                            n = this._getParticipantOlmData(e);
                        if (!n.session) return void Vr.warn(`Tried to start verification with participant ${t} but we have no session`);
                        if (n.sasVerification) return void Vr.warn(`There is already a verification in progress with participant ${t}`);
                        n.sasVerification = {
                            sas: new Olm.SAS,
                            transactionId: Mr()
                        };
                        const i = {
                            transactionId: n.sasVerification.transactionId
                        };
                        n.sasVerification.startContent = i, n.sasVerification.isInitiator = !0;
                        const r = {
                            [Ra]: Hr,
                            olm: {
                                type: zr,
                                data: i
                            }
                        };
                        this._sendMessage(r, t)
                    }
                    _onIdKeysReady(e) {
                        Vr.debug(`Olm id key ready: ${e}`);
                        for (const t in e)
                            if (e.hasOwnProperty(t)) {
                                const n = e[t];
                                this._conf.setLocalParticipantProperty(`e2ee.idKey.${t}`, n)
                            }
                    }
                    _onParticipantE2EEChannelReady(e) {
                        Vr.debug(`E2EE channel with participant ${e} is ready`)
                    }
                    _encryptKeyInfo(e) {
                        const t = {};
                        return void 0 !== this._mediaKey && (t.key = !!this._mediaKey && Nr.fromByteArray(this._mediaKey), t.keyIndex = this._mediaKeyIndex), e.encrypt(JSON.stringify(t))
                    }
                    _getParticipantOlmData(e) {
                        return e[Zr] = e[Zr] || {}, e[Zr]
                    }
                    async _onConferenceLeft() {
                        Vr.debug("Conference left"), await this._init;
                        for (const e of this._conf.getParticipants()) this._onParticipantLeft(e.getId(), e);
                        this._olmAccount && (this._olmAccount.free(), this._olmAccount = void 0)
                    }
                    async _onEndpointMessageReceived(e, t) {
                        if (t[Ra] !== Hr) return;
                        if (!t.olm) return void Vr.warn("Incorrectly formatted message");
                        await this._init;
                        const n = t.olm,
                            i = e.getId(),
                            r = this._getParticipantOlmData(e);
                        switch (n.type) {
                            case Gr:
                                if (r.session) Vr.warn(`Participant ${i} already has a session`), this._sendError(e, "Session already established");
                                else {
                                    const e = new Olm.Session;
                                    e.create_outbound(this._olmAccount, n.data.idKey, n.data.otKey), r.session = e;
                                    const t = {
                                        [Ra]: Hr,
                                        olm: {
                                            type: qr,
                                            data: {
                                                ciphertext: this._encryptKeyInfo(e),
                                                uuid: n.data.uuid
                                            }
                                        }
                                    };
                                    this._sendMessage(t, i), this._onParticipantE2EEChannelReady(i)
                                }
                                break;
                            case qr:
                                if (r.session) Vr.warn(`Participant ${i} already has a session`), this._sendError(e, "No session found");
                                else if (n.data.uuid === r.pendingSessionUuid) {
                                    const {
                                        ciphertext: e
                                    } = n.data, t = this._reqs.get(n.data.uuid), o = new Olm.Session;
                                    o.create_inbound(this._olmAccount, e.body), this._olmAccount.remove_one_time_keys(o);
                                    const s = o.decrypt(e.type, e.body);
                                    r.session = o, r.pendingSessionUuid = void 0, this._onParticipantE2EEChannelReady(i), this._reqs.delete(n.data.uuid), t.resolve();
                                    const a = no(s);
                                    if (a.key) {
                                        const e = Nr.toByteArray(a.key),
                                            t = a.keyIndex;
                                        r.lastKey = e, this.eventEmitter.emit(eo.PARTICIPANT_KEY_UPDATED, i, e, t)
                                    }
                                } else Vr.warn("Received ACK with the wrong UUID"), this._sendError(e, "Invalid UUID");
                                break;
                            case $r:
                                Vr.error(n.data.error);
                                break;
                            case Jr:
                                if (r.session) {
                                    const {
                                        ciphertext: e
                                    } = n.data, t = no(r.session.decrypt(e.type, e.body));
                                    if (void 0 !== t.key && void 0 !== t.keyIndex) {
                                        const e = !!t.key && Nr.toByteArray(t.key),
                                            o = t.keyIndex;
                                        Et()(r.lastKey, e) || (r.lastKey = e, this.eventEmitter.emit(eo.PARTICIPANT_KEY_UPDATED, i, e, o));
                                        const s = {
                                            [Ra]: Hr,
                                            olm: {
                                                type: Br,
                                                data: {
                                                    ciphertext: this._encryptKeyInfo(r.session),
                                                    uuid: n.data.uuid
                                                }
                                            }
                                        };
                                        this._sendMessage(s, i)
                                    }
                                } else Vr.debug(`Received key info message from ${i} but we have no session for them!`), this._sendError(e, "No session found while processing key-info");
                                break;
                            case Br:
                                if (r.session) {
                                    const {
                                        ciphertext: e
                                    } = n.data, t = no(r.session.decrypt(e.type, e.body));
                                    if (void 0 !== t.key && void 0 !== t.keyIndex) {
                                        const e = !!t.key && Nr.toByteArray(t.key),
                                            n = t.keyIndex;
                                        Et()(r.lastKey, e) || (r.lastKey = e, this.eventEmitter.emit(eo.PARTICIPANT_KEY_UPDATED, i, e, n))
                                    }
                                    const o = this._reqs.get(n.data.uuid);
                                    this._reqs.delete(n.data.uuid), o.resolve()
                                } else Vr.debug(`Received key info ack message from ${i} but we have no session for them!`), this._sendError(e, "No session found while processing key-info-ack");
                                break;
                            case zr: {
                                var o;
                                if (!r.session) return Vr.debug(`Received sas init message from ${i} but we have no session for them!`), void this._sendError(e, "No session found while processing sas-init");
                                if (null !== (o = r.sasVerification) && void 0 !== o && o.sas) return Vr.warn(`SAS already created for participant ${i}`), void this.eventEmitter.emit(eo.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, Lr.E2EE_SAS_INVALID_SAS_VERIFICATION);
                                const {
                                    transactionId: t
                                } = n.data, s = new Olm.SAS;
                                r.sasVerification = {
                                    sas: s,
                                    transactionId: t,
                                    isInitiator: !1
                                };
                                const a = r.sasVerification.sas.get_pubkey(),
                                    d = this._computeCommitment(a, n.data),
                                    c = {
                                        [Ra]: Hr,
                                        olm: {
                                            type: Kr,
                                            data: {
                                                transactionId: t,
                                                commitment: d
                                            }
                                        }
                                    };
                                this._sendMessage(c, i);
                                break
                            }
                            case Kr: {
                                if (!r.session) return Vr.debug(`Received sas accept message from ${i} but we have no session for them!`), void this._sendError(e, "No session found while processing sas-accept");
                                const {
                                    commitment: t,
                                    transactionId: o
                                } = n.data;
                                if (!r.sasVerification) return Vr.warn(`SAS_ACCEPT Participant ${i} does not have valid sasVerification`), void this.eventEmitter.emit(eo.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, Lr.E2EE_SAS_INVALID_SAS_VERIFICATION);
                                if (r.sasVerification.sasCommitment) return Vr.debug(`Already received sas commitment message from ${i}!`), void this._sendError(e, "Already received sas commitment message from ${pId}!");
                                r.sasVerification.sasCommitment = t;
                                const s = r.sasVerification.sas.get_pubkey(),
                                    a = {
                                        [Ra]: Hr,
                                        olm: {
                                            type: Wr,
                                            data: {
                                                key: s,
                                                transactionId: o
                                            }
                                        }
                                    };
                                this._sendMessage(a, i), r.sasVerification.keySent = !0;
                                break
                            }
                            case Wr: {
                                if (!r.session) return Vr.debug(`Received sas key message from ${i} but we have no session for them!`), void this._sendError(e, "No session found while processing sas-key");
                                if (!r.sasVerification) return Vr.warn(`SAS_KEY Participant ${i} does not have valid sasVerification`), void this.eventEmitter.emit(eo.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, Lr.E2EE_SAS_INVALID_SAS_VERIFICATION);
                                const {
                                    isInitiator: t,
                                    sas: o,
                                    sasCommitment: s,
                                    startContent: a,
                                    keySent: d
                                } = r.sasVerification;
                                if (o.is_their_key_set()) return void Vr.warn("SAS already has their key!");
                                const {
                                    key: c,
                                    transactionId: l
                                } = n.data;
                                if (s && s !== this._computeCommitment(c, a)) return this._sendError(e, "OlmAdapter commitments mismatched"), this.eventEmitter.emit(eo.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, Lr.E2EE_SAS_COMMITMENT_MISMATCHED), void r.sasVerification.free();
                                o.set_their_key(c);
                                const h = o.get_pubkey(),
                                    u = `${this.myId}|${h}`,
                                    p = `${i}|${c}`,
                                    m = t ? `${u}|${p}` : `${p}|${u}`,
                                    g = function(e) {
                                        const t = {};
                                        for (const n in jr) jr.hasOwnProperty(n) && (t[n] = jr[n](e));
                                        return t
                                    }(o.generate_bytes(m, 6));
                                if (this.eventEmitter.emit(eo.PARTICIPANT_SAS_READY, i, g), d) return;
                                const f = {
                                    [Ra]: Hr,
                                    olm: {
                                        type: Wr,
                                        data: {
                                            key: h,
                                            transactionId: l
                                        }
                                    }
                                };
                                this._sendMessage(f, i), r.sasVerification.keySent = !0;
                                break
                            }
                            case Xr: {
                                if (!r.session) return Vr.debug(`Received sas mac message from ${i} but we have no session for them!`), void this._sendError(e, "No session found while processing sas-mac");
                                const {
                                    keys: t,
                                    mac: o,
                                    transactionId: s
                                } = n.data;
                                if (!o || !t) return void Vr.warn("Invalid SAS MAC message");
                                if (!r.sasVerification) return void Vr.warn(`SAS_MAC Participant ${i} does not have valid sasVerification`);
                                const a = r.sasVerification.sas,
                                    d = `${Yr}${i}${this.myId}${s}`;
                                if (a.calculate_mac(Object.keys(o).sort().join(","), d + Qr) !== t) return Vr.error("SAS verification error: keys MAC mismatch"), void this.eventEmitter.emit(eo.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, Lr.E2EE_SAS_KEYS_MAC_MISMATCH);
                                if (!r.ed25519) return Vr.warn("SAS verification error: Missing ed25519 key"), void this.eventEmitter.emit(eo.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, Lr.E2EE_SAS_MISSING_KEY);
                                for (const [e, t] of Object.entries(o))
                                    if (t !== a.calculate_mac(r.ed25519, d + e)) return Vr.error("SAS verification error: MAC mismatch"), void this.eventEmitter.emit(eo.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, Lr.E2EE_SAS_MAC_MISMATCH);
                                Vr.info(`SAS MAC verified for participant ${i}`), this.eventEmitter.emit(eo.PARTICIPANT_VERIFICATION_COMPLETED, i, !0);
                                break
                            }
                        }
                    }
                    _onParticipantLeft(e, t) {
                        Vr.debug(`Participant ${e} left`), this.clearParticipantSession(t)
                    }
                    async _onParticipantPropertyChanged(e, t, n, i) {
                        const r = e.getId(),
                            o = this._getParticipantOlmData(e);
                        switch (t) {
                            case "e2ee.enabled":
                                if (i && this._conf.isE2EEEnabled()) {
                                    const t = this._conf.myUserId();
                                    if ((await e.getFeatures()).has(wa) && t < r) {
                                        this._sessionInitialization && await this._sessionInitialization, await this._sendSessionInit(e);
                                        const t = Mr(),
                                            n = new Tr;
                                        n.setRejectTimeout(Ur), n.catch((() => {
                                            this._reqs.delete(t), o.pendingSessionUuid = void 0
                                        })), this._reqs.set(t, n);
                                        const i = {
                                            [Ra]: Hr,
                                            olm: {
                                                type: Jr,
                                                data: {
                                                    ciphertext: this._encryptKeyInfo(o.session),
                                                    uuid: t
                                                }
                                            }
                                        };
                                        this._sendMessage(i, r)
                                    }
                                }
                                break;
                            case "e2ee.idKey.ed25519":
                                o.ed25519 = i, this.eventEmitter.emit(eo.PARTICIPANT_SAS_AVAILABLE, r)
                        }
                    }
                    _sendError(e, t) {
                        const n = e.getId(),
                            i = {
                                [Ra]: Hr,
                                olm: {
                                    type: $r,
                                    data: {
                                        error: t
                                    }
                                }
                            };
                        this._sendMessage(i, n)
                    }
                    _sendMessage(e, t) {
                        this._conf.sendMessage(e, t)
                    }
                    _sendSessionInit(e) {
                        const t = e.getId(),
                            n = this._getParticipantOlmData(e);
                        if (n.session) return Vr.warn(`Tried to send session-init to ${t} but we already have a session`), Promise.reject();
                        if (void 0 !== n.pendingSessionUuid) return Vr.warn(`Tried to send session-init to ${t} but we already have a pending session`), Promise.reject();
                        this._olmAccount.generate_one_time_keys(1);
                        const i = vr(this._olmAccount.one_time_keys()),
                            r = Object.values(i.curve25519)[0];
                        if (!r) return Promise.reject(new Error("No one-time-keys generated"));
                        this._olmAccount.mark_keys_as_published();
                        const o = Mr(),
                            s = {
                                [Ra]: Hr,
                                olm: {
                                    type: Gr,
                                    data: {
                                        idKey: this._idKeys.curve25519,
                                        otKey: r,
                                        uuid: o
                                    }
                                }
                            },
                            a = new Tr;
                        return a.setRejectTimeout(Ur), a.catch((() => {
                            this._reqs.delete(o), n.pendingSessionUuid = void 0
                        })), this._reqs.set(o, a), this._sendMessage(s, t), n.pendingSessionUuid = o, a
                    }
                    _sendSasMac(e) {
                        const t = e.getId(),
                            n = this._getParticipantOlmData(e),
                            {
                                sas: i,
                                transactionId: r
                            } = n.sasVerification,
                            o = {},
                            s = [],
                            a = `${Yr}${this.myId}${t}${r}`,
                            d = `ed25519:${t}`;
                        o[d] = i.calculate_mac(this._idKeys.ed25519, a + d), s.push(d);
                        const c = i.calculate_mac(s.sort().join(","), a + Qr),
                            l = {
                                [Ra]: Hr,
                                olm: {
                                    type: Xr,
                                    data: {
                                        keys: c,
                                        mac: o,
                                        transactionId: r
                                    }
                                }
                            };
                        this._sendMessage(l, t)
                    }
                    _computeCommitment(e, t) {
                        const n = new Olm.Utility,
                            i = n.sha256(e + JSON.stringify(t));
                        return n.free(), i
                    }
                }

                function no(e) {
                    try {
                        return vr(e)
                    } catch (e) {
                        return {}
                    }
                }
                to.events = eo;
                const io = (0, E.getLogger)("modules/e2ee/ManagedKeyHandler.js");
                class ro extends Ir {
                    constructor(e) {
                        super(e), this._key = void 0, this._conferenceJoined = !1, this._olmAdapter = new to(e), this._rotateKey = Or()(this._rotateKeyImpl, 5e3), this._ratchetKey = Or()(this._ratchetKeyImpl, 5e3), this._olmAdapter.on(to.events.PARTICIPANT_KEY_UPDATED, this._onParticipantKeyUpdated.bind(this)), this._olmAdapter.on(to.events.PARTICIPANT_SAS_READY, this._onParticipantSasReady.bind(this)), this._olmAdapter.on(to.events.PARTICIPANT_SAS_AVAILABLE, this._onParticipantSasAvailable.bind(this)), this._olmAdapter.on(to.events.PARTICIPANT_VERIFICATION_COMPLETED, this._onParticipantVerificationCompleted.bind(this)), this.conference.on(qe, this._onParticipantPropertyChanged.bind(this)), this.conference.on(at, this._onParticipantJoined.bind(this)), this.conference.on(dt, this._onParticipantLeft.bind(this)), this.conference.on(ce, (() => {
                            this._conferenceJoined = !0
                        }))
                    }
                    get sasVerification() {
                        return this._olmAdapter
                    }
                    async _setEnabled(e) {
                        e ? await this._olmAdapter.initSessions() : this._olmAdapter.clearAllParticipantsSessions(), this._key = !!e && this._generateKey();
                        const t = await this._olmAdapter.updateKey(this._key);
                        this.e2eeCtx.setKey(this.conference.myUserId(), this._key, t)
                    }
                    async _onParticipantPropertyChanged(e, t, n, i) {
                        switch (t) {
                            case "e2ee.idKey":
                                io.debug(`Participant ${e.getId()} updated their id key: ${i}`);
                                break;
                            case "e2ee.enabled":
                                !i && this.enabled && this._olmAdapter.clearParticipantSession(e)
                        }
                    }
                    _onParticipantJoined() {
                        this._conferenceJoined && this.enabled && this._ratchetKey()
                    }
                    _onParticipantLeft(e) {
                        this.e2eeCtx.cleanup(e), this.enabled && this._rotateKey()
                    }
                    async _rotateKeyImpl() {
                        io.debug("Rotating key"), this._key = this._generateKey();
                        const e = await this._olmAdapter.updateKey(this._key);
                        this.e2eeCtx.setKey(this.conference.myUserId(), this._key, e)
                    }
                    async _ratchetKeyImpl() {
                        io.debug("Ratchetting key");
                        const e = await async function(e) {
                            return crypto.subtle.importKey("raw", e, "HKDF", !1, ["deriveBits", "deriveKey"])
                        }(this._key), t = await async function(e) {
                            const t = new TextEncoder;
                            return crypto.subtle.deriveBits({
                                name: "HKDF",
                                salt: t.encode("JFrameRatchetKey"),
                                hash: "SHA-256",
                                info: new ArrayBuffer
                            }, e, 256)
                        }(e);
                        this._key = new Uint8Array(t);
                        const n = this._olmAdapter.updateCurrentMediaKey(this._key);
                        this.e2eeCtx.setKey(this.conference.myUserId(), this._key, n)
                    }
                    _onParticipantKeyUpdated(e, t, n) {
                        io.debug(`Participant ${e} updated their key`), this.e2eeCtx.setKey(e, t, n)
                    }
                    _onParticipantSasReady(e, t) {
                        this.conference.eventEmitter.emit(Te, e, t)
                    }
                    _onParticipantSasAvailable(e) {
                        this.conference.eventEmitter.emit(Se, e)
                    }
                    _onParticipantVerificationCompleted(e, t, n) {
                        this.conference.eventEmitter.emit(be, e, t, n)
                    }
                    _generateKey() {
                        return window.crypto.getRandomValues(new Uint8Array(32))
                    }
                }
                class oo {
                    constructor(e) {
                        const {
                            e2ee: t = {}
                        } = e.options.config;
                        this._externallyManaged = t.externallyManagedKey, this._externallyManaged ? this._keyHandler = new Pr(e) : this._keyHandler = new ro(e)
                    }
                    static isSupported(e) {
                        const {
                            e2ee: t = {}
                        } = e;
                        return !(!t.externallyManagedKey && !to.isSupported()) && !(e.testing && e.testing.disableE2EE) && (ci.supportsInsertableStreams() || e.enableEncodedTransformSupport && ci.supportsEncodedTransform())
                    }
                    isEnabled() {
                        return this._keyHandler.isEnabled()
                    }
                    async setEnabled(e) {
                        await this._keyHandler.setEnabled(e)
                    }
                    setEncryptionKey(e) {
                        this._keyHandler.setKey(e)
                    }
                    startVerification(e) {
                        var t;
                        null === (t = this._keyHandler.sasVerification) || void 0 === t || t.startVerification(e)
                    }
                    markParticipantVerified(e, t) {
                        var n;
                        null === (n = this._keyHandler.sasVerification) || void 0 === n || n.markParticipantVerified(e, t)
                    }
                }
                var so = n(399),
                    ao = n.n(so);

                function co(e, t) {
                    e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;
                    var n, i, r, o, s, a, d, c, l = new Array(80),
                        h = 1732584193,
                        u = -271733879,
                        p = -1732584194,
                        m = 271733878,
                        g = -1009589776;
                    for (n = 0; n < e.length; n += 16) {
                        for (o = h, s = u, a = p, d = m, c = g, i = 0; i < 80; i++) l[i] = i < 16 ? e[n + i] : po(l[i - 3] ^ l[i - 8] ^ l[i - 14] ^ l[i - 16], 1), r = uo(uo(po(h, 5), lo(i, u, p, m)), uo(uo(g, l[i]), ho(i))), g = m, m = p, p = po(u, 30), u = h, h = r;
                        h = uo(h, o), u = uo(u, s), p = uo(p, a), m = uo(m, d), g = uo(g, c)
                    }
                    return [h, u, p, m, g]
                }

                function lo(e, t, n, i) {
                    return e < 20 ? t & n | ~t & i : e < 40 ? t ^ n ^ i : e < 60 ? t & n | t & i | n & i : t ^ n ^ i
                }

                function ho(e) {
                    return e < 20 ? 1518500249 : e < 40 ? 1859775393 : e < 60 ? -1894007588 : -899497514
                }

                function uo(e, t) {
                    var n = (65535 & e) + (65535 & t);
                    return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                }

                function po(e, t) {
                    return e << t | e >>> 32 - t
                }

                function mo(e) {
                    for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << 24 - n % 32;
                    return t
                }

                function go(e) {
                    for (var t, n, i = "", r = 0; r < 4 * e.length; r += 3)
                        for (t = (e[r >> 2] >> 8 * (3 - r % 4) & 255) << 16 | (e[r + 1 >> 2] >> 8 * (3 - (r + 1) % 4) & 255) << 8 | e[r + 2 >> 2] >> 8 * (3 - (r + 2) % 4) & 255, n = 0; n < 4; n++) 8 * r + 6 * n > 32 * e.length ? i += "=" : i += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(t >> 6 * (3 - n) & 63);
                    return i
                }
                const fo = function(e) {
                        return go(co(mo(e), 8 * e.length))
                    },
                    vo = ["category", "type", "lang", "name"],
                    _o = ["category", "type", "lang"];

                function yo(e, t) {
                    let n = 0;
                    return _o.some((i => 0 !== (n = e[i] > t[i] ? 1 : e[i] < t[i] && -1))), n
                }

                function Eo(e) {
                    const t = new Set,
                        n = new Set;
                    return _t()(e).find(">query>feature").each(((e, n) => t.add(n.getAttribute("var")))), _t()(e).find(">query>identity").each(((e, t) => n.add({
                        type: t.getAttribute("type"),
                        name: t.getAttribute("name"),
                        category: t.getAttribute("category")
                    }))), {
                        features: t,
                        identities: n
                    }
                }
                class So extends Cr {
                    constructor() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "http://jitsi.org/jitsimeet";
                        if (super(), this.node = t, this.disco = e.disco, !this.disco) throw new Error("Missing strophe-plugins (disco plugin is required)!");
                        this.version = "", this.rooms = new Set, this.externalFeatures = new Set;
                        const n = e.emuc;
                        n.addListener(Hi.XMPPEvents.EMUC_ROOM_ADDED, (e => this._addChatRoom(e))), n.addListener(Hi.XMPPEvents.EMUC_ROOM_REMOVED, (e => this._removeChatRoom(e))), Object.keys(n.rooms).forEach((e => {
                            this._addChatRoom(n.rooms[e])
                        })), St.Strophe.addNamespace("CAPS", "http://jabber.org/protocol/caps"), this.disco.addFeature(St.Strophe.NS.CAPS)
                    }
                    addFeature(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        this.disco.addFeature(e), this._generateVersion(), n && !this.externalFeatures.has(e) && (this.externalFeatures.add(e), this.rooms.forEach((e => this._updateRoomWithExternalFeatures(e)))), t && this.submit()
                    }
                    removeFeature(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        this.disco.removeFeature(e), this._generateVersion(), n && this.externalFeatures.has(e) && (this.externalFeatures.delete(e), this.rooms.forEach((e => this._updateRoomWithExternalFeatures(e)))), t && this.submit()
                    }
                    submit() {
                        this.rooms.forEach((e => e.sendPresence()))
                    }
                    _updateRoomWithExternalFeatures(e) {
                        if (0 === this.externalFeatures.size) e.removeFromPresence("features");
                        else {
                            const t = [];
                            this.externalFeatures.forEach((e => {
                                t.push({
                                    tagName: "feature",
                                    attributes: {
                                        var: e
                                    }
                                })
                            })), e.addOrReplaceInPresence("features", {
                                children: t
                            })
                        }
                    }
                    getFeaturesAndIdentities(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5e3;
                        return this._getDiscoInfo(e, t, n)
                    }
                    _getDiscoInfo(e, t, n) {
                        return new Promise(((i, r) => this.disco.info(e, t, (e => {
                            i(Eo(e))
                        }), r, n)))
                    }
                    _addChatRoom(e) {
                        this.rooms.add(e), this._fixChatRoomPresenceMap(e), this._updateRoomWithExternalFeatures(e)
                    }
                    _removeChatRoom(e) {
                        this.rooms.delete(e)
                    }
                    _fixChatRoomPresenceMap(e) {
                        e.addOrReplaceInPresence("c", {
                            attributes: {
                                xmlns: St.Strophe.NS.CAPS,
                                hash: "sha-1",
                                node: this.node,
                                ver: this.version
                            }
                        })
                    }
                    _notifyVersionChanged() {
                        this.rooms.forEach((e => this._fixChatRoomPresenceMap(e)))
                    }
                    _generateVersion() {
                        this.version = function(e, t) {
                            const n = e.sort(yo).reduce(((e, t) => `${vo.reduce(((e,n,i)=>e+(0===i?"":"/")+(t[n]?t[n]:"")),"")}<`), ""),
                                i = t.sort().reduce(((e, t) => `${e+t}<`), "");
                            return fo(n + i)
                        }(this.disco._identities, this.disco._features), this._notifyVersionChanged()
                    }
                }
                n(617);
                const bo = "NETWORK_INFO_CHANGED",
                    To = (0, E.getLogger)("modules/connectivity/NetworkInfo.js"),
                    Co = new class extends Cr {
                        constructor() {
                            super(), this._current = {
                                isOnline: !0
                            }
                        }
                        updateNetworkInfo(e) {
                            let {
                                isOnline: t
                            } = e;
                            To.debug("updateNetworkInfo", {
                                isOnline: t
                            }), this._current = {
                                isOnline: !0 === t
                            }, this.eventEmitter.emit(bo, this._current)
                        }
                        isOnline() {
                            return !0 === this._current.isOnline
                        }
                    };

                function xo(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2;
                    return Math.floor(Math.random() * (1e3 * Math.pow(n, e) - t) + t)
                }
                const Ro = (0, E.getLogger)("modules/xmpp/ResumeTask.js");
                class Ao {
                    constructor(e) {
                        this._stropheConn = e, this._resumeRetryN = 0, this._retryDelay = void 0
                    }
                    get retryDelay() {
                        return this._retryDelay
                    }
                    schedule() {
                        this._cancelResume(), this._resumeRetryN += 1, this._networkOnlineListener = Co.addCancellableListener(bo, (e => {
                            let {
                                isOnline: t
                            } = e;
                            t ? this._scheduleResume() : this._cancelResume()
                        })), Co.isOnline() && this._scheduleResume()
                    }
                    _scheduleResume() {
                        this._resumeTimeout || (this._resumeRetryN = Math.min(3, this._resumeRetryN), this._retryDelay = xo(this._resumeRetryN, 1500 * this._resumeRetryN, 3), Ro.info(`Will try to resume the XMPP connection in ${this.retryDelay}ms`), this._resumeTimeout = setTimeout((() => this._resumeConnection()), this.retryDelay))
                    }
                    _cancelResume() {
                        this._resumeTimeout && (Ro.info("Canceling connection resume task"), clearTimeout(this._resumeTimeout), this._resumeTimeout = void 0, this._retryDelay = void 0)
                    }
                    _resumeConnection() {
                        const {
                            streamManagement: e
                        } = this._stropheConn, t = e.getResumeToken();
                        if (!t) return;
                        Ro.info("Trying to resume the XMPP connection");
                        const n = new URL(this._stropheConn.service);
                        let {
                            search: i
                        } = n;
                        const r = /(previd=)([\w-]+)/,
                            o = i.match(r);
                        o && -1 === o.indexOf(t) ? i = i.replace(r, `$1${t}`) : o || (i += -1 === i.indexOf("?") ? `?previd=${t}` : `&previd=${t}`), n.search = i, this._stropheConn.service = n.toString(), e.resume()
                    }
                    cancel() {
                        this._cancelResume(), this._resumeRetryN = 0, this._networkOnlineListener && (this._networkOnlineListener(), this._networkOnlineListener = null)
                    }
                }
                class wo {
                    constructor() {
                        this._lastSuccess = null, this._lastFailedMessage = null
                    }
                    startTracking(e, t) {
                        var n = this;
                        const i = t.rawInput;
                        t.rawInput = function() {
                            for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];
                            const a = o[0];
                            a.includes("failure") && (n._lastFailedMessage = a), e.connected && (n._lastSuccess = Date.now()), i.apply(t, o)
                        }
                    }
                    getLastFailedMessage() {
                        return this._lastFailedMessage
                    }
                    getTimeSinceLastSuccess() {
                        return this._lastSuccess ? Date.now() - this._lastSuccess : null
                    }
                }

                function Io() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : class {};
                    return class extends e {
                        constructor() {
                            super(...arguments), this.connection = null
                        }
                        init(e) {
                            this.connection = e
                        }
                    }
                }
                const Po = Io(),
                    Do = Io(Cr),
                    Oo = (0, E.getLogger)("modules/xmpp/strophe.ping.js");
                class No extends Po {
                    constructor(e) {
                        let {
                            getTimeSinceLastServerResponse: t,
                            onPingThresholdExceeded: n,
                            pingOptions: i = {}
                        } = e;
                        super(), this.failedPings = 0, this._onPingThresholdExceeded = n, this._getTimeSinceLastServerResponse = t, this.pingInterval = "number" == typeof i.interval ? i.interval : 1e4, this.pingTimeout = "number" == typeof i.timeout ? i.timeout : 5e3, this.pingThreshold = "number" == typeof i.threshold ? i.threshold : 2, this.pingTimestampsToKeep = Math.round(12e4 / this.pingInterval), this.pingExecIntervals = new Array(this.pingTimestampsToKeep)
                    }
                    init(e) {
                        super.init(e), St.Strophe.addNamespace("PING", "urn:xmpp:ping")
                    }
                    ping(e, t, n, i) {
                        this._addPingExecutionTimestamp();
                        const r = (0, St.$iq)({
                            type: "get",
                            to: e
                        });
                        r.c("ping", {
                            xmlns: St.Strophe.NS.PING
                        }), this.connection.sendIQ2(r, {
                            timeout: i
                        }).then(t, n)
                    }
                    startInterval(e) {
                        clearInterval(this.intervalId), this.intervalId = window.setInterval((() => {
                            const t = Date.now();
                            if (this._getTimeSinceLastServerResponse() < t - this._lastServerCheck) return this._addPingExecutionTimestamp(), this._lastServerCheck = t, void(this.failedPings = 0);
                            this.ping(e, (() => {
                                this._lastServerCheck = this._getTimeSinceLastServerResponse() + Date.now(), this.failedPings = 0
                            }), (e => {
                                this.failedPings += 1;
                                const t = "Ping " + (e ? "error" : "timeout");
                                this.failedPings >= this.pingThreshold ? (Oo.error(t, e), this._onPingThresholdExceeded && this._onPingThresholdExceeded()) : Oo.warn(t, e)
                            }), this.pingTimeout)
                        }), this.pingInterval), Oo.info(`XMPP pings will be sent every ${this.pingInterval} ms`)
                    }
                    stopInterval() {
                        this.intervalId && (window.clearInterval(this.intervalId), this.intervalId = null, this.failedPings = 0, Oo.info("Ping interval cleared"))
                    }
                    _addPingExecutionTimestamp() {
                        this.pingExecIntervals.push((new Date).getTime()), this.pingExecIntervals.length > this.pingTimestampsToKeep && this.pingExecIntervals.shift()
                    }
                    getPingSuspendTime() {
                        const e = this.pingExecIntervals.slice();
                        e.push((new Date).getTime());
                        let t = 0,
                            n = e[0];
                        return e.forEach((e => {
                            const i = e - n;
                            i > t && (t = i), n = e
                        })), t -= this.pingInterval, Math.max(t, 0)
                    }
                }
                const ko = (0, E.getLogger)("modules/xmpp/XmppConnection.js");
                class Mo extends Cr {
                    static get Events() {
                        return {
                            CONN_STATUS_CHANGED: "CONN_STATUS_CHANGED",
                            CONN_SHARD_CHANGED: "CONN_SHARD_CHANGED"
                        }
                    }
                    static get Status() {
                        return St.Strophe.Status
                    }
                    constructor(e) {
                        let {
                            enableWebsocketResume: t,
                            websocketKeepAlive: n,
                            websocketKeepAliveUrl: i,
                            serviceUrl: r,
                            shard: o,
                            xmppPing: s
                        } = e;
                        super(), this._options = {
                            enableWebsocketResume: void 0 === t || t,
                            pingOptions: s,
                            shard: o,
                            websocketKeepAlive: void 0 === n ? 6e4 : Number(n),
                            websocketKeepAliveUrl: i
                        }, this._stropheConn = new St.Strophe.Connection(r), this._usesWebsocket = r.startsWith("ws:") || r.startsWith("wss:"), this._stropheConn.maxRetries = 3, this._rawInputTracker = new wo, this._rawInputTracker.startTracking(this, this._stropheConn), this._resumeTask = new Ao(this._stropheConn), this._deferredIQs = [], this.addConnectionPlugin("ping", new No({
                            getTimeSinceLastServerResponse: () => this.getTimeSinceLastSuccess(),
                            onPingThresholdExceeded: () => this._onPingErrorThresholdExceeded(),
                            pingOptions: s
                        })), this._oneSuccessfulConnect = !1
                    }
                    get connected() {
                        const e = this._stropheConn && this._stropheConn._proto && this._stropheConn._proto.socket;
                        return (this._status === St.Strophe.Status.CONNECTED || this._status === St.Strophe.Status.ATTACHED) && (!this.isUsingWebSocket || e && e.readyState === WebSocket.OPEN)
                    }
                    get disco() {
                        return this._stropheConn.disco
                    }
                    get disconnecting() {
                        return !0 === this._stropheConn.disconnecting
                    }
                    get domain() {
                        return this._stropheConn.domain
                    }
                    get isUsingWebSocket() {
                        return this._usesWebsocket
                    }
                    get jid() {
                        return this._stropheConn.jid
                    }
                    get lastResponseHeaders() {
                        return this._stropheConn._proto && this._stropheConn._proto.lastResponseHeaders
                    }
                    get logger() {
                        return this._stropheConn.logger
                    }
                    get options() {
                        return this._stropheConn.options
                    }
                    get pingDomain() {
                        var e;
                        return (null === (e = this._options.pingOptions) || void 0 === e ? void 0 : e.domain) || this.domain
                    }
                    get service() {
                        return this._stropheConn.service
                    }
                    set shard(e) {
                        this._options.shard = e, this._oneSuccessfulConnect && this._maybeStartWSKeepAlive()
                    }
                    get status() {
                        return this._status
                    }
                    addConnectionPlugin(e, t) {
                        this[e] = t, t.init(this)
                    }
                    addHandler() {
                        return this._stropheConn.addHandler(...arguments)
                    }
                    deleteHandler() {
                        this._stropheConn.deleteHandler(...arguments)
                    }
                    attach(e, t, n, i) {
                        for (var r = arguments.length, o = new Array(r > 4 ? r - 4 : 0), s = 4; s < r; s++) o[s - 4] = arguments[s];
                        this._stropheConn.attach(e, t, n, this._stropheConnectionCb.bind(this, i), ...o)
                    }
                    connect(e, t, n) {
                        for (var i = arguments.length, r = new Array(i > 3 ? i - 3 : 0), o = 3; o < i; o++) r[o - 3] = arguments[o];
                        this._stropheConn.connect(e, t, this._stropheConnectionCb.bind(this, n), ...r)
                    }
                    _stropheConnectionCb(e, t) {
                        this._status = t;
                        let n = !1;
                        var i;
                        if (t === St.Strophe.Status.CONNECTED || t === St.Strophe.Status.ATTACHED ? (this._maybeEnableStreamResume(), this._usesWebsocket && this._oneSuccessfulConnect && this._keepAliveAndCheckShard(), this._oneSuccessfulConnect = !0, this._maybeStartWSKeepAlive(), this._processDeferredIQs(), this._resumeTask.cancel(), this.ping.startInterval((null === (i = this._options.pingOptions) || void 0 === i ? void 0 : i.domain) || this.domain)) : t === St.Strophe.Status.DISCONNECTED && (this.ping.stopInterval(), n = this._tryResumingConnection(), n || clearTimeout(this._wsKeepAlive)), !n) {
                            for (var r = arguments.length, o = new Array(r > 2 ? r - 2 : 0), s = 2; s < r; s++) o[s - 2] = arguments[s];
                            e(t, ...o), this.eventEmitter.emit(Mo.Events.CONN_STATUS_CHANGED, t)
                        }
                    }
                    _clearDeferredIQs() {
                        for (const e of this._deferredIQs) e.reject(new Error("disconnect"));
                        this._deferredIQs = []
                    }
                    closeWebsocket() {
                        this._stropheConn && this._stropheConn._proto && (this._stropheConn._proto._closeSocket(), this._stropheConn._proto._onClose(null))
                    }
                    disconnect() {
                        this._resumeTask.cancel(), clearTimeout(this._wsKeepAlive), this._clearDeferredIQs(), this._stropheConn.disconnect(...arguments)
                    }
                    flush() {
                        this._stropheConn.flush(...arguments)
                    }
                    getTimeSinceLastSuccess() {
                        return this._rawInputTracker.getTimeSinceLastSuccess()
                    }
                    getLastFailedMessage() {
                        return this._rawInputTracker.getLastFailedMessage()
                    }
                    _maybeEnableStreamResume() {
                        if (!this._options.enableWebsocketResume) return;
                        const {
                            streamManagement: e
                        } = this._stropheConn;
                        this.isUsingWebSocket ? e ? e.isSupported() ? e.getResumeToken() || (ko.info("Enabling XEP-0198 stream management"), e.enable(!0)) : ko.warn("Stream resume enabled, but XEP-0198 is not supported by the server") : ko.warn("Stream resume enabled, but Strophe streamManagement plugin is not installed") : ko.warn("Stream resume enabled, but WebSockets are not enabled")
                    }
                    _maybeStartWSKeepAlive() {
                        const {
                            websocketKeepAlive: e
                        } = this._options;
                        if (this._usesWebsocket && e > 0) {
                            this._wsKeepAlive || ko.info(`WebSocket keep alive interval: ${e}ms`), clearTimeout(this._wsKeepAlive);
                            const t = e + 60 * Math.random() * 1e3;
                            ko.debug(`Scheduling next WebSocket keep-alive in ${t}ms`), this._wsKeepAlive = setTimeout((() => this._keepAliveAndCheckShard().then((() => this._maybeStartWSKeepAlive()))), t)
                        }
                    }
                    _keepAliveAndCheckShard() {
                        const {
                            shard: e,
                            websocketKeepAliveUrl: t
                        } = this._options, n = t || this.service.replace("wss://", "https://").replace("ws://", "http://");
                        return fetch(n).then((t => {
                            if (!e) return;
                            const n = t.headers.get("x-jitsi-shard");
                            n !== e && (ko.error(`Detected that shard changed from ${e} to ${n}`), this.eventEmitter.emit(Mo.Events.CONN_SHARD_CHANGED))
                        })).catch((e => {
                            ko.error(`Websocket Keep alive failed for url: ${n}`, {
                                error: e
                            })
                        }))
                    }
                    _processDeferredIQs() {
                        for (const e of this._deferredIQs)
                            if (e.iq) {
                                clearTimeout(e.timeout);
                                const t = Date.now() - e.start;
                                this.sendIQ(e.iq, (t => e.resolve(t)), (t => e.reject(t)), t)
                            } this._deferredIQs = []
                    }
                    send(e) {
                        var t, n, i;
                        if (!this.connected) throw ko.error(`Trying to send stanza while not connected. Status:${this._status} Proto:${this.isUsingWebSocket?null===(t=this._stropheConn)||void 0===t||null===(n=t._proto)||void 0===n||null===(i=n.socket)||void 0===i?void 0:i.readyState:"bosh"}`), new Error("Not connected");
                        this._stropheConn.send(e)
                    }
                    sendIQ(e, t, n, i) {
                        if (this.connected) return this._stropheConn.sendIQ(e, t, n, i);
                        n("Not connected")
                    }
                    sendIQ2(e, t) {
                        let {
                            timeout: n
                        } = t;
                        return new Promise(((t, i) => {
                            if (this.connected) this.sendIQ(e, (e => t(e)), (e => i(e)), n);
                            else {
                                const r = {
                                    iq: e,
                                    resolve: t,
                                    reject: i,
                                    start: Date.now(),
                                    timeout: setTimeout((() => {
                                        r.iq = void 0, i(void 0)
                                    }), n)
                                };
                                this._deferredIQs.push(r)
                            }
                        }))
                    }
                    _onPingErrorThresholdExceeded() {
                        this.isUsingWebSocket && (ko.warn("Ping error threshold exceeded - killing the WebSocket"), this.closeWebsocket())
                    }
                    sendPresence(e, t, n, i) {
                        this.connected ? this._stropheConn.sendPresence(e, t, n, i) : n("Not connected")
                    }
                    sendUnavailableBeacon() {
                        if (!navigator.sendBeacon || this._stropheConn.disconnecting || !this._stropheConn.connected) return !1;
                        this._stropheConn._changeConnectStatus(St.Strophe.Status.DISCONNECTING), this._stropheConn.disconnecting = !0;
                        const e = this._stropheConn._proto._buildBody().attrs({
                                type: "terminate"
                            }),
                            t = (0, St.$pres)({
                                xmlns: St.Strophe.NS.CLIENT,
                                type: "unavailable"
                            });
                        e.cnode(t.tree());
                        const n = navigator.sendBeacon(-1 === this.service.indexOf("https://") ? `https:${this.service}` : this.service, St.Strophe.serialize(e.tree()));
                        return ko.info(`Successfully send unavailable beacon ${n}`), this._stropheConn._proto._abortAllRequests(), this._stropheConn._doDisconnect(), !0
                    }
                    _tryResumingConnection() {
                        const {
                            streamManagement: e
                        } = this._stropheConn;
                        return !(!e || !e.getResumeToken() || (this._resumeTask.schedule(), 0))
                    }
                }
                var Lo = n(667),
                    Fo = n.n(Lo);
                const jo = (0, E.getLogger)("modules/settings/Settings.js");
                let Vo, Uo;
                const Ho = {
                    _storage: di,
                    init(e) {
                        this._storage = e || di
                    },
                    get callStatsUserName() {
                        return Vo || (Vo = this._storage.getItem("callStatsUserName"), Vo || (Vo = function() {
                            const e = Fo().generateUsername();
                            return jo.log("generated stats id", e), e
                        }(), this._storage.setItem("callStatsUserName", Vo))), Vo
                    },
                    get machineId() {
                        if (!Uo) {
                            const e = this._storage.getItem("billingId");
                            Uo = e || this._storage.getItem("jitsiMeetId"), e ? this._storage.setItem("jitsiMeetId", e) : Uo || (Uo = function() {
                                const e = $o() + $o() + $o() + $o();
                                return jo.log("generated id", e), e
                            }(), this._storage.setItem("jitsiMeetId", Uo))
                        }
                        return Uo
                    },
                    get sessionId() {
                        return this._storage.getItem("sessionId")
                    },
                    set sessionId(e) {
                        e ? this._storage.setItem("sessionId", e) : this._storage.removeItem("sessionId")
                    }
                };

                function $o() {
                    return `${Math.random().toString(16)}000000000`.substr(2, 8)
                }
                const Jo = n(514),
                    {
                        XMPPEvents: Bo
                    } = n(609),
                    qo = (0, E.getLogger)("modules/xmpp/moderator.js");

                function Go(e) {
                    let t = 1;
                    return function(n) {
                        if (n) return void(t = 1);
                        const i = Math.pow(2, t - 1);
                        return t += 1, Math.min(i * e, 12e4)
                    }
                }
                class zo extends Cr {
                    constructor(e) {
                        var t, n;

                        function i(e) {
                            if (e.data && e.data.sessionId) {
                                if (e.origin !== window.location.origin) return void qo.warn(`Ignoring sessionId from different origin: ${e.origin}`);
                                Ho.sessionId = e.data.sessionId
                            }
                        }
                        super(), this.getNextTimeout = Go(1e3), this.getNextErrorTimeout = Go(1e3), this.options = e.options, this.sipGatewayEnabled = !1, this.xmpp = e, this.connection = e.connection, this.targetJid = null === (t = this.options.hosts) || void 0 === t ? void 0 : t.focus, this.targetJid || (this.targetJid = `focus.${null===(n=this.options.hosts)||void 0===n?void 0:n.domain}`), this.targetUrl = this.options.conferenceRequestUrl, this.mode = this.targetUrl ? "http" : "xmpp", qo.info(`Using ${this.mode} for conference requests.`), this.focusUserJids = new Set, this.options.focusUserJid && this.focusUserJids.add(this.options.focusUserJid), window.addEventListener ? window.addEventListener("message", i, !1) : window.attachEvent("onmessage", i)
                    }
                    isFocusJid(e) {
                        if (!e) return !1;
                        for (const t of this.focusUserJids)
                            if (0 === e.indexOf(`${t}/`)) return !0;
                        return !1
                    }
                    isSipGatewayEnabled() {
                        return this.sipGatewayEnabled
                    }
                    _createConferenceRequest(e) {
                        var t, n;
                        const {
                            sessionId: i
                        } = Ho, r = this.options, o = {};
                        void 0 !== r.startAudioMuted && (o.startAudioMuted = r.startAudioMuted), void 0 !== r.startVideoMuted && (o.startVideoMuted = r.startVideoMuted), null !== (t = null == r || null === (n = r.analytics) || void 0 === n ? void 0 : n.rtcstatsEnabled) && void 0 !== t && t || (o.rtcstatsEnabled = !1);
                        const s = {
                            properties: o,
                            machineUid: Ho.machineId,
                            room: e
                        };
                        return i && (s.sessionId = i), !Ai.isJoinAsVisitorSupported() || r.iAmRecorder || r.iAmSipGateway || (s.properties["visitors-version"] = 1, this.options.preferVisitor && (s.properties.visitor = !0)), s
                    }
                    _createConferenceIq(e) {
                        const t = this._createConferenceRequest(e),
                            n = (0, St.$iq)({
                                to: this.targetJid,
                                type: "set"
                            });
                        n.c("conference", {
                            xmlns: "http://jitsi.org/protocol/focus",
                            room: e,
                            "machine-uid": t.machineUid
                        }), t.sessionId && n.attrs({
                            "session-id": t.sessionId
                        });
                        for (const e in t.properties) t.properties.hasOwnProperty(e) && n.c("property", {
                            name: e,
                            value: t.properties[e]
                        }).up();
                        return n
                    }
                    _parseConferenceIq(e) {
                        const t = {
                            properties: {}
                        };
                        return t.focusJid = _t()(e).find("conference").attr("focusjid"), t.sessionId = _t()(e).find("conference").attr("session-id"), t.identity = _t()(e).find(">conference").attr("identity"), t.ready = "true" === _t()(e).find("conference").attr("ready"), t.vnode = _t()(e).find("conference").attr("vnode"), _t()(e).find(">conference>property[name='authentication'][value='true']").length > 0 && (t.properties.authentication = "true"), _t()(e).find(">conference>property[name='externalAuth'][value='true']").length > 0 && (t.properties.externalAuth = "true"), _t()(e).find(">conference>property[name='sipGatewayEnabled'][value='true']").length > 0 && (t.properties.sipGatewayEnabled = "true"), t
                    }
                    sendConferenceRequest(e) {
                        return this.conferenceRequestSent ? Promise.resolve() : (this.conferenceRequestSent = !1, new Promise((t => {
                            "xmpp" === this.mode ? (qo.info(`Sending conference request over XMPP to ${this.targetJid}`), this.connection.sendIQ(this._createConferenceIq(e), (n => this._handleIqSuccess(e, n, t)), (n => this._handleIqError(e, n, t))), this.connection.flush()) : (qo.info(`Sending conference request over HTTP to ${this.targetUrl}`), fetch(this.targetUrl, {
                                method: "POST",
                                body: JSON.stringify(this._createConferenceRequest(e)),
                                headers: {
                                    "Content-Type": "application/json"
                                }
                            }).then((n => {
                                n.ok ? n.json().then((n => {
                                    this._handleSuccess(e, n, t)
                                })) : n.text().then((i => {
                                    qo.warn(`Received HTTP ${n.status} ${n.statusText}. Body: ${i}`);
                                    const r = 400 === n.status && i.indexOf("400 invalid-session") > 0,
                                        o = 403 === n.status;
                                    this._handleError(e, r, o, t)
                                })).catch((t => {
                                    qo.warn(`Error: ${t}`), this._handleError(e)
                                }))
                            })).catch((t => {
                                qo.warn(`Error: ${t}`), this._handleError(e)
                            })))
                        })).then((() => {
                            this.conferenceRequestSent = !0
                        })))
                    }
                    _handleSuccess(e, t, n) {
                        this.getNextErrorTimeout(!0), t.focusJid ? (qo.info(`Adding focus JID: ${t.focusJid}`), this.focusUserJids.add(t.focusJid)) : qo.warn("Conference request response contained no focusJid.");
                        const i = "true" === t.properties.authentication;
                        if (qo.info(`Authentication enabled: ${i}`), t.sessionId && (qo.info(`Received sessionId: ${t.sessionId}`), Ho.sessionId = t.sessionId), this.eventEmitter.emit(Jo.IDENTITY_UPDATED, i, t.identity), this.sipGatewayEnabled = t.properties.sipGatewayEnabled, qo.info(`Sip gateway enabled: ${this.sipGatewayEnabled}`), t.ready) {
                            if (this.getNextTimeout(!0), t.vnode && !this.options.iAmRecorder && !this.options.iAmSipGateway) return qo.warn(`Redirected to: ${t.vnode} with focusJid ${t.focusJid}`), void this.xmpp.eventEmitter.emit(pr, t.vnode, t.focusJid);
                            qo.info("Conference-request successful, ready to join the MUC."), n()
                        } else {
                            const t = this.getNextTimeout();
                            qo.info(`Not ready yet, will retry in ${t} ms.`), window.setTimeout((() => this.sendConferenceRequest(e).then(n)), t)
                        }
                    }
                    _handleError(e, t, n, i) {
                        if (t && (qo.info("Session expired! - removing"), Ho.sessionId = void 0), n) return qo.warn("Unauthorized to start the conference"), void this.eventEmitter.emit(Bo.AUTHENTICATION_REQUIRED);
                        const r = this.getNextErrorTimeout();
                        t && r < 6e4 ? (qo.info(`Invalid session, will retry after ${r} ms.`), this.getNextTimeout(!0), window.setTimeout((() => this.sendConferenceRequest(e).then(i)), r)) : (qo.error("Failed to get a successful response, giving up."), this.eventEmitter.emit(Bo.FOCUS_DISCONNECTED))
                    }
                    _handleIqError(e, t, n) {
                        const i = _t()(t).find(">error>reservation-error");
                        if (i.length) {
                            const e = i.attr("error-code"),
                                n = _t()(t).find(">error>text");
                            let r;
                            return n && (r = n.text()), void this.eventEmitter.emit(Bo.RESERVATION_ERROR, e, r)
                        }
                        const r = Boolean(_t()(t).find(">error>session-invalid").length || _t()(t).find(">error>not-acceptable").length),
                            o = _t()(t).find(">error>not-authorized").length > 0;
                        this._handleError(e, r, o, n)
                    }
                    _handleIqSuccess(e, t, n) {
                        const i = this._parseConferenceIq(t);
                        this._handleSuccess(e, i, n)
                    }
                    authenticate(e) {
                        return new Promise(((t, n) => {
                            this.connection.sendIQ(this._createConferenceIq(e), (e => {
                                const n = _t()(e).find("conference").attr("session-id");
                                n ? (qo.info(`Received sessionId:  ${n}`), Ho.sessionId = n) : qo.warn("Response did not contain a session-id"), t()
                            }), (e => n({
                                error: _t()(e).find("iq>error :first").prop("tagName"),
                                message: _t()(e).find("iq>error>text").text()
                            })))
                        }))
                    }
                    logout(e) {
                        const t = (0, St.$iq)({
                                to: this.targetJid,
                                type: "set"
                            }),
                            {
                                sessionId: n
                            } = Ho;
                        n ? (t.c("logout", {
                            xmlns: "http://jitsi.org/protocol/focus",
                            "session-id": n
                        }), this.connection.sendIQ(t, (t => {
                            qo.info("Log out OK", t), Ho.sessionId = void 0, e()
                        }), (e => {
                            qo.error("Logout error", e)
                        }))) : e()
                    }
                }
                let Ko;
                ! function(e) {
                    e.ON = "on", e.OFF = "off"
                }(Ko || (Ko = {}));
                const Wo = Ko.ON,
                    Xo = Ko.OFF;
                var Yo = n(408);
                const Qo = (0, E.getLogger)("modules/xmpp/AVModeration.js");
                class Zo {
                    constructor(e) {
                        this._xmpp = e.xmpp, this._mainRoom = e, this._moderationEnabledByType = {
                            [Ri.AUDIO]: !1,
                            [Ri.VIDEO]: !1
                        }, this._whitelistAudio = [], this._whitelistVideo = [], this._onMessage = this._onMessage.bind(this), this._xmpp.addListener(Hi.XMPPEvents.AV_MODERATION_RECEIVED, this._onMessage)
                    }
                    dispose() {
                        this._xmpp.removeListener(Hi.XMPPEvents.AV_MODERATION_RECEIVED, this._onMessage)
                    }
                    isSupported() {
                        return Boolean(this._xmpp.avModerationComponentAddress)
                    }
                    enable(e, t) {
                        if (!this.isSupported() || !this._mainRoom.isModerator()) return void Qo.error(`Cannot enable:${e} AV moderation supported:${this.isSupported()},\n                moderator:${this._mainRoom.isModerator()}`);
                        if (e === this._moderationEnabledByType[t]) return void Qo.warn(`Moderation already in state:${e} for mediaType:${t}`);
                        const n = (0, St.$msg)({
                            to: this._xmpp.avModerationComponentAddress
                        });
                        n.c("av_moderation", {
                            enable: e,
                            mediaType: t
                        }).up(), this._xmpp.connection.send(n)
                    }
                    approve(e, t) {
                        if (!this.isSupported() || !this._mainRoom.isModerator()) return void Qo.error(`Cannot approve in AV moderation supported:${this.isSupported()},\n                moderator:${this._mainRoom.isModerator()}`);
                        const n = (0, St.$msg)({
                            to: this._xmpp.avModerationComponentAddress
                        });
                        n.c("av_moderation", {
                            mediaType: e,
                            jidToWhitelist: t
                        }).up(), this._xmpp.connection.send(n)
                    }
                    reject(e, t) {
                        if (!this.isSupported() || !this._mainRoom.isModerator()) return void Qo.error(`Cannot reject in AV moderation supported:${this.isSupported()},\n                moderator:${this._mainRoom.isModerator()}`);
                        const n = (0, St.$msg)({
                            to: this._xmpp.avModerationComponentAddress
                        });
                        n.c("av_moderation", {
                            mediaType: e,
                            jidToBlacklist: t
                        }).up(), this._xmpp.connection.send(n)
                    }
                    _onMessage(e) {
                        const {
                            removed: t,
                            mediaType: n,
                            enabled: i,
                            approved: r,
                            actor: o,
                            whitelists: s
                        } = e;
                        if (s) {
                            const e = n === Ri.AUDIO ? this._whitelistAudio : this._whitelistVideo,
                                i = Array.isArray(s[n]) ? s[n] : [];
                            t ? e.filter((e => !i.includes(e))).forEach((e => this._xmpp.eventEmitter.emit(Hi.XMPPEvents.AV_MODERATION_PARTICIPANT_REJECTED, n, e))) : i.filter((t => !e.includes(t))).forEach((e => this._xmpp.eventEmitter.emit(Hi.XMPPEvents.AV_MODERATION_PARTICIPANT_APPROVED, n, e))), n === Ri.AUDIO ? this._whitelistAudio = i : this._whitelistVideo = i
                        } else void 0 !== i && this._moderationEnabledByType[n] !== i ? (this._moderationEnabledByType[n] = i, this._xmpp.eventEmitter.emit(Hi.XMPPEvents.AV_MODERATION_CHANGED, i, n, o)) : t ? this._xmpp.eventEmitter.emit(Hi.XMPPEvents.AV_MODERATION_REJECTED, n) : r && this._xmpp.eventEmitter.emit(Hi.XMPPEvents.AV_MODERATION_APPROVED, n)
                    }
                }
                const es = "features/breakout-rooms",
                    ts = {
                        ADD: `${es}/add`,
                        MOVE_TO_ROOM: `${es}/move-to-room`,
                        REMOVE: `${es}/remove`,
                        RENAME: `${es}/rename`
                    },
                    ns = `${es}/move-to-room`,
                    is = `${es}/update`,
                    rs = (0, E.getLogger)("modules/xmpp/BreakoutRooms.js");
                class os {
                    constructor(e) {
                        this.room = e, this._handleMessages = this._handleMessages.bind(this), this.room.xmpp.addListener(Hi.XMPPEvents.BREAKOUT_ROOMS_EVENT, this._handleMessages), this._rooms = {}
                    }
                    dispose() {
                        this.room.xmpp.removeListener(Hi.XMPPEvents.BREAKOUT_ROOMS_EVENT, this._handleMessages)
                    }
                    createBreakoutRoom(e) {
                        if (!this.isSupported() || !this.room.isModerator()) return void rs.error(`Cannot create breakout room - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
                        const t = {
                            type: ts.ADD,
                            subject: e
                        };
                        this._sendMessage(t)
                    }
                    removeBreakoutRoom(e) {
                        if (!this.isSupported() || !this.room.isModerator()) return void rs.error(`Cannot remove breakout room - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
                        const t = {
                            type: ts.REMOVE,
                            breakoutRoomJid: e
                        };
                        this._sendMessage(t)
                    }
                    renameBreakoutRoom(e, t) {
                        if (!this.isSupported() || !this.room.isModerator()) return void rs.error(`Cannot rename breakout room - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
                        const n = {
                            type: ts.RENAME,
                            breakoutRoomJid: e,
                            subject: t
                        };
                        this._sendMessage(n)
                    }
                    sendParticipantToRoom(e, t) {
                        if (!this.isSupported() || !this.room.isModerator()) return void rs.error(`Cannot send participant to room - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
                        const n = {
                            type: ts.MOVE_TO_ROOM,
                            participantJid: e,
                            roomJid: t
                        };
                        this._sendMessage(n)
                    }
                    isFeatureSupported(e) {
                        return Boolean((this.room.xmpp.breakoutRoomsFeatures || {})[e])
                    }
                    isSupported() {
                        return Boolean(this.getComponentAddress())
                    }
                    getComponentAddress() {
                        return this.room.xmpp.breakoutRoomsComponentAddress
                    }
                    _setIsBreakoutRoom(e) {
                        this._isBreakoutRoom = e
                    }
                    isBreakoutRoom() {
                        return void 0 !== this._isBreakoutRoom ? this._isBreakoutRoom : St.Strophe.getDomainFromJid(this.room.myroomjid) === this.getComponentAddress()
                    }
                    _setMainRoomJid(e) {
                        this._mainRoomJid = e
                    }
                    getMainRoomJid() {
                        return this._mainRoomJid
                    }
                    _handleMessages(e) {
                        switch (e.event) {
                            case ns:
                                this.room.eventEmitter.emit(Hi.XMPPEvents.BREAKOUT_ROOMS_MOVE_TO_ROOM, e.roomJid);
                                break;
                            case is: {
                                const t = this._filterUpdatePayload(e);
                                this._rooms = t.rooms, this.room.eventEmitter.emit(Hi.XMPPEvents.BREAKOUT_ROOMS_UPDATED, t);
                                break
                            }
                        }
                    }
                    _filterUpdatePayload(e) {
                        const t = this.room.options.hiddenDomain,
                            {
                                rooms: n
                            } = e,
                            i = {};
                        return Object.entries(n).forEach((e => {
                            let [n, r] = e;
                            const {
                                participants: o = {}
                            } = r, s = {};
                            Object.entries(o).forEach((e => {
                                let [n, i] = e;
                                St.Strophe.getDomainFromJid(i.jid) !== t && (s[n] = i)
                            })), i[n] = {
                                ...r,
                                participants: s
                            }
                        })), {
                            ...e,
                            rooms: i
                        }
                    }
                    _sendMessage(e) {
                        const t = (0, St.$msg)({
                            to: this.getComponentAddress()
                        });
                        t.c("breakout_rooms", e).up(), this.room.xmpp.connection.send(t)
                    }
                }
                const ss = (0, E.getLogger)("modules/xmpp/Lobby.js"),
                    as = "email";
                class ds {
                    constructor(e) {
                        this.xmpp = e.xmpp, this.mainRoom = e;
                        const t = this._maybeJoinLobbyRoom.bind(this);
                        this.mainRoom.addEventListener(Hi.XMPPEvents.LOCAL_ROLE_CHANGED, t), this.mainRoom.addEventListener(Hi.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, t), this.mainRoom.addEventListener(Hi.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, (e => {
                            this.lobbyRoomJid = e
                        }))
                    }
                    isSupported() {
                        return this.xmpp.lobbySupported
                    }
                    enable() {
                        return this.isSupported() ? this.mainRoom.initialDiscoRoomInfoReceived ? this.mainRoom.membersOnlyEnabled ? Promise.resolve() : new Promise(((e, t) => {
                            this.mainRoom.setMembersOnly(!0, e, t)
                        })) : new Promise(((e, t) => {
                            let n = [];
                            const i = () => {
                                n.forEach((e => e())), n = []
                            };
                            n.push(this.mainRoom.addCancellableListener(Hi.XMPPEvents.ROOM_DISCO_INFO_UPDATED, (() => {
                                i(), this.mainRoom.membersOnlyEnabled ? e() : this.mainRoom.setMembersOnly(!0, e, t)
                            }))), n.push(this.mainRoom.addCancellableListener(Hi.XMPPEvents.ROOM_DISCO_INFO_FAILED, (e => {
                                i(), t(e)
                            })))
                        })) : Promise.reject(new Error("Lobby not supported!"))
                    }
                    disable() {
                        this.isSupported() && this.mainRoom.isModerator() && this.lobbyRoom && this.mainRoom.membersOnlyEnabled && this.mainRoom.setMembersOnly(!1)
                    }
                    sendMessage(e) {
                        this.lobbyRoom && this.lobbyRoom.sendMessage(JSON.stringify(e), "json-message")
                    }
                    sendPrivateMessage(e, t) {
                        this.lobbyRoom && this.lobbyRoom.sendPrivateMessage(e, JSON.stringify(t), "json-message")
                    }
                    getLocalId() {
                        if (this.lobbyRoom) return St.Strophe.getResourceFromJid(this.lobbyRoom.myroomjid)
                    }
                    addMessageListener(e) {
                        if (this.lobbyRoom) {
                            const t = (t, n) => {
                                e(n, St.Strophe.getResourceFromJid(t))
                            };
                            return this.lobbyRoom.on(Hi.XMPPEvents.JSON_MESSAGE_RECEIVED, t), t
                        }
                    }
                    removeMessageHandler(e) {
                        this.lobbyRoom && this.lobbyRoom.off(Hi.XMPPEvents.JSON_MESSAGE_RECEIVED, e)
                    }
                    leave() {
                        return this.lobbyRoom ? this.lobbyRoom.leave().then((() => {
                            this.lobbyRoom = void 0, ss.info("Lobby room left!")
                        })).catch((() => {})) : Promise.reject(new Error("The lobby has already been left"))
                    }
                    setLobbyRoomJid(e) {
                        this.lobbyRoomJid = e
                    }
                    _maybeJoinLobbyRoom() {
                        this.isSupported() && this.mainRoom.joined && this.mainRoom.isModerator() && this.mainRoom.membersOnlyEnabled && !this.lobbyRoom && this.join().then((() => ss.info("Joined lobby room"))).catch((e => ss.error("Failed joining lobby", e)))
                    }
                    join(e, t) {
                        const n = this.mainRoom.joined && this.mainRoom.isModerator();
                        if (!this.lobbyRoomJid) return Promise.reject(new Error("Missing lobbyRoomJid, cannot join lobby room."));
                        const i = St.Strophe.getNodeFromJid(this.lobbyRoomJid),
                            r = St.Strophe.getDomainFromJid(this.lobbyRoomJid);
                        return this.lobbyRoom = this.xmpp.createRoom(i, {
                            customDomain: r,
                            disableDiscoInfo: !0,
                            disableFocus: !0,
                            enableLobby: !1
                        }), e && this.lobbyRoom.addOrReplaceInPresence("nick", {
                            attributes: {
                                xmlns: "http://jabber.org/protocol/nick"
                            },
                            value: e
                        }), n ? (this.lobbyRoom.addPresenceListener(as, ((e, t) => {
                            this.mainRoom.eventEmitter.emit(Hi.XMPPEvents.MUC_LOBBY_MEMBER_UPDATED, t, {
                                email: e.value
                            })
                        })), this.lobbyRoom.addEventListener(Hi.XMPPEvents.MUC_MEMBER_JOINED, ((e, t, n, i, r, o, s, a, d) => {
                            if (!Object.values(this.mainRoom.members).find((e => e.jid === d))) {
                                for (const e of Object.values(this.mainRoom.getBreakoutRooms()._rooms))
                                    if (Object.values(e.participants).find((e => e.jid === d))) return;
                                this.mainRoom.eventEmitter.emit(Hi.XMPPEvents.MUC_LOBBY_MEMBER_JOINED, St.Strophe.getResourceFromJid(e), t, s ? s.avatar : void 0)
                            }
                        })), this.lobbyRoom.addEventListener(Hi.XMPPEvents.MUC_MEMBER_LEFT, (e => {
                            this.mainRoom.eventEmitter.emit(Hi.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, St.Strophe.getResourceFromJid(e))
                        })), this.lobbyRoom.addEventListener(Hi.XMPPEvents.MUC_DESTROYED, (() => {
                            Object.keys(this.lobbyRoom.members).forEach((e => this.mainRoom.eventEmitter.emit(Hi.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, St.Strophe.getResourceFromJid(e)))), this.lobbyRoom.clean(), this.lobbyRoom = void 0, ss.info("Lobby room left(destroyed)!")
                        }))) : (this.lobbyRoom.addEventListener(Hi.XMPPEvents.KICKED, (e => {
                            if (e) return this.mainRoom.eventEmitter.emit(Hi.XMPPEvents.MUC_DENIED_ACCESS), void this.lobbyRoom.clean()
                        })), this.mainRoom.addEventListener(Hi.XMPPEvents.INVITE_MESSAGE_RECEIVED, ((e, t, n, i) => {
                            ss.debug(`Received approval to join ${e} ${t} ${n}`), e === this.mainRoom.roomjid && this.mainRoom.join(i)
                        })), this.lobbyRoom.addEventListener(Hi.XMPPEvents.MUC_DESTROYED, ((e, t) => {
                            var n;
                            null === (n = this.lobbyRoom) || void 0 === n || n.clean(), this.lobbyRoom = void 0, ss.info("Lobby room left(destroyed)!"), t ? this.mainRoom.join() : this.mainRoom.eventEmitter.emit(Hi.XMPPEvents.MUC_DESTROYED, e)
                        })), this.mainRoom.addEventListener(Hi.XMPPEvents.MUC_JOINED, (() => {
                            this.leave().catch((() => {}))
                        }))), new Promise(((e, i) => {
                            this.lobbyRoom.addEventListener(Hi.XMPPEvents.MUC_JOINED, (() => {
                                e(), t && !n && this.lobbyRoom.addOrReplaceInPresence(as, {
                                    value: t
                                }) && this.lobbyRoom.sendPresence()
                            })), this.lobbyRoom.addEventListener(Hi.XMPPEvents.ROOM_JOIN_ERROR, i), this.lobbyRoom.addEventListener(Hi.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR, i), this.lobbyRoom.addEventListener(Hi.XMPPEvents.ROOM_CONNECT_ERROR, i), this.lobbyRoom.join()
                        }))
                    }
                    denyAccess(e) {
                        if (!this.isSupported() || !this.mainRoom.isModerator()) return;
                        const t = Object.keys(this.lobbyRoom.members).find((t => St.Strophe.getResourceFromJid(t) === e));
                        t ? this.lobbyRoom.kick(t) : ss.error(`Not found member for ${e} in lobby room.`)
                    }
                    approveAccess(e) {
                        if (!this.isSupported() || !this.mainRoom.isModerator()) return;
                        let t = this.mainRoom.roomjid;
                        this.mainRoom.getBreakoutRooms().isBreakoutRoom() && (t = this.mainRoom.getBreakoutRooms().getMainRoomJid());
                        const n = [];
                        let i = e;
                        if (Array.isArray(e) || (i = [e]), i.forEach((e => {
                                const t = Object.keys(this.lobbyRoom.members).find((t => St.Strophe.getResourceFromJid(t) === e));
                                t ? n.push(this.lobbyRoom.members[t].jid) : ss.error(`Not found member for ${t} in lobby room.`)
                            })), n.length > 0) {
                            const e = (0, St.$msg)({
                                to: t
                            }).c("x", {
                                xmlns: "http://jabber.org/protocol/muc#user"
                            });
                            n.forEach((t => {
                                e.c("invite", {
                                    to: t
                                }).up()
                            })), this.xmpp.connection.sendIQ(e, (() => {}), (e => {
                                ss.error(`Error sending invite for ${n}`, e)
                            }))
                        }
                    }
                }
                const cs = (0, E.getLogger)("modules/xmpp/RoomMetadata.ts");
                class ls {
                    constructor(e) {
                        this.room = e, this._handleMessages = this._handleMessages.bind(this), this.room.xmpp.addListener(Hi.XMPPEvents.ROOM_METADATA_EVENT, this._handleMessages), this._metadata = {}
                    }
                    dispose() {
                        this.room.xmpp.removeListener(Hi.XMPPEvents.ROOM_METADATA_EVENT, this._handleMessages)
                    }
                    setMetadata(e, t) {
                        if (!this.isSupported() || !this.room.isModerator()) return void cs.error(`Cannot set room metadata - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
                        const n = {
                            key: e,
                            data: t
                        };
                        this._sendMessage(n)
                    }
                    getMetadata() {
                        return this._metadata
                    }
                    isSupported() {
                        return Boolean(this.getComponentAddress())
                    }
                    getComponentAddress() {
                        return this.room.xmpp.roomMetadataComponentAddress
                    }
                    _handleMessages(e) {
                        const {
                            metadata: t
                        } = e;
                        t && !Et()(this._metadata, t) && (this._metadata = t, this.room.eventEmitter.emit(Hi.XMPPEvents.ROOM_METADATA_UPDATED, t))
                    }
                    _sendMessage(e) {
                        e[Ra] = "room_metadata";
                        const t = (0, St.$msg)({
                            to: this.getComponentAddress()
                        });
                        t.c("room_metadata", {
                            room: this.room.roomjid,
                            xmlns: "http://jitsi.org/jitmeet"
                        }, JSON.stringify(e)).up(), this.room.xmpp.connection.send(t)
                    }
                }
                const hs = (0, E.getLogger)("modules/xmpp/ChatRoom.js"),
                    us = {
                        packet2JSON(e, t) {
                            for (const n of Array.from(e.children)) {
                                const e = {
                                    attributes: {},
                                    children: [],
                                    tagName: n.tagName
                                };
                                for (const t of Array.from(n.attributes)) e.attributes[t.name] = t.value;
                                const i = St.Strophe.getText(n);
                                i && (e.value = St.Strophe.xmlunescape(i)), t.push(e), this.packet2JSON(n, e.children)
                            }
                        },
                        json2packet(e, t) {
                            for (let n = 0; n < e.length; n++) {
                                const i = e[n];
                                i && (t.c(i.tagName, i.attributes), i.value && t.t(i.value), i.children && this.json2packet(i.children, t), t.up())
                            }
                        }
                    };

                function ps(e, t) {
                    const n = [];
                    for (let i = 0; i < e.length; i++) e[i].tagName === t && n.push(e[i]);
                    return n
                }
                const ms = ["owner", "admin", "member"];

                function gs(e, t) {
                    const n = {},
                        i = e.children.find((e => "user" === e.tagName));
                    if (i) {
                        n.user = {};
                        const e = ["id", "name", "avatar"];
                        t && e.push("hidden-from-recorder");
                        for (const t of e) {
                            const e = i.children.find((e => e.tagName === t));
                            e && (n.user[t] = e.value)
                        }
                    }
                    const r = e.children.find((e => "group" === e.tagName));
                    return r && (n.group = r.value), n
                }
                class fs extends Cr {
                    constructor(e, t, n, i, r) {
                        super(), this.xmpp = i, this.connection = e, this.roomjid = St.Strophe.getBareJidFromJid(t), this.myroomjid = t, this.password = n, this.replaceParticipant = !1, hs.info(`Joining MUC as ${this.myroomjid}`), this.members = {}, this.presMap = {}, this.presHandlers = {}, this._removeConnListeners = [], this.joined = !1, this.inProgressEmitted = !1, this.role = null, this.focusMucJid = null, this.noBridgeAvailable = !1, this.options = r || {}, this.eventsForwarder = new(Fi())(this.xmpp.moderator, this.eventEmitter), this.eventsForwarder.forward(Ui().IDENTITY_UPDATED, Ui().IDENTITY_UPDATED), this.eventsForwarder.forward(Hi.XMPPEvents.AUTHENTICATION_REQUIRED, Hi.XMPPEvents.AUTHENTICATION_REQUIRED), this.eventsForwarder.forward(Hi.XMPPEvents.FOCUS_DISCONNECTED, Hi.XMPPEvents.FOCUS_DISCONNECTED), this.eventsForwarder.forward(Hi.XMPPEvents.RESERVATION_ERROR, Hi.XMPPEvents.RESERVATION_ERROR), (void 0 === this.options.enableLobby || this.options.enableLobby) && (this.lobby = new ds(this)), this.avModeration = new Zo(this), this.breakoutRooms = new os(this), this.roomMetadata = new ls(this), this.initPresenceMap(r), this.lastPresences = {}, this.phoneNumber = null, this.phonePin = null, this.connectionTimes = {}, this.participantPropertyListener = null, this.locked = !1, this.transcriptionStatus = Xo, this.initialDiscoRoomInfoReceived = !1
                    }
                    initPresenceMap() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        this.presMap.to = this.myroomjid, this.presMap.xns = "http://jabber.org/protocol/muc", this.presMap.nodes = [], e.statsId && this.presMap.nodes.push({
                            tagName: "stats-id",
                            value: e.statsId
                        }), this.presenceUpdateTime = Date.now()
                    }
                    join(e, t) {
                        return this.password = e, this.replaceParticipant = t, new Promise((e => {
                            this.options.disableFocus && hs.info(`Conference focus disabled for ${this.roomjid}`), (this.options.disableFocus ? Promise.resolve() : this.xmpp.moderator.sendConferenceRequest(this.roomjid)).then((() => {
                                this.sendPresence(!0), this._removeConnListeners.push(this.connection.addCancellableListener(Mo.Events.CONN_STATUS_CHANGED, this.onConnStatusChanged.bind(this))), e()
                            }))
                        }))
                    }
                    sendPresence(e) {
                        const t = this.presMap.to;
                        if (!this.connection || !this.connection.connected || !t || !this.joined && !e) return;
                        const n = (0, St.$pres)({
                            to: t
                        });
                        e && (this.replaceParticipant && n.c("flip_device").up(), n.c("x", {
                            xmlns: this.presMap.xns
                        }), this.password && n.c("password").t(this.password).up(), this.xmpp.moderator.targetUrl && n.c("billingid").t(Ho.machineId).up(), n.up()), us.json2packet(this.presMap.nodes, n), this.presenceSyncTime = Date.now(), this.connection.send(n), e && this.connection.flush()
                    }
                    doLeave(e) {
                        hs.log("do leave", this.myroomjid);
                        const t = (0, St.$pres)({
                            to: this.myroomjid,
                            type: "unavailable"
                        });
                        e && t.c("status").t(e).up(), this.presMap.length = 0, !this.connection.isUsingWebSocket && this.connection.flush(), this.connection.send(t), this.connection.flush()
                    }
                    discoRoomInfo() {
                        const e = (0, St.$iq)({
                            type: "get",
                            to: this.roomjid
                        }).c("query", {
                            xmlns: St.Strophe.NS.DISCO_INFO
                        });
                        this.connection.sendIQ(e, (e => {
                            const t = 1 === _t()(e).find('>query>feature[var="muc_passwordprotected"]').length;
                            t !== this.locked && (this.eventEmitter.emit(Hi.XMPPEvents.MUC_LOCK_CHANGED, t), this.locked = t);
                            const n = _t()(e).find('>query>x[type="result"]>field[var="muc#roominfo_meetingId"]>value');
                            n.length ? this.setMeetingId(n.text()) : hs.warn("No meeting ID from backend");
                            const i = _t()(e).find('>query>x[type="result"]>field[var="muc#roominfo_created_timestamp"]>value');
                            i.length ? this.eventEmitter.emit(Hi.XMPPEvents.CONFERENCE_TIMESTAMP_RECEIVED, i.text()) : hs.warn("No conference duration from backend");
                            const r = 1 === _t()(e).find('>query>feature[var="muc_membersonly"]').length,
                                o = _t()(e).find('>query>x[type="result"]>field[var="muc#roominfo_lobbyroom"]>value');
                            this.lobby && this.lobby.setLobbyRoomJid(o && o.length ? o.text() : void 0);
                            const s = _t()(e).find('>query>x[type="result"]>field[var="muc#roominfo_isbreakout"]>value'),
                                a = Boolean(null == s ? void 0 : s.text());
                            this.breakoutRooms._setIsBreakoutRoom(a);
                            const d = _t()(e).find('>query>x[type="result"]>field[var="muc#roominfo_breakout_main_room"]>value');
                            null != d && d.length && this.breakoutRooms._setMainRoomJid(d.text()), r !== this.membersOnlyEnabled && (this.membersOnlyEnabled = r, this.eventEmitter.emit(Hi.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, r));
                            const c = "1" === _t()(e).find('>query>x[type="result"]>field[var="muc#roominfo_visitorsEnabled"]>value').text();
                            c !== this.visitorsSupported && (this.visitorsSupported = c, this.eventEmitter.emit(Hi.XMPPEvents.MUC_VISITORS_SUPPORTED_CHANGED, c));
                            const l = _t()(e).find('>query>x[type="result"]>field[var="muc#roominfo_jitsimetadata"]>value'),
                                h = null == l ? void 0 : l.text();
                            if (h) try {
                                this.roomMetadata._handleMessages(vr(h))
                            } catch (e) {
                                hs.warn("Failed to set room metadata", e)
                            }
                            this.initialDiscoRoomInfoReceived = !0, this.eventEmitter.emit(Hi.XMPPEvents.ROOM_DISCO_INFO_UPDATED)
                        }), (e => {
                            hs.error("Error getting room info: ", e), this.eventEmitter.emit(Hi.XMPPEvents.ROOM_DISCO_INFO_FAILED, e)
                        }), 1e4)
                    }
                    setMeetingId(e) {
                        this.meetingId !== e && (this.meetingId && hs.warn(`Meeting Id changed from:${this.meetingId} to:${e}`), this.meetingId = e, this.eventEmitter.emit(Hi.XMPPEvents.MEETING_ID_SET, e))
                    }
                    createNonAnonymousRoom() {
                        if (this.options.disableDiscoInfo) return;
                        const e = (0, St.$iq)({
                            type: "get",
                            to: this.roomjid
                        }).c("query", {
                            xmlns: "http://jabber.org/protocol/muc#owner"
                        }).c("x", {
                            xmlns: "jabber:x:data",
                            type: "submit"
                        });
                        this.connection.sendIQ(e, (e => {
                            if (!_t()(e).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_whois"]').length) return void hs.error("non-anonymous rooms not supported");
                            const t = (0, St.$iq)({
                                to: this.roomjid,
                                type: "set"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            });
                            t.c("x", {
                                xmlns: "jabber:x:data",
                                type: "submit"
                            }), t.c("field", {
                                var: "FORM_TYPE"
                            }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), t.c("field", {
                                var: "muc#roomconfig_whois"
                            }).c("value").t("anyone").up().up(), this.connection.sendIQ(t)
                        }), (e => {
                            hs.error("Error getting room configuration form: ", e)
                        }))
                    }
                    onConnStatusChanged(e) {
                        e === Mo.Status.CONNECTED && this.presenceUpdateTime > this.presenceSyncTime && this.sendPresence()
                    }
                    onPresence(e) {
                        const t = e.getAttribute("from"),
                            n = {},
                            i = e.getElementsByTagName("status")[0];
                        i && (n.status = i.textContent || "");
                        let r = !1,
                            o = !1;
                        const s = e.getElementsByTagNameNS("http://jabber.org/protocol/muc#user", "x")[0],
                            a = s && s.getElementsByTagName("item")[0];
                        n.isReplaceParticipant = e.getElementsByTagName("flip_device").length, n.affiliation = a && a.getAttribute("affiliation"), n.role = a && a.getAttribute("role");
                        const d = a && a.getAttribute("jid");
                        n.jid = d, n.isFocus = this.xmpp.moderator.isFocusJid(d), n.isHiddenDomain = d && d.indexOf("@") > 0 && this.options.hiddenDomain === d.substring(d.indexOf("@") + 1, d.indexOf("/")), this.eventEmitter.emit(Hi.XMPPEvents.PRESENCE_RECEIVED, {
                            fromHiddenDomain: n.isHiddenDomain,
                            presence: e
                        });
                        const c = e.querySelector("x");
                        c && c.remove();
                        const l = [];
                        us.packet2JSON(e, l), this.lastPresences[t] = l;
                        for (let e = 0; e < l.length; e++) {
                            const t = l[e];
                            switch (t.tagName) {
                                case "bot": {
                                    const {
                                        attributes: e
                                    } = t;
                                    if (!e) break;
                                    const {
                                        type: i
                                    } = e;
                                    n.botType = i;
                                    break
                                }
                                case "nick":
                                    n.nick = t.value;
                                    break;
                                case "userId":
                                    n.id = t.value;
                                    break;
                                case "stats-id":
                                    n.statsID = t.value;
                                    break;
                                case "identity":
                                    n.identity = gs(t, this.options.hiddenFromRecorderFeatureEnabled);
                                    break;
                                case "features":
                                    n.features = this._extractFeatures(t);
                                    break;
                                case "stat": {
                                    const {
                                        attributes: e
                                    } = t;
                                    if (!e) break;
                                    const {
                                        name: i
                                    } = e;
                                    "version" === i && (n.version = e.value);
                                    break
                                }
                            }
                        }
                        if (!this.joined && !this.inProgressEmitted) {
                            const e = this.connectionTimes["muc.join.started"] = window.performance.now();
                            hs.log("(TIME) MUC join started:\t", e), this.eventEmitter.emit(Hi.XMPPEvents.MUC_JOIN_IN_PROGRESS), this.inProgressEmitted = !0
                        }
                        if (t === this.myroomjid) {
                            const e = "owner" === n.affiliation ? n.role : "none";
                            if (this.role !== e && (this.role = e, this.eventEmitter.emit(Hi.XMPPEvents.LOCAL_ROLE_CHANGED, this.role)), !this.joined) {
                                this.joined = !0;
                                const e = this.connectionTimes["muc.joined"] = window.performance.now();
                                hs.log("(TIME) MUC joined:\t", e), this.password && (this.locked = !0), this.presenceUpdateTime >= this.presenceSyncTime && this.sendPresence(), this.xmpp.moderator.conferenceRequestSent = !1, this.eventEmitter.emit(Hi.XMPPEvents.MUC_JOINED), !this.options.disableDiscoInfo && this.discoRoomInfo()
                            }
                        } else if (void 0 === d) hs.info("Ignoring member with undefined JID");
                        else if (void 0 === this.members[t]) this.members[t] = n, hs.log("entered", t, n), r = void 0 !== n.status, o = void 0 !== n.version, n.isFocus ? this._initFocus(t, n.features) : (this.eventEmitter.emit(Hi.XMPPEvents.MUC_MEMBER_JOINED, t, n.nick, n.role, n.isHiddenDomain, n.statsID, n.status, n.identity, n.botType, n.jid, n.features, n.isReplaceParticipant), r = !1);
                        else {
                            const e = this.members[t];
                            e.role !== n.role && (e.role = n.role, this.eventEmitter.emit(Hi.XMPPEvents.MUC_ROLE_CHANGED, t, n.role)), e.affiliation !== n.affiliation && (e.affiliation = n.affiliation), e.botType !== n.botType && (e.botType = n.botType, this.eventEmitter.emit(Hi.XMPPEvents.MUC_MEMBER_BOT_TYPE_CHANGED, t, n.botType)), n.isFocus && (e.isFocus = !0, this._initFocus(t, n.features)), n.displayName && (e.displayName = n.displayName), e.status !== n.status && (r = !0, e.status = n.status), e.version !== n.version && (o = !0, e.version = n.version), Et()(e.features, n.features) || (e.features = n.features, this.eventEmitter.emit(Hi.XMPPEvents.PARTICIPANT_FEATURES_CHANGED, t, n.features))
                        }
                        for (let e = 0; e < l.length; e++) {
                            const i = l[e];
                            switch (i.tagName) {
                                case "nick":
                                    if (!n.isFocus) {
                                        const e = this.xmpp.options.displayJids ? St.Strophe.getResourceFromJid(t) : n.nick;
                                        this.eventEmitter.emit(Hi.XMPPEvents.DISPLAY_NAME_CHANGED, t, e)
                                    }
                                    break;
                                case "bridgeNotAvailable":
                                    n.isFocus && !this.noBridgeAvailable && (this.noBridgeAvailable = !0, this.eventEmitter.emit(Hi.XMPPEvents.BRIDGE_DOWN));
                                    break;
                                case "conference-properties":
                                    if (n.isFocus) {
                                        const e = {};
                                        for (let t = 0; t < i.children.length; t++) {
                                            const {
                                                attributes: n
                                            } = i.children[t];
                                            n && n.key && (e[n.key] = n.value)
                                        }
                                        this.eventEmitter.emit(Hi.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, e), void 0 === this.restartByTerminateSupported && (this.restartByTerminateSupported = "true" === e["support-terminate-restart"], hs.info(`Jicofo supports restart by terminate: ${this.supportsRestartByTerminate()}`))
                                    }
                                    break;
                                case "transcription-status": {
                                    const {
                                        attributes: e
                                    } = i;
                                    if (!e) break;
                                    const {
                                        status: t
                                    } = e;
                                    t && t !== this.transcriptionStatus && (this.transcriptionStatus = t, this.eventEmitter.emit(Hi.XMPPEvents.TRANSCRIPTION_STATUS_CHANGED, t));
                                    break
                                }
                                case "call-control": {
                                    const e = i.attributes;
                                    if (!e) break;
                                    this.phoneNumber = e.phone || null, this.phonePin = e.pin || null, this.eventEmitter.emit(Hi.XMPPEvents.PHONE_NUMBER_CHANGED);
                                    break
                                }
                                default:
                                    this.processNode(i, t)
                            }
                        }
                        r && this.eventEmitter.emit(Hi.XMPPEvents.PRESENCE_STATUS, t, n.status), o && hs.info(`Received version for ${d}: ${n.version}`)
                    }
                    _extractFeatures(e) {
                        const t = new Set;
                        for (let n = 0; n < e.children.length; n++) {
                            const {
                                attributes: i
                            } = e.children[n];
                            i && i.var && t.add(i.var)
                        }
                        return t
                    }
                    _initFocus(e, t) {
                        this.focusMucJid = e, this.focusFeatures = t
                    }
                    setParticipantPropertyListener(e) {
                        this.participantPropertyListener = e
                    }
                    supportsRestartByTerminate() {
                        return this.restartByTerminateSupported
                    }
                    processNode(e, t) {
                        try {
                            let n = this.presHandlers[e.tagName];
                            e.tagName.startsWith("jitsi_participant_") && (n = [this.participantPropertyListener]), n && n.forEach((n => {
                                n(e, St.Strophe.getResourceFromJid(t), t)
                            }))
                        } catch (t) {
                            hs.error(`Error processing:${e.tagName} node.`, t)
                        }
                    }
                    sendMessage(e, t) {
                        const n = (0, St.$msg)({
                            to: this.roomjid,
                            type: "groupchat"
                        });
                        "body" === t ? n.c(t, {}, e) : n.c(t, {
                            xmlns: "http://jitsi.org/jitmeet"
                        }, e), this.connection.send(n), this.eventEmitter.emit(Hi.XMPPEvents.SENDING_CHAT_MESSAGE, e)
                    }
                    sendPrivateMessage(e, t, n) {
                        const i = (0, St.$msg)({
                            to: `${this.roomjid}/${e}`,
                            type: "chat"
                        });
                        "body" === n ? i.c(n, t).up() : i.c(n, {
                            xmlns: "http://jitsi.org/jitmeet"
                        }, t).up(), this.connection.send(i), this.eventEmitter.emit(Hi.XMPPEvents.SENDING_PRIVATE_CHAT_MESSAGE, t)
                    }
                    setSubject(e) {
                        const t = (0, St.$msg)({
                            to: this.roomjid,
                            type: "groupchat"
                        });
                        t.c("subject", e), this.connection.send(t)
                    }
                    onPresenceUnavailable(e, t) {
                        if (_t()(e).find('>ignore[xmlns="http://jitsi.org/jitmeet/"]').length) return !0;
                        const n = _t()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy');
                        if (n.length) {
                            let t;
                            const i = _t()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy>reason');
                            return i.length && (t = i.text()), this.eventEmitter.emit(Hi.XMPPEvents.MUC_DESTROYED, t, n.attr("jid")), this.connection.emuc.doLeave(this.roomjid), !0
                        }
                        const i = _t()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="110"]').length,
                            r = _t()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="307"]').length,
                            o = Object.keys(this.members),
                            s = _t()(e).find("flip_device").length;
                        if (r) {
                            const n = _t()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>actor');
                            let r, o;
                            n.length && (r = n.attr("nick"));
                            const a = _t()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>reason');
                            a.length && (o = a.text()), this.eventEmitter.emit(Hi.XMPPEvents.KICKED, i, r, St.Strophe.getResourceFromJid(t), o, s)
                        }
                        if (i) o.forEach((e => {
                            const t = this.members[e];
                            delete this.members[e], delete this.lastPresences[e], t.isFocus || this.eventEmitter.emit(Hi.XMPPEvents.MUC_MEMBER_LEFT, e)
                        })), this.connection.emuc.doLeave(this.roomjid), r || this.eventEmitter.emit(Hi.XMPPEvents.MUC_LEFT);
                        else {
                            const n = _t()(e).find(">status"),
                                i = this.members[t];
                            let r;
                            n.length && (r = n.text()), delete this.members[t], delete this.lastPresences[t], this.eventEmitter.emit(Hi.XMPPEvents.MUC_MEMBER_LEFT, t, r), null != i && i.isFocus && (hs.info("Focus has left the room - leaving conference"), this.eventEmitter.emit(Hi.XMPPEvents.FOCUS_LEFT))
                        }
                    }
                    onMessage(e, t) {
                        const n = e.getAttribute("type");
                        if ("error" === n) {
                            const t = _t()(e).find(">settings-error>text").text();
                            if (t.length) return this.eventEmitter.emit(Hi.XMPPEvents.SETTINGS_ERROR_RECEIVED, t), !0;
                            const n = _t()(e).find(">error>text").text();
                            return this.eventEmitter.emit(Hi.XMPPEvents.CHAT_ERROR_RECEIVED, n), !0
                        }
                        const i = _t()(e).find(">body").text(),
                            r = _t()(e).find(">subject");
                        if (r.length) {
                            const e = r.text();
                            (e || "" === e) && (this.eventEmitter.emit(Hi.XMPPEvents.SUBJECT_CHANGED, e), hs.log(`Subject is changed to ${e}`))
                        }
                        let o = _t()(e).find(">delay").attr("stamp");
                        if (!o && (o = _t()(e).find('>[xmlns="jabber:x:delay"]').attr("stamp"), o)) {
                            const e = o.match(/(\d{4})(\d{2})(\d{2}T\d{2}:\d{2}:\d{2})/);
                            o = `${e[1]}-${e[2]}-${e[3]}Z`
                        }
                        if (t === this.roomjid) {
                            let n;
                            if (_t()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="104"]').length) this.discoRoomInfo();
                            else if ((n = _t()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>invite')) && n.length) {
                                const r = _t()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>password');
                                let o;
                                r && r.length && (o = r.text()), this.eventEmitter.emit(Hi.XMPPEvents.INVITE_MESSAGE_RECEIVED, t, n.attr("from"), i, o)
                            }
                        }
                        const s = _t()(e).find(">json-message").text();
                        if (s) {
                            const e = this.xmpp.tryParseJSONAndVerify(s);
                            if (e && void 0 === o) return void this.eventEmitter.emit(Hi.XMPPEvents.JSON_MESSAGE_RECEIVED, t, e)
                        }
                        if (i)
                            if ("chat" === n) this.eventEmitter.emit(Hi.XMPPEvents.PRIVATE_MESSAGE_RECEIVED, t, i, this.myroomjid, o);
                            else if ("groupchat" === n) {
                            const n = _t()(e).find(">nick");
                            let r;
                            n.length > 0 && (r = n.text()), this.eventEmitter.emit(Hi.XMPPEvents.MESSAGE_RECEIVED, t, i, this.myroomjid, o, r, Boolean(r))
                        }
                    }
                    onPresenceError(e, t) {
                        let n;
                        if (_t()(e).find('>error[type="auth"]>not-authorized[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) hs.log("on password required", t), this.eventEmitter.emit(Hi.XMPPEvents.PASSWORD_REQUIRED);
                        else if (_t()(e).find('>error[type="cancel"]>not-allowed[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length)
                            if (St.Strophe.getDomainFromJid(e.getAttribute("to")) === this.xmpp.options.hosts.anonymousdomain) this.eventEmitter.emit(Hi.XMPPEvents.ROOM_JOIN_ERROR);
                            else {
                                hs.warn("onPresError ", e);
                                const t = _t()(e).find('>error[type="cancel"]>text[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]'),
                                    n = t.length && t.text();
                                if ("Room creation is restricted" === n && (this._roomCreationRetries || (this._roomCreationRetries = 0), this._roomCreationRetries++, this._roomCreationRetries <= 3)) {
                                    const e = xo(this._roomCreationRetries, 300, 1);
                                    return void setTimeout((() => this.join(this.password, this.replaceParticipant)), e)
                                }
                                this.eventEmitter.emit(Hi.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR, n)
                            }
                        else if (_t()(e).find(">error>service-unavailable").length) hs.warn("Maximum users limit for the room has been reached", e), this.eventEmitter.emit(Hi.XMPPEvents.ROOM_MAX_USERS_ERROR);
                        else if (_t()(e).find('>error[type="auth"]>registration-required[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
                            const t = _t()(e).find('>error[type="auth"]>lobbyroom');
                            let n;
                            t.length && (n = t.text());
                            const i = _t()(e).find('>error[type="auth"]>waiting-for-host').length > 0;
                            this.eventEmitter.emit(Hi.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, n, i)
                        } else if ((n = _t()(e).find('>error[type="modify"]>displayname-required[xmlns="http://jitsi.org/jitmeet"]')).length) {
                            var i;
                            hs.warn("display name required ", e), this.eventEmitter.emit(Hi.XMPPEvents.DISPLAY_NAME_REQUIRED, null === (i = n[0].attributes.lobby) || void 0 === i ? void 0 : i.value)
                        } else hs.warn("onPresError ", e), this.eventEmitter.emit(Hi.XMPPEvents.ROOM_CONNECT_ERROR)
                    }
                    setAffiliation(e, t) {
                        const n = (0, St.$iq)({
                            to: this.roomjid,
                            type: "set"
                        }).c("query", {
                            xmlns: "http://jabber.org/protocol/muc#admin"
                        }).c("item", {
                            affiliation: t,
                            jid: St.Strophe.getBareJidFromJid(e)
                        }).c("reason").t(`Your affiliation has been changed to '${t}'.`).up().up().up();
                        this.connection.sendIQ(n, (n => hs.log("Set affiliation of participant with jid: ", e, "to", t, n)), (e => hs.log("Set affiliation of participant error: ", e)))
                    }
                    kick(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "You have been kicked.";
                        const n = (0, St.$iq)({
                            to: this.roomjid,
                            type: "set"
                        }).c("query", {
                            xmlns: "http://jabber.org/protocol/muc#admin"
                        }).c("item", {
                            nick: St.Strophe.getResourceFromJid(e),
                            role: "none"
                        }).c("reason").t(t).up().up().up();
                        this.connection.sendIQ(n, (t => hs.log("Kick participant with jid: ", e, t)), (e => hs.log("Kick participant error: ", e)))
                    }
                    lockRoom(e, t, n, i) {
                        this.connection.sendIQ((0, St.$iq)({
                            to: this.roomjid,
                            type: "get"
                        }).c("query", {
                            xmlns: "http://jabber.org/protocol/muc#owner"
                        }), (r => {
                            if (_t()(r).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_roomsecret"]').length) {
                                const i = (0, St.$iq)({
                                    to: this.roomjid,
                                    type: "set"
                                }).c("query", {
                                    xmlns: "http://jabber.org/protocol/muc#owner"
                                });
                                i.c("x", {
                                    xmlns: "jabber:x:data",
                                    type: "submit"
                                }), i.c("field", {
                                    var: "FORM_TYPE"
                                }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), i.c("field", {
                                    var: "muc#roomconfig_roomsecret"
                                }).c("value").t(e).up().up(), i.c("field", {
                                    var: "muc#roomconfig_passwordprotectedroom"
                                }).c("value").t(null === e || 0 === e.length ? "0" : "1").up().up(), this.membersOnlyEnabled && i.c("field", {
                                    var: "muc#roomconfig_membersonly"
                                }).c("value").t("true").up().up(), i.c("field", {
                                    var: "muc#roomconfig_whois"
                                }).c("value").t("anyone").up().up(), this.connection.sendIQ(i, (() => {
                                    this.password = e, t()
                                }), n)
                            } else i()
                        }), n)
                    }
                    setMembersOnly(e, t, n) {
                        if (e && Object.values(this.members).filter((e => !e.isFocus)).length) {
                            const e = (0, St.$iq)({
                                to: this.roomjid,
                                type: "set"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#admin"
                            });
                            Object.values(this.members).forEach((t => {
                                t.jid && !ms.includes(t.affiliation) && e.c("item", {
                                    affiliation: "member",
                                    jid: St.Strophe.getBareJidFromJid(t.jid)
                                }).up()
                            })), this.xmpp.connection.sendIQ(e.up())
                        }
                        const i = n || (() => {});
                        this.xmpp.connection.sendIQ((0, St.$iq)({
                            to: this.roomjid,
                            type: "get"
                        }).c("query", {
                            xmlns: "http://jabber.org/protocol/muc#owner"
                        }), (n => {
                            if (_t()(n).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_membersonly"]').length) {
                                const n = (0, St.$iq)({
                                    to: this.roomjid,
                                    type: "set"
                                }).c("query", {
                                    xmlns: "http://jabber.org/protocol/muc#owner"
                                });
                                n.c("x", {
                                    xmlns: "jabber:x:data",
                                    type: "submit"
                                }), n.c("field", {
                                    var: "FORM_TYPE"
                                }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), n.c("field", {
                                    var: "muc#roomconfig_membersonly"
                                }).c("value").t(e ? "true" : "false").up().up(), this.locked && n.c("field", {
                                    var: "muc#roomconfig_passwordprotectedroom"
                                }).c("value").t("1").up().up(), this.xmpp.connection.sendIQ(n, t, i)
                            } else i(new Error("Setting members only room not supported!"))
                        }), i)
                    }
                    addToPresence(e, t) {
                        return this.addOrReplaceInPresence(e, t)
                    }
                    addOrReplaceInPresence(e, t) {
                        t.tagName = e;
                        const n = this.presMap.nodes.filter((t => e === t.tagName));
                        return !(1 === n.length && Et()(n[0], t) || (this.removeFromPresence(e), this.presMap.nodes.push(t), this.presenceUpdateTime = Date.now(), 0))
                    }
                    getFromPresence(e) {
                        return this.presMap.nodes.find((t => e === t.tagName))
                    }
                    removeFromPresence(e) {
                        const t = this.presMap.nodes.filter((t => e !== t.tagName));
                        this.presMap.nodes = t, this.presenceUpdateTime = Date.now()
                    }
                    addPresenceListener(e, t) {
                        if ("function" != typeof t) throw new Error('"handler" is not a function');
                        let n = this.presHandlers[e];
                        n || (this.presHandlers[e] = n = []), -1 === n.indexOf(t) ? n.push(t) : hs.warn(`Trying to add the same handler more than once for: ${e}`)
                    }
                    removePresenceListener(e, t) {
                        const n = this.presHandlers[e],
                            i = n ? n.indexOf(t) : -1; - 1 !== i ? n.splice(i, 1) : hs.warn(`Handler for: ${e} was not registered`)
                    }
                    isFocus(e) {
                        const t = this.members[e];
                        return t ? t.isFocus : null
                    }
                    isModerator() {
                        return "moderator" === this.role
                    }
                    getMediaPresenceInfo(e, t) {
                        const n = this.lastPresences[`${this.roomjid}/${e}`];
                        if (!n) return null;
                        const i = {
                            muted: !0,
                            videoType: t === Ri.VIDEO ? Yo.VideoType.CAMERA : void 0
                        };
                        let r = null;
                        if (t === Ri.AUDIO) r = ps(n, "audiomuted");
                        else {
                            if (t !== Ri.VIDEO) return hs.error(`Unsupported media type: ${t}`), null;
                            {
                                r = ps(n, "videomuted");
                                const e = ps(n, "jitsi_participant_codecType"),
                                    t = ps(n, "videoType");
                                t.length > 0 && (i.videoType = t[0].value), e.length > 0 && (i.codecType = e[0].value)
                            }
                        }
                        return r.length > 0 && (i.muted = "true" === r[0].value), i
                    }
                    getMemberRole(e) {
                        return this.members[e] ? this.members[e].role : null
                    }
                    getLastPresence(e) {
                        return this.lastPresences[`${this.roomjid}/${e}`]
                    }
                    dial(e) {
                        return this.connection.rayo.dial(e, "fromnumber", St.Strophe.getBareJidFromJid(this.myroomjid), this.password, this.focusMucJid)
                    }
                    hangup() {
                        return this.connection.rayo.hangup()
                    }
                    getLobby() {
                        return this.lobby
                    }
                    getAVModeration() {
                        return this.avModeration
                    }
                    getBreakoutRooms() {
                        return this.breakoutRooms
                    }
                    getMetadataHandler() {
                        return this.roomMetadata
                    }
                    getPhoneNumber() {
                        return this.phoneNumber
                    }
                    getPhonePin() {
                        return this.phonePin
                    }
                    getMeetingId() {
                        return this.meetingId
                    }
                    muteParticipant(e, t, n) {
                        hs.info("set mute", t, e);
                        const i = (0, St.$iq)({
                            to: this.focusMucJid,
                            type: "set"
                        }).c("mute", {
                            xmlns: `http://jitsi.org/jitmeet/${n}`,
                            jid: e
                        }).t(t.toString()).up();
                        this.connection.sendIQ(i, (e => hs.log("set mute", e)), (e => hs.log("set mute error", e)))
                    }
                    onMute(e) {
                        if (e.getAttribute("from") !== this.focusMucJid) return void hs.warn("Ignored mute from non focus peer");
                        const t = _t()(e).find("mute");
                        t.length && "true" === t.text() ? this.eventEmitter.emit(Hi.XMPPEvents.AUDIO_MUTED_BY_FOCUS, t.attr("actor")) : hs.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
                    }
                    onMuteVideo(e) {
                        if (e.getAttribute("from") !== this.focusMucJid) return void hs.warn("Ignored mute from non focus peer");
                        const t = _t()(e).find("mute");
                        t.length && "true" === t.text() ? this.eventEmitter.emit(Hi.XMPPEvents.VIDEO_MUTED_BY_FOCUS, t.attr("actor")) : hs.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
                    }
                    clean() {
                        this._removeConnListeners.forEach((e => e())), this._removeConnListeners = [], this.eventsForwarder.removeListeners(Ui().IDENTITY_UPDATED, Hi.XMPPEvents.AUTHENTICATION_REQUIRED, Hi.XMPPEvents.FOCUS_DISCONNECTED, Hi.XMPPEvents.RESERVATION_ERROR), this.joined = !1, this.inProgressEmitted = !1
                    }
                    leave(e) {
                        var t, n = this;
                        this.avModeration.dispose(), this.breakoutRooms.dispose(), this.roomMetadata.dispose();
                        const i = [];
                        return (null === (t = this.lobby) || void 0 === t ? void 0 : t.lobbyRoom) && i.push(this.lobby.leave()), i.push(new Promise(((t, i) => {
                            let r = -1;
                            const o = function() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                                n.eventEmitter.removeListener(Hi.XMPPEvents.MUC_LEFT, o), clearTimeout(r), n.clean(), e ? (n.connection.emuc.doLeave(n.roomjid), i(new Error("The timeout for the confirmation about leaving the room expired."))) : t()
                            };
                            this.joined ? (r = setTimeout((() => o(!0)), 5e3), this.eventEmitter.on(Hi.XMPPEvents.MUC_LEFT, o), this.doLeave(e)) : (this.connection.emuc.doLeave(this.roomjid), this.clean(), t())
                        }))), Promise.allSettled(i)
                    }
                    end() {
                        if (this.breakoutRooms.isBreakoutRoom()) return void hs.warn("Cannot end conference: this is a breakout room.");
                        const e = (0, St.$msg)({
                            to: this.xmpp.endConferenceComponentAddress
                        });
                        e.c("end_conference").up(), this.xmpp.connection.send(e)
                    }
                }
                const vs = (0, E.getLogger)("modules/xmpp/strophe.emuc.js");
                class _s extends Do {
                    constructor(e) {
                        super(), this.xmpp = e, this.rooms = {}
                    }
                    init(e) {
                        super.init(e), this.connection.addHandler(this.onPresence.bind(this), null, "presence", null, null, null, null), this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, "presence", "unavailable", null), this.connection.addHandler(this.onPresenceError.bind(this), null, "presence", "error", null), this.connection.addHandler(this.onMessage.bind(this), null, "message", null, null), this.connection.addHandler(this.onMute.bind(this), "http://jitsi.org/jitmeet/audio", "iq", "set", null, null), this.connection.addHandler(this.onMuteVideo.bind(this), "http://jitsi.org/jitmeet/video", "iq", "set", null, null), this.connection.addHandler(this.onVisitors.bind(this), "jitsi:visitors", "iq", "set", null, null)
                    }
                    createRoom(e, t, n) {
                        const i = St.Strophe.getBareJidFromJid(e);
                        if (this.isRoomCreated(i)) {
                            const e = "You are already in the room!";
                            throw vs.error(e), new Error(e)
                        }
                        return this.rooms[i] = new fs(this.connection, e, t, this.xmpp, n), this.eventEmitter.emit(Hi.XMPPEvents.EMUC_ROOM_ADDED, this.rooms[i]), this.rooms[i]
                    }
                    isRoomCreated(e) {
                        return e in this.rooms
                    }
                    doLeave(e) {
                        this.eventEmitter.emit(Hi.XMPPEvents.EMUC_ROOM_REMOVED, this.rooms[e]), delete this.rooms[e]
                    }
                    onPresence(e) {
                        const t = e.getAttribute("from");
                        if (e.getAttribute("type")) return !0;
                        const n = this.rooms[St.Strophe.getBareJidFromJid(t)];
                        return !n || (_t()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="201"]').length && n.createNonAnonymousRoom(), n.onPresence(e), !0)
                    }
                    onPresenceUnavailable(e) {
                        const t = e.getAttribute("from"),
                            n = this.rooms[St.Strophe.getBareJidFromJid(t)];
                        return !n || (n.onPresenceUnavailable(e, t), !0)
                    }
                    onPresenceError(e) {
                        const t = e.getAttribute("from"),
                            n = this.rooms[St.Strophe.getBareJidFromJid(t)];
                        return !n || (n.onPresenceError(e, t), !0)
                    }
                    onMessage(e) {
                        const t = e.getAttribute("from"),
                            n = this.rooms[St.Strophe.getBareJidFromJid(t)];
                        return !n || (n.onMessage(e, t), !0)
                    }
                    onMute(e) {
                        const t = e.getAttribute("from"),
                            n = this.rooms[St.Strophe.getBareJidFromJid(t)];
                        return !n || (n.onMute(e), !0)
                    }
                    onMuteVideo(e) {
                        const t = e.getAttribute("from"),
                            n = this.rooms[St.Strophe.getBareJidFromJid(t)];
                        return !n || (n.onMuteVideo(e), !0)
                    }
                    onVisitors(e) {
                        const t = e.getAttribute("from");
                        if (!this.rooms[St.Strophe.getBareJidFromJid(t)]) return !0;
                        const n = _t()(e).find('>visitors[xmlns="jitsi:visitors"]'),
                            i = _t()(e).find("promotion-response");
                        return n.length && i.length && ("true" === String(i.attr("allow")).toLowerCase() ? (vs.info("Promotion request accepted. Redirected to main room."), this.xmpp.eventEmitter.emit(pr, void 0, n.attr("focusjid"), i.attr("username"))) : (vs.info("Promotion request rejected."), this.xmpp.eventEmitter.emit(Hi.XMPPEvents.VISITORS_REJECTION))), !0
                    }
                }
                var ys = n(138),
                    Es = n.n(ys);
                const Ss = (0, E.getLogger)("modules/xmpp/JingleHelperFunctions.js");

                function bs(e, t) {
                    const n = (0, St.$build)("source", {
                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                        ssrc: t.s,
                        name: t.n
                    });
                    return t.m && n.c("parameter", {
                        name: "msid",
                        value: t.m
                    }).up(), n.c("ssrc-info", {
                        xmlns: "http://jitsi.org/jitmeet",
                        owner: e
                    }).up(), n.node
                }

                function Ts(e) {
                    const t = (0, St.$build)("ssrc-group", {
                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                        semantics: (n = e[0], "f" === n ? "FID" : "s" === n ? "SIM" : null)
                    });
                    var n;
                    for (let n = 1; n < e.length; n++) t.c("source", {
                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                        ssrc: e[n]
                    }).up();
                    return t.node
                }

                function Cs(e, t) {
                    const n = _t()(e).find("jingle")[0];
                    let i, r = _t()(n).find(`content[name="${t}"]`);
                    return r.length ? r = r[0] : (r = (0, St.$build)("content", {
                        name: t
                    }).node, n.appendChild(r)), i = _t()(r).find("description"), i.length ? i = i[0] : (i = (0, St.$build)("description", {
                        xmlns: "urn:xmpp:jingle:apps:rtp:1",
                        media: t
                    }).node, r.appendChild(i)), i
                }

                function xs(e, t) {
                    var n;
                    let i;
                    try {
                        i = vr(t.textContent)
                    } catch (e) {
                        return Ss.error(`json-message XML contained invalid JSON, ignoring: ${t.textContent}`), null
                    }
                    if (null === (n = i) || void 0 === n || !n.sources) return null;
                    const r = Cs(e, Ri.AUDIO),
                        o = Cs(e, Ri.VIDEO),
                        s = new Map;
                    for (const e in i.sources)
                        if (i.sources.hasOwnProperty(e)) {
                            const t = [],
                                n = i.sources[e],
                                c = (null == n ? void 0 : n.length) && n[0],
                                l = (null == n ? void 0 : n.length) > 1 && n[1],
                                h = (null == n ? void 0 : n.length) > 2 && n[2],
                                u = (null == n ? void 0 : n.length) > 3 && n[3];
                            if (null != c && c.length)
                                for (let n = 0; n < c.length; n++) {
                                    var a;
                                    o.appendChild(bs(e, c[n])), t.push(null === (a = c[n]) || void 0 === a ? void 0 : a.s)
                                }
                            if (null != l && l.length)
                                for (let e = 0; e < l.length; e++) o.appendChild(Ts(l[e]));
                            if (null != h && h.length)
                                for (let n = 0; n < h.length; n++) {
                                    var d;
                                    r.appendChild(bs(e, h[n])), t.push(null === (d = h[n]) || void 0 === d ? void 0 : d.s)
                                }
                            if (null != u && u.length)
                                for (let e = 0; e < u.length; e++) r.appendChild(Ts(u[e]));
                            s.set(e, t)
                        } return s
                }
                let Rs;
                ! function(e) {
                    e.INACTIVE = "inactive", e.RECVONLY = "recvonly", e.SENDONLY = "sendonly", e.SENDRECV = "sendrecv"
                }(Rs || (Rs = {}));
                const As = n(810).getLogger("modules/RTC/ScreenObtainer.js"),
                    ws = {
                        obtainStream: null,
                        init() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            this.options = e, this.obtainStream = this._createObtainStreamMethod(), this.obtainStream || As.info("Desktop sharing disabled")
                        },
                        _createObtainStreamMethod() {
                            return ci.isElectron() ? this.obtainScreenOnElectron : ci.isReactNative() && ci.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMediaRN : ci.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMedia : (As.log("Screen sharing not supported on ", ci.getName()), null)
                        },
                        _getAudioConstraints() {
                            const {
                                audioQuality: e
                            } = this.options;
                            return null == e || !e.stereo || {
                                autoGainControl: !1,
                                channelCount: 2,
                                echoCancellation: !1,
                                noiseSuppression: !1
                            }
                        },
                        isSupported() {
                            return null !== this.obtainStream
                        },
                        obtainScreenOnElectron(e, t) {
                            var n = this;
                            let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                            if (window.JitsiMeetScreenObtainer && window.JitsiMeetScreenObtainer.openDesktopPicker) {
                                const {
                                    desktopSharingFrameRate: r,
                                    desktopSharingResolution: o,
                                    desktopSharingSources: s
                                } = this.options;
                                window.JitsiMeetScreenObtainer.openDesktopPicker({
                                    desktopSharingSources: i.desktopSharingSources || s || ["screen", "window"]
                                }, (function(i, s) {
                                    if (i) {
                                        var a, d, c, l, h, u, p, m;
                                        let g = !1;
                                        if (arguments.length > 2 && void 0 !== arguments[2] && arguments[2]) {
                                            g = {};
                                            const e = n._getAudioConstraints();
                                            "boolean" != typeof e && (g = {
                                                optional: e
                                            }), "screen" === s && (g.mandatory = {
                                                chromeMediaSource: "desktop"
                                            })
                                        }
                                        const f = {
                                            audio: g,
                                            video: {
                                                mandatory: {
                                                    chromeMediaSource: "desktop",
                                                    chromeMediaSourceId: i,
                                                    minFrameRate: null !== (a = null == r ? void 0 : r.min) && void 0 !== a ? a : 5,
                                                    maxFrameRate: null !== (d = null == r ? void 0 : r.max) && void 0 !== d ? d : 5,
                                                    minWidth: null == o || null === (c = o.width) || void 0 === c ? void 0 : c.min,
                                                    minHeight: null == o || null === (l = o.height) || void 0 === l ? void 0 : l.min,
                                                    maxWidth: null !== (h = null == o || null === (u = o.width) || void 0 === u ? void 0 : u.max) && void 0 !== h ? h : window.screen.width,
                                                    maxHeight: null !== (p = null == o || null === (m = o.height) || void 0 === m ? void 0 : m.max) && void 0 !== p ? p : window.screen.height
                                                }
                                            }
                                        };
                                        navigator.mediaDevices.getUserMedia(f).then((t => {
                                            n.setContentHint(t), e({
                                                stream: t,
                                                sourceId: i,
                                                sourceType: s
                                            })
                                        })).catch((e => t(e)))
                                    } else t(new dr(Zi))
                                }), (e => t(new dr(zi, e))))
                            } else t(new dr(Ki))
                        },
                        obtainScreenFromGetDisplayMedia(e, t) {
                            let n;
                            n = navigator.getDisplayMedia ? navigator.getDisplayMedia.bind(navigator) : navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices);
                            const i = this._getAudioConstraints();
                            let r = {};
                            const o = {},
                                {
                                    desktopSharingFrameRate: s,
                                    screenShareSettings: a
                                } = this.options;
                            "object" == typeof s && (r.frameRate = s), r.frameRate && delete r.frameRate.min, ci.isChromiumBased() && (ci.isEngineVersionGreaterThan(93) && (o.preferCurrentTab = (null == a ? void 0 : a.desktopPreferCurrentTab) || !1), ci.isEngineVersionGreaterThan(104) && (o.systemAudio = (null == a ? void 0 : a.desktopSystemAudio) || "include"), ci.isEngineVersionGreaterThan(106) && (o.surfaceSwitching = (null == a ? void 0 : a.desktopSurfaceSwitching) || "include"), ci.isEngineVersionGreaterThan(106) && (null == a ? void 0 : a.desktopDisplaySurface) && (r.displaySurface = null == a ? void 0 : a.desktopDisplaySurface), ci.isEngineVersionGreaterThan(111) && (o.selfBrowserSurface = (null == a ? void 0 : a.desktopSelfBrowserSurface) || "exclude"), (null == s ? void 0 : s.max) > 5 || (r.height = 99999, r.width = 99999)), ci.isSafari() && null != a && a.desktopDisplaySurface && (r.displaySurface = null == a ? void 0 : a.desktopDisplaySurface), 0 === Object.keys(r).length && (r = !0);
                            const d = {
                                video: r,
                                audio: i,
                                ...o,
                                cursor: "always"
                            };
                            As.info("Using getDisplayMedia for screen sharing", d), n(d).then((t => {
                                if (this.setContentHint(t), ci.isChromiumBased()) {
                                    const e = t.getVideoTracks()[0];
                                    let n = 5;
                                    "number" == typeof(null == s ? void 0 : s.min) && s.min > 0 && (n = s.min);
                                    const i = {
                                        frameRate: {
                                            min: n
                                        }
                                    };
                                    try {
                                        e.applyConstraints(i)
                                    } catch (e) {
                                        As.warn(`Min fps=${n} constraint could not be applied on the desktop track,${e.message}`)
                                    }
                                }
                                e({
                                    stream: t,
                                    sourceId: t.id
                                })
                            })).catch((e => {
                                const n = {
                                    errorName: e && e.name,
                                    errorMsg: e && e.message,
                                    errorStack: e && e.stack
                                };
                                As.error("getDisplayMedia error", JSON.stringify(d), JSON.stringify(n)), n.errorMsg && -1 !== n.errorMsg.indexOf("denied by system") ? t(new dr(Yi)) : t(new dr(Zi))
                            }))
                        },
                        obtainScreenFromGetDisplayMediaRN(e, t) {
                            As.info("Using getDisplayMedia for screen sharing"), navigator.mediaDevices.getDisplayMedia({
                                video: !0
                            }).then((t => {
                                this.setContentHint(t), e({
                                    stream: t,
                                    sourceId: t.id
                                })
                            })).catch((() => {
                                t(new dr(Zi))
                            }))
                        },
                        setContentHint(e) {
                            const {
                                desktopSharingFrameRate: t
                            } = this.options, n = e.getVideoTracks()[0];
                            "contentHint" in n ? n.contentHint = (null == t ? void 0 : t.max) > 5 ? "motion" : "detail" : As.warn("MediaStreamTrack contentHint attribute not supported")
                        },
                        setDesktopSharingFrameRate(e) {
                            As.info(`Setting the desktop capture rate to ${e}`), this.options.desktopSharingFrameRate = {
                                min: 5,
                                max: e
                            }
                        }
                    };
                var Is = n(310);
                let Ps;
                ! function(e) {
                    e.AV1 = "av1", e.H264 = "h264", e.OPUS = "opus", e.RED = "red", e.ULPFEC = "ulpfec", e.VP8 = "vp8", e.VP9 = "vp9"
                }(Ps || (Ps = {}));
                const Ds = (0, E.getLogger)("modules/sdp/SDPUtil.js"),
                    Os = {
                        filterSpecialChars: e => e ? e.replace(/[\\\/\{,\}\+]/g, "") : e,
                        iceparams(e, t) {
                            let n, i, r = null;
                            return (i = Os.findLine(e, "a=ice-ufrag:", t)) && (n = Os.findLine(e, "a=ice-pwd:", t)) && (r = {
                                ufrag: Os.parseICEUfrag(i),
                                pwd: Os.parseICEPwd(n)
                            }), r
                        },
                        parseICEUfrag: e => e.substring(12),
                        buildICEUfrag: e => `a=ice-ufrag:${e}`,
                        parseICEPwd: e => e.substring(10),
                        buildICEPwd: e => `a=ice-pwd:${e}`,
                        parseMID: e => e.substring(6),
                        parseMSIDAttribute(e) {
                            const t = e.find((e => e.indexOf(" msid:") > 0));
                            if (!t) return;
                            const n = t.substring(t.indexOf(" msid:") + 6);
                            return Os.filterSpecialChars(n)
                        },
                        parseMLine(e) {
                            const t = {},
                                n = e.substring(2).split(" ");
                            return t.media = n.shift(), t.port = n.shift(), t.proto = n.shift(), "" === n[n.length - 1] && n.pop(), t.fmt = n, t
                        },
                        buildMLine: e => `m=${e.media} ${e.port} ${e.proto} ${e.fmt.join(" ")}`,
                        parseRTPMap(e) {
                            const t = {};
                            let n = e.substring(9).split(" ");
                            return t.id = n.shift(), n = n[0].split("/"), t.name = n.shift(), t.clockrate = n.shift(), t.channels = n.length ? n.shift() : "1", t
                        },
                        parseSCTPMap(e) {
                            const t = e.substring(10).split(" ");
                            return [t[0], t[1], t.length > 2 ? t[2] : null]
                        },
                        parseSCTPPort: e => e.substring(12),
                        buildRTPMap(e) {
                            let t = `a=rtpmap:${e.getAttribute("id")} ${e.getAttribute("name")}/${e.getAttribute("clockrate")}`;
                            return e.getAttribute("channels") && "1" !== e.getAttribute("channels") && (t += `/${e.getAttribute("channels")}`), t
                        },
                        parseCrypto(e) {
                            const t = {},
                                n = e.substring(9).split(" ");
                            return t.tag = n.shift(), t["crypto-suite"] = n.shift(), t["key-params"] = n.shift(), n.length && (t["session-params"] = n.join(" ")), t
                        },
                        parseFingerprint(e) {
                            const t = {},
                                n = e.substring(14).split(" ");
                            return t.hash = n.shift(), t.fingerprint = n.shift(), t
                        },
                        parseFmtp(e) {
                            const t = [];
                            let n = e.split(" ");
                            n.shift(), n = n.join(" ").split(";");
                            for (let e = 0; e < n.length; e++) {
                                let i = n[e].split("=")[0];
                                for (; i.length && " " === i[0];) i = i.substring(1);
                                const r = n[e].split("=")[1];
                                i && r ? t.push({
                                    name: i,
                                    value: r
                                }) : i && t.push({
                                    name: "",
                                    value: i
                                })
                            }
                            return t
                        },
                        parseICECandidate(e) {
                            const t = {},
                                n = e.split(" ");
                            t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = 0;
                            for (let e = 8; e < n.length; e += 2) switch (n[e]) {
                                case "raddr":
                                    t["rel-addr"] = n[e + 1];
                                    break;
                                case "rport":
                                    t["rel-port"] = n[e + 1];
                                    break;
                                case "generation":
                                    t.generation = n[e + 1];
                                    break;
                                case "tcptype":
                                    t.tcptype = n[e + 1];
                                    break;
                                default:
                                    Ds.debug(`parseICECandidate not translating "${n[e]}" = "${n[e+1]}"`)
                            }
                            return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                        },
                        buildICECandidate(e) {
                            let t = [`a=candidate:${e.foundation}`, e.component, e.protocol, e.priority, e.ip, e.port, "typ", e.type].join(" ");
                            switch (t += " ", e.type) {
                                case "srflx":
                                case "prflx":
                                case "relay":
                                    e.hasOwnAttribute("rel-addr") && e.hasOwnAttribute("rel-port") && (t += "raddr", t += " ", t += e["rel-addr"], t += " ", t += "rport", t += " ", t += e["rel-port"], t += " ")
                            }
                            return e.hasOwnAttribute("tcptype") && (t += "tcptype", t += " ", t += e.tcptype, t += " "), t += "generation", t += " ", t += e.hasOwnAttribute("generation") ? e.generation : "0", t
                        },
                        parseSSRC(e) {
                            const t = new Map,
                                n = e.split("\r\n");
                            for (let e = 0; e < n.length; e++)
                                if ("a=ssrc:" === n[e].substring(0, 7)) {
                                    const i = n[e].split("a=ssrc:")[1].split(" ")[0];
                                    t.get(i) || t.set(i, []), t.get(i).push(n[e])
                                } return t
                        },
                        parseSourceNameLine(e) {
                            const t = e.find((e => e.indexOf(" name:") > 0));
                            return null == t ? void 0 : t.substring(t.indexOf(" name:") + 6)
                        },
                        parseVideoTypeLine(e) {
                            const t = " videoType:",
                                n = e.find((e => e.indexOf(t) > 0));
                            return null == n ? void 0 : n.substring(n.indexOf(t) + t.length)
                        },
                        parseRTCPFB(e) {
                            const t = e.substr(10).split(" "),
                                n = {};
                            return n.pt = t.shift(), n.type = t.shift(), n.params = t, n
                        },
                        parseExtmap(e) {
                            const t = e.substr(9).split(" "),
                                n = {};
                            return n.value = t.shift(), -1 === n.value.indexOf("/") ? n.direction = "both" : (n.direction = n.value.substr(n.value.indexOf("/") + 1), n.value = n.value.substr(0, n.value.indexOf("/"))), n.uri = t.shift(), n.params = t, n
                        },
                        findLine(e, t, n) {
                            let i = e.split("\r\n");
                            for (let e = 0; e < i.length; e++)
                                if (i[e].substring(0, t.length) === t) return i[e];
                            if (!n) return !1;
                            i = n.split("\r\n");
                            for (let e = 0; e < i.length; e++)
                                if (i[e].substring(0, t.length) === t) return i[e];
                            return !1
                        },
                        findLines(e, t, n) {
                            let i = e.split("\r\n");
                            const r = [];
                            for (let e = 0; e < i.length; e++) i[e].substring(0, t.length) === t && r.push(i[e]);
                            if (r.length || !n) return r;
                            i = n.split("\r\n");
                            for (let e = 0; e < i.length; e++) i[e].substring(0, t.length) === t && r.push(i[e]);
                            return r
                        },
                        candidateToJingle(e) {
                            if (0 === e.indexOf("candidate:")) e = `a=${e}`;
                            else if ("a=candidate:" !== e.substring(0, 12)) return Ds.warn("parseCandidate called with a line that is not a candidate line"), Ds.warn(e), null;
                            "\r\n" === e.substring(e.length - 2) && (e = e.substring(0, e.length - 2));
                            const t = {},
                                n = e.split(" ");
                            if ("typ" !== n[6]) return Ds.warn("did not find typ in the right place"), Ds.warn(e), null;
                            t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = "0";
                            for (let e = 8; e < n.length; e += 2) switch (n[e]) {
                                case "raddr":
                                    t["rel-addr"] = n[e + 1];
                                    break;
                                case "rport":
                                    t["rel-port"] = n[e + 1];
                                    break;
                                case "generation":
                                    t.generation = n[e + 1];
                                    break;
                                case "tcptype":
                                    t.tcptype = n[e + 1];
                                    break;
                                default:
                                    Ds.debug(`not translating "${n[e]}" = "${n[e+1]}"`)
                            }
                            return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                        },
                        candidateFromJingle(e) {
                            let t = "a=candidate:";
                            t += e.getAttribute("foundation"), t += " ", t += e.getAttribute("component"), t += " ";
                            let n = e.getAttribute("protocol");
                            switch (ci.isFirefox() && "ssltcp" === n.toLowerCase() && (n = "tcp"), t += n, t += " ", t += e.getAttribute("priority"), t += " ", t += e.getAttribute("ip"), t += " ", t += e.getAttribute("port"), t += " ", t += "typ", t += ` ${e.getAttribute("type")}`, t += " ", e.getAttribute("type")) {
                                case "srflx":
                                case "prflx":
                                case "relay":
                                    e.getAttribute("rel-addr") && e.getAttribute("rel-port") && (t += "raddr", t += " ", t += e.getAttribute("rel-addr"), t += " ", t += "rport", t += " ", t += e.getAttribute("rel-port"), t += " ")
                            }
                            return "tcp" === n.toLowerCase() && (t += "tcptype", t += " ", t += e.getAttribute("tcptype"), t += " "), t += "generation", t += " ", t += e.getAttribute("generation") || "0", `${t}\r\n`
                        },
                        parsePrimaryVideoSsrc(e) {
                            const t = e.ssrcs.map((e => e.id)).filter(((e, t, n) => n.indexOf(e) === t)).length,
                                n = e.ssrcGroups && e.ssrcGroups.length || 0;
                            if (t > 1 && 0 === n) return;
                            let i = null;
                            if (1 === t) i = e.ssrcs[0].id;
                            else if (2 === t) {
                                const t = e.ssrcGroups.find((e => "FID" === e.semantics));
                                t && (i = t.ssrcs.split(" ")[0])
                            } else if (t >= 3) {
                                const t = e.ssrcGroups.find((e => "SIM" === e.semantics));
                                t && (i = t.ssrcs.split(" ")[0])
                            }
                            return i
                        },
                        generateSsrc: () => ao().randomInt(1, 4294967295),
                        getSsrcAttribute(e, t, n) {
                            for (let i = 0; i < e.ssrcs.length; ++i) {
                                const r = e.ssrcs[i];
                                if (r.id === t && r.attribute === n) return r.value
                            }
                        },
                        parseGroupSsrcs: e => e.ssrcs.split(" ").map((e => parseInt(e, 10))),
                        getMedia: (e, t) => e.media.find((e => e.type === t)),
                        getUfrag(e) {
                            const t = e.split("\n").filter((e => e.startsWith("a=ice-ufrag:")));
                            if (t.length > 0) return t[0].substr("a=ice-ufrag:".length)
                        },
                        preferCodec(e, t) {
                            let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                            if (!e || !t) return;
                            const i = e.rtp.filter((e => e.codec && e.codec.toLowerCase() === t.toLowerCase())).map((e => e.payload));
                            if (i) {
                                if (n && t === Ps.H264) {
                                    const t = i.filter((t => {
                                        const n = e.fmtp.find((e => e.payload === t));
                                        return !!n && n.config.includes("packetization-mode=0")
                                    }));
                                    for (const e of t.reverse()) {
                                        const t = i.findIndex((t => t === e));
                                        t >= 0 && (i.splice(t, 1), i.unshift(e))
                                    }
                                }
                                const r = e.payloads.toString().split(" ").map((e => parseInt(e, 10)));
                                for (const e of i.reverse()) {
                                    const t = r.indexOf(e);
                                    r.splice(t, 1), r.unshift(e)
                                }
                                e.payloads = r.join(" ")
                            } else Ds.error(`No matching RTP payload type found for ${t}, failed to set preferred codecs`)
                        },
                        stripCodec(e, t) {
                            let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                            if (!e || !t) return;
                            const i = new Map;
                            let r = [];
                            for (const o of e.rtp) o.codec && o.codec.toLowerCase() === t.toLowerCase() && (n ? i.set(o.payload, o.codec) : r.push(o.payload));
                            if (n && (r = e.fmtp.filter((e => {
                                    const t = i.get(e.payload);
                                    return !!t && (t.toLowerCase() === Ps.VP9 ? !e.config.includes("profile-id=0") : !e.config.includes("profile-level-id=42"))
                                })).map((e => e.payload))), r.length > 0) {
                                const t = r.map((e => `apt=${e}`)),
                                    n = e.fmtp.filter((e => -1 !== t.indexOf(e.config)));
                                r.push(...n.map((e => e.payload)));
                                const i = e.payloads.toString().split(" ").map(Number).filter((e => -1 === r.indexOf(e)));
                                0 === i.length ? (e.port = 0, e.direction = Rs.INACTIVE, e.payloads = "*") : e.payloads = i.join(" "), e.rtp = e.rtp.filter((e => -1 !== i.indexOf(e.payload))), e.fmtp = e.fmtp.filter((e => -1 !== i.indexOf(e.payload))), e.rtcpFb && (e.rtcpFb = e.rtcpFb.filter((e => -1 !== i.indexOf(e.payload))))
                            }
                        }
                    },
                    Ns = Os;

                function ks(e) {
                    const t = e.split("\r\nm=");
                    for (let e = 1, n = t.length; e < n; e++) {
                        let i = `m=${t[e]}`;
                        e !== n - 1 && (i += "\r\n"), t[e] = i
                    }
                    const n = `${t.shift()}\r\n`;
                    this.media = t, this.raw = n + t.join(""), this.session = n
                }

                function Ms(e, t) {
                    if (!t) return !1;
                    if (e.length !== t.length) return !1;
                    for (let n = 0, i = e.length; n < i; n++)
                        if (e[n] instanceof Array && t[n] instanceof Array) {
                            if (!e[n].equals(t[n])) return !1
                        } else if (e[n] !== t[n]) return !1;
                    return !0
                }

                function Ls(e, t) {
                    if (this.mySDP = e, this.otherSDP = t, !e) throw new Error('"mySDP" is undefined!');
                    if (!t) throw new Error('"otherSDP" is undefined!')
                }

                function Fs(e) {
                    return function() {
                        if (null === e) throw new Error("Callback was already called.");
                        var t = e;
                        e = null;
                        for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        t.apply(this, i)
                    }
                }
                ks.prototype.failICE = !1, ks.prototype.removeTcpCandidates = !1, ks.prototype.removeUdpCandidates = !1, ks.prototype.addMlineForNewLocalSource = function(e) {
                    const t = this.media.length,
                        n = Is.parse(this.raw),
                        i = Es()(n.media.find((t => t.type === e)));
                    i.mid = t, i.direction = Rs.RECVONLY, i.msid = void 0, i.ssrcs = void 0, i.ssrcGroups = void 0, n.media = n.media.concat(i), n.groups.forEach((e => {
                        if ("BUNDLE" === e.type) {
                            const n = e.mids.split(" ");
                            n.push(t), e.mids = n.join(" ")
                        }
                    })), this.raw = Is.write(n)
                }, ks.prototype.getMediaSsrcMap = function() {
                    const e = {};
                    for (let t = 0; t < this.media.length; t++) {
                        const n = {
                            mediaindex: t,
                            mid: Ns.parseMID(Ns.findLine(this.media[t], "a=mid:")),
                            ssrcs: {},
                            ssrcGroups: []
                        };
                        e[t] = n, Ns.findLines(this.media[t], "a=ssrc:").forEach((e => {
                            const t = e.substring(7).split(" ")[0];
                            n.ssrcs[t] || (n.ssrcs[t] = {
                                ssrc: t,
                                lines: []
                            }), n.ssrcs[t].lines.push(e)
                        })), Ns.findLines(this.media[t], "a=ssrc-group:").forEach((e => {
                            const t = e.indexOf(" "),
                                i = e.substr(0, t).substr(13),
                                r = e.substr(14 + i.length).split(" ");
                            r.length && n.ssrcGroups.push({
                                semantics: i,
                                ssrcs: r
                            })
                        }))
                    }
                    return e
                }, ks.prototype.containsSSRC = function(e) {
                    const t = this.getMediaSsrcMap();
                    let n = !1;
                    return Object.keys(t).forEach((i => {
                        n || t[i].ssrcs[e] && (n = !0)
                    })), n
                }, ks.prototype.toJingle = function(e, t) {
                    Ns.findLines(this.session, "a=group:").forEach((t => {
                        const n = t.split(" "),
                            i = n.shift().substr(8);
                        e.c("group", {
                            xmlns: "urn:xmpp:jingle:apps:grouping:0",
                            semantics: i
                        });
                        for (let t = 0; t < n.length; t++) e.c("content", {
                            name: n[t]
                        }).up();
                        e.up()
                    }));
                    for (let n = 0; n < this.media.length; n++) {
                        const i = Ns.parseMLine(this.media[n].split("\r\n")[0]);
                        if ("audio" !== i.media && "video" !== i.media && "application" !== i.media) continue;
                        let r;
                        const o = Ns.findLine(this.media[n], "a=ssrc:");
                        r = !!o && o.substring(7).split(" ")[0], e.c("content", {
                            creator: t,
                            name: i.media
                        });
                        const s = Ns.findLine(this.media[n], "a=mid:");
                        if (s) {
                            const t = Ns.parseMID(s);
                            e.attrs({
                                name: t
                            })
                        }
                        if ("video" === i.media && "number" == typeof this.initialLastN && e.c("initial-last-n", {
                                xmlns: "jitsi:colibri2",
                                value: this.initialLastN
                            }).up(), "audio" === i.media || "video" === i.media) {
                            e.c("description", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:1",
                                media: i.media
                            }), r && e.attrs({
                                ssrc: r
                            });
                            for (let t = 0; t < i.fmt.length; t++) {
                                const r = Ns.findLine(this.media[n], `a=rtpmap:${i.fmt[t]}`);
                                e.c("payload-type", Ns.parseRTPMap(r));
                                const o = Ns.findLine(this.media[n], `a=fmtp:${i.fmt[t]}`);
                                if (o) {
                                    const t = Ns.parseFmtp(o);
                                    for (let n = 0; n < t.length; n++) e.c("parameter", t[n]).up()
                                }
                                this.rtcpFbToJingle(n, e, i.fmt[t]), e.up()
                            }
                            if (r) {
                                const t = Ns.parseSSRC(this.media[n]);
                                for (const [n, i] of t) {
                                    const t = Ns.parseSourceNameLine(i),
                                        r = Ns.parseVideoTypeLine(i);
                                    e.c("source", {
                                        ssrc: n,
                                        name: t,
                                        videoType: r,
                                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                    });
                                    const o = Ns.parseMSIDAttribute(i);
                                    o && (e.c("parameter"), e.attrs({
                                        name: "msid"
                                    }), e.attrs({
                                        value: o
                                    }), e.up()), e.up()
                                }
                                Ns.findLines(this.media[n], "a=ssrc-group:").forEach((t => {
                                    const n = t.indexOf(" "),
                                        i = t.substr(0, n).substr(13),
                                        r = t.substr(14 + i.length).split(" ");
                                    r.length && (e.c("ssrc-group", {
                                        semantics: i,
                                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                    }), r.forEach((t => e.c("source", {
                                        ssrc: t
                                    }).up())), e.up())
                                }))
                            }
                            const t = Ns.findLines(this.media[n], "a=rid:");
                            if (t.length && ci.usesRidsForSimulcast()) {
                                const i = t.map((e => e.split(":")[1])).map((e => e.split(" ")[0]));
                                i.forEach((t => {
                                    e.c("source", {
                                        rid: t,
                                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                    }), e.up()
                                })), Ns.findLine(this.media[n], "a=simulcast:") && (e.c("rid-group", {
                                    semantics: "SIM",
                                    xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                }), i.forEach((t => {
                                    e.c("source", {
                                        rid: t
                                    }).up()
                                })), e.up())
                            }
                            Ns.findLine(this.media[n], "a=rtcp-mux") && e.c("rtcp-mux").up(), this.rtcpFbToJingle(n, e, "*");
                            const o = Ns.findLines(this.media[n], "a=extmap:", this.session);
                            for (let t = 0; t < o.length; t++) {
                                const n = Ns.parseExtmap(o[t]);
                                if (e.c("rtp-hdrext", {
                                        xmlns: "urn:xmpp:jingle:apps:rtp:rtp-hdrext:0",
                                        uri: n.uri,
                                        id: n.value
                                    }), n.hasOwnProperty("direction")) switch (n.direction) {
                                    case Rs.SENDONLY:
                                        e.attrs({
                                            senders: "responder"
                                        });
                                        break;
                                    case Rs.RECVONLY:
                                        e.attrs({
                                            senders: "initiator"
                                        });
                                        break;
                                    case Rs.SENDRECV:
                                        e.attrs({
                                            senders: "both"
                                        });
                                        break;
                                    case Rs.INACTIVE:
                                        e.attrs({
                                            senders: "none"
                                        })
                                }
                                e.up()
                            }
                            Ns.findLine(this.media[n], "a=extmap-allow-mixed", this.session) && (e.c("extmap-allow-mixed", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"
                            }), e.up()), e.up()
                        }
                        this.transportToJingle(n, e);
                        const a = this.media[n];
                        Ns.findLine(a, `a=${Rs.SENDRECV}`) ? e.attrs({
                            senders: "both"
                        }) : Ns.findLine(a, `a=${Rs.SENDONLY}`) ? e.attrs({
                            senders: "initiator"
                        }) : Ns.findLine(a, `a=${Rs.RECVONLY}`) ? e.attrs({
                            senders: "responder"
                        }) : Ns.findLine(a, `a=${Rs.INACTIVE}`) && e.attrs({
                            senders: "none"
                        }), "0" !== i.port || Ns.findLine(a, "a=bundle-only", this.session) || e.attrs({
                            senders: "rejected"
                        }), e.up()
                    }
                    return e.up(), e
                }, ks.prototype.transportToJingle = function(e, t) {
                    t.c("transport");
                    const n = Ns.findLine(this.media[e], "a=sctp-port:", this.session),
                        i = Ns.findLine(this.media[e], "a=sctpmap:", this.session);
                    if (n) {
                        const e = Ns.parseSCTPPort(n);
                        t.c("sctpmap", {
                            xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
                            number: e,
                            protocol: "webrtc-datachannel"
                        }), t.attrs({
                            streams: 0
                        }), t.up()
                    } else if (i) {
                        const e = Ns.parseSCTPMap(i);
                        t.c("sctpmap", {
                            xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
                            number: e[0],
                            protocol: e[1]
                        }), e.length > 2 ? t.attrs({
                            streams: e[2]
                        }) : t.attrs({
                            streams: 0
                        }), t.up()
                    }
                    Ns.findLines(this.media[e], "a=fingerprint:", this.session).forEach((n => {
                        const i = Ns.parseFingerprint(n);
                        i.xmlns = "urn:xmpp:jingle:apps:dtls:0", t.c("fingerprint").t(i.fingerprint), delete i.fingerprint;
                        const r = Ns.findLine(this.media[e], "a=setup:", this.session);
                        r && (i.setup = r.substr(8)), t.attrs(i), t.up()
                    }));
                    const r = Ns.iceparams(this.media[e], this.session);
                    r && (r.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.attrs(r), Ns.findLines(this.media[e], "a=candidate:", this.session).forEach((e => {
                        const n = Ns.candidateToJingle(e);
                        this.failICE && (n.ip = "1.1.1.1");
                        const i = n && "string" == typeof n.protocol ? n.protocol.toLowerCase() : "";
                        this.removeTcpCandidates && ("tcp" === i || "ssltcp" === i) || this.removeUdpCandidates && "udp" === i || t.c("candidate", n).up()
                    }))), t.up()
                }, ks.prototype.rtcpFbToJingle = function(e, t, n) {
                    Ns.findLines(this.media[e], `a=rtcp-fb:${n}`).forEach((e => {
                        const n = Ns.parseRTCPFB(e);
                        "trr-int" === n.type ? (t.c("rtcp-fb-trr-int", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                            value: n.params[0]
                        }), t.up()) : (t.c("rtcp-fb", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                            type: n.type
                        }), n.params.length > 0 && t.attrs({
                            subtype: n.params[0]
                        }), t.up())
                    }))
                }, ks.prototype.rtcpFbFromJingle = function(e, t) {
                    let n = "";
                    const i = e.find('>rtcp-fb-trr-int[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
                    return i.length && (n += "a=rtcp-fb:* trr-int ", i.attr("value") ? n += i.attr("value") : n += "0", n += "\r\n"), e.find('>rtcp-fb[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]').each(((e, i) => {
                        n += `a=rtcp-fb:${t} ${i.getAttribute("type")}`, i.hasAttribute("subtype") && (n += ` ${i.getAttribute("subtype")}`), n += "\r\n"
                    })), n
                }, ks.prototype.fromJingle = function(e) {
                    const t = Date.now();
                    this.raw = `v=0\r\no=- ${t} 2 IN IP4 0.0.0.0\r\ns=-\r\nt=0 0\r\n`;
                    const n = _t()(e).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]');
                    n.length && n.each(((e, t) => {
                        const n = _t()(t).find(">content").map(((e, t) => t.getAttribute("name"))).get();
                        n.length > 0 && (this.raw += `a=group:${t.getAttribute("semantics")||t.getAttribute("type")} ${n.join(" ")}\r\n`)
                    })), this.session = this.raw, e.find(">content").each(((e, t) => {
                        const n = this.jingle2media(_t()(t));
                        this.media.push(n)
                    })), this.raw = this.session + this.media.join("")
                }, ks.prototype.jingle2media = function(e) {
                    const t = e.find(">description"),
                        n = e.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]');
                    let i = "";
                    const r = n.find('>sctpmap[xmlns="urn:xmpp:jingle:transports:dtls-sctp:1"]'),
                        o = {
                            media: t.attr("media"),
                            port: "9"
                        };
                    switch ("rejected" === e.attr("senders") && (o.port = "0"), n.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').length ? o.proto = r.length ? "UDP/DTLS/SCTP" : "UDP/TLS/RTP/SAVPF" : o.proto = "UDP/TLS/RTP/SAVPF", r.length ? (i += `m=application ${o.port} UDP/DTLS/SCTP webrtc-datachannel\r\n`, i += `a=sctp-port:${r.attr("number")}\r\n`, i += "a=max-message-size:262144\r\n") : (o.fmt = t.find(">payload-type").map(((e, t) => t.getAttribute("id"))).get(), i += `${Ns.buildMLine(o)}\r\n`), i += "c=IN IP4 0.0.0.0\r\n", r.length || (i += "a=rtcp:1 IN IP4 0.0.0.0\r\n"), n.length && (n.attr("ufrag") && (i += `${Ns.buildICEUfrag(n.attr("ufrag"))}\r\n`), n.attr("pwd") && (i += `${Ns.buildICEPwd(n.attr("pwd"))}\r\n`), n.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').each(((e, t) => {
                            i += `a=fingerprint:${t.getAttribute("hash")}`, i += ` ${_t()(t).text()}`, i += "\r\n", t.hasAttribute("setup") && (i += `a=setup:${t.getAttribute("setup")}\r\n`)
                        }))), n.find(">candidate").each(((e, t) => {
                            let n = t.getAttribute("protocol");
                            n = "string" == typeof n ? n.toLowerCase() : "", this.removeTcpCandidates && ("tcp" === n || "ssltcp" === n) || this.removeUdpCandidates && "udp" === n || (this.failICE && t.setAttribute("ip", "1.1.1.1"), i += Ns.candidateFromJingle(t))
                        })), e.attr("senders")) {
                        case "initiator":
                            i += `a=${Rs.SENDONLY}\r\n`;
                            break;
                        case "responder":
                            i += `a=${Rs.RECVONLY}\r\n`;
                            break;
                        case "none":
                            i += `a=${Rs.INACTIVE}\r\n`;
                            break;
                        case "both":
                            i += `a=${Rs.SENDRECV}\r\n`
                    }
                    i += `a=mid:${e.attr("name")}\r\n`, t.find(">rtcp-mux").length && (i += "a=rtcp-mux\r\n"), t.find(">payload-type").each(((e, t) => {
                        i += `${Ns.buildRTPMap(t)}\r\n`, _t()(t).find(">parameter").length && (i += `a=fmtp:${t.getAttribute("id")} `, i += _t()(t).find(">parameter").map(((e, t) => {
                            const n = t.getAttribute("name");
                            return (n ? `${n}=` : "") + t.getAttribute("value")
                        })).get().join(";"), i += "\r\n"), i += this.rtcpFbFromJingle(_t()(t), t.getAttribute("id"))
                    })), i += this.rtcpFbFromJingle(t, "*"), t.find('>rtp-hdrext[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]').each(((e, t) => {
                        i += `a=extmap:${t.getAttribute("id")} ${t.getAttribute("uri")}\r\n`
                    })), t.find('>extmap-allow-mixed[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]').length > 0 && (i += "a=extmap-allow-mixed\r\n"), t.find('>ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
                        const n = t.getAttribute("semantics"),
                            r = _t()(t).find(">source").map(((e, t) => t.getAttribute("ssrc"))).get();
                        r.length && (i += `a=ssrc-group:${n} ${r.join(" ")}\r\n`)
                    }));
                    let s = "",
                        a = "";
                    return t.find('>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
                        const n = t.getAttribute("ssrc");
                        let i = !0,
                            r = "";
                        _t()(t).find(">parameter").each(((e, t) => {
                            var o;
                            const s = t.getAttribute("name");
                            let a = t.getAttribute("value");
                            a = Ns.filterSpecialChars(a), r += `a=ssrc:${n} ${s}`, a && a.length && (r += `:${a}`), r += "\r\n", null !== (o = a) && void 0 !== o && o.includes("mixedmslabel") && (i = !1)
                        })), i ? s += r : a += r
                    })), i += a + s, i
                }, Ls.prototype.getNewMedia = function() {
                    const e = this.mySDP.getMediaSsrcMap(),
                        t = this.otherSDP.getMediaSsrcMap(),
                        n = {};
                    return Object.keys(t).forEach((i => {
                        const r = e[i],
                            o = t[i];
                        r || !o ? (Object.keys(o.ssrcs).forEach((e => {
                            (-1 === Object.keys(r.ssrcs).indexOf(e) || o.ssrcs[e].lines && r.ssrcs[e].lines && void 0 !== r.ssrcs[e].lines.find((e => -1 !== e.indexOf("msid"))) != (void 0 !== o.ssrcs[e].lines.find((e => -1 !== e.indexOf("msid"))))) && (n[i] || (n[i] = {
                                mediaindex: o.mediaindex,
                                mid: o.mid,
                                ssrcs: {},
                                ssrcGroups: []
                            }), n[i].ssrcs[e] = o.ssrcs[e])
                        })), o.ssrcGroups.forEach((e => {
                            let t = !1;
                            for (let n = 0; n < r.ssrcGroups.length; n++) {
                                const i = r.ssrcGroups[n];
                                if (e.semantics === i.semantics && Ms(e.ssrcs, i.ssrcs)) {
                                    t = !0;
                                    break
                                }
                            }
                            t || (n[i] || (n[i] = {
                                mediaindex: o.mediaindex,
                                mid: o.mid,
                                ssrcs: {},
                                ssrcGroups: []
                            }), n[i].ssrcGroups.push(e))
                        }))) : n[i] = o
                    })), n
                }, Ls.prototype.toJingle = function(e) {
                    const t = this.getNewMedia();
                    let n = !1;
                    return Object.keys(t).forEach((i => {
                        n = !0;
                        const r = t[i];
                        e.c("content", {
                            name: r.mid
                        }), e.c("description", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:1",
                            media: r.mid
                        }), Object.keys(r.ssrcs).forEach((t => {
                            const n = r.ssrcs[t],
                                i = n.lines,
                                o = Ns.parseSourceNameLine(i),
                                s = Ns.parseVideoTypeLine(i);
                            e.c("source", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                            }), e.attrs({
                                name: o,
                                videoType: s,
                                ssrc: n.ssrc
                            });
                            const a = Ns.parseMSIDAttribute(i);
                            a && (e.c("parameter"), e.attrs({
                                name: "msid"
                            }), e.attrs({
                                value: a
                            }), e.up()), e.up()
                        })), r.ssrcGroups.forEach((t => {
                            t.ssrcs.length && (e.c("ssrc-group", {
                                semantics: t.semantics,
                                xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                            }), t.ssrcs.forEach((t => {
                                e.c("source", {
                                    ssrc: t
                                }).up()
                            })), e.up())
                        })), e.up(), e.up()
                    })), n
                };
                var js, Vs = "function" == typeof queueMicrotask && queueMicrotask,
                    Us = "function" == typeof setImmediate && setImmediate,
                    Hs = "object" == typeof process && "function" == typeof process.nextTick;
                js = Vs ? queueMicrotask : Us ? setImmediate : Hs ? process.nextTick : function(e) {
                    setTimeout(e, 0)
                };
                const $s = (Js = js, function(e) {
                    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                    return Js((() => e(...n)))
                });
                var Js;
                class Bs {
                    constructor() {
                        this.head = this.tail = null, this.length = 0
                    }
                    removeLink(e) {
                        return e.prev ? e.prev.next = e.next : this.head = e.next, e.next ? e.next.prev = e.prev : this.tail = e.prev, e.prev = e.next = null, this.length -= 1, e
                    }
                    empty() {
                        for (; this.head;) this.shift();
                        return this
                    }
                    insertAfter(e, t) {
                        t.prev = e, t.next = e.next, e.next ? e.next.prev = t : this.tail = t, e.next = t, this.length += 1
                    }
                    insertBefore(e, t) {
                        t.prev = e.prev, t.next = e, e.prev ? e.prev.next = t : this.head = t, e.prev = t, this.length += 1
                    }
                    unshift(e) {
                        this.head ? this.insertBefore(this.head, e) : qs(this, e)
                    }
                    push(e) {
                        this.tail ? this.insertAfter(this.tail, e) : qs(this, e)
                    }
                    shift() {
                        return this.head && this.removeLink(this.head)
                    }
                    pop() {
                        return this.tail && this.removeLink(this.tail)
                    }
                    toArray() {
                        return [...this]
                    }*[Symbol.iterator]() {
                        for (var e = this.head; e;) yield e.data, e = e.next
                    }
                    remove(e) {
                        for (var t = this.head; t;) {
                            var {
                                next: n
                            } = t;
                            e(t) && this.removeLink(t), t = n
                        }
                        return this
                    }
                }

                function qs(e, t) {
                    e.length = 1, e.head = e.tail = t
                }

                function Gs(e, t) {
                    return e.then((e => {
                        zs(t, null, e)
                    }), (e => {
                        zs(t, e && e.message ? e : new Error(e))
                    }))
                }

                function zs(e, t, n) {
                    try {
                        e(t, n)
                    } catch (e) {
                        $s((e => {
                            throw e
                        }), e)
                    }
                }

                function Ks(e) {
                    return "AsyncFunction" === e[Symbol.toStringTag]
                }
                const Ws = function(e) {
                    if ("function" != typeof e) throw new Error("expected a function");
                    return Ks(e) ? Ks(t = e) ? function() {
                        for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                        const r = n.pop();
                        return Gs(t.apply(this, n), r)
                    } : (n = function(e, n) {
                        var i;
                        try {
                            i = t.apply(this, e)
                        } catch (e) {
                            return n(e)
                        }
                        if (i && "function" == typeof i.then) return Gs(i, n);
                        n(null, i)
                    }, function() {
                        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                        var r = t.pop();
                        return n.call(this, t, r)
                    }) : e;
                    var t, n
                };

                function Xs(e, t, n) {
                    if (null == t) t = 1;
                    else if (0 === t) throw new RangeError("Concurrency must not be zero");
                    var i = Ws(e),
                        r = 0,
                        o = [];
                    const s = {
                        error: [],
                        drain: [],
                        saturated: [],
                        unsaturated: [],
                        empty: []
                    };

                    function a(e, t) {
                        return e ? t ? void(s[e] = s[e].filter((e => e !== t))) : s[e] = [] : Object.keys(s).forEach((e => s[e] = []))
                    }

                    function d(e) {
                        for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                        s[e].forEach((e => e(...n)))
                    }
                    var c = !1;

                    function l(e, t, n, i) {
                        if (null != i && "function" != typeof i) throw new Error("task callback must be a function");
                        var r, o;

                        function s(e) {
                            if (e) return n ? o(e) : r();
                            for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) i[s - 1] = arguments[s];
                            if (i.length <= 1) return r(i[0]);
                            r(i)
                        }
                        g.started = !0;
                        var a = g._createTaskItem(e, n ? s : i || s);
                        if (t ? g._tasks.unshift(a) : g._tasks.push(a), c || (c = !0, $s((() => {
                                c = !1, g.process()
                            }))), n || !i) return new Promise(((e, t) => {
                            r = e, o = t
                        }))
                    }

                    function h(e) {
                        return function(t) {
                            r -= 1;
                            for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++) i[s - 1] = arguments[s];
                            for (var a = 0, c = e.length; a < c; a++) {
                                var l = e[a],
                                    h = o.indexOf(l);
                                0 === h ? o.shift() : h > 0 && o.splice(h, 1), l.callback(t, ...i), null != t && d("error", t, l.data)
                            }
                            r <= g.concurrency - g.buffer && d("unsaturated"), g.idle() && d("drain"), g.process()
                        }
                    }

                    function u(e) {
                        return !(0 !== e.length || !g.idle() || ($s((() => d("drain"))), 0))
                    }
                    const p = e => t => {
                        if (!t) return new Promise(((t, n) => {
                            ! function(e, i) {
                                const r = function() {
                                    a(e, r), ((e, i) => {
                                        if (e) return n(e);
                                        t(i)
                                    })(...arguments)
                                };
                                s[e].push(r)
                            }(e)
                        }));
                        a(e),
                            function(e, t) {
                                s[e].push(t)
                            }(e, t)
                    };
                    var m = !1,
                        g = {
                            _tasks: new Bs,
                            _createTaskItem: (e, t) => ({
                                data: e,
                                callback: t
                            }),
                            *[Symbol.iterator]() {
                                yield* g._tasks[Symbol.iterator]()
                            },
                            concurrency: t,
                            payload: n,
                            buffer: t / 4,
                            started: !1,
                            paused: !1,
                            push(e, t) {
                                if (Array.isArray(e)) {
                                    if (u(e)) return;
                                    return e.map((e => l(e, !1, !1, t)))
                                }
                                return l(e, !1, !1, t)
                            },
                            pushAsync(e, t) {
                                if (Array.isArray(e)) {
                                    if (u(e)) return;
                                    return e.map((e => l(e, !1, !0, t)))
                                }
                                return l(e, !1, !0, t)
                            },
                            kill() {
                                a(), g._tasks.empty()
                            },
                            unshift(e, t) {
                                if (Array.isArray(e)) {
                                    if (u(e)) return;
                                    return e.map((e => l(e, !0, !1, t)))
                                }
                                return l(e, !0, !1, t)
                            },
                            unshiftAsync(e, t) {
                                if (Array.isArray(e)) {
                                    if (u(e)) return;
                                    return e.map((e => l(e, !0, !0, t)))
                                }
                                return l(e, !0, !0, t)
                            },
                            remove(e) {
                                g._tasks.remove(e)
                            },
                            process() {
                                if (!m) {
                                    for (m = !0; !g.paused && r < g.concurrency && g._tasks.length;) {
                                        var e = [],
                                            t = [],
                                            n = g._tasks.length;
                                        g.payload && (n = Math.min(n, g.payload));
                                        for (var s = 0; s < n; s++) {
                                            var a = g._tasks.shift();
                                            e.push(a), o.push(a), t.push(a.data)
                                        }
                                        r += 1, 0 === g._tasks.length && d("empty"), r === g.concurrency && d("saturated");
                                        var c = Fs(h(e));
                                        i(t, c)
                                    }
                                    m = !1
                                }
                            },
                            length: () => g._tasks.length,
                            running: () => r,
                            workersList: () => o,
                            idle: () => g._tasks.length + r === 0,
                            pause() {
                                g.paused = !0
                            },
                            resume() {
                                !1 !== g.paused && (g.paused = !1, $s(g.process))
                            }
                        };
                    return Object.defineProperties(g, {
                        saturated: {
                            writable: !1,
                            value: p("saturated")
                        },
                        unsaturated: {
                            writable: !1,
                            value: p("unsaturated")
                        },
                        empty: {
                            writable: !1,
                            value: p("empty")
                        },
                        drain: {
                            writable: !1,
                            value: p("drain")
                        },
                        error: {
                            writable: !1,
                            value: p("error")
                        }
                    }), g
                }
                const Ys = (0, E.getLogger)("modules/util/AsyncQueue.js");
                class Qs extends Error {
                    constructor(e) {
                        super(e), this.name = "ClearedQueueError"
                    }
                }
                class Zs {
                    constructor() {
                        var e, t;
                        this._queue = (e = this._processQueueTasks.bind(this), 1, t = Ws(e), Xs(((e, n) => {
                            t(e[0], n)
                        }), 1, 1)), this._stopped = !1, this._taskCallbacks = new Map
                    }
                    clear() {
                        for (const e of this._taskCallbacks.values()) try {
                            null == e || e(new Qs("The queue has been cleared"))
                        } catch (e) {
                            Ys.error("Error in callback while clearing the queue:", e)
                        }
                        this._queue.kill()
                    }
                    _processQueueTasks(e, t) {
                        try {
                            e(t)
                        } catch (e) {
                            Ys.error(`Task failed: ${null==e?void 0:e.stack}`), t(e)
                        } finally {
                            this._taskCallbacks.delete(e)
                        }
                    }
                    pause() {
                        this._queue.pause()
                    }
                    push(e, t) {
                        this._stopped ? t && t(new Error("The queue has been stopped")) : (this._taskCallbacks.set(e, t), this._queue.push(e, t))
                    }
                    resume() {
                        this._queue.resume()
                    }
                    shutdown() {
                        this._stopped = !0
                    }
                }
                let ea;
                ! function(e) {
                    e.PENDING = "pending", e.ACTIVE = "active", e.ENDED = "ended"
                }(ea || (ea = {}));
                const ta = ea.PENDING,
                    na = ea.ACTIVE,
                    ia = ea.ENDED,
                    ra = (0, E.getLogger)("modules/xmpp/JingleSession.js");
                class oa extends Cr {
                    constructor(e, t, n, i, r, o, s) {
                        super(), this.sid = e, this.localJid = t, this.remoteJid = n, this.connection = i, this.mediaConstraints = r, this.pcConfig = o, this.isInitiator = s, this.usedrip = !0, this.dripContainer = [], this.room = null, this._signalingLayer = null, this.state = null, this.rtc = null
                    }
                    get initiatorJid() {
                        return this.isInitiator ? this.localJid : this.remoteJid
                    }
                    get responderJid() {
                        return this.isInitiator ? this.remoteJid : this.localJid
                    }
                    initialize(e, t, n, i) {
                        if (null !== this.state) {
                            const e = `attempt to initiate on session ${this.sid}\n                   in state ${this.state}`;
                            throw ra.error(e), new Error(e)
                        }
                        this.room = e, this.rtc = t, this._signalingLayer = n, this.state = ta, this.doInitialize(i)
                    }
                    doInitialize(e) {}
                    addIceCandidates(e) {}
                    getState() {
                        return this.state
                    }
                    addSources(e) {}
                    removeSources(e) {}
                    terminate(e, t, n) {}
                    acceptOffer(e, t, n) {}
                }
                var sa;
                ! function(e) {
                    e.REMOTE_SOURCE_CONSTRAINTS_CHANGED = "media_session.REMOTE_SOURCE_CONSTRAINTS_CHANGED"
                }(sa || (sa = {}));
                const aa = sa,
                    da = (0, E.getLogger)("modules/xmpp/JingleSessionPC.js"),
                    ca = 1e4;

                function la(e, t, n, i) {
                    e.c("source", {
                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                        ssrc: n,
                        name: t.source
                    }).c("parameter", {
                        name: "msid",
                        value: i
                    }).up().c("ssrc-info", {
                        xmlns: "http://jitsi.org/jitmeet",
                        owner: t.owner
                    }).up().up()
                }
                class ha extends oa {
                    static parseVideoSenders(e) {
                        const t = e.find('>content[name="video"]');
                        if (t.length) {
                            const e = t[0].getAttribute("senders");
                            if ("both" === e || "initiator" === e || "responder" === e || "none" === e) return e
                        }
                        return null
                    }
                    static parseSourceMaxFrameHeight(e) {
                        const t = [],
                            n = e.find('>content[name="video"]>source-frame-height');
                        let i, r;
                        return n.length ? (n.each(((e, n) => {
                            r = n.getAttribute("sourceName"), i = n.getAttribute("maxHeight"), t.push({
                                maxHeight: i,
                                sourceName: r
                            })
                        })), t) : null
                    }
                    constructor(e, t, n, i, r, o, s, a) {
                        super(e, t, n, i, r, o, a), this._bridgeSessionId = null, this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0, this._iceCheckingStartedTimestamp = null, this._gatheringStartedTimestamp = null, this._sourceReceiverConstraints = void 0, this._localSendReceiveVideoActive = !0, this._remoteSendReceiveVideoActive = !0, this._gatheringReported = !1, this.lasticecandidate = !1, this.closed = !1, this.isP2P = s, this.remoteRecvMaxFrameHeight = void 0, this.numRemoteVideoSources = 0, this.numRemoteAudioSources = 0, this.remoteSourceMaxFrameHeights = void 0, this.modificationQueue = new Zs, this.modificationQueue.pause(), this.wasConnected = !1, this.establishmentDuration = void 0, this._xmppListeners = [], this._xmppListeners.push(i.addCancellableListener(Mo.Events.CONN_STATUS_CHANGED, this.onXmppStatusChanged.bind(this))), this._removeSenderVideoConstraintsChangeListener = void 0
                    }
                    _assertNotEnded() {
                        return this.state !== ia
                    }
                    doInitialize(e) {
                        this.failICE = Boolean(e.failICE), this.lasticecandidate = !1, this.options = e, this.isReconnect = !1, this.wasstable = !1, this.webrtcIceUdpDisable = Boolean(e.webrtcIceUdpDisable), this.webrtcIceTcpDisable = Boolean(e.webrtcIceTcpDisable);
                        const t = {
                            disableRtx: e.disableRtx
                        };
                        if (e.gatherStats && (t.maxstats = 300), t.capScreenshareBitrate = !1, t.codecSettings = e.codecSettings, t.enableInsertableStreams = e.enableInsertableStreams, e.videoQuality) {
                            const n = Object.entries(e.videoQuality).map((e => (e[0] = e[0].toLowerCase(), e)));
                            t.videoQuality = Object.fromEntries(n)
                        }
                        var n;
                        t.forceTurnRelay = e.forceTurnRelay, t.audioQuality = e.audioQuality, t.disableSimulcast = !!this.isP2P || e.disableSimulcast, this.isP2P || (t.capScreenshareBitrate = !((null === (n = e.desktopSharingFrameRate) || void 0 === n ? void 0 : n.max) > 5)), e.startSilent && (t.startSilent = !0), this.peerconnection = this.rtc.createPeerConnection(this._signalingLayer, this.pcConfig, this.isP2P, t), this.peerconnection.onicecandidate = e => {
                            if (!e) return;
                            const t = e.candidate,
                                n = window.performance.now();
                            if (t) {
                                null === this._gatheringStartedTimestamp && (this._gatheringStartedTimestamp = n);
                                let e = t.protocol;
                                if ("string" == typeof e)
                                    if (e = e.toLowerCase(), "tcp" === e || "ssltcp" === e) {
                                        if (this.webrtcIceTcpDisable) return
                                    } else if ("udp" === e && this.webrtcIceUdpDisable) return
                            } else this._gatheringReported || (Mi.sendAnalytics(Qt, {
                                phase: "gathering",
                                value: n - this._gatheringStartedTimestamp,
                                p2p: this.isP2P,
                                initiator: this.isInitiator
                            }), this._gatheringReported = !0);
                            this.isP2P && this.sendIceCandidate(t)
                        }, this.peerconnection.onsignalingstatechange = () => {
                            "stable" === this.peerconnection.signalingState ? this.wasstable = !0 : "closed" !== this.peerconnection.signalingState && "closed" !== this.peerconnection.connectionState || this.room.eventEmitter.emit(Hi.XMPPEvents.SUSPEND_DETECTED, this)
                        }, this.peerconnection.oniceconnectionstatechange = () => {
                            const e = window.performance.now();
                            let t = !1;
                            switch (this.isP2P || (this.room.connectionTimes[`ice.state.${this.peerconnection.iceConnectionState}`] = e), da.log(`(TIME) ICE ${this.peerconnection.iceConnectionState} ${this.isP2P?"P2P":"JVB"}:\t`, e), Mi.sendAnalytics(en, {
                                    p2p: this.isP2P,
                                    state: this.peerconnection.iceConnectionState,
                                    signaling_state: this.peerconnection.signalingState,
                                    reconnect: this.isReconnect,
                                    value: e
                                }), this.room.eventEmitter.emit(Hi.XMPPEvents.ICE_CONNECTION_STATE_CHANGED, this, this.peerconnection.iceConnectionState), this.peerconnection.iceConnectionState) {
                                case "checking":
                                    this._iceCheckingStartedTimestamp = e;
                                    break;
                                case "connected":
                                    if ("stable" === this.peerconnection.signalingState) {
                                        t = !0;
                                        const e = !this.options.enableIceRestart && this.room.supportsRestartByTerminate();
                                        (this.isReconnect || e) && this.room.eventEmitter.emit(Hi.XMPPEvents.CONNECTION_RESTORED, this)
                                    }
                                    if (!this.wasConnected && (this.wasstable || t || this.isInitiator && (ci.isChromiumBased() || ci.isReactNative()))) {
                                        Mi.sendAnalytics(Qt, {
                                            phase: "checking",
                                            value: e - this._iceCheckingStartedTimestamp,
                                            p2p: this.isP2P,
                                            initiator: this.isInitiator
                                        });
                                        const t = Math.min(this._iceCheckingStartedTimestamp, this._gatheringStartedTimestamp);
                                        this.establishmentDuration = e - t, Mi.sendAnalytics(Qt, {
                                            phase: "establishment",
                                            value: this.establishmentDuration,
                                            p2p: this.isP2P,
                                            initiator: this.isInitiator
                                        }), this.wasConnected = !0, this.room.eventEmitter.emit(Hi.XMPPEvents.CONNECTION_ESTABLISHED, this)
                                    }
                                    this.isReconnect = !1;
                                    break;
                                case "disconnected":
                                    this.isReconnect = !0, this.wasstable && this.room.eventEmitter.emit(Hi.XMPPEvents.CONNECTION_INTERRUPTED, this);
                                    break;
                                case "failed":
                                    this.room.eventEmitter.emit(Hi.XMPPEvents.CONNECTION_ICE_FAILED, this)
                            }
                        }, this.peerconnection.onconnectionstatechange = () => {
                            const e = this.peerconnection.iceConnectionState;
                            "failed" === this.peerconnection.connectionState && "disconnected" === e && this.room.eventEmitter.emit(Hi.XMPPEvents.CONNECTION_ICE_FAILED, this)
                        }, this.peerconnection.onnegotiationneeded = () => {
                            const e = this.peerconnection.signalingState,
                                t = this.peerconnection.remoteDescription;
                            if (!this.isP2P && "stable" === e && t && "string" == typeof t.sdp) {
                                da.info(`${this} onnegotiationneeded fired on ${this.peerconnection}`);
                                const e = e => {
                                    this._renegotiate().then((() => e()), (t => e(t)))
                                };
                                this.modificationQueue.push(e, (e => {
                                    e ? da.error(`${this} onnegotiationneeded error`, e) : da.debug(`${this} onnegotiationneeded executed - OK`)
                                }))
                            }
                        }
                    }
                    getRemoteRecvMaxFrameHeight() {
                        if (this.isP2P) return this.remoteRecvMaxFrameHeight
                    }
                    getRemoteSourcesRecvMaxFrameHeight() {
                        if (this.isP2P) return this.remoteSourceMaxFrameHeights
                    }
                    sendIceCandidate(e) {
                        const t = new ks(this.peerconnection.localDescription.sdp);
                        if (e && e.candidate.length && !this.lasticecandidate) {
                            const n = Ns.iceparams(t.media[e.sdpMLineIndex], t.session),
                                i = Ns.candidateToJingle(e.candidate);
                            if (!n || !i) return void da.error("failed to get ice && jcand");
                            n.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", this.usedrip ? (0 === this.dripContainer.length && setTimeout((() => {
                                0 !== this.dripContainer.length && (this.sendIceCandidates(this.dripContainer), this.dripContainer = [])
                            }), 150), this.dripContainer.push(e)) : this.sendIceCandidates([e])
                        } else da.log(`${this} sendIceCandidate: last candidate`), this.lasticecandidate = !0
                    }
                    sendIceCandidates(e) {
                        if (!this._assertNotEnded("sendIceCandidates")) return;
                        da.log(`${this} sendIceCandidates ${JSON.stringify(e)}`);
                        const t = (0, St.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "transport-info",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            }),
                            n = new ks(this.peerconnection.localDescription.sdp);
                        for (let i = 0; i < n.media.length; i++) {
                            const r = e.filter((e => e.sdpMLineIndex === i)),
                                o = Ns.parseMLine(n.media[i].split("\r\n")[0]);
                            if (r.length > 0) {
                                const e = Ns.iceparams(n.media[i], n.session);
                                e.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.c("content", {
                                    creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
                                    name: r[0].sdpMid ? r[0].sdpMid : o.media
                                }).c("transport", e);
                                for (let e = 0; e < r.length; e++) {
                                    const n = Ns.candidateToJingle(r[e].candidate);
                                    this.failICE && (n.ip = "1.1.1.1"), t.c("candidate", n).up()
                                }
                                const s = Ns.findLine(n.media[i], "a=fingerprint:", n.session);
                                if (s) {
                                    const e = Ns.parseFingerprint(s);
                                    e.required = !0, t.c("fingerprint", {
                                        xmlns: "urn:xmpp:jingle:apps:dtls:0"
                                    }).t(e.fingerprint), delete e.fingerprint, t.attrs(e), t.up()
                                }
                                t.up(), t.up()
                            }
                        }
                        this.connection.sendIQ(t, null, this.newJingleErrorHandler(t), ca)
                    }
                    sendIceFailedNotification() {
                        const e = (0, St.$iq)({
                            to: this.remoteJid,
                            type: "set"
                        }).c("jingle", {
                            xmlns: "urn:xmpp:jingle:1",
                            action: "session-info",
                            initiator: this.initiatorJid,
                            sid: this.sid
                        }).c("ice-state", {
                            xmlns: "http://jitsi.org/protocol/focus"
                        }).t("failed").up();
                        this._bridgeSessionId && e.c("bridge-session", {
                            xmlns: "http://jitsi.org/protocol/focus",
                            id: this._bridgeSessionId
                        }), this.connection.sendIQ2(e, {
                            timeout: 65
                        }).catch(this.newJingleErrorHandler(e))
                    }
                    addIceCandidates(e) {
                        if ("closed" === this.peerconnection.signalingState) return void da.warn(`${this} Ignored add ICE candidate when in closed state`);
                        const t = [];
                        e.find(">content>transport>candidate").each(((e, n) => {
                            let i = Ns.candidateFromJingle(n);
                            i = i.replace("\r\n", "").replace("a=", "");
                            const r = new RTCIceCandidate({
                                sdpMLineIndex: 0,
                                sdpMid: "",
                                candidate: i
                            });
                            t.push(r)
                        })), t.length ? (da.debug(`${this} Queued add (${t.length}) ICE candidates task`), this.modificationQueue.push((e => {
                            for (const e of t) this.peerconnection.addIceCandidate(e).then((() => da.debug(`${this} addIceCandidate ok!`)), (e => da.error(`${this} addIceCandidate failed!`, e)));
                            e(), da.debug(`${this} ICE candidates task finished`)
                        }))) : da.error(`${this} No ICE candidates to add ?`, e[0] && e[0].outerHTML)
                    }
                    readSsrcInfo(e) {
                        _t()(e).find('>description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
                            const n = Number(t.getAttribute("ssrc"));
                            let i;
                            t.hasAttribute("name") && (i = t.getAttribute("name")), this.isP2P ? this._signalingLayer.setSSRCOwner(n, St.Strophe.getResourceFromJid(this.remoteJid), i) : _t()(t).find('>ssrc-info[xmlns="http://jitsi.org/jitmeet"]').each(((e, t) => {
                                const r = t.getAttribute("owner");
                                var o;
                                null != r && r.length && (isNaN(n) || n < 0 ? da.warn(`${this} Invalid SSRC ${n} value received for ${r}`) : this._signalingLayer.setSSRCOwner(n, (o = r, St.Strophe.getResourceFromJid(o) || o), i))
                            }))
                        }))
                    }
                    getConfiguredVideoCodec() {
                        return this.peerconnection.getConfiguredVideoCodec()
                    }
                    acceptOffer(e, t, n) {
                        let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [];
                        this.setOfferAnswerCycle(e, (() => {
                            this.sendSessionAccept((() => {
                                da.debug(`${this} Resuming the modification queue after session is established!`), this.modificationQueue.resume(), t(), this.room.eventEmitter.emit(Hi.XMPPEvents.SESSION_ACCEPT, this);
                                const e = i.filter((e => e.getType() === Ri.VIDEO));
                                e.length && e.splice(0, 1), e.length && this.addTracks(e)
                            }), (e => {
                                n(e), this.room.eventEmitter.emit(Hi.XMPPEvents.SESSION_ACCEPT_ERROR, this, e)
                            }))
                        }), n, i)
                    }
                    invite() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        if (!this.isInitiator) throw new Error("Trying to invite from the responder session");
                        da.debug(`${this} Executing invite task`);
                        const t = [];
                        for (const n of e) t.push(this.peerconnection.addTrack(n, this.isInitiator));
                        Promise.all(t).then((() => this.peerconnection.createOffer(this.mediaConstraints))).then((e => this.peerconnection.setLocalDescription(e))).then((() => {
                            this.peerconnection.processLocalSdpForTransceiverInfo(e), this.sendSessionInitiate(this.peerconnection.localDescription.sdp)
                        })).then((() => {
                            da.debug(`${this} invite executed - OK`)
                        })).catch((e => {
                            da.error(`${this} invite error`, e)
                        }))
                    }
                    sendSessionInitiate(e) {
                        let t = (0, St.$iq)({
                            to: this.remoteJid,
                            type: "set"
                        }).c("jingle", {
                            xmlns: "urn:xmpp:jingle:1",
                            action: "session-initiate",
                            initiator: this.initiatorJid,
                            sid: this.sid
                        });
                        new ks(e).toJingle(t, this.isInitiator ? "initiator" : "responder"), t = t.tree(), da.debug(`${this} Session-initiate: `, t), this.connection.sendIQ(t, (() => {
                            da.info(`${this} Got RESULT for "session-initiate"`)
                        }), (e => {
                            da.error(`${this} "session-initiate" error`, e)
                        }), ca)
                    }
                    setAnswer(e) {
                        if (!this.isInitiator) throw new Error("Trying to set an answer on the responder session");
                        da.debug(`${this} Executing setAnswer task`);
                        const t = this._processNewJingleOfferIq(e),
                            n = new ks(this.peerconnection.localDescription.sdp),
                            i = new RTCSessionDescription({
                                type: "answer",
                                sdp: t.raw
                            });
                        this.peerconnection.setRemoteDescription(i).then((() => {
                            if (this.state === ta) {
                                this.state = na, da.debug(`${this} Resuming the modification queue after session is established!`), this.modificationQueue.resume();
                                const e = new ks(this.peerconnection.localDescription.sdp);
                                this.sendContentModify(), this.notifyMySSRCUpdate(n, e)
                            }
                        })).then((() => {
                            da.debug(`${this} setAnswer task done`)
                        })).catch((e => {
                            da.error(`${this} setAnswer task failed: ${e}`)
                        }))
                    }
                    setOfferAnswerCycle(e, t, n) {
                        let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [];
                        da.debug(`${this} Executing setOfferAnswerCycle task`);
                        const r = [],
                            o = i.filter((e => e.getType() === Ri.AUDIO)),
                            s = i.filter((e => e.getType() === Ri.VIDEO));
                        let a = i;
                        s.length > 1 && (a = [...o, s[0]]);
                        for (const e of a) r.push(this.peerconnection.addTrack(e, this.isInitiator));
                        const d = this._processNewJingleOfferIq(e),
                            c = _t()(e).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("id");
                        c !== this._bridgeSessionId && (this._bridgeSessionId = c), Promise.all(r).then((() => this._renegotiate(d.raw))).then((() => {
                            this.peerconnection.processLocalSdpForTransceiverInfo(a), this.state === ta && (this.state = na, !this.isP2P || this._localSendReceiveVideoActive && !this._sourceReceiverConstraints || this.sendContentModify())
                        })).then((() => {
                            da.debug(`${this} setOfferAnswerCycle task done`), t()
                        })).catch((e => {
                            da.error(`${this} setOfferAnswerCycle task failed: ${e}`), n(e)
                        }))
                    }
                    setVideoCodecs(e) {
                        if (this._assertNotEnded()) {
                            da.info(`${this} setVideoCodecs: ${e}`), this.peerconnection.setVideoCodecs(e);
                            const t = e => {
                                this._renegotiate().then((() => this.peerconnection.configureSenderVideoEncodings())).then((() => (da.debug(`${this} setVideoCodecs task is done`), e())), (t => (da.error(`${this} setVideoCodecs task failed: ${t}`), e(t))))
                            };
                            da.debug(`${this} Queued setVideoCodecs task`), this.modificationQueue.push(t)
                        }
                    }
                    replaceTransport(e, t, n) {
                        if (this.options.enableForcedReload) {
                            const e = new ks(this.peerconnection.localDescription.sdp);
                            return this.sendTransportAccept(e, t, n), void this.room.eventEmitter.emit(Hi.XMPPEvents.CONNECTION_RESTARTED, this)
                        }
                        this.room.eventEmitter.emit(Hi.XMPPEvents.ICE_RESTARTING, this);
                        const i = e.clone();
                        e.find(">content[name='data']").attr("senders", "rejected"), e.find(">content>description>source").remove(), e.find(">content>description>ssrc-group").remove();
                        const r = e.find(">content>transport>fingerprint");
                        r.attr("hash", "sha-1"), r.text("00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00"), da.debug(`${this} Queued ICE restart task`), this.modificationQueue.push((r => {
                            this.setOfferAnswerCycle(e, (() => {
                                this.setOfferAnswerCycle(i, (() => {
                                    const e = new ks(this.peerconnection.localDescription.sdp);
                                    "number" == typeof this.options.channelLastN && this.options.channelLastN >= 0 && (e.initialLastN = this.options.channelLastN), this.sendTransportAccept(e, t, n), this.room.eventEmitter.emit(Hi.XMPPEvents.ICE_RESTART_SUCCESS, this, i), r()
                                }), (e => r(e)))
                            }), (e => r(e)))
                        }), (e => {
                            if (e) {
                                if (e instanceof Qs) return da.debug(`${this} ICE restart task aborted: session terminated`), void t();
                                da.error(`${this} ICE restart task failed: ${e}`), n(e)
                            } else da.debug(`${this} ICE restart task done`), t()
                        }))
                    }
                    sendSessionAccept(e, t) {
                        const n = new ks(this.peerconnection.localDescription.sdp),
                            i = (0, St.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "session-accept",
                                initiator: this.initiatorJid,
                                responder: this.responderJid,
                                sid: this.sid
                            });
                        this.webrtcIceTcpDisable && (n.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (n.removeUdpCandidates = !0), this.failICE && (n.failICE = !0), "number" == typeof this.options.channelLastN && this.options.channelLastN >= 0 && (n.initialLastN = this.options.channelLastN), n.toJingle(i, this.initiatorJid === this.localJid ? "initiator" : "responder"), da.info(`${this} Sending session-accept`), da.debug(i.tree()), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, (e => {
                            t(e), this.room.eventEmitter.emit(Hi.XMPPEvents.SESSION_ACCEPT_TIMEOUT, this)
                        })), ca)
                    }
                    sendContentModify() {
                        const e = this._localSendReceiveVideoActive ? "both" : "none",
                            t = (0, St.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "content-modify",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            }).c("content", {
                                name: Ri.VIDEO,
                                senders: e
                            });
                        void 0 !== this._sourceReceiverConstraints && this._sourceReceiverConstraints.forEach(((e, n) => {
                            t.c("source-frame-height", {
                                xmlns: "http://jitsi.org/jitmeet/video"
                            }).attrs({
                                sourceName: n,
                                maxHeight: e
                            }), t.up(), da.info(`${this} sending content-modify for source-name: ${n}, maxHeight: ${e}`)
                        })), da.debug(t.tree()), this.connection.sendIQ(t, null, this.newJingleErrorHandler(t), ca)
                    }
                    setReceiverVideoConstraint(e) {
                        da.info(`${this} setReceiverVideoConstraint - constraints: ${JSON.stringify(e)}`), this._sourceReceiverConstraints = e, this.isP2P && this.state === na && this.sendContentModify()
                    }
                    sendTransportAccept(e, t, n) {
                        const i = (0, St.$iq)({
                            to: this.remoteJid,
                            type: "set"
                        }).c("jingle", {
                            xmlns: "urn:xmpp:jingle:1",
                            action: "transport-accept",
                            initiator: this.initiatorJid,
                            sid: this.sid
                        });
                        e.media.forEach(((t, n) => {
                            const r = Ns.parseMLine(t.split("\r\n")[0]);
                            i.c("content", {
                                creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
                                name: r.media
                            }), e.transportToJingle(n, i), i.up()
                        })), da.info(`${this} Sending transport-accept`), da.debug(i.tree()), this.connection.sendIQ(i, t, this.newJingleErrorHandler(i, n), ca)
                    }
                    sendTransportReject(e, t) {
                        const n = (0, St.$iq)({
                            to: this.remoteJid,
                            type: "set"
                        }).c("jingle", {
                            xmlns: "urn:xmpp:jingle:1",
                            action: "transport-reject",
                            initiator: this.initiatorJid,
                            sid: this.sid
                        });
                        da.info(`${this} Sending 'transport-reject'`), da.debug(n.tree()), this.connection.sendIQ(n, e, this.newJingleErrorHandler(n, t), ca)
                    }
                    setSenderVideoConstraint(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                        if (this._assertNotEnded()) {
                            da.info(`${this} setSenderVideoConstraint: ${e}, sourceName: ${t}`);
                            const n = t ? this.rtc.getLocalVideoTracks().find((e => e.getSourceName() === t)) : this.rtc.getLocalVideoTrack();
                            return this.peerconnection.setSenderVideoConstraints(e, n)
                        }
                        return Promise.resolve()
                    }
                    terminate(e, t, n) {
                        if (this.state !== ia) {
                            if (!n || Boolean(n.sendSessionTerminate)) {
                                const i = (0, St.$iq)({
                                    to: this.remoteJid,
                                    type: "set"
                                }).c("jingle", {
                                    xmlns: "urn:xmpp:jingle:1",
                                    action: "session-terminate",
                                    initiator: this.initiatorJid,
                                    sid: this.sid
                                }).c("reason").c(n && n.reason || "success").up();
                                n && n.reasonDescription ? i.c("text").t(n.reasonDescription).up().up() : i.up(), this._bridgeSessionId && i.c("bridge-session", {
                                    xmlns: "http://jitsi.org/protocol/focus",
                                    id: this._bridgeSessionId,
                                    restart: n && !0 === n.requestRestart
                                }).up(), da.info(`${this} Sending session-terminate`), da.debug(i.tree()), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, t), ca)
                            } else da.info(`${this} Skipped sending session-terminate`);
                            this.connection.jingle.terminate(this.sid)
                        }
                    }
                    onTerminated(e, t) {
                        da.info(`${this} Session terminated`, e, t), this._xmppListeners.forEach((e => e())), this._xmppListeners = [], this._removeSenderVideoConstraintsChangeListener && this._removeSenderVideoConstraintsChangeListener(), Ai.isSsrcRewritingSupported() && this.peerconnection && this.peerconnection.getRemoteTracks().forEach((e => {
                            this.room.eventEmitter.emit(bt.TRACK_REMOVED, e)
                        })), this.close()
                    }
                    onXmppStatusChanged(e) {
                        e === Mo.Status.CONNECTED && this._cachedOldLocalSdp && (da.info(`${this} Sending SSRC update on reconnect`), this.notifyMySSRCUpdate(this._cachedOldLocalSdp, this._cachedNewLocalSdp))
                    }
                    _parseSsrcInfoFromSourceAdd(e, t) {
                        const n = [],
                            i = this;
                        return _t()(e).each(((e, r) => {
                            const o = _t()(r).attr("name");
                            let s = "";
                            _t()(r).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                const e = this.getAttribute("semantics"),
                                    t = _t()(this).find(">source").map((function() {
                                        return this.getAttribute("ssrc")
                                    })).get();
                                t.length && (s += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
                            })), _t()(r).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                const e = _t()(this).attr("ssrc");
                                t.containsSSRC(e) ? !i.isP2P && da.warn(`${i} Source-add request for existing SSRC: ${e}`) : _t()(this).find(">parameter").each((function() {
                                    s += `a=ssrc:${e} ${_t()(this).attr("name")}`, _t()(this).attr("value") && _t()(this).attr("value").length && (s += `:${_t()(this).attr("value")}`), s += "\r\n"
                                }))
                            }));
                            let a = !1;
                            t.media.forEach(((e, t) => {
                                Ns.findLine(e, `a=mid:${o}`) && (n[t] || (n[t] = ""), n[t] += s, a = !0)
                            })), !a && this.isP2P && (n[o] = s)
                        })), n
                    }
                    addRemoteStream(e) {
                        this._addOrRemoveRemoteStream(!0, e)
                    }
                    removeRemoteStream(e) {
                        this._addOrRemoveRemoteStream(!1, e)
                    }
                    processSourceMap(e, t) {
                        if (!Ai.isSsrcRewritingSupported()) return;
                        const n = [];
                        for (const i of e.mappedSources) {
                            const {
                                owner: e,
                                source: r,
                                ssrc: o
                            } = i;
                            if (this.peerconnection.addRemoteSsrc(o, r)) {
                                n.push(i), da.debug(`New SSRC signaled ${o}: owner=${e}, source-name=${r}`);
                                const t = this.peerconnection.remoteSources.get(r);
                                if (t) {
                                    this._signalingLayer.removeSSRCOwners([t]);
                                    const e = this.peerconnection.getTrackBySSRC(t);
                                    e && (e.setSourceName(void 0), e.setOwner(void 0), e._setVideoType(void 0))
                                }
                            } else {
                                da.debug(`Existing SSRC re-mapped ${o}: new owner=${e}, source-name=${r}`);
                                const n = this.peerconnection.getTrackBySSRC(o);
                                this._signalingLayer.setSSRCOwner(o, e, r), n.setSourceName(r), n.setOwner(e);
                                const i = this._signalingLayer.getPeerMediaInfo(e, t, r);
                                i && (n._setVideoType(i.videoType), this.peerconnection._sourceMutedChanged(r, i.muted))
                            }
                        }
                        if (n.length) {
                            let e = (0, St.$build)("content", {
                                xmlns: "urn:xmpp:jingle:1",
                                name: t
                            }).c("description", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:1",
                                media: t
                            });
                            for (const i of n) {
                                const {
                                    rtx: n,
                                    ssrc: r,
                                    source: o
                                } = i;
                                let s;
                                if (t === Ri.VIDEO) {
                                    const t = ++this.numRemoteVideoSources;
                                    s = `remote-video-${t} remote-video-${t}`, "-1" !== n && (la(e, i, n, s), e.c("ssrc-group", {
                                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                                        semantics: "FID"
                                    }).c("source", {
                                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                                        ssrc: r
                                    }).up().c("source", {
                                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                                        ssrc: n
                                    }).up().up())
                                } else {
                                    const e = ++this.numRemoteAudioSources;
                                    s = `remote-audio-${e} remote-audio-${e}`
                                }
                                la(e, i, r, s), this.peerconnection.remoteSources.set(o, r)
                            }
                            e = e.up(), this._addOrRemoveRemoteStream(!0, e.node)
                        }
                    }
                    removeRemoteStreamsOnLeave(e) {
                        da.debug(`${this} Queued removeRemoteStreamsOnLeave task for participant ${e}`), this.modificationQueue.push((t => {
                            const n = this.peerconnection.getRemoteSourceInfoByParticipant(e);
                            if (n.length) {
                                const e = this._processRemoteRemoveSource(n);
                                this._renegotiate(e.raw).then((() => t()), (e => t(e)))
                            } else t()
                        }), (e => {
                            e ? da.error(`${this} removeRemoteStreamsOnLeave error:`, e) : da.info(`${this} removeRemoteStreamsOnLeave done!`)
                        }))
                    }
                    _addOrRemoveRemoteStream(e, t) {
                        const n = e ? "addRemoteStream" : "removeRemoteStream";
                        e && this.readSsrcInfo(t), da.debug(`${this} Queued ${n} task`), this.modificationQueue.push((i => {
                            if (!this.peerconnection.localDescription || !this.peerconnection.localDescription.sdp) {
                                const e = `${n} - localDescription not ready yet`;
                                return da.error(e), void i(e)
                            }
                            da.log(`${this} Processing ${n}`);
                            const r = new ks(this.peerconnection.remoteDescription.sdp),
                                o = e ? this._parseSsrcInfoFromSourceAdd(t, r) : this._parseSsrcInfoFromSourceRemove(t, r),
                                s = e ? this._processRemoteAddSource(o) : this._processRemoteRemoveSource(o);
                            this._renegotiate(s.raw).then((() => {
                                da.log(`${this} ${n} - OK`), i()
                            }), (e => {
                                da.error(`${this} ${n} failed:`, e), i(e)
                            }))
                        }))
                    }
                    _processNewJingleOfferIq(e) {
                        const t = new ks("");
                        return this.webrtcIceTcpDisable && (t.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (t.removeUdpCandidates = !0), this.failICE && (t.failICE = !0), t.fromJingle(e), this.readSsrcInfo(_t()(e).find(">content")), t
                    }
                    _processRemoteRemoveSource(e) {
                        var t;
                        const n = new ks(this.peerconnection.peerconnection.remoteDescription.sdp);
                        let i;
                        return e.forEach((e => {
                            let t;
                            (e = e.split("\r\n")).pop(), i = e.map((e => {
                                var t;
                                return Number(null === (t = e.split("a=ssrc:")[1]) || void 0 === t ? void 0 : t.split(" ")[0])
                            })), e.forEach((e => {
                                if (t = n.media.findIndex((t => t.includes(e))), t > -1)
                                    if (n.media[t] = n.media[t].replace(`${e}\r\n`, ""), this.isP2P) {
                                        var i;
                                        const e = null === (i = Ns.parseMLine(n.media[t].split("\r\n")[0])) || void 0 === i ? void 0 : i.media,
                                            r = this.peerconnection.getDesiredMediaDirection(e, !1);
                                        [Rs.SENDRECV, Rs.SENDONLY].forEach((e => {
                                            n.media[t] = n.media[t].replace(`a=${e}`, `a=${r}`)
                                        }))
                                    } else {
                                        n.media[t] = n.media[t].replace(`a=${Rs.SENDONLY}`, `a=${Rs.INACTIVE}`);
                                        const {
                                            media: e,
                                            port: i
                                        } = Ns.parseMLine(n.media[t].split("\r\n")[0]);
                                        n.media[t] = n.media[t].replace(`m=${e} ${i}`, `m=${e} 0`)
                                    }
                            }))
                        })), (null === (t = i) || void 0 === t ? void 0 : t.length) && this._signalingLayer.removeSSRCOwners(i), n.raw = n.session + n.media.join(""), n
                    }
                    _processRemoteAddSource(e) {
                        let t = new ks(this.peerconnection.remoteDescription.sdp);
                        return e.length > t.media.length && this.isP2P && (t.addMlineForNewLocalSource(Ri.VIDEO), t = new ks(t.raw)), e.forEach(((e, n) => {
                            if (t.media[n] += e, this.isP2P) {
                                var i;
                                const e = null === (i = Ns.parseMLine(t.media[n].split("\r\n")[0])) || void 0 === i ? void 0 : i.media,
                                    r = this.peerconnection.getDesiredMediaDirection(e, !0);
                                [Rs.RECVONLY, Rs.INACTIVE].forEach((e => {
                                    t.media[n] = t.media[n].replace(`a=${e}`, `a=${r}`)
                                }))
                            }
                        })), t.raw = t.session + t.media.join(""), t
                    }
                    _renegotiate(e) {
                        if ("closed" === this.peerconnection.signalingState) {
                            const e = new Error("Attempted to renegotiate in state closed");
                            return this.room.eventEmitter.emit(Hi.XMPPEvents.RENEGOTIATION_FAILED, e, this), Promise.reject(e)
                        }
                        const t = e || this.peerconnection.remoteDescription.sdp;
                        if (!t) {
                            const e = new Error(`Can not renegotiate without remote description, current state: ${this.state}`);
                            return this.room.eventEmitter.emit(Hi.XMPPEvents.RENEGOTIATION_FAILED, e, this), Promise.reject(e)
                        }
                        const n = new RTCSessionDescription({
                                type: "offer",
                                sdp: t
                            }),
                            i = this.peerconnection.localDescription.sdp;
                        return da.debug(`${this} Renegotiate: setting remote description`), this.peerconnection.setRemoteDescription(n).then((() => (da.debug(`${this} Renegotiate: creating answer`), this.peerconnection.createAnswer(this.mediaConstraints)))).then((e => (da.debug(`${this} Renegotiate: setting local description`), this.peerconnection.setLocalDescription(e)))).then((() => {
                            i && this.notifyMySSRCUpdate(new ks(i), new ks(this.peerconnection.localDescription.sdp))
                        }))
                    }
                    addTracks() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                        if (null != e && e.length || Promise.reject(new Error("No tracks passed")), e.find((e => e.getType() !== Ri.VIDEO))) return Promise.reject(new Error("Multiple tracks of the given media type are not supported"));
                        const t = [],
                            n = n => {
                                const i = new ks(this.peerconnection.peerconnection.remoteDescription.sdp),
                                    r = this.peerconnection.peerconnection.getTransceivers().find((e => e.receiver.track.kind === Ri.VIDEO && e.direction === Rs.RECVONLY && e.currentDirection === Rs.RECVONLY));
                                for (const t of e) this.isP2P && r || i.addMlineForNewLocalSource(t.getType());
                                this._renegotiate(i.raw).then((() => {
                                    for (const n of e) t.push(this.peerconnection.replaceTrack(null, n));
                                    return Promise.all(t)
                                })).then((() => this._renegotiate())).then((() => n()), (e => n(e)))
                            };
                        return new Promise(((e, t) => {
                            da.debug(`${this} Queued renegotiation after addTrack`), this.modificationQueue.push(n, (n => {
                                if (n) {
                                    if (n instanceof Qs) return da.debug(`${this} renegotiation after addTrack aborted: session terminated`), void e();
                                    da.error(`${this} renegotiation after addTrack error`, n), t(n)
                                } else da.debug(`${this} renegotiation after addTrack executed - OK`), e()
                            }))
                        }))
                    }
                    setMediaTransferActive(e) {
                        return this.peerconnection.tpcUtils.setMediaTransferActive(e).then((() => {
                            this.peerconnection.audioTransferActive = e, this.peerconnection.videoTransferActive = e;
                            const t = [];
                            for (const e of this.rtc.getLocalVideoTracks()) t.push(this.peerconnection.configureSenderVideoEncodings(e));
                            return Promise.allSettled(t)
                        }))
                    }
                    replaceTrack(e, t) {
                        const n = n => {
                            da.debug(`${this} replaceTrack worker started. oldTrack = ${e}, newTrack = ${t}`), this.peerconnection.replaceTrack(e, t).then((n => {
                                let i = Promise.resolve();
                                return da.debug(`${this} TPC.replaceTrack finished. shouldRenegotiate = ${n}, JingleSessionState = ${this.state}`), n && (e || t) && this.state === na && (i = this._renegotiate()), i.then((() => {
                                    e && t && e.isVideoTrack() && t.setSourceName(e.getSourceName())
                                }))
                            })).then((() => n()), (e => n(e)))
                        };
                        return new Promise(((i, r) => {
                            da.debug(`${this} Queued replaceTrack task. Old track = ${e}, new track = ${t}`), this.modificationQueue.push(n, (e => {
                                if (e) {
                                    if (e instanceof Qs) return da.debug("Replace track aborted: session terminated"), void i();
                                    da.error(`${this} Replace track error:`, e), r(e)
                                } else da.info(`${this}  Replace track done!`), i()
                            }))
                        }))
                    }
                    _parseSsrcInfoFromSourceRemove(e, t) {
                        const n = [];
                        return _t()(e).each(((e, i) => {
                            const r = _t()(i).attr("name");
                            let o = "";
                            _t()(i).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                const e = this.getAttribute("semantics"),
                                    t = _t()(this).find(">source").map((function() {
                                        return this.getAttribute("ssrc")
                                    })).get();
                                t.length && (o += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
                            }));
                            const s = [];
                            _t()(i).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                const e = _t()(this).attr("ssrc");
                                s.push(e)
                            })), t.media.forEach(((e, t) => {
                                Ns.findLine(e, `a=mid:${r}`) && (n[t] || (n[t] = ""), s.forEach((i => {
                                    const r = Ns.findLines(e, `a=ssrc:${i}`);
                                    r.length && (n[t] += `${r.join("\r\n")}\r\n`)
                                })), n[t] += o)
                            }))
                        })), n
                    }
                    addTrackToPc(e) {
                        return this._addRemoveTrack(!1, e).then((() => {
                            if (e.isVideoTrack()) return this.peerconnection.configureSenderVideoEncodings(e)
                        }))
                    }
                    removeTrackFromPc(e) {
                        return this._addRemoveTrack(!0, e)
                    }
                    _addRemoveTrack(e, t) {
                        if (!t) return Promise.reject('invalid "track" argument value');
                        const n = e ? "removeTrack" : "addTrack",
                            i = i => {
                                const r = this.peerconnection;
                                r ? (e ? r.removeTrackFromPc(t) : r.addTrackToPc(t)).then((e => {
                                    e ? this._renegotiate().then(i) : i()
                                }), i) : i(`Error:  tried ${n} track with no active peer connection`)
                            };
                        return da.debug(`${this} Queued ${n} task`), new Promise(((e, t) => {
                            this.modificationQueue.push(i, (i => {
                                if (i) {
                                    if (i instanceof Qs) return da.debug(`${this} ${n} aborted: session terminated`), void e();
                                    da.error(`${this} ${n} failed`), t(i)
                                } else da.debug(`${this} ${n} done`), e()
                            }))
                        }))
                    }
                    setP2pVideoTransferActive(e) {
                        return this.peerconnection ? this._localSendReceiveVideoActive !== e ? (this._localSendReceiveVideoActive = e, this.isP2P && this.state === na && this.sendContentModify(), this.peerconnection.setVideoTransferActive(this._localSendReceiveVideoActive && this._remoteSendReceiveVideoActive)) : Promise.resolve() : Promise.reject('Can not modify video transfer active state, before "initialize" is called')
                    }
                    modifyContents(e) {
                        const t = ha.parseVideoSenders(e),
                            n = ha.parseSourceMaxFrameHeight(e);
                        if (n && (this.remoteSourceMaxFrameHeights = n, this.eventEmitter.emit(aa.REMOTE_SOURCE_CONSTRAINTS_CHANGED, this, n)), null === t) return void da.error(`${this} - failed to parse video "senders" attribute in "content-modify" action`);
                        if (!this._assertNotEnded()) return;
                        const i = "both" === t || "initiator" === t && this.isInitiator || "responder" === t && !this.isInitiator;
                        i !== this._remoteSendReceiveVideoActive && (da.debug(`${this} new remote video active: ${i}`), this._remoteSendReceiveVideoActive = i, this.peerconnection.setVideoTransferActive(this._localSendReceiveVideoActive && this._remoteSendReceiveVideoActive))
                    }
                    notifyMySSRCUpdate(e, t) {
                        if (this.state !== na) return void da.warn(`${this} Skipping SSRC update in '${this.state} ' state.`);
                        if (!this.connection.connected) return this._cachedOldLocalSdp || (this._cachedOldLocalSdp = e), this._cachedNewLocalSdp = t, void da.warn(`${this} Not sending SSRC update while the signaling is disconnected`);
                        this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0;
                        const n = e => {
                            const t = e.getNewMedia();
                            let n = [],
                                i = null;
                            return Object.keys(t).forEach((e => {
                                const r = Object.keys(t[e].ssrcs);
                                i = t[e].mid, null != r && r.length && (n = n.concat(r))
                            })), {
                                mediaType: i,
                                ssrcs: n
                            }
                        };
                        let i = new Ls(t, e);
                        const r = (0, St.$iq)({
                            to: this.remoteJid,
                            type: "set"
                        }).c("jingle", {
                            xmlns: "urn:xmpp:jingle:1",
                            action: "source-remove",
                            initiator: this.initiatorJid,
                            sid: this.sid
                        });
                        i.toJingle(r);
                        const o = {},
                            s = n(i);
                        s.ssrcs.length && (da.info(`${this} Sending source-remove for ${s.mediaType} ssrcs=${s.ssrcs}`), this.connection.sendIQ(r, (() => {
                            this.room.eventEmitter.emit(Hi.XMPPEvents.SOURCE_REMOVE, this, o)
                        }), this.newJingleErrorHandler(r, (e => {
                            this.room.eventEmitter.emit(Hi.XMPPEvents.SOURCE_REMOVE_ERROR, this, e, o)
                        })), ca)), i = new Ls(e, t);
                        const a = (0, St.$iq)({
                            to: this.remoteJid,
                            type: "set"
                        }).c("jingle", {
                            xmlns: "urn:xmpp:jingle:1",
                            action: "source-add",
                            initiator: this.initiatorJid,
                            sid: this.sid
                        });
                        i.toJingle(a);
                        const d = n(i);
                        d.ssrcs.length && (da.info(`${this} Sending source-add for ${d.mediaType} ssrcs=${d.ssrcs}`), this.connection.sendIQ(a, (() => {
                            this.room.eventEmitter.emit(Hi.XMPPEvents.SOURCE_ADD, this, o)
                        }), this.newJingleErrorHandler(a, (e => {
                            this.room.eventEmitter.emit(Hi.XMPPEvents.SOURCE_ADD_ERROR, this, e, d.mediaType, o)
                        })), ca))
                    }
                    newJingleErrorHandler(e, t) {
                        return e => {
                            const n = {},
                                i = _t()(e).find("error");
                            if (i.length) {
                                n.code = i.attr("code");
                                const t = _t()(e).find("error :first");
                                t.length && (n.reason = t[0].tagName);
                                const r = i.find(">text");
                                r.length && (n.msg = r.text())
                            }
                            e || (n.reason = "timeout"), n.session = this.toString(), t ? t(n) : this.state === ia && "item-not-found" === n.reason ? da.debug(`${this} Jingle error: ${JSON.stringify(n)}`) : da.error(`Jingle error: ${JSON.stringify(n)}`)
                        }
                    }
                    getIceConnectionState() {
                        return this.peerconnection.getConnectionState()
                    }
                    close() {
                        this.state = ia, this.establishmentDuration = void 0, this.peerconnection && (this.peerconnection.onicecandidate = null, this.peerconnection.oniceconnectionstatechange = null, this.peerconnection.onnegotiationneeded = null, this.peerconnection.onsignalingstatechange = null), da.debug(`${this} Clearing modificationQueue`), this.modificationQueue.clear(), da.debug(`${this} Queued PC close task`), this.modificationQueue.push((e => {
                            this.peerconnection && this.peerconnection.close(), e(), da.debug(`${this} PC close task done!`)
                        })), da.debug(`${this} Shutdown modificationQueue!`), this.modificationQueue.shutdown()
                    }
                    toString() {
                        return `JingleSessionPC[session=${this.isP2P?"P2P":"JVB"},initiator=${this.isInitiator},sid=${this.sid}]`
                    }
                }
                const ua = (0, E.getLogger)("modules/xmpp/strophe.jingle.js");

                function pa(e) {
                    const t = _t()(e).find(">candidate"),
                        n = [];
                    return t.each(((e, t) => {
                        const i = t.attributes,
                            r = [];
                        for (let e = 0; e < i.length; e++) {
                            const t = i[e];
                            r.push(`${t.name}: ${t.value}`)
                        }
                        n.push(r.join(" "))
                    })), n
                }
                class ma extends Po {
                    constructor(e, t, n) {
                        super(), this.xmpp = e, this.eventEmitter = t, this.sessions = {}, this.jvbIceConfig = n.jvb, this.p2pIceConfig = n.p2p, this.mediaConstraints = {
                            offerToReceiveAudio: !0,
                            offerToReceiveVideo: !0
                        }
                    }
                    init(e) {
                        super.init(e), this.connection.addHandler(this.onJingle.bind(this), "urn:xmpp:jingle:1", "iq", "set", null, null)
                    }
                    onJingle(e) {
                        const t = _t()(e).find("jingle").attr("sid"),
                            n = _t()(e).find("jingle").attr("action"),
                            i = e.getAttribute("from"),
                            r = (0, St.$iq)({
                                type: "result",
                                to: i,
                                id: e.getAttribute("id")
                            });
                        let o = this.sessions[t];
                        if ("session-initiate" !== n) {
                            if (!o) return r.attrs({
                                type: "error"
                            }), r.c("error", {
                                type: "cancel"
                            }).c("item-not-found", {
                                xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                            }).up().c("unknown-session", {
                                xmlns: "urn:xmpp:jingle:errors:1"
                            }), ua.warn(`invalid session id: ${t}`), ua.debug(e), this.connection.send(r), !0;
                            if (i !== o.remoteJid) return ua.warn("jid mismatch for session id", t, o.remoteJid, e), r.attrs({
                                type: "error"
                            }), r.c("error", {
                                type: "cancel"
                            }).c("item-not-found", {
                                xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                            }).up().c("unknown-session", {
                                xmlns: "urn:xmpp:jingle:errors:1"
                            }), this.connection.send(r), !0
                        } else if (void 0 !== o) return r.attrs({
                            type: "error"
                        }), r.c("error", {
                            type: "cancel"
                        }).c("service-unavailable", {
                            xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                        }).up(), ua.warn("duplicate session id", t, e), this.connection.send(r), !0;
                        const s = window.performance.now(),
                            a = "focus" !== St.Strophe.getResourceFromJid(i),
                            d = _t()(e).find("jingle>json-message");
                        if (null != d && d.length) {
                            var c;
                            let t;
                            ua.info(`Found a JSON-encoded element in ${n}, translating to standard Jingle.`);
                            for (let n = 0; n < d.length; n++) t = xs(e, d[n]);
                            if (null !== (c = t) && void 0 !== c && c.size) {
                                const e = [];
                                for (const n of t.keys()) e.push(`${n}:[${t.get(n)}]`);
                                ua.debug(`Received ${n} from ${i} with sources=${e.join(", ")}`)
                            }
                        }
                        switch (n) {
                            case "session-initiate": {
                                ua.log("(TIME) received session-initiate:\t", s);
                                const t = _t()(e).find("jingle>startmuted");
                                if (a && ua.debug(`Received ${n} from ${i}`), null != t && t.length) {
                                    const e = t.attr(Ri.AUDIO),
                                        n = t.attr(Ri.VIDEO);
                                    this.eventEmitter.emit(Hi.XMPPEvents.START_MUTED_FROM_FOCUS, "true" === e, "true" === n)
                                }
                                const r = a ? this.p2pIceConfig : this.jvbIceConfig;
                                o = new ha(_t()(e).find("jingle").attr("sid"), _t()(e).attr("to"), i, this.connection, this.mediaConstraints, Es()(r), a, !1), this.sessions[o.sid] = o, this.eventEmitter.emit(Hi.XMPPEvents.CALL_INCOMING, o, _t()(e).find(">jingle"), s);
                                break
                            }
                            case "session-accept": {
                                const t = [],
                                    r = _t()(e).find("jingle>content");
                                for (const e of r) {
                                    const n = _t()(e).find("description").attr("ssrc");
                                    n && t.push(n)
                                }
                                ua.debug(`Received ${n} from ${i} with ssrcs=${t}`), this.eventEmitter.emit(Hi.XMPPEvents.CALL_ACCEPTED, o, _t()(e).find(">jingle"));
                                break
                            }
                            case "content-modify":
                                ua.debug(`Received ${n} from ${i}`), o.modifyContents(_t()(e).find(">jingle"));
                                break;
                            case "transport-info": {
                                const t = pa(_t()(e).find("jingle>content>transport"));
                                ua.debug(`Received ${n} from ${i} for candidates=${t.join(", ")}`), this.eventEmitter.emit(Hi.XMPPEvents.TRANSPORT_INFO, o, _t()(e).find(">jingle"));
                                break
                            }
                            case "session-terminate": {
                                ua.log("terminating...", o.sid);
                                let t = null,
                                    r = null;
                                _t()(e).find(">jingle>reason").length && (t = _t()(e).find(">jingle>reason>:first")[0].tagName, r = _t()(e).find(">jingle>reason>text").text()), ua.debug(`Received ${n} from ${i} disconnect reason=${r}`), this.terminate(o.sid, t, r), this.eventEmitter.emit(Hi.XMPPEvents.CALL_ENDED, o, t, r);
                                break
                            }
                            case "transport-replace": {
                                var l;
                                ua.info("(TIME) Start transport replace:\t", s);
                                const t = _t()(e).find("jingle>content>transport"),
                                    r = pa(t),
                                    d = _t()(t).attr("ufrag"),
                                    c = _t()(t).attr("pwd"),
                                    h = null === (l = _t()(t).find(">fingerprint")) || void 0 === l ? void 0 : l.text();
                                ua.debug(`Received ${n} from ${i} with iceUfrag=${d}, icePwd=${c}, DTLS fingerprint=${h}, candidates=${r.join(", ")}`), Mi.sendAnalytics(dn(Jt, {
                                    p2p: a,
                                    value: s
                                })), o.replaceTransport(_t()(e).find(">jingle"), (() => {
                                    const e = window.performance.now();
                                    ua.info("(TIME) Transport replace success:\t", e), Mi.sendAnalytics(dn(Bt, {
                                        p2p: a,
                                        value: e
                                    }))
                                }), (e => {
                                    ua.error("Transport replace failed", e), o.sendTransportReject()
                                }));
                                break
                            }
                            case "source-add":
                                o.addRemoteStream(_t()(e).find(">jingle>content"));
                                break;
                            case "source-remove":
                                o.removeRemoteStream(_t()(e).find(">jingle>content"));
                                break;
                            default:
                                ua.warn("jingle action not implemented", n), r.attrs({
                                    type: "error"
                                }), r.c("error", {
                                    type: "cancel"
                                }).c("bad-request", {
                                    xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                                }).up()
                        }
                        return this.connection.send(r), !0
                    }
                    newP2PJingleSession(e, t) {
                        const n = new ha(ao().randomHexString(12), e, t, this.connection, this.mediaConstraints, this.p2pIceConfig, !0, !0);
                        return this.sessions[n.sid] = n, n
                    }
                    terminate(e, t, n) {
                        this.sessions.hasOwnProperty(e) && ("ended" !== this.sessions[e].state && this.sessions[e].onTerminated(t, n), delete this.sessions[e])
                    }
                    getStunAndTurnCredentials() {
                        this.connection.sendIQ((0, St.$iq)({
                            type: "get",
                            to: this.xmpp.options.hosts.domain
                        }).c("services", {
                            xmlns: "urn:xmpp:extdisco:2"
                        }), (e => this.onReceiveStunAndTurnCredentials(e)), (() => {
                            ua.warn("getting turn credentials with extdisco:2 failed, trying extdisco:1"), this.connection.sendIQ((0, St.$iq)({
                                type: "get",
                                to: this.xmpp.options.hosts.domain
                            }).c("services", {
                                xmlns: "urn:xmpp:extdisco:1"
                            }), (e => this.onReceiveStunAndTurnCredentials(e)), (() => {
                                ua.warn("getting turn credentials failed"), ua.warn("is mod_turncredentials or similar installed and configured?")
                            }))
                        }))
                    }
                    onReceiveStunAndTurnCredentials(e) {
                        let t = [];
                        _t()(e).find(">services>service").each(((e, n) => {
                            const i = {},
                                r = (n = _t()(n)).attr("type");
                            switch (r) {
                                case "stun":
                                    i.urls = `stun:${n.attr("host")}`, n.attr("port") && (i.urls += `:${n.attr("port")}`), t.push(i);
                                    break;
                                case "turn":
                                case "turns": {
                                    i.urls = `${r}:`, i.username = n.attr("username"), i.urls += n.attr("host");
                                    const e = n.attr("port");
                                    e && (i.urls += `:${e}`);
                                    const o = n.attr("transport");
                                    o && "udp" !== o && (i.urls += `?transport=${o}`), i.credential = n.attr("password") || i.credential, t.push(i);
                                    break
                                }
                            }
                        }));
                        const n = this.xmpp.options,
                            {
                                iceServersOverride: i = []
                            } = n;
                        i.forEach((e => {
                            let {
                                targetType: n,
                                urls: i,
                                username: r,
                                credential: o
                            } = e;
                            if (!["turn", "turns", "stun"].includes(n)) return;
                            const s = `${n}:`;
                            void 0 === i && void 0 === r && void 0 === o || (null === i && (t = t.filter((e => !e.urls.startsWith(s)))), t.forEach((e => {
                                e.urls.startsWith(s) && (e.urls = null != i ? i : e.urls, null === r ? delete e.username : e.username = null != r ? r : e.username, null === o ? delete e.credential : e.credential = null != o ? o : e.credential)
                            })))
                        }));
                        for (let e = t.length - 1; e > 0; e--) {
                            const n = Math.floor(Math.random() * (e + 1)),
                                i = t[e];
                            t[e] = t[n], t[n] = i
                        }
                        let r;
                        return r = n.useTurnUdp ? e => e.urls.startsWith("turn") : e => e.urls.startsWith("turn") && e.urls.indexOf("transport=tcp") >= 0, this.jvbIceConfig.iceServers = t.filter(r), this.p2pIceConfig.iceServers = t, t.length > 0
                    }
                    getLog() {
                        const e = {};
                        return Object.keys(this.sessions).forEach((t => {
                            const n = this.sessions[t].peerconnection;
                            n && n.updateLog && (e[`jingle_${t}`] = {
                                updateLog: n.updateLog,
                                stats: n.stats,
                                url: window.location.href
                            })
                        })), e
                    }
                }
                class ga extends Po {
                    constructor() {
                        super(), this.log = []
                    }
                    init(e) {
                        super.init(e), this.connection.rawInput = this.logIncoming.bind(this), this.connection.rawOutput = this.logOutgoing.bind(this)
                    }
                    logIncoming(e) {
                        this.log.push([(new Date).getTime(), "incoming", e])
                    }
                    logOutgoing(e) {
                        this.log.push([(new Date).getTime(), "outgoing", e])
                    }
                }
                const fa = (0, E.getLogger)("modules/xmpp/strophe.rayo.js"),
                    va = "urn:xmpp:rayo:1";
                class _a extends Po {
                    init(e) {
                        super.init(e), this.connection.addHandler(this.onRayo.bind(this), va, "iq", "set", null, null)
                    }
                    onRayo(e) {
                        fa.info("Rayo IQ", e)
                    }
                    dial(e, t, n, i, r) {
                        return new Promise(((o, s) => {
                            if (!r) return void s(new Error("Internal error!"));
                            const a = (0, St.$iq)({
                                type: "set",
                                to: r
                            });
                            a.c("dial", {
                                xmlns: va,
                                to: e,
                                from: t
                            }), a.c("header", {
                                name: "JvbRoomName",
                                value: n
                            }).up(), i && i.length && a.c("header", {
                                name: "JvbRoomPassword",
                                value: i
                            }).up(), this.connection.sendIQ(a, (e => {
                                fa.info("Dial result ", e);
                                const t = _t()(e).find("ref").attr("uri");
                                this.callResource = t.substr("xmpp:".length), fa.info(`Received call resource: ${this.callResource}`), o()
                            }), (e => {
                                fa.info("Dial error ", e), s(e)
                            }))
                        }))
                    }
                    hangup() {
                        return new Promise(((e, t) => {
                            if (!this.callResource) return t(new Error("No call in progress")), void fa.warn("No call in progress");
                            const n = (0, St.$iq)({
                                type: "set",
                                to: this.callResource
                            });
                            n.c("hangup", {
                                xmlns: va
                            }), this.connection.sendIQ(n, (t => {
                                fa.info("Hangup result ", t), this.callResource = null, e()
                            }), (e => {
                                fa.info("Hangup error ", e), this.callResource = null, t(new Error("Hangup error "))
                            }))
                        }))
                    }
                }
                const ya = (0, E.getLogger)("modules/xmpp/strophe.util.js");
                let Ea = -1;
                const Sa = /request id \d+.\d+ got 200/,
                    ba = /request errored, status: (\d+), number of errors: \d+/,
                    Ta = (0, E.getLogger)("modules/xmpp/xmpp.js"),
                    Ca = /<failure.*><not-allowed\/><text>(.*)<\/text><\/failure>/gi;
                const xa = [{
                        urls: "stun:meet-jit-si-turnrelay.jitsi.net:443"
                    }],
                    Ra = "type",
                    Aa = "http://jitsi.org/protocol/jigasi",
                    wa = "https://jitsi.org/meet/e2ee";
                class Ia extends Cr {
                    constructor(e, t) {
                        if (super(), e.bosh && !e.serviceUrl) throw new Error('The "bosh" option is no longer supported, please use "serviceUrl" instead');
                        this.connection = null, this.disconnectInProgress = !1, this.connectionTimes = {}, this.options = e, this.token = t, this.authenticatedUser = !1, this.options.deploymentInfo || (this.options.deploymentInfo = {}), this._components = [], St.Strophe.log = function(e, t) {
                            switch (ya.trace("Strophe", e, t), "string" == typeof t && -1 !== t.indexOf("Request ") && -1 !== t.indexOf("timed out (secondary), restarting") && (e = St.Strophe.LogLevel.WARN), e) {
                                case St.Strophe.LogLevel.DEBUG:
                                    -1 !== Ea && Sa.test(t) && (ya.debug("Reset lastErrorStatus"), Ea = -1);
                                    break;
                                case St.Strophe.LogLevel.WARN:
                                    ya.warn(`Strophe: ${t}`);
                                    const e = ba.exec(t);
                                    e && 2 === e.length && (Ea = parseInt(e[1], 10), ya.debug(`lastErrorStatus set to: ${Ea}`));
                                    break;
                                case St.Strophe.LogLevel.ERROR:
                                case St.Strophe.LogLevel.FATAL:
                                    ya.error(`Strophe: ${t}`, t)
                            }
                        }, St.Strophe.getLastErrorStatus = function() {
                            return Ea
                        }, St.Strophe.getStatusString = function(e) {
                            switch (e) {
                                case St.Strophe.Status.BINDREQUIRED:
                                    return "BINDREQUIRED";
                                case St.Strophe.Status.ERROR:
                                    return "ERROR";
                                case St.Strophe.Status.CONNECTING:
                                    return "CONNECTING";
                                case St.Strophe.Status.CONNFAIL:
                                    return "CONNFAIL";
                                case St.Strophe.Status.AUTHENTICATING:
                                    return "AUTHENTICATING";
                                case St.Strophe.Status.AUTHFAIL:
                                    return "AUTHFAIL";
                                case St.Strophe.Status.CONNECTED:
                                    return "CONNECTED";
                                case St.Strophe.Status.DISCONNECTED:
                                    return "DISCONNECTED";
                                case St.Strophe.Status.DISCONNECTING:
                                    return "DISCONNECTING";
                                case St.Strophe.Status.ATTACHED:
                                    return "ATTACHED";
                                default:
                                    return "unknown"
                            }
                        }, St.Strophe.addConnectionPlugin("logger", new ga);
                        const n = e.xmppPing || {};
                        n.domain = e.hosts.domain, this.connection = function(e) {
                            let {
                                enableWebsocketResume: t,
                                serviceUrl: n = "/http-bind",
                                shard: i,
                                token: r,
                                websocketKeepAlive: o,
                                websocketKeepAliveUrl: s,
                                xmppPing: a
                            } = e;
                            return r && (n += `${-1===n.indexOf("?")?"?":"&"}token=${r}`), new Mo({
                                enableWebsocketResume: t,
                                serviceUrl: n,
                                websocketKeepAlive: o,
                                websocketKeepAliveUrl: s,
                                xmppPing: a,
                                shard: i
                            })
                        }({
                            enableWebsocketResume: e.enableWebsocketResume,
                            serviceUrl: e.serviceUrl,
                            token: t,
                            websocketKeepAlive: e.websocketKeepAlive,
                            websocketKeepAliveUrl: e.websocketKeepAliveUrl,
                            xmppPing: n,
                            shard: e.deploymentInfo.shard
                        }), this.moderator = new zo(this), this.connection.on(Mo.Events.CONN_SHARD_CHANGED, (() => {
                            const e = {
                                shard_changed: !0,
                                suspend_time: this.connection.ping.getPingSuspendTime(),
                                time_since_last_success: this.connection.getTimeSinceLastSuccess()
                            };
                            this.eventEmitter.emit(ur, Er, void 0, void 0, e)
                        })), this._initStrophePlugins(), this.caps = new So(this.connection, "https://jitsi.org/jitsi-meet"), this.initFeaturesList(), _t()(window).on((this.options.disableBeforeUnloadHandlers ? "" : "beforeunload ") + "unload", (e => {
                            this.disconnect(e).catch((() => {}))
                        }))
                    }
                    initFeaturesList() {
                        this.caps.addFeature("urn:xmpp:jingle:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:1"), this.caps.addFeature("urn:xmpp:jingle:transports:ice-udp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:dtls:0"), this.caps.addFeature("urn:xmpp:jingle:transports:dtls-sctp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:audio"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:video"), this.caps.addFeature("http://jitsi.org/json-encoded-sources"), !this.options.disableRtx && ci.supportsRTX() && this.caps.addFeature("urn:ietf:rfc:4588"), !0 === this.options.enableOpusRed && ci.supportsAudioRed() && this.caps.addFeature("http://jitsi.org/opus-red"), (void 0 === this.options.enableRemb || this.options.enableRemb) && this.caps.addFeature("http://jitsi.org/remb"), ci.isFirefox() && ci.isVersionLessThan(115) || void 0 !== this.options.enableTcc && !this.options.enableTcc || this.caps.addFeature("http://jitsi.org/tcc"), this.connection.rayo && this.caps.addFeature("urn:xmpp:rayo:client:1"), oo.isSupported(this.options) && this.caps.addFeature(wa, !1, !0), Ta.debug("Source-name signaling is enabled"), this.caps.addFeature("http://jitsi.org/source-name"), Ta.debug("Receiving multiple video streams is enabled"), this.caps.addFeature("http://jitsi.org/receive-multiple-video-streams"), Ai.isSsrcRewritingSupported() && this.caps.addFeature("http://jitsi.org/ssrc-rewriting-1"), Ai.isJoinAsVisitorSupported() && this.caps.addFeature("http://jitsi.org/visitors-1")
                    }
                    getConnection() {
                        return this.connection
                    }
                    connectionHandler() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            t = arguments.length > 1 ? arguments[1] : void 0,
                            n = arguments.length > 2 ? arguments[2] : void 0;
                        const i = window.performance.now(),
                            r = St.Strophe.getStatusString(t).toLowerCase();
                        if (this.connectionTimes[r] = i, Ta.log(`(TIME) Strophe ${r}${n?`[${n}]`:""}:\t`, i), this.eventEmitter.emit(Hi.XMPPEvents.CONNECTION_STATUS_CHANGED, e, t, n), this._maybeSendDeploymentInfoStat(), t === St.Strophe.Status.CONNECTED || t === St.Strophe.Status.ATTACHED) this._sysMessageHandler && (this.connection._stropheConn.deleteHandler(this._sysMessageHandler), this._sysMessageHandler = null), this.sendDiscoInfo && this.connection.jingle.getStunAndTurnCredentials(), Ta.info(`My Jabber ID: ${this.connection.jid}`), this._resetState(), this.sendDeploymentInfo = !1, this.sendDiscoInfo && this.caps.getFeaturesAndIdentities(this.options.hosts.domain).then((e => {
                            let {
                                features: t,
                                identities: n
                            } = e;
                            t.has(St.Strophe.NS.PING) || Ta.error(`Ping NOT supported by ${this.options.hosts.domain} - please enable ping in your XMPP server config`), this._processDiscoInfoIdentities(n, void 0)
                        })).catch((e => {
                            Ta.error("Feature discovery error", e), this._maybeSendDeploymentInfoStat(!0)
                        })), this.sendDiscoInfo = !1, e.password && (this.authenticatedUser = !0), this.connection && this.connection.connected && St.Strophe.getResourceFromJid(this.connection.jid) && this.eventEmitter.emit(hr, St.Strophe.getResourceFromJid(this.connection.jid));
                        else if (t === St.Strophe.Status.CONNFAIL) "x-strophe-bad-non-anon-jid" === n ? this.anonymousConnectionFailed = !0 : this.connectionFailed = !0, this.lastErrorMsg = n, "giving-up" === n && this.eventEmitter.emit(ur, Er, n);
                        else if (t === St.Strophe.Status.ERROR) this.lastErrorMsg = n;
                        else if (t === St.Strophe.Status.DISCONNECTED) {
                            this.connection.ping.stopInterval();
                            const e = Boolean(this.disconnectInProgress),
                                t = n || this.lastErrorMsg;
                            if (this.anonymousConnectionFailed) this.eventEmitter.emit(ur, Sr);
                            else if (this.connectionFailed) this.eventEmitter.emit(ur, Er, t, void 0, this._getConnectionFailedReasonDetails());
                            else if (e) this.eventEmitter.emit(lr, t);
                            else {
                                Ta.error("XMPP connection dropped!");
                                const e = St.Strophe.getLastErrorStatus();
                                e >= 500 && e < 600 ? this.eventEmitter.emit(ur, br, t || "server-error", void 0, this._getConnectionFailedReasonDetails()) : this.eventEmitter.emit(ur, yr, t || "connection-dropped-error", void 0, this._getConnectionFailedReasonDetails())
                            }
                        } else if (t === St.Strophe.Status.AUTHFAIL) {
                            const t = this.getConnection().getLastFailedMessage();
                            this.eventEmitter.emit(ur, Sr, n || this._parseConnectionFailedMessage(t), e)
                        }
                    }
                    _processDiscoInfoIdentities(e, t) {
                        e.forEach((e => {
                            if ("av_moderation" === e.type && (this.avModerationComponentAddress = e.name, this._components.push(this.avModerationComponentAddress)), "end_conference" === e.type && (this.endConferenceComponentAddress = e.name, this._components.push(this.endConferenceComponentAddress)), "speakerstats" === e.type && (this.speakerStatsComponentAddress = e.name, this._components.push(this.speakerStatsComponentAddress)), "lobbyrooms" === e.type) {
                                this.lobbySupported = !0;
                                const n = e => {
                                    e.forEach((e => {
                                        e.endsWith("#displayname_required") && this.eventEmitter.emit(gr)
                                    }))
                                };
                                t ? n(t) : e.name && this.caps.getFeaturesAndIdentities(e.name, e.type).then((e => {
                                    let {
                                        features: t
                                    } = e;
                                    return n(t)
                                })).catch((e => Ta.warn("Error getting features from lobby.", e && e.message)))
                            }
                            if ("shard" === e.type && (this.options.deploymentInfo.shard = this.connection.shard = e.name), "region" === e.type && (this.options.deploymentInfo.region = this.connection.region = e.name), "release" === e.type && (this.options.deploymentInfo.backendRelease = e.name), "breakout_rooms" === e.type) {
                                this.breakoutRoomsComponentAddress = e.name, this._components.push(this.breakoutRoomsComponentAddress);
                                const n = e => {
                                    this.breakoutRoomsFeatures = {}, e.forEach((e => {
                                        e.endsWith("#rename") && (this.breakoutRoomsFeatures.rename = !0)
                                    }))
                                };
                                t ? n(t) : e.name && this.caps.getFeaturesAndIdentities(e.name, e.type).then((e => {
                                    let {
                                        features: t
                                    } = e;
                                    return n(t)
                                })).catch((e => Ta.warn("Error getting features for breakout rooms.", e && e.message)))
                            }
                            "room_metadata" === e.type && (this.roomMetadataComponentAddress = e.name, this._components.push(this.roomMetadataComponentAddress)), "visitors" === e.type && this._components.push(e.name)
                        })), this._maybeSendDeploymentInfoStat(!0), this._components.length > 0 && this.connection.addHandler(this._onPrivateMessage.bind(this), null, "message", null, null)
                    }
                    _parseConnectionFailedMessage(e) {
                        if (!e) return null;
                        Ca.lastIndex = 0;
                        const t = Ca.exec(e);
                        return t ? t[1] : null
                    }
                    _connect(e, t) {
                        this._resetState(), this.sendDiscoInfo = !0, this.sendDeploymentInfo = !0, this.connection._stropheConn && this.connection._stropheConn._addSysHandler ? this._sysMessageHandler = this.connection._stropheConn._addSysHandler(this._onSystemMessage.bind(this), null, "message") : Ta.warn("Cannot attach strophe system handler, jiconop cannot operate"), this.connection.connect(e, t, this.connectionHandler.bind(this, {
                            jid: e,
                            password: t
                        }))
                    }
                    _onSystemMessage(e) {
                        if (0 === _t()(e).find(">services").length && 0 === _t()(e).find(">query").length) return;
                        this.sendDiscoInfo = !1;
                        const t = this.connection.jingle.onReceiveStunAndTurnCredentials(e),
                            {
                                features: n,
                                identities: i
                            } = Eo(e);
                        this._processDiscoInfoIdentities(i, n), (t || i.size > 0 || n.size > 0) && (this.connection._stropheConn.deleteHandler(this._sysMessageHandler), this._sysMessageHandler = null)
                    }
                    attach(e) {
                        this._resetState(), this.sendDiscoInfo = !0;
                        const t = this.connectionTimes.attaching = window.performance.now();
                        Ta.log("(TIME) Strophe Attaching:\t", t), this.connection.attach(e.jid, e.sid, parseInt(e.rid, 10) + 1, this.connectionHandler.bind(this, {
                            jid: e.jid,
                            password: e.password
                        }))
                    }
                    _resetState() {
                        this.anonymousConnectionFailed = !1, this.connectionFailed = !1, this.lastErrorMsg = void 0, this.disconnectInProgress = void 0
                    }
                    connect(e, t) {
                        if (!e) {
                            const {
                                anonymousdomain: t,
                                domain: n
                            } = this.options.hosts;
                            let i = t || n;
                            const {
                                location: r
                            } = window;
                            if (t) {
                                const e = r && r.search;
                                (e && -1 !== e.indexOf("login=true") || this.token) && (i = n)
                            }
                            e = i || r && r.hostname
                        }
                        return this._startConnecting = !0, this._connect(e, t)
                    }
                    createRoom(e, t, n) {
                        const i = e.domain || t.customDomain;
                        let r = `${this.getRoomJid(e,i)}/`;
                        const o = n ? n(this.connection.jid, this.authenticatedUser) : ao().randomHexString(8).toLowerCase();
                        return Ta.info(`JID ${this.connection.jid} using MUC nickname ${o}`), r += o, this.connection.emuc.createRoom(r, null, t)
                    }
                    getRoomJid(e, t) {
                        return `${e}@${t||this.options.hosts.muc.toLowerCase()}`
                    }
                    isRoomCreated(e, t) {
                        return this.connection.emuc.isRoomCreated(this.getRoomJid(e, t))
                    }
                    getJid() {
                        return this.connection.jid
                    }
                    getJingleLog() {
                        const e = this.connection.jingle;
                        return e ? e.getLog() : {}
                    }
                    getXmppLog() {
                        return (this.connection.logger || {}).log || null
                    }
                    dial() {
                        this.connection.rayo.dial(...arguments)
                    }
                    ping(e) {
                        return new Promise(((t, n) => {
                            this.connection.ping.ping(this.connection.pingDomain, t, n, e)
                        }))
                    }
                    getSessions() {
                        return this.connection.jingle.sessions
                    }
                    disconnect(e) {
                        return this.disconnectInProgress ? this.disconnectInProgress : this.connection && this._startConnecting ? (this.disconnectInProgress = new Promise((e => {
                            const t = (n, i) => {
                                i === St.Strophe.Status.DISCONNECTED && (this.eventEmitter.removeListener(Hi.XMPPEvents.CONNECTION_STATUS_CHANGED, t), e())
                            };
                            this.eventEmitter.on(Hi.XMPPEvents.CONNECTION_STATUS_CHANGED, t)
                        })), this._cleanupXmppConnection(e), this.disconnectInProgress) : Promise.resolve()
                    }
                    _cleanupXmppConnection(e) {
                        if (!this.connection.isUsingWebSocket && this.connection.flush(), !this.connection.isUsingWebSocket && null != e) {
                            const t = e.type;
                            if (("beforeunload" === t || "unload" === t) && (this.connection.options.sync = !0, this.connection.sendUnavailableBeacon())) return
                        }
                        this.connection.disconnect(), this._startConnecting = !1, !0 !== this.connection.options.sync && this.connection.flush()
                    }
                    _initStrophePlugins() {
                        const e = {
                                jvb: {
                                    iceServers: []
                                },
                                p2p: {
                                    iceServers: []
                                }
                            },
                            t = this.options.p2p && this.options.p2p.stunServers || xa;
                        Array.isArray(t) && (Ta.info("P2P STUN servers: ", t), e.p2p.iceServers = t), this.options.p2p && this.options.p2p.iceTransportPolicy && (Ta.info("P2P ICE transport policy: ", this.options.p2p.iceTransportPolicy), e.p2p.iceTransportPolicy = this.options.p2p.iceTransportPolicy), this.connection.addConnectionPlugin("emuc", new _s(this)), this.connection.addConnectionPlugin("jingle", new ma(this, this.eventEmitter, e)), this.connection.addConnectionPlugin("rayo", new _a)
                    }
                    _getConnectionFailedReasonDetails() {
                        const e = {};
                        if (this.options.deploymentInfo && this.options.deploymentInfo.shard && this.connection.lastResponseHeaders) {
                            const t = this.connection.lastResponseHeaders.trim().split(/[\r\n]+/),
                                n = {};
                            t.forEach((e => {
                                const t = e.split(": "),
                                    i = t.shift(),
                                    r = t.join(": ");
                                n[i] = r
                            })), e.shard_changed = this.options.deploymentInfo.shard !== n["x-jitsi-shard"]
                        }
                        return e.suspend_time = this.connection.ping.getPingSuspendTime(), e.time_since_last_success = this.connection.getTimeSinceLastSuccess(), e
                    }
                    sendDominantSpeakerEvent(e, t) {
                        if (!this.speakerStatsComponentAddress || !e) return;
                        const n = (0, St.$msg)({
                            to: this.speakerStatsComponentAddress
                        });
                        n.c("speakerstats", {
                            xmlns: "http://jitsi.org/jitmeet",
                            room: e,
                            silence: t
                        }).up(), this.connection.send(n)
                    }
                    sendFaceLandmarksEvent(e, t) {
                        if (!this.speakerStatsComponentAddress || !e) return;
                        const n = (0, St.$msg)({
                            to: this.speakerStatsComponentAddress
                        });
                        n.c("faceLandmarks", {
                            xmlns: "http://jitsi.org/jitmeet",
                            room: e,
                            faceExpression: t.faceExpression,
                            timestamp: t.timestamp,
                            duration: t.duration
                        }).up(), this.connection.send(n)
                    }
                    tryParseJSONAndVerify(e) {
                        if (!e) return !1;
                        try {
                            const t = vr(e);
                            if (t && "object" == typeof t) {
                                const e = t[Ra];
                                if (void 0 !== e) return t;
                                Ta.debug("parsing valid json but does not have correct structure", "topic: ", e)
                            }
                        } catch (t) {
                            return Ta.error(`Error parsing json ${e}`, t), !1
                        }
                        return !1
                    }
                    _onPrivateMessage(e) {
                        const t = e.getAttribute("from");
                        if (!this._components.includes(t)) return !0;
                        const n = _t()(e).find(">json-message").text(),
                            i = this.tryParseJSONAndVerify(n);
                        return !i || ("speakerstats" === i[Ra] && i.users ? this.eventEmitter.emit(Hi.XMPPEvents.SPEAKER_STATS_RECEIVED, i.users) : "av_moderation" === i[Ra] ? this.eventEmitter.emit(Hi.XMPPEvents.AV_MODERATION_RECEIVED, i) : "breakout_rooms" === i[Ra] ? this.eventEmitter.emit(Hi.XMPPEvents.BREAKOUT_ROOMS_EVENT, i) : "room_metadata" === i[Ra] ? this.eventEmitter.emit(Hi.XMPPEvents.ROOM_METADATA_EVENT, i) : "visitors" === i[Ra] && this.eventEmitter.emit(Hi.XMPPEvents.VISITORS_MESSAGE, i), !0)
                    }
                    _maybeSendDeploymentInfoStat(e) {
                        const t = [St.Strophe.Status.ERROR, St.Strophe.Status.CONNFAIL, St.Strophe.Status.AUTHFAIL, St.Strophe.Status.DISCONNECTED, St.Strophe.Status.CONNTIMEOUT];
                        if (!(e || t.includes(this.connection.status) && this.sendDeploymentInfo)) return;
                        const n = this.options.deploymentInfo;
                        if (n && Object.keys(n).length > 0) {
                            const e = {};
                            for (const t in n) n.hasOwnProperty(t) && (e[t] = n[t]);
                            Mi.analytics.addPermanentProperties({
                                ...e
                            }), e.id = "deployment_info";
                            const t = JSON.stringify(e);
                            Ta.info(t)
                        }
                        this.sendDeploymentInfo = !1
                    }
                }

                function Pa(e) {
                    let t, {
                            id: n,
                            password: i,
                            onCreateResource: r,
                            onLoginSuccessful: o
                        } = e,
                        s = !1,
                        a = new Ia(this.connection.options);
                    const d = new Promise(((e, d) => {
                        t = d, a.addListener(lr, (() => {
                            a = void 0
                        })), a.addListener(hr, (() => {
                            if (s) return;
                            o && o();
                            const t = a.createRoom(this.options.name, this.options.config, r);
                            t.xmpp.moderator.authenticate(t.roomjid).then((() => {
                                a && a.disconnect(), s || this.room.xmpp.moderator.sendConferenceRequest(this.room.roomjid).finally(e)
                            })).catch((e => {
                                let {
                                    error: t,
                                    message: n
                                } = e;
                                a.disconnect(), d({
                                    authenticationError: t,
                                    message: n
                                })
                            }))
                        })), a.addListener(ur, ((e, t, n) => {
                            d({
                                connectionError: e,
                                credentials: n,
                                message: t
                            }), a = void 0
                        })), s || a.connect(n, i)
                    }));
                    return d.cancel = () => {
                        s = !0, t({}), a && a.disconnect()
                    }, d
                }
                const Da = (0, E.getLogger)("modules/RTC/CodecSelection.js"),
                    Oa = [Ps.VP9, Ps.VP8, Ps.H264],
                    Na = [Ps.H264, Ps.VP8, Ps.VP9],
                    ka = [Ps.VP8, Ps.VP9, Ps.H264];
                class Ma {
                    constructor(e, t) {
                        this.conference = e, this.options = t, this.codecPreferenceOrder = {}, this.visitorCodecs = [];
                        for (const e of Object.keys(t)) {
                            let {
                                disabledCodec: r,
                                preferredCodec: o,
                                preferenceOrder: s
                            } = t[e];
                            const a = new Set(this._getSupportedVideoCodecs(e));
                            let d = Array.from(a);
                            if (s) s = s.map((e => e.toLowerCase())), d = s.filter((e => a.has(e)));
                            else if (o || r) {
                                var n, i;
                                r = null === (n = r) || void 0 === n ? void 0 : n.toLowerCase(), o = null === (i = o) || void 0 === i ? void 0 : i.toLowerCase(), r && r !== Ps.VP8 && (d = d.filter((e => e !== r)));
                                const e = d.findIndex((e => e === o));
                                o && -1 !== e && (d.splice(e, 1), d.unshift(o))
                            }
                            if (!(ci.supportsVP9() || ci.isWebKitBased() && "p2p" === e) || this.conference.isE2EEEnabled()) {
                                const e = d.findIndex((e => e === Ps.VP9)); - 1 !== e && (d.splice(e, 1), this.conference.isE2EEEnabled() || d.push(Ps.VP9))
                            }
                            Da.info(`Codec preference order for ${e} connection is ${d}`), this.codecPreferenceOrder[e] = d
                        }
                        this.conference.on(q, (e => this._selectPreferredCodec(e))), this.conference.on(ue, (e => this._updateVisitorCodecs(e))), this.conference.on(at, (() => this._selectPreferredCodec())), this.conference.on(dt, (() => this._selectPreferredCodec()))
                    }
                    _getSupportedVideoCodecs(e) {
                        const t = ci.isMobileDevice() && "p2p" === e ? Na : ci.isMobileDevice() ? ka : Oa;
                        ("p2p" === e || this.options.jvb.supportsAv1) && t.push(Ps.AV1);
                        const n = t.filter((e => {
                            var t, n, i, r;
                            return (null !== (t = null === (n = window.RTCRtpReceiver) || void 0 === n || null === (i = n.getCapabilities) || void 0 === i || null === (r = i.call(n, Ri.VIDEO)) || void 0 === r ? void 0 : r.codecs) && void 0 !== t ? t : []).some((t => t.mimeType.toLowerCase() === `${Ri.VIDEO}/${e}`))
                        }));
                        return !n.length && n.push(Ps.VP8), n
                    }
                    _selectPreferredCodec(e) {
                        const t = e || this.conference.jvbJingleSession;
                        if (!t) return;
                        const n = t.peerconnection.getConfiguredVideoCodecs(),
                            i = t === this.conference.jvbJingleSession;
                        let r = i ? this.codecPreferenceOrder.jvb : this.codecPreferenceOrder.p2p;
                        this.conference.isE2EEEnabled() && i && (r = [Ps.VP8]);
                        const o = this.conference.getParticipants().map((e => e.getId())),
                            s = null == o ? void 0 : o.map((e => {
                                const n = t._signalingLayer.getPeerMediaInfo(e, Ri.VIDEO);
                                return null != n && n.codecList ? n.codecList : null != n && n.codecType ? [n.codecType] : []
                            }));
                        this.visitorCodecs.length && s.push(this.visitorCodecs);
                        const a = r.reduce(((e, n) => {
                            let i = !1;
                            if (!t.isP2P)
                                for (const e of s) e.length && (i = i || !e.find((e => e === n)));
                            return i || e.push(n), e
                        }), []);
                        a.length ? a.every(((e, t) => e === n[t])) || t.setVideoCodecs(a) : Da.warn("Invalid codec list generated because of a user joining/leaving the call")
                    }
                    _updateVisitorCodecs(e) {
                        this.visitorCodecs !== e && (this.visitorCodecs = e, this._selectPreferredCodec())
                    }
                    getCodecPreferenceList(e) {
                        return this.codecPreferenceOrder[e]
                    }
                }
                const La = (0, E.getLogger)("modules/RTC/BridgeChannel.js");
                class Fa {
                    constructor(e, t, n, i) {
                        if (!e && !t) throw new TypeError("At least peerconnection or wsUrl must be given");
                        if (e && t) throw new TypeError("Just one of peerconnection or wsUrl must be given");
                        if (e ? La.debug("constructor() with peerconnection") : La.debug(`constructor() with wsUrl:"${t}"`), this._channel = null, this._conference = i, this._connected = void 0, this._eventEmitter = n, this._mode = null, this._areRetriesEnabled = !1, this._closedFromClient = !1, e) {
                            const t = e.createDataChannel("JVB data channel", {
                                protocol: "http://jitsi.org/protocols/colibri"
                            });
                            this._handleChannel(t), this._mode = "datachannel"
                        } else t && (this._areRetriesEnabled = !0, this._wsUrl = t, this._initWebSocket())
                    }
                    _initWebSocket() {
                        const e = new WebSocket(this._wsUrl);
                        this._handleChannel(e), this._mode = "websocket"
                    }
                    _startConnectionRetries() {
                        let e = 1;
                        const t = () => {
                            !this._channel || "connecting" !== this._channel.readyState && this._channel.readyState !== WebSocket.CONNECTING ? this.isOpen() || (this._initWebSocket(this._wsUrl), e = Math.min(2 * e, 60), this._retryTimeout = setTimeout(t, 1e3 * e)) : this._retryTimeout = setTimeout(t, 1e3 * e)
                        };
                        this._retryTimeout = setTimeout(t, 1e3 * e)
                    }
                    _stopConnectionRetries() {
                        this._retryTimeout && (clearTimeout(this._retryTimeout), this._retryTimeout = void 0)
                    }
                    _retryWebSocketConnection(e) {
                        if (!this._areRetriesEnabled) return;
                        const {
                            code: t,
                            reason: n
                        } = e;
                        Mi.sendAnalytics(((e, t) => ({
                            type: Nt.TYPE_OPERATIONAL,
                            action: "bridge-channel.error",
                            attributes: {
                                code: e,
                                reason: t
                            }
                        }))(t, n)), this._areRetriesEnabled = !1, this._eventEmitter.once(ji.default.DATA_CHANNEL_OPEN, (() => {
                            this._stopConnectionRetries(), this._areRetriesEnabled = !0
                        })), this._startConnectionRetries()
                    }
                    get mode() {
                        return this._mode
                    }
                    close() {
                        if (this._closedFromClient = !0, this._stopConnectionRetries(), this._areRetriesEnabled = !1, this._channel) {
                            try {
                                this._channel.close()
                            } catch (e) {}
                            this._channel = null
                        }
                    }
                    isOpen() {
                        return this._channel && ("open" === this._channel.readyState || this._channel.readyState === WebSocket.OPEN)
                    }
                    sendEndpointStatsMessage(e) {
                        this._send({
                            colibriClass: "EndpointStats",
                            ...e
                        })
                    }
                    sendMessage(e, t) {
                        this._send({
                            colibriClass: "EndpointMessage",
                            msgPayload: t,
                            to: e
                        })
                    }
                    sendSetLastNMessage(e) {
                        La.log(`Sending lastN=${e}.`), this._send({
                            colibriClass: "LastNChangedEvent",
                            lastN: e
                        })
                    }
                    sendReceiverVideoConstraintsMessage(e) {
                        La.log(`Sending ReceiverVideoConstraints with ${JSON.stringify(e)}`), this._send({
                            colibriClass: "ReceiverVideoConstraints",
                            ...e
                        })
                    }
                    sendSourceVideoTypeMessage(e, t) {
                        La.info(`Sending SourceVideoTypeMessage with video type ${e}: ${t}`), this._send({
                            colibriClass: "SourceVideoTypeMessage",
                            sourceName: e,
                            videoType: t
                        })
                    }
                    _handleChannel(e) {
                        const t = this._eventEmitter;
                        e.onopen = () => {
                            La.info(`${this._mode} channel opened`), this._connected = !0, t.emit(ji.default.DATA_CHANNEL_OPEN)
                        }, e.onerror = e => {
                            "websocket" !== this._mode && La.error(`Channel error: ${e.message}`)
                        }, e.onmessage = e => {
                            let n, {
                                data: i
                            } = e;
                            try {
                                n = vr(i)
                            } catch (e) {
                                return void La.error("Failed to parse channel message as JSON: ", i, e)
                            }
                            const r = n.colibriClass;
                            switch (r) {
                                case "DominantSpeakerEndpointChangeEvent": {
                                    const {
                                        dominantSpeakerEndpoint: e,
                                        previousSpeakers: i = [],
                                        silence: r
                                    } = n;
                                    La.debug(`Dominant speaker: ${e}, previous speakers: ${i}`), t.emit(ji.default.DOMINANT_SPEAKER_CHANGED, e, i, r);
                                    break
                                }
                                case "EndpointConnectivityStatusChangeEvent": {
                                    const e = n.endpoint,
                                        i = "true" === n.active;
                                    La.info(`Endpoint connection status changed: ${e} active=${i}`), t.emit(ji.default.ENDPOINT_CONN_STATUS_CHANGED, e, i);
                                    break
                                }
                                case "EndpointMessage":
                                    t.emit(ji.default.ENDPOINT_MESSAGE_RECEIVED, n.from, n.msgPayload);
                                    break;
                                case "EndpointStats":
                                    t.emit(ji.default.ENDPOINT_STATS_RECEIVED, n.from, n);
                                    break;
                                case "ForwardedSources": {
                                    const e = n.forwardedSources;
                                    La.info(`New forwarded sources: ${e}`), t.emit(ji.default.FORWARDED_SOURCES_CHANGED, e);
                                    break
                                }
                                case "SenderSourceConstraints":
                                    "string" == typeof n.sourceName && "number" == typeof n.maxHeight ? (La.info(`SenderSourceConstraints: ${n.sourceName} - ${n.maxHeight}`), t.emit(ji.default.SENDER_VIDEO_CONSTRAINTS_CHANGED, n)) : La.error(`Invalid SenderSourceConstraints: ${n.sourceName} - ${n.maxHeight}`);
                                    break;
                                case "ServerHello":
                                    La.info(`Received ServerHello, version=${n.version}.`);
                                    break;
                                case "VideoSourcesMap":
                                    La.info(`Received VideoSourcesMap: ${JSON.stringify(n.mappedSources)}`), t.emit(ji.default.VIDEO_SSRCS_REMAPPED, n);
                                    break;
                                case "AudioSourcesMap":
                                    La.info(`Received AudioSourcesMap: ${JSON.stringify(n.mappedSources)}`), t.emit(ji.default.AUDIO_SSRCS_REMAPPED, n);
                                    break;
                                default:
                                    La.debug("Channel JSON-formatted message: ", n), t.emit(`rtc.datachannel.${r}`, n)
                            }
                        }, e.onclose = n => {
                            if (La.debug("Channel closed by " + (this._closedFromClient ? "client" : "server")), e === this._channel) {
                                if (!(this._closedFromClient || 1001 === n.code && 1 === this._conference.getParticipantCount())) {
                                    const {
                                        code: e,
                                        reason: i
                                    } = n;
                                    La.error(`Channel closed: ${e} ${i}`), "websocket" === this._mode && (this._retryWebSocketConnection(n), !1 !== this._connected && t.emit(ji.default.DATA_CHANNEL_CLOSED, {
                                        code: e,
                                        reason: i
                                    }))
                                }
                                this._connected = !1, this._channel = null
                            } else La.debug("Skip close handler, channel instance is not equal to stored one")
                        }, this._channel = e
                    }
                    _send(e) {
                        const t = this._channel;
                        if (!this.isOpen()) throw La.error("Bridge Channel send: no opened channel."), new Error("No opened channel");
                        t.send(JSON.stringify(e))
                    }
                }
                let ja;
                ! function(e) {
                    e.ENVIRONMENT = "environment", e.USER = "user"
                }(ja || (ja = {}));
                let Va = !0,
                    Ua = !0;

                function Ha(e, t, n) {
                    const i = e.match(t);
                    return i && i.length >= n && parseInt(i[n], 10)
                }

                function $a(e, t, n) {
                    if (!e.RTCPeerConnection) return;
                    const i = e.RTCPeerConnection.prototype,
                        r = i.addEventListener;
                    i.addEventListener = function(e, i) {
                        if (e !== t) return r.apply(this, arguments);
                        const o = e => {
                            const t = n(e);
                            t && (i.handleEvent ? i.handleEvent(t) : i(t))
                        };
                        return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(i, o), r.apply(this, [e, o])
                    };
                    const o = i.removeEventListener;
                    i.removeEventListener = function(e, n) {
                        if (e !== t || !this._eventMap || !this._eventMap[t]) return o.apply(this, arguments);
                        if (!this._eventMap[t].has(n)) return o.apply(this, arguments);
                        const i = this._eventMap[t].get(n);
                        return this._eventMap[t].delete(n), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o.apply(this, [e, i])
                    }, Object.defineProperty(i, "on" + t, {
                        get() {
                            return this["_on" + t]
                        },
                        set(e) {
                            this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e)
                        },
                        enumerable: !0,
                        configurable: !0
                    })
                }

                function Ja(e) {
                    return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (Va = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled")
                }

                function Ba(e) {
                    return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (Ua = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"))
                }

                function qa() {
                    if ("object" == typeof window) {
                        if (Va) return;
                        "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments)
                    }
                }

                function Ga(e, t) {
                    Ua && console.warn(e + " is deprecated, please use " + t + " instead.")
                }

                function za(e) {
                    return "[object Object]" === Object.prototype.toString.call(e)
                }

                function Ka(e) {
                    return za(e) ? Object.keys(e).reduce((function(t, n) {
                        const i = za(e[n]),
                            r = i ? Ka(e[n]) : e[n],
                            o = i && !Object.keys(r).length;
                        return void 0 === r || o ? t : Object.assign(t, {
                            [n]: r
                        })
                    }), {}) : e
                }

                function Wa(e, t, n) {
                    t && !n.has(t.id) && (n.set(t.id, t), Object.keys(t).forEach((i => {
                        i.endsWith("Id") ? Wa(e, e.get(t[i]), n) : i.endsWith("Ids") && t[i].forEach((t => {
                            Wa(e, e.get(t), n)
                        }))
                    })))
                }

                function Xa(e, t, n) {
                    const i = n ? "outbound-rtp" : "inbound-rtp",
                        r = new Map;
                    if (null === t) return r;
                    const o = [];
                    return e.forEach((e => {
                        "track" === e.type && e.trackIdentifier === t.id && o.push(e)
                    })), o.forEach((t => {
                        e.forEach((n => {
                            n.type === i && n.trackId === t.id && Wa(e, n, r)
                        }))
                    })), r
                }
                const Ya = qa;

                function Qa(e, t) {
                    const n = e && e.navigator;
                    if (!n.mediaDevices) return;
                    const i = function(e) {
                            if ("object" != typeof e || e.mandatory || e.optional) return e;
                            const t = {};
                            return Object.keys(e).forEach((n => {
                                if ("require" === n || "advanced" === n || "mediaSource" === n) return;
                                const i = "object" == typeof e[n] ? e[n] : {
                                    ideal: e[n]
                                };
                                void 0 !== i.exact && "number" == typeof i.exact && (i.min = i.max = i.exact);
                                const r = function(e, t) {
                                    return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t
                                };
                                if (void 0 !== i.ideal) {
                                    t.optional = t.optional || [];
                                    let e = {};
                                    "number" == typeof i.ideal ? (e[r("min", n)] = i.ideal, t.optional.push(e), e = {}, e[r("max", n)] = i.ideal, t.optional.push(e)) : (e[r("", n)] = i.ideal, t.optional.push(e))
                                }
                                void 0 !== i.exact && "number" != typeof i.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[r("", n)] = i.exact) : ["min", "max"].forEach((e => {
                                    void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[r(e, n)] = i[e])
                                }))
                            })), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t
                        },
                        r = function(e, r) {
                            if (t.version >= 61) return r(e);
                            if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) {
                                const t = function(e, t, n) {
                                    t in e && !(n in e) && (e[n] = e[t], delete e[t])
                                };
                                t((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), t(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = i(e.audio)
                            }
                            if (e && "object" == typeof e.video) {
                                let o = e.video.facingMode;
                                o = o && ("object" == typeof o ? o : {
                                    ideal: o
                                });
                                const s = t.version < 66;
                                if (o && ("user" === o.exact || "environment" === o.exact || "user" === o.ideal || "environment" === o.ideal) && (!n.mediaDevices.getSupportedConstraints || !n.mediaDevices.getSupportedConstraints().facingMode || s)) {
                                    let t;
                                    if (delete e.video.facingMode, "environment" === o.exact || "environment" === o.ideal ? t = ["back", "rear"] : "user" !== o.exact && "user" !== o.ideal || (t = ["front"]), t) return n.mediaDevices.enumerateDevices().then((n => {
                                        let s = (n = n.filter((e => "videoinput" === e.kind))).find((e => t.some((t => e.label.toLowerCase().includes(t)))));
                                        return !s && n.length && t.includes("back") && (s = n[n.length - 1]), s && (e.video.deviceId = o.exact ? {
                                            exact: s.deviceId
                                        } : {
                                            ideal: s.deviceId
                                        }), e.video = i(e.video), Ya("chrome: " + JSON.stringify(e)), r(e)
                                    }))
                                }
                                e.video = i(e.video)
                            }
                            return Ya("chrome: " + JSON.stringify(e)), r(e)
                        },
                        o = function(e) {
                            return t.version >= 64 ? e : {
                                name: {
                                    PermissionDeniedError: "NotAllowedError",
                                    PermissionDismissedError: "NotAllowedError",
                                    InvalidStateError: "NotAllowedError",
                                    DevicesNotFoundError: "NotFoundError",
                                    ConstraintNotSatisfiedError: "OverconstrainedError",
                                    TrackStartError: "NotReadableError",
                                    MediaDeviceFailedDueToShutdown: "NotAllowedError",
                                    MediaDeviceKillSwitchOn: "NotAllowedError",
                                    TabCaptureError: "AbortError",
                                    ScreenCaptureError: "AbortError",
                                    DeviceCaptureError: "AbortError"
                                } [e.name] || e.name,
                                message: e.message,
                                constraint: e.constraint || e.constraintName,
                                toString() {
                                    return this.name + (this.message && ": ") + this.message
                                }
                            }
                        };
                    if (n.getUserMedia = function(e, t, i) {
                            r(e, (e => {
                                n.webkitGetUserMedia(e, t, (e => {
                                    i && i(o(e))
                                }))
                            }))
                        }.bind(n), n.mediaDevices.getUserMedia) {
                        const e = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
                        n.mediaDevices.getUserMedia = function(t) {
                            return r(t, (t => e(t).then((e => {
                                if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach((e => {
                                    e.stop()
                                })), new DOMException("", "NotFoundError");
                                return e
                            }), (e => Promise.reject(o(e))))))
                        }
                    }
                }

                function Za(e, t) {
                    e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function(n) {
                        return t(n).then((t => {
                            const i = n.video && n.video.width,
                                r = n.video && n.video.height,
                                o = n.video && n.video.frameRate;
                            return n.video = {
                                mandatory: {
                                    chromeMediaSource: "desktop",
                                    chromeMediaSourceId: t,
                                    maxFrameRate: o || 3
                                }
                            }, i && (n.video.mandatory.maxWidth = i), r && (n.video.mandatory.maxHeight = r), e.navigator.mediaDevices.getUserMedia(n)
                        }))
                    } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"))
                }

                function ed(e) {
                    e.MediaStream = e.MediaStream || e.webkitMediaStream
                }

                function td(e) {
                    if ("object" == typeof e && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) {
                        Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
                            get() {
                                return this._ontrack
                            },
                            set(e) {
                                this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e)
                            },
                            enumerable: !0,
                            configurable: !0
                        });
                        const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                        e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                            return this._ontrackpoly || (this._ontrackpoly = t => {
                                t.stream.addEventListener("addtrack", (n => {
                                    let i;
                                    i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === n.track.id)) : {
                                        track: n.track
                                    };
                                    const r = new Event("track");
                                    r.track = n.track, r.receiver = i, r.transceiver = {
                                        receiver: i
                                    }, r.streams = [t.stream], this.dispatchEvent(r)
                                })), t.stream.getTracks().forEach((n => {
                                    let i;
                                    i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === n.id)) : {
                                        track: n
                                    };
                                    const r = new Event("track");
                                    r.track = n, r.receiver = i, r.transceiver = {
                                        receiver: i
                                    }, r.streams = [t.stream], this.dispatchEvent(r)
                                }))
                            }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments)
                        }
                    } else $a(e, "track", (e => (e.transceiver || Object.defineProperty(e, "transceiver", {
                        value: {
                            receiver: e.receiver
                        }
                    }), e)))
                }

                function nd(e) {
                    if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) {
                        const t = function(e, t) {
                            return {
                                track: t,
                                get dtmf() {
                                    return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf
                                },
                                _pc: e
                            }
                        };
                        if (!e.RTCPeerConnection.prototype.getSenders) {
                            e.RTCPeerConnection.prototype.getSenders = function() {
                                return this._senders = this._senders || [], this._senders.slice()
                            };
                            const n = e.RTCPeerConnection.prototype.addTrack;
                            e.RTCPeerConnection.prototype.addTrack = function(e, i) {
                                let r = n.apply(this, arguments);
                                return r || (r = t(this, e), this._senders.push(r)), r
                            };
                            const i = e.RTCPeerConnection.prototype.removeTrack;
                            e.RTCPeerConnection.prototype.removeTrack = function(e) {
                                i.apply(this, arguments);
                                const t = this._senders.indexOf(e); - 1 !== t && this._senders.splice(t, 1)
                            }
                        }
                        const n = e.RTCPeerConnection.prototype.addStream;
                        e.RTCPeerConnection.prototype.addStream = function(e) {
                            this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach((e => {
                                this._senders.push(t(this, e))
                            }))
                        };
                        const i = e.RTCPeerConnection.prototype.removeStream;
                        e.RTCPeerConnection.prototype.removeStream = function(e) {
                            this._senders = this._senders || [], i.apply(this, [e]), e.getTracks().forEach((e => {
                                const t = this._senders.find((t => t.track === e));
                                t && this._senders.splice(this._senders.indexOf(t), 1)
                            }))
                        }
                    } else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) {
                        const t = e.RTCPeerConnection.prototype.getSenders;
                        e.RTCPeerConnection.prototype.getSenders = function() {
                            const e = t.apply(this, []);
                            return e.forEach((e => e._pc = this)), e
                        }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                            get() {
                                return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf
                            }
                        })
                    }
                }

                function id(e) {
                    if (!e.RTCPeerConnection) return;
                    const t = e.RTCPeerConnection.prototype.getStats;
                    e.RTCPeerConnection.prototype.getStats = function() {
                        const [e, n, i] = arguments;
                        if (arguments.length > 0 && "function" == typeof e) return t.apply(this, arguments);
                        if (0 === t.length && (0 === arguments.length || "function" != typeof e)) return t.apply(this, []);
                        const r = function(e) {
                                const t = {};
                                return e.result().forEach((e => {
                                    const n = {
                                        id: e.id,
                                        timestamp: e.timestamp,
                                        type: {
                                            localcandidate: "local-candidate",
                                            remotecandidate: "remote-candidate"
                                        } [e.type] || e.type
                                    };
                                    e.names().forEach((t => {
                                        n[t] = e.stat(t)
                                    })), t[n.id] = n
                                })), t
                            },
                            o = function(e) {
                                return new Map(Object.keys(e).map((t => [t, e[t]])))
                            };
                        if (arguments.length >= 2) {
                            const i = function(e) {
                                n(o(r(e)))
                            };
                            return t.apply(this, [i, e])
                        }
                        return new Promise(((e, n) => {
                            t.apply(this, [function(t) {
                                e(o(r(t)))
                            }, n])
                        })).then(n, i)
                    }
                }

                function rd(e) {
                    if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;
                    if (!("getStats" in e.RTCRtpSender.prototype)) {
                        const t = e.RTCPeerConnection.prototype.getSenders;
                        t && (e.RTCPeerConnection.prototype.getSenders = function() {
                            const e = t.apply(this, []);
                            return e.forEach((e => e._pc = this)), e
                        });
                        const n = e.RTCPeerConnection.prototype.addTrack;
                        n && (e.RTCPeerConnection.prototype.addTrack = function() {
                            const e = n.apply(this, arguments);
                            return e._pc = this, e
                        }), e.RTCRtpSender.prototype.getStats = function() {
                            const e = this;
                            return this._pc.getStats().then((t => Xa(t, e.track, !0)))
                        }
                    }
                    if (!("getStats" in e.RTCRtpReceiver.prototype)) {
                        const t = e.RTCPeerConnection.prototype.getReceivers;
                        t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                            const e = t.apply(this, []);
                            return e.forEach((e => e._pc = this)), e
                        }), $a(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function() {
                            const e = this;
                            return this._pc.getStats().then((t => Xa(t, e.track, !1)))
                        }
                    }
                    if (!("getStats" in e.RTCRtpSender.prototype) || !("getStats" in e.RTCRtpReceiver.prototype)) return;
                    const t = e.RTCPeerConnection.prototype.getStats;
                    e.RTCPeerConnection.prototype.getStats = function() {
                        if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {
                            const e = arguments[0];
                            let t, n, i;
                            return this.getSenders().forEach((n => {
                                n.track === e && (t ? i = !0 : t = n)
                            })), this.getReceivers().forEach((t => (t.track === e && (n ? i = !0 : n = t), t.track === e))), i || t && n ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t ? t.getStats() : n ? n.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"))
                        }
                        return t.apply(this, arguments)
                    }
                }

                function od(e) {
                    e.RTCPeerConnection.prototype.getLocalStreams = function() {
                        return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e => this._shimmedLocalStreams[e][0]))
                    };
                    const t = e.RTCPeerConnection.prototype.addTrack;
                    e.RTCPeerConnection.prototype.addTrack = function(e, n) {
                        if (!n) return t.apply(this, arguments);
                        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                        const i = t.apply(this, arguments);
                        return this._shimmedLocalStreams[n.id] ? -1 === this._shimmedLocalStreams[n.id].indexOf(i) && this._shimmedLocalStreams[n.id].push(i) : this._shimmedLocalStreams[n.id] = [n, i], i
                    };
                    const n = e.RTCPeerConnection.prototype.addStream;
                    e.RTCPeerConnection.prototype.addStream = function(e) {
                        this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach((e => {
                            if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError")
                        }));
                        const t = this.getSenders();
                        n.apply(this, arguments);
                        const i = this.getSenders().filter((e => -1 === t.indexOf(e)));
                        this._shimmedLocalStreams[e.id] = [e].concat(i)
                    };
                    const i = e.RTCPeerConnection.prototype.removeStream;
                    e.RTCPeerConnection.prototype.removeStream = function(e) {
                        return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], i.apply(this, arguments)
                    };
                    const r = e.RTCPeerConnection.prototype.removeTrack;
                    e.RTCPeerConnection.prototype.removeTrack = function(e) {
                        return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach((t => {
                            const n = this._shimmedLocalStreams[t].indexOf(e); - 1 !== n && this._shimmedLocalStreams[t].splice(n, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t]
                        })), r.apply(this, arguments)
                    }
                }

                function sd(e, t) {
                    if (!e.RTCPeerConnection) return;
                    if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return od(e);
                    const n = e.RTCPeerConnection.prototype.getLocalStreams;
                    e.RTCPeerConnection.prototype.getLocalStreams = function() {
                        const e = n.apply(this);
                        return this._reverseStreams = this._reverseStreams || {}, e.map((e => this._reverseStreams[e.id]))
                    };
                    const i = e.RTCPeerConnection.prototype.addStream;
                    e.RTCPeerConnection.prototype.addStream = function(t) {
                        if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach((e => {
                                if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError")
                            })), !this._reverseStreams[t.id]) {
                            const n = new e.MediaStream(t.getTracks());
                            this._streams[t.id] = n, this._reverseStreams[n.id] = t, t = n
                        }
                        i.apply(this, [t])
                    };
                    const r = e.RTCPeerConnection.prototype.removeStream;

                    function o(e, t) {
                        let n = t.sdp;
                        return Object.keys(e._reverseStreams || []).forEach((t => {
                            const i = e._reverseStreams[t],
                                r = e._streams[i.id];
                            n = n.replace(new RegExp(r.id, "g"), i.id)
                        })), new RTCSessionDescription({
                            type: t.type,
                            sdp: n
                        })
                    }
                    e.RTCPeerConnection.prototype.removeStream = function(e) {
                        this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id]
                    }, e.RTCPeerConnection.prototype.addTrack = function(t, n) {
                        if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                        const i = [].slice.call(arguments, 1);
                        if (1 !== i.length || !i[0].getTracks().find((e => e === t))) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
                        if (this.getSenders().find((e => e.track === t))) throw new DOMException("Track already exists.", "InvalidAccessError");
                        this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
                        const r = this._streams[n.id];
                        if (r) r.addTrack(t), Promise.resolve().then((() => {
                            this.dispatchEvent(new Event("negotiationneeded"))
                        }));
                        else {
                            const i = new e.MediaStream([t]);
                            this._streams[n.id] = i, this._reverseStreams[i.id] = n, this.addStream(i)
                        }
                        return this.getSenders().find((e => e.track === t))
                    }, ["createOffer", "createAnswer"].forEach((function(t) {
                        const n = e.RTCPeerConnection.prototype[t],
                            i = {
                                [t]() {
                                    const e = arguments;
                                    return arguments.length && "function" == typeof arguments[0] ? n.apply(this, [t => {
                                        const n = o(this, t);
                                        e[0].apply(null, [n])
                                    }, t => {
                                        e[1] && e[1].apply(null, t)
                                    }, arguments[2]]) : n.apply(this, arguments).then((e => o(this, e)))
                                }
                            };
                        e.RTCPeerConnection.prototype[t] = i[t]
                    }));
                    const s = e.RTCPeerConnection.prototype.setLocalDescription;
                    e.RTCPeerConnection.prototype.setLocalDescription = function() {
                        return arguments.length && arguments[0].type ? (arguments[0] = function(e, t) {
                            let n = t.sdp;
                            return Object.keys(e._reverseStreams || []).forEach((t => {
                                const i = e._reverseStreams[t],
                                    r = e._streams[i.id];
                                n = n.replace(new RegExp(i.id, "g"), r.id)
                            })), new RTCSessionDescription({
                                type: t.type,
                                sdp: n
                            })
                        }(this, arguments[0]), s.apply(this, arguments)) : s.apply(this, arguments)
                    };
                    const a = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription");
                    Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", {
                        get() {
                            const e = a.get.apply(this);
                            return "" === e.type ? e : o(this, e)
                        }
                    }), e.RTCPeerConnection.prototype.removeTrack = function(e) {
                        if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                        if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
                        if (e._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
                        let t;
                        this._streams = this._streams || {}, Object.keys(this._streams).forEach((n => {
                            this._streams[n].getTracks().find((t => e.track === t)) && (t = this._streams[n])
                        })), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded")))
                    }
                }

                function ad(e, t) {
                    !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                        const n = e.RTCPeerConnection.prototype[t],
                            i = {
                                [t]() {
                                    return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
                                }
                            };
                        e.RTCPeerConnection.prototype[t] = i[t]
                    }))
                }

                function dd(e, t) {
                    $a(e, "negotiationneeded", (e => {
                        const n = e.target;
                        if (!(t.version < 72 || n.getConfiguration && "plan-b" === n.getConfiguration().sdpSemantics) || "stable" === n.signalingState) return e
                    }))
                }

                function cd(e, t) {
                    const n = e && e.navigator,
                        i = e && e.MediaStreamTrack;
                    if (n.getUserMedia = function(e, t, i) {
                            Ga("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), n.mediaDevices.getUserMedia(e).then(t, i)
                        }, !(t.version > 55 && "autoGainControl" in n.mediaDevices.getSupportedConstraints())) {
                        const e = function(e, t, n) {
                                t in e && !(n in e) && (e[n] = e[t], delete e[t])
                            },
                            t = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
                        if (n.mediaDevices.getUserMedia = function(n) {
                                return "object" == typeof n && "object" == typeof n.audio && (n = JSON.parse(JSON.stringify(n)), e(n.audio, "autoGainControl", "mozAutoGainControl"), e(n.audio, "noiseSuppression", "mozNoiseSuppression")), t(n)
                            }, i && i.prototype.getSettings) {
                            const t = i.prototype.getSettings;
                            i.prototype.getSettings = function() {
                                const n = t.apply(this, arguments);
                                return e(n, "mozAutoGainControl", "autoGainControl"), e(n, "mozNoiseSuppression", "noiseSuppression"), n
                            }
                        }
                        if (i && i.prototype.applyConstraints) {
                            const t = i.prototype.applyConstraints;
                            i.prototype.applyConstraints = function(n) {
                                return "audio" === this.kind && "object" == typeof n && (n = JSON.parse(JSON.stringify(n)), e(n, "autoGainControl", "mozAutoGainControl"), e(n, "noiseSuppression", "mozNoiseSuppression")), t.apply(this, [n])
                            }
                        }
                    }
                }

                function ld(e, t) {
                    e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function(n) {
                        if (!n || !n.video) {
                            const e = new DOMException("getDisplayMedia without video constraints is undefined");
                            return e.name = "NotFoundError", e.code = 8, Promise.reject(e)
                        }
                        return !0 === n.video ? n.video = {
                            mediaSource: t
                        } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n)
                    })
                }

                function hd(e) {
                    "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                        get() {
                            return {
                                receiver: this.receiver
                            }
                        }
                    })
                }

                function ud(e, t) {
                    if ("object" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;
                    !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                        const n = e.RTCPeerConnection.prototype[t],
                            i = {
                                [t]() {
                                    return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
                                }
                            };
                        e.RTCPeerConnection.prototype[t] = i[t]
                    }));
                    const n = {
                            inboundrtp: "inbound-rtp",
                            outboundrtp: "outbound-rtp",
                            candidatepair: "candidate-pair",
                            localcandidate: "local-candidate",
                            remotecandidate: "remote-candidate"
                        },
                        i = e.RTCPeerConnection.prototype.getStats;
                    e.RTCPeerConnection.prototype.getStats = function() {
                        const [e, r, o] = arguments;
                        return i.apply(this, [e || null]).then((e => {
                            if (t.version < 53 && !r) try {
                                e.forEach((e => {
                                    e.type = n[e.type] || e.type
                                }))
                            } catch (t) {
                                if ("TypeError" !== t.name) throw t;
                                e.forEach(((t, i) => {
                                    e.set(i, Object.assign({}, t, {
                                        type: n[t.type] || t.type
                                    }))
                                }))
                            }
                            return e
                        })).then(r, o)
                    }
                }

                function pd(e) {
                    if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
                    if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return;
                    const t = e.RTCPeerConnection.prototype.getSenders;
                    t && (e.RTCPeerConnection.prototype.getSenders = function() {
                        const e = t.apply(this, []);
                        return e.forEach((e => e._pc = this)), e
                    });
                    const n = e.RTCPeerConnection.prototype.addTrack;
                    n && (e.RTCPeerConnection.prototype.addTrack = function() {
                        const e = n.apply(this, arguments);
                        return e._pc = this, e
                    }), e.RTCRtpSender.prototype.getStats = function() {
                        return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map)
                    }
                }

                function md(e) {
                    if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
                    if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return;
                    const t = e.RTCPeerConnection.prototype.getReceivers;
                    t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                        const e = t.apply(this, []);
                        return e.forEach((e => e._pc = this)), e
                    }), $a(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function() {
                        return this._pc.getStats(this.track)
                    }
                }

                function gd(e) {
                    e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function(e) {
                        Ga("removeStream", "removeTrack"), this.getSenders().forEach((t => {
                            t.track && e.getTracks().includes(t.track) && this.removeTrack(t)
                        }))
                    })
                }

                function fd(e) {
                    e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel)
                }

                function vd(e) {
                    if ("object" != typeof e || !e.RTCPeerConnection) return;
                    const t = e.RTCPeerConnection.prototype.addTransceiver;
                    t && (e.RTCPeerConnection.prototype.addTransceiver = function() {
                        this.setParametersPromises = [];
                        const e = arguments[1],
                            n = e && "sendEncodings" in e;
                        n && e.sendEncodings.forEach((e => {
                            if ("rid" in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided.");
                            if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
                            if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0")
                        }));
                        const i = t.apply(this, arguments);
                        if (n) {
                            const {
                                sender: t
                            } = i, n = t.getParameters();
                            (!("encodings" in n) || 1 === n.encodings.length && 0 === Object.keys(n.encodings[0]).length) && (n.encodings = e.sendEncodings, t.sendEncodings = e.sendEncodings, this.setParametersPromises.push(t.setParameters(n).then((() => {
                                delete t.sendEncodings
                            })).catch((() => {
                                delete t.sendEncodings
                            }))))
                        }
                        return i
                    })
                }

                function _d(e) {
                    if ("object" != typeof e || !e.RTCRtpSender) return;
                    const t = e.RTCRtpSender.prototype.getParameters;
                    t && (e.RTCRtpSender.prototype.getParameters = function() {
                        const e = t.apply(this, arguments);
                        return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e
                    })
                }

                function yd(e) {
                    if ("object" != typeof e || !e.RTCPeerConnection) return;
                    const t = e.RTCPeerConnection.prototype.createOffer;
                    e.RTCPeerConnection.prototype.createOffer = function() {
                        return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => {
                            this.setParametersPromises = []
                        })) : t.apply(this, arguments)
                    }
                }

                function Ed(e) {
                    if ("object" != typeof e || !e.RTCPeerConnection) return;
                    const t = e.RTCPeerConnection.prototype.createAnswer;
                    e.RTCPeerConnection.prototype.createAnswer = function() {
                        return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => {
                            this.setParametersPromises = []
                        })) : t.apply(this, arguments)
                    }
                }

                function Sd(e) {
                    if ("object" == typeof e && e.RTCPeerConnection) {
                        if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() {
                                return this._localStreams || (this._localStreams = []), this._localStreams
                            }), !("addStream" in e.RTCPeerConnection.prototype)) {
                            const t = e.RTCPeerConnection.prototype.addTrack;
                            e.RTCPeerConnection.prototype.addStream = function(e) {
                                this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach((n => t.call(this, n, e))), e.getVideoTracks().forEach((n => t.call(this, n, e)))
                            }, e.RTCPeerConnection.prototype.addTrack = function(e) {
                                for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                                return i && i.forEach((e => {
                                    this._localStreams ? this._localStreams.includes(e) || this._localStreams.push(e) : this._localStreams = [e]
                                })), t.apply(this, arguments)
                            }
                        }
                        "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e) {
                            this._localStreams || (this._localStreams = []);
                            const t = this._localStreams.indexOf(e);
                            if (-1 === t) return;
                            this._localStreams.splice(t, 1);
                            const n = e.getTracks();
                            this.getSenders().forEach((e => {
                                n.includes(e.track) && this.removeTrack(e)
                            }))
                        })
                    }
                }

                function bd(e) {
                    if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() {
                            return this._remoteStreams ? this._remoteStreams : []
                        }), !("onaddstream" in e.RTCPeerConnection.prototype))) {
                        Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", {
                            get() {
                                return this._onaddstream
                            },
                            set(e) {
                                this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = e => {
                                    e.streams.forEach((e => {
                                        if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return;
                                        this._remoteStreams.push(e);
                                        const t = new Event("addstream");
                                        t.stream = e, this.dispatchEvent(t)
                                    }))
                                })
                            }
                        });
                        const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                        e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                            const e = this;
                            return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t) {
                                t.streams.forEach((t => {
                                    if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return;
                                    e._remoteStreams.push(t);
                                    const n = new Event("addstream");
                                    n.stream = t, e.dispatchEvent(n)
                                }))
                            }), t.apply(e, arguments)
                        }
                    }
                }

                function Td(e) {
                    if ("object" != typeof e || !e.RTCPeerConnection) return;
                    const t = e.RTCPeerConnection.prototype,
                        n = t.createOffer,
                        i = t.createAnswer,
                        r = t.setLocalDescription,
                        o = t.setRemoteDescription,
                        s = t.addIceCandidate;
                    t.createOffer = function(e, t) {
                        const i = arguments.length >= 2 ? arguments[2] : arguments[0],
                            r = n.apply(this, [i]);
                        return t ? (r.then(e, t), Promise.resolve()) : r
                    }, t.createAnswer = function(e, t) {
                        const n = arguments.length >= 2 ? arguments[2] : arguments[0],
                            r = i.apply(this, [n]);
                        return t ? (r.then(e, t), Promise.resolve()) : r
                    };
                    let a = function(e, t, n) {
                        const i = r.apply(this, [e]);
                        return n ? (i.then(t, n), Promise.resolve()) : i
                    };
                    t.setLocalDescription = a, a = function(e, t, n) {
                        const i = o.apply(this, [e]);
                        return n ? (i.then(t, n), Promise.resolve()) : i
                    }, t.setRemoteDescription = a, a = function(e, t, n) {
                        const i = s.apply(this, [e]);
                        return n ? (i.then(t, n), Promise.resolve()) : i
                    }, t.addIceCandidate = a
                }

                function Cd(e) {
                    const t = e && e.navigator;
                    if (t.mediaDevices && t.mediaDevices.getUserMedia) {
                        const e = t.mediaDevices,
                            n = e.getUserMedia.bind(e);
                        t.mediaDevices.getUserMedia = e => n(xd(e))
                    }!t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function(e, n, i) {
                        t.mediaDevices.getUserMedia(e).then(n, i)
                    }.bind(t))
                }

                function xd(e) {
                    return e && void 0 !== e.video ? Object.assign({}, e, {
                        video: Ka(e.video)
                    }) : e
                }

                function Rd(e) {
                    if (!e.RTCPeerConnection) return;
                    const t = e.RTCPeerConnection;
                    e.RTCPeerConnection = function(e, n) {
                        if (e && e.iceServers) {
                            const t = [];
                            for (let n = 0; n < e.iceServers.length; n++) {
                                let i = e.iceServers[n];
                                !i.hasOwnProperty("urls") && i.hasOwnProperty("url") ? (Ga("RTCIceServer.url", "RTCIceServer.urls"), i = JSON.parse(JSON.stringify(i)), i.urls = i.url, delete i.url, t.push(i)) : t.push(e.iceServers[n])
                            }
                            e.iceServers = t
                        }
                        return new t(e, n)
                    }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
                        get: () => t.generateCertificate
                    })
                }

                function Ad(e) {
                    "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                        get() {
                            return {
                                receiver: this.receiver
                            }
                        }
                    })
                }

                function wd(e) {
                    const t = e.RTCPeerConnection.prototype.createOffer;
                    e.RTCPeerConnection.prototype.createOffer = function(e) {
                        if (e) {
                            void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio);
                            const t = this.getTransceivers().find((e => "audio" === e.receiver.track.kind));
                            !1 === e.offerToReceiveAudio && t ? "sendrecv" === t.direction ? t.setDirection ? t.setDirection("sendonly") : t.direction = "sendonly" : "recvonly" === t.direction && (t.setDirection ? t.setDirection("inactive") : t.direction = "inactive") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver("audio", {
                                direction: "recvonly"
                            }), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo);
                            const n = this.getTransceivers().find((e => "video" === e.receiver.track.kind));
                            !1 === e.offerToReceiveVideo && n ? "sendrecv" === n.direction ? n.setDirection ? n.setDirection("sendonly") : n.direction = "sendonly" : "recvonly" === n.direction && (n.setDirection ? n.setDirection("inactive") : n.direction = "inactive") : !0 !== e.offerToReceiveVideo || n || this.addTransceiver("video", {
                                direction: "recvonly"
                            })
                        }
                        return t.apply(this, arguments)
                    }
                }

                function Id(e) {
                    "object" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext)
                }

                function Pd(e) {
                    if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return;
                    const t = e.RTCIceCandidate;
                    e.RTCIceCandidate = function(e) {
                        if ("object" == typeof e && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) {
                            const n = new t(e),
                                i = Wn().parseCandidate(e.candidate),
                                r = Object.assign(n, i);
                            return r.toJSON = function() {
                                return {
                                    candidate: r.candidate,
                                    sdpMid: r.sdpMid,
                                    sdpMLineIndex: r.sdpMLineIndex,
                                    usernameFragment: r.usernameFragment
                                }
                            }, r
                        }
                        return new t(e)
                    }, e.RTCIceCandidate.prototype = t.prototype, $a(e, "icecandidate", (t => (t.candidate && Object.defineProperty(t, "candidate", {
                        value: new e.RTCIceCandidate(t.candidate),
                        writable: "false"
                    }), t)))
                }

                function Dd(e, t) {
                    if (!e.RTCPeerConnection) return;
                    "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", {
                        get() {
                            return void 0 === this._sctp ? null : this._sctp
                        }
                    });
                    const n = e.RTCPeerConnection.prototype.setRemoteDescription;
                    e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                        if (this._sctp = null, "chrome" === t.browser && t.version >= 76) {
                            const {
                                sdpSemantics: e
                            } = this.getConfiguration();
                            "plan-b" === e && Object.defineProperty(this, "sctp", {
                                get() {
                                    return void 0 === this._sctp ? null : this._sctp
                                },
                                enumerable: !0,
                                configurable: !0
                            })
                        }
                        if (function(e) {
                                if (!e || !e.sdp) return !1;
                                const t = Wn().splitSections(e.sdp);
                                return t.shift(), t.some((e => {
                                    const t = Wn().parseMLine(e);
                                    return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP")
                                }))
                            }(arguments[0])) {
                            const e = function(e) {
                                    const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
                                    if (null === t || t.length < 2) return -1;
                                    const n = parseInt(t[1], 10);
                                    return n != n ? -1 : n
                                }(arguments[0]),
                                n = function(e) {
                                    let n = 65536;
                                    return "firefox" === t.browser && (n = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), n
                                }(e),
                                i = function(e, n) {
                                    let i = 65536;
                                    "firefox" === t.browser && 57 === t.version && (i = 65535);
                                    const r = Wn().matchPrefix(e.sdp, "a=max-message-size:");
                                    return r.length > 0 ? i = parseInt(r[0].substr(19), 10) : "firefox" === t.browser && -1 !== n && (i = 2147483637), i
                                }(arguments[0], e);
                            let r;
                            r = 0 === n && 0 === i ? Number.POSITIVE_INFINITY : 0 === n || 0 === i ? Math.max(n, i) : Math.min(n, i);
                            const o = {};
                            Object.defineProperty(o, "maxMessageSize", {
                                get: () => r
                            }), this._sctp = o
                        }
                        return n.apply(this, arguments)
                    }
                }

                function Od(e) {
                    if (!e.RTCPeerConnection || !("createDataChannel" in e.RTCPeerConnection.prototype)) return;

                    function t(e, t) {
                        const n = e.send;
                        e.send = function() {
                            const i = arguments[0],
                                r = i.length || i.size || i.byteLength;
                            if ("open" === e.readyState && t.sctp && r > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)");
                            return n.apply(e, arguments)
                        }
                    }
                    const n = e.RTCPeerConnection.prototype.createDataChannel;
                    e.RTCPeerConnection.prototype.createDataChannel = function() {
                        const e = n.apply(this, arguments);
                        return t(e, this), e
                    }, $a(e, "datachannel", (e => (t(e.channel, e.target), e)))
                }

                function Nd(e) {
                    if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return;
                    const t = e.RTCPeerConnection.prototype;
                    Object.defineProperty(t, "connectionState", {
                        get() {
                            return {
                                completed: "connected",
                                checking: "connecting"
                            } [this.iceConnectionState] || this.iceConnectionState
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(t, "onconnectionstatechange", {
                        get() {
                            return this._onconnectionstatechange || null
                        },
                        set(e) {
                            this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e)
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ["setLocalDescription", "setRemoteDescription"].forEach((e => {
                        const n = t[e];
                        t[e] = function() {
                            return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => {
                                const t = e.target;
                                if (t._lastConnectionState !== t.connectionState) {
                                    t._lastConnectionState = t.connectionState;
                                    const n = new Event("connectionstatechange", e);
                                    t.dispatchEvent(n)
                                }
                                return e
                            }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments)
                        }
                    }))
                }

                function kd(e, t) {
                    if (!e.RTCPeerConnection) return;
                    if ("chrome" === t.browser && t.version >= 71) return;
                    if ("safari" === t.browser && t.version >= 605) return;
                    const n = e.RTCPeerConnection.prototype.setRemoteDescription;
                    e.RTCPeerConnection.prototype.setRemoteDescription = function(t) {
                        if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) {
                            const n = t.sdp.split("\n").filter((e => "a=extmap-allow-mixed" !== e.trim())).join("\n");
                            e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({
                                type: t.type,
                                sdp: n
                            }) : t.sdp = n
                        }
                        return n.apply(this, arguments)
                    }
                }

                function Md(e, t) {
                    if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
                    const n = e.RTCPeerConnection.prototype.addIceCandidate;
                    n && 0 !== n.length && (e.RTCPeerConnection.prototype.addIceCandidate = function() {
                        return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : n.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
                    })
                }

                function Ld(e, t) {
                    if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
                    const n = e.RTCPeerConnection.prototype.setLocalDescription;
                    n && 0 !== n.length && (e.RTCPeerConnection.prototype.setLocalDescription = function() {
                        let e = arguments[0] || {};
                        if ("object" != typeof e || e.type && e.sdp) return n.apply(this, arguments);
                        if (e = {
                                type: e.type,
                                sdp: e.sdp
                            }, !e.type) switch (this.signalingState) {
                            case "stable":
                            case "have-local-offer":
                            case "have-remote-pranswer":
                                e.type = "offer";
                                break;
                            default:
                                e.type = "answer"
                        }
                        return e.sdp || "offer" !== e.type && "answer" !== e.type ? n.apply(this, [e]) : ("offer" === e.type ? this.createOffer : this.createAnswer).apply(this).then((e => n.apply(this, [e])))
                    })
                }! function() {
                    let {
                        window: e
                    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                        shimChrome: !0,
                        shimFirefox: !0,
                        shimSafari: !0
                    };
                    const n = qa,
                        i = function(e) {
                            const t = {
                                browser: null,
                                version: null
                            };
                            if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t;
                            const {
                                navigator: n
                            } = e;
                            if (n.mozGetUserMedia) t.browser = "firefox", t.version = Ha(n.userAgent, /Firefox\/(\d+)\./, 1);
                            else if (n.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = Ha(n.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
                            else {
                                if (!e.RTCPeerConnection || !n.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t;
                                t.browser = "safari", t.version = Ha(n.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype
                            }
                            return t
                        }(e),
                        r = {
                            browserDetails: i,
                            commonShim: m,
                            extractVersion: Ha,
                            disableLog: Ja,
                            disableWarnings: Ba,
                            sdp: Kn
                        };
                    switch (i.browser) {
                        case "chrome":
                            if (!h || !ad || !t.shimChrome) return n("Chrome shim is not included in this adapter release."), r;
                            if (null === i.version) return n("Chrome shim can not determine version, not shimming."), r;
                            n("adapter.js shimming chrome."), r.browserShim = h, Md(e, i), Ld(e), Qa(e, i), ed(e), ad(e, i), td(e), sd(e, i), nd(e), id(e), rd(e), dd(e, i), Pd(e), Nd(e), Dd(e, i), Od(e), kd(e, i);
                            break;
                        case "firefox":
                            if (!u || !ud || !t.shimFirefox) return n("Firefox shim is not included in this adapter release."), r;
                            n("adapter.js shimming firefox."), r.browserShim = u, Md(e, i), Ld(e), cd(e, i), ud(e, i), hd(e), gd(e), pd(e), md(e), fd(e), vd(e), _d(e), yd(e), Ed(e), Pd(e), Nd(e), Dd(e, i), Od(e);
                            break;
                        case "safari":
                            if (!p || !t.shimSafari) return n("Safari shim is not included in this adapter release."), r;
                            n("adapter.js shimming safari."), r.browserShim = p, Md(e, i), Ld(e), Rd(e), wd(e), Td(e), Sd(e), bd(e), Ad(e), Cd(e), Id(e), Pd(e), Dd(e, i), Od(e), kd(e, i);
                            break;
                        default:
                            n("Unsupported browser!")
                    }
                }({
                    window: "undefined" == typeof window ? void 0 : window
                });
                var Fd = n(125),
                    jd = n.n(Fd);
                const Vd = (0, E.getLogger)("modules/RTC/RTCUtils.js"),
                    Ud = {
                        video: {
                            height: {
                                ideal: 720,
                                max: 720,
                                min: 180
                            },
                            width: {
                                ideal: 1280,
                                max: 1280,
                                min: 320
                            }
                        }
                    };
                let Hd = "default",
                    $d = !1,
                    Jd = !1,
                    Bd = !1,
                    qd = !1,
                    Gd = !1,
                    zd = null;
                const Kd = document.createElement("audio"),
                    Wd = void 0 !== Kd.setSinkId;
                let Xd, Yd = [];

                function Qd() {}

                function Zd(e) {
                    const t = e.filter((e => "audioinput" === e.kind)).length,
                        n = e.filter((e => "audiooutput" === e.kind)).length,
                        i = e.filter((e => "videoinput" === e.kind)).length,
                        r = e.filter((e => "videooutput" === e.kind)).length;
                    e.forEach((e => {
                        const o = {
                            audio_input_device_count: t,
                            audio_output_device_count: n,
                            video_input_device_count: i,
                            video_output_device_count: r,
                            device_id: e.deviceId,
                            device_group_id: e.groupId,
                            device_kind: e.kind,
                            device_label: e.label
                        };
                        Mi.sendAnalytics(Wt, o)
                    }))
                }
                const ec = new class extends Cr {
                        init() {
                            var e;
                            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            var n;
                            "boolean" == typeof t.disableAEC && (Bd = t.disableAEC, Vd.info(`Disable AEC: ${Bd}`)), "boolean" == typeof t.disableNS && (qd = t.disableNS, Vd.info(`Disable NS: ${qd}`)), "boolean" == typeof t.disableAP && (Jd = t.disableAP, Vd.info(`Disable AP: ${Jd}`)), "boolean" == typeof t.disableAGC && (Gd = t.disableAGC, Vd.info(`Disable AGC: ${Gd}`)), "boolean" == typeof(null === (e = t.audioQuality) || void 0 === e ? void 0 : e.stereo) && (zd = t.audioQuality.stereo, Vd.info(`Stereo: ${zd}`)), window.clearInterval(Xd), Xd = void 0, ci.isReactNative() || (this.attachMediaStream = (n = (e, t) => {
                                e && (e.srcObject = t)
                            }, function(e, t) {
                                return n.apply(ec, arguments), t && ec.isDeviceChangeAvailable("output") && t.getAudioTracks && t.getAudioTracks().length && $d ? e.setSinkId(ec.getAudioOutputDevice()).catch((t => {
                                    const n = new dr(t, null, ["audiooutput"]);
                                    throw Vd.warn("Failed to set audio output device for the element. Default audio output device will be used instead", null == e ? void 0 : e.id, n), n
                                })) : Promise.resolve()
                            })), this.pcConstraints = {}, ws.init(t), this.isDeviceListAvailable() && this.enumerateDevices((e => {
                                Yd = e.slice(0), Vd.debug("Available devices: ", Yd), Zd(Yd), this.eventEmitter.emit(ji.default.DEVICE_LIST_AVAILABLE, Yd), ci.supportsDeviceChangeEvent() ? navigator.mediaDevices.addEventListener("devicechange", (() => this.enumerateDevices(Qd))) : Xd = window.setInterval((() => this.enumerateDevices(Qd)), 3e3)
                            }))
                        }
                        enumerateDevices(e) {
                            navigator.mediaDevices.enumerateDevices().then((t => {
                                this._updateKnownDevices(t), e(t)
                            })).catch((t => {
                                Vd.warn(`Failed to  enumerate devices. ${t}`), this._updateKnownDevices([]), e([])
                            }))
                        }
                        _getUserMedia(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                            return new Promise(((i, r) => {
                                let o, s = !1;
                                "number" == typeof n && !isNaN(n) && n > 0 && (o = setTimeout((() => {
                                    s = !0, o = void 0, r(new dr(er))
                                }), n)), navigator.mediaDevices.getUserMedia(t).then((t => {
                                    Vd.log("onUserMediaSuccess"), this._updateGrantedPermissions(e, t), s || (void 0 !== o && clearTimeout(o), i(t))
                                })).catch((n => {
                                    Vd.warn(`Failed to get access to local media. ${n} ${JSON.stringify(t)}`);
                                    const i = new dr(n, t, e);
                                    s || (void 0 !== o && clearTimeout(o), r(i)), i.name === Yi && this._updateGrantedPermissions(e, void 0)
                                }))
                            }))
                        }
                        _getDesktopMedia(e) {
                            return ws.isSupported() ? new Promise(((t, n) => {
                                ws.obtainStream((e => {
                                    t(e)
                                }), (e => {
                                    n(e)
                                }), e)
                            })) : Promise.reject(new Error("Desktop sharing is not supported!"))
                        }
                        _getMissingTracks() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 ? arguments[1] : void 0;
                            const n = [],
                                i = e.includes("audio"),
                                r = t && t.getAudioTracks().length > 0;
                            i && !r && n.push("audio");
                            const o = e.includes("video"),
                                s = t && t.getVideoTracks().length > 0;
                            return o && !s && n.push("video"), n
                        }
                        _onMediaDevicesListChanged(e) {
                            Yd = e.slice(0), Vd.info("list of media devices has changed:", Yd), Zd(Yd), this.eventEmitter.emit(ji.default.DEVICE_LIST_WILL_CHANGE, Yd), this.eventEmitter.emit(ji.default.DEVICE_LIST_CHANGED, Yd)
                        }
                        _updateKnownDevices(e) {
                            (function(e) {
                                return e.length !== Yd.length || e.map(t).sort().join("") !== Yd.map(t).sort().join("");

                                function t(e) {
                                    return JSON.stringify({
                                        kind: e.kind,
                                        deviceId: e.deviceId,
                                        groupId: e.groupId,
                                        label: e.label,
                                        facing: e.facing
                                    })
                                }
                            })(e) && this._onMediaDevicesListChanged(e)
                        }
                        _updateGrantedPermissions(e, t) {
                            const n = Boolean(t) && t.getAudioTracks().length > 0,
                                i = Boolean(t) && t.getVideoTracks().length > 0,
                                r = {}; - 1 !== e.indexOf("video") && (r.video = i), -1 !== e.indexOf("audio") && (r.audio = n), this.eventEmitter.emit(ji.default.PERMISSIONS_CHANGED, r)
                        }
                        obtainAudioAndVideoPermissions(e) {
                            const {
                                timeout: t,
                                ...n
                            } = e, i = [];
                            let r = {};
                            const o = function() {
                                    if (-1 === (n.devices || []).indexOf("desktop")) return Promise.resolve();
                                    const {
                                        desktopSharingSourceDevice: e,
                                        desktopSharingSources: i
                                    } = n;
                                    if (e) {
                                        const n = Yd && Yd.find((t => "videoinput" === t.kind && (t.deviceId === e || t.label === e)));
                                        if (!n) return Promise.reject(new dr({
                                            name: "ConstraintNotSatisfiedError"
                                        }, {}, [e]));
                                        const i = ["video"],
                                            r = {
                                                video: {
                                                    deviceId: n.deviceId
                                                }
                                            };
                                        return this._getUserMedia(i, r, t).then((e => ({
                                            sourceType: "device",
                                            stream: e
                                        })))
                                    }
                                    return this._getDesktopMedia({
                                        desktopSharingSources: i
                                    })
                                }.bind(this),
                                s = function() {
                                    const e = (n.devices || ["audio", "video"]).filter((e => "audio" === e || "video" === e));
                                    return e.length ? (r = function() {
                                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                        const n = Es()(t.constraints || Ud);
                                        if (e.indexOf("video") >= 0) {
                                            if (jd()[t.resolution]) {
                                                const e = jd()[t.resolution];
                                                n.video.height = {
                                                    ideal: e.height
                                                }, n.video.width = {
                                                    ideal: e.width
                                                }
                                            }
                                            if (n.video || (n.video = {}), ci.isWebKitBased() && (n.video.height && n.video.height.ideal ? n.video.height = {
                                                    ideal: n.video.height.ideal
                                                } : Vd.warn("Ideal camera height missing, camera may not start properly"), n.video.width && n.video.width.ideal ? n.video.width = {
                                                    ideal: n.video.width.ideal
                                                } : Vd.warn("Ideal camera width missing, camera may not start properly")), t.cameraDeviceId) n.video.deviceId = t.cameraDeviceId;
                                            else {
                                                const e = t.facingMode || ja.USER;
                                                n.video.facingMode = e
                                            }
                                        } else n.video = !1;
                                        return e.indexOf("audio") >= 0 ? (n.audio && "boolean" != typeof n.audio || (n.audio = {}), n.audio = {
                                            autoGainControl: !Gd && !Jd,
                                            deviceId: t.micDeviceId,
                                            echoCancellation: !Bd && !Jd,
                                            noiseSuppression: !qd && !Jd
                                        }, zd && Object.assign(n.audio, {
                                            channelCount: 2
                                        })) : n.audio = !1, n
                                    }(e, n), Vd.info("Got media constraints: ", JSON.stringify(r)), this._getUserMedia(e, r, t)) : Promise.resolve()
                                }.bind(this);
                            return o().then((function(e) {
                                if (!e) return;
                                const {
                                    stream: t,
                                    sourceId: n,
                                    sourceType: r
                                } = e, o = t.getAudioTracks();
                                if (o.length) {
                                    const e = new MediaStream(o);
                                    i.push({
                                        stream: e,
                                        sourceId: n,
                                        sourceType: r,
                                        track: e.getAudioTracks()[0]
                                    })
                                }
                                const s = t.getVideoTracks();
                                if (s.length) {
                                    const e = new MediaStream(s);
                                    i.push({
                                        stream: e,
                                        sourceId: n,
                                        sourceType: r,
                                        track: e.getVideoTracks()[0],
                                        videoType: Yo.VideoType.DESKTOP
                                    })
                                }
                            })).then(s).then((function(e) {
                                if (!e) return;
                                const t = e.getAudioTracks();
                                if (t.length) {
                                    const e = new MediaStream(t);
                                    i.push({
                                        constraints: r.audio,
                                        stream: e,
                                        track: e.getAudioTracks()[0],
                                        effects: n.effects
                                    })
                                }
                                const o = e.getVideoTracks();
                                if (o.length) {
                                    const e = new MediaStream(o);
                                    i.push({
                                        constraints: r.video,
                                        stream: e,
                                        track: e.getVideoTracks()[0],
                                        videoType: Yo.VideoType.CAMERA,
                                        effects: n.effects
                                    })
                                }
                            })).then((() => i)).catch((e => (i.forEach((e => {
                                let {
                                    stream: t
                                } = e;
                                this.stopMediaStream(t)
                            })), Promise.reject(e))))
                        }
                        isDeviceListAvailable() {
                            return Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)
                        }
                        isDeviceChangeAvailable(e) {
                            return "output" !== e && "audiooutput" !== e || Wd
                        }
                        stopMediaStream(e) {
                            e && (e.getTracks().forEach((e => {
                                e.stop && e.stop()
                            })), e.stop && e.stop(), e.release && e.release())
                        }
                        isDesktopSharingEnabled() {
                            return ws.isSupported()
                        }
                        setAudioOutputDevice(e) {
                            return this.isDeviceChangeAvailable("output") ? Kd.setSinkId(e).then((() => {
                                Hd = e, $d = !0, Vd.log(`Audio output device set to ${e}`), this.eventEmitter.emit(ji.default.AUDIO_OUTPUT_DEVICE_CHANGED, e)
                            })) : Promise.reject(new Error("Audio output device change is not supported"))
                        }
                        setDesktopSharingFrameRate(e) {
                            ws.setDesktopSharingFrameRate(e)
                        }
                        getAudioOutputDevice() {
                            return Hd
                        }
                        getCurrentlyAvailableMediaDevices() {
                            return Yd
                        }
                        arePermissionsGrantedForAvailableDevices() {
                            return Yd.some((e => Boolean(e.label)))
                        }
                        getEventDataForActiveDevice(e) {
                            const t = [],
                                n = {
                                    deviceId: e.deviceId,
                                    kind: e.kind,
                                    label: e.label,
                                    groupId: e.groupId
                                };
                            return t.push(n), {
                                deviceList: t
                            }
                        }
                        isUserStreamById(e) {
                            return e && "mixedmslabel" !== e && "default" !== e
                        }
                    },
                    tc = ec,
                    nc = (0, E.getLogger)("modules/RTC/JitsiTrack.js"),
                    ic = {
                        track_mute: "onmute",
                        track_unmute: "onunmute",
                        track_ended: "onended"
                    };
                class rc extends ii {
                    constructor(e, t, n, i, r, o) {
                        super(), this.containers = [], this.conference = e, this.audioLevel = -1, this.type = r, this.track = n, this.videoType = o, this.handlers = new Map, this.disposed = !1, this._streamInactiveHandler = i, this._setStream(t)
                    }
                    _addMediaStreamInactiveHandler(e) {
                        ci.isFirefox() || ci.isWebKitBased() ? this.track.onended = e : this.stream.oninactive = e
                    }
                    _attachTTFMTracker(e) {}
                    _onTrackAttach(e) {}
                    _onTrackDetach(e) {}
                    _setHandler(e, t) {
                        if (ic.hasOwnProperty(e)) {
                            if (t ? this.handlers.set(e, t) : this.handlers.delete(e), this.stream)
                                for (const n of this.stream.getTracks()) n[ic[e]] = t
                        } else nc.error(`Invalid handler type ${e}`)
                    }
                    _setStream(e) {
                        if (this.stream !== e && (this.stream = e, this.stream)) {
                            for (const e of this.handlers.keys()) this._setHandler(e, this.handlers.get(e));
                            this._streamInactiveHandler && this._addMediaStreamInactiveHandler(this._streamInactiveHandler)
                        }
                    }
                    _unregisterHandlers() {
                        if (this.stream) {
                            for (const e of this.handlers.keys())
                                for (const t of this.stream.getVideoTracks()) t[ic[e]] = void 0;
                            this._streamInactiveHandler && this._addMediaStreamInactiveHandler(void 0)
                        } else nc.warn(`${this}: unable to unregister handlers - no stream object`)
                    }
                    attach(e) {
                        let t = Promise.resolve();
                        return this.stream && (this._onTrackAttach(e), t = tc.attachMediaStream(e, this.stream)), this.containers.push(e), this._attachTTFMTracker(e), t
                    }
                    detach(e) {
                        for (let t = this.containers, n = t.length - 1; n >= 0; --n) {
                            const i = t[n];
                            e || (this._onTrackDetach(i), tc.attachMediaStream(i, null).catch((() => {
                                nc.error(`Detach for ${this} failed!`)
                            }))), e && i !== e || t.splice(n, 1)
                        }
                        e && (this._onTrackDetach(e), tc.attachMediaStream(e, null).catch((() => {
                            nc.error(`Detach for ${this} failed!`)
                        })))
                    }
                    dispose() {
                        return this.removeAllListeners(), this.disposed = !0, Promise.resolve()
                    }
                    getId() {
                        return this.getStreamId()
                    }
                    getMSID() {
                        const e = this.getStreamId(),
                            t = this.getTrackId();
                        return e && t ? `${e} ${t}` : null
                    }
                    getOriginalStream() {
                        return this.stream
                    }
                    getSourceName() {}
                    getStreamId() {
                        return this.stream ? this.stream.id : null
                    }
                    getTrack() {
                        return this.track
                    }
                    getTrackLabel() {
                        return this.track.label
                    }
                    getTrackId() {
                        return this.track ? this.track.id : null
                    }
                    getType() {
                        return this.type
                    }
                    getUsageLabel() {
                        return this.isAudioTrack() ? "mic" : this.videoType ? this.videoType : "default"
                    }
                    getVideoType() {
                        return this.videoType
                    }
                    getHeight() {
                        return Math.min(this.track.getSettings().height, this.track.getSettings().width)
                    }
                    getWidth() {
                        return Math.max(this.track.getSettings().height, this.track.getSettings().width)
                    }
                    isActive() {
                        return void 0 === this.stream.active || this.stream.active
                    }
                    isAudioTrack() {
                        return this.getType() === Ri.AUDIO
                    }
                    isLocal() {
                        throw new Error("Not implemented by subclass")
                    }
                    isLocalAudioTrack() {
                        return this.isAudioTrack() && this.isLocal()
                    }
                    isVideoTrack() {
                        return this.getType() === Ri.VIDEO
                    }
                    isWebRTCTrackMuted() {
                        return this.track && this.track.muted
                    }
                    setAudioLevel(e, t) {
                        let n = e;
                        ci.supportsReceiverStats() && void 0 !== t && this.isMuted() && (n = 0), this.audioLevel !== n ? (this.audioLevel = n, this.emit(Ct, n, t)) : 0 === this.audioLevel && 0 === n && this.isLocal() && !this.isWebRTCTrackMuted() && this.emit(It, n)
                    }
                    setAudioOutput(e) {
                        return tc.isDeviceChangeAvailable("output") ? this.isVideoTrack() ? Promise.resolve() : Promise.all(this.containers.map((t => t.setSinkId(e).catch((e => {
                            throw nc.warn("Failed to change audio output device on element. Default or previously set audio output device will be used.", t, e), e
                        }))))).then((() => {
                            this.emit(xt, e)
                        })) : Promise.reject(new Error("Audio output device change is not supported"))
                    }
                    setSourceName(e) {}
                }
                const oc = (0, E.getLogger)("modules/RTC/JitsiLocalTrack.js");
                class sc extends rc {
                    constructor(e) {
                        let {
                            constraints: t,
                            deviceId: n,
                            facingMode: i,
                            mediaType: r,
                            rtcId: o,
                            sourceId: s,
                            sourceType: a,
                            stream: d,
                            track: c,
                            videoType: l,
                            effects: h = []
                        } = e;
                        super(null, d, c, (() => this.emit(Tt, this)), r, l), this._setEffectInProgress = !1;
                        const u = h.find((e => e.isEnabled(this)));
                        u && this._startStreamEffect(u);
                        const p = l === Yo.VideoType.DESKTOP ? c.getSettings().displaySurface : null;
                        var m;
                        this.metadata = {
                            timestamp: Date.now(),
                            ...p ? {
                                displaySurface: p
                            } : {}
                        }, this.rtcId = o, this.sourceId = s, this.sourceType = null != a ? a : p, this._constraints = c.getConstraints(), r === Ri.VIDEO && (l === Yo.VideoType.CAMERA && (Object.keys(this._constraints).length || (this._constraints = {
                            height: {
                                ideal: this.getHeight()
                            },
                            width: {
                                ideal: this.getWidth()
                            }
                        }), isNaN(this._constraints.height.ideal) && isNaN(this._constraints.width.ideal) && (this._constraints.height = {
                            ideal: t.height.ideal
                        }, this._constraints.width = {
                            ideal: t.width.ideal
                        })), this.resolution = this.getHeight(), isNaN(this.resolution) && null !== (m = this._constraints.height) && void 0 !== m && m.ideal && (this.resolution = this._constraints.height.ideal), this.maxEnabledResolution = this.resolution), this.deviceId = n, this._prevSetMuted = Promise.resolve(), this._facingMode = i, this._trackEnded = !1, this._hasSentData = !1, this._testDataSent = !0, this._realDeviceId = "" === this.deviceId ? void 0 : this.deviceId, this._sourceName = null, this._trackMutedTS = 0, this._onDeviceListWillChange = e => {
                            const t = this._realDeviceId;
                            this._setRealDeviceIdFromDeviceList(e), (void 0 === this.getTrack().readyState && void 0 !== this._realDeviceId && !e.find((e => e.deviceId === this._realDeviceId)) || void 0 !== t && void 0 === this._realDeviceId) && (this._trackEnded = !0)
                        }, this.isAudioTrack() && tc.isDeviceChangeAvailable("output") && (this._onAudioOutputDeviceChanged = this.setAudioOutput.bind(this), tc.addListener(ji.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged)), tc.addListener(ji.default.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._initNoDataFromSourceHandlers()
                    }
                    _addStreamToConferenceAsUnmute() {
                        return this.conference ? new Promise(((e, t) => {
                            this.conference._addLocalTrackToPc(this).then(e, (e => t(new Error(e))))
                        })) : Promise.resolve()
                    }
                    _fireNoDataFromSourceEvent() {
                        const e = !this.isReceivingData();
                        this.emit(wt, e), oc.debug(`NO_DATA_FROM_SOURCE event with value ${e} detected for track: ${this}`), Mi.sendAnalytics(((e, t) => ({
                            attributes: {
                                media_type: e,
                                value: t
                            },
                            action: "track.no.data.from.source",
                            type: Nt.TYPE_OPERATIONAL
                        }))(this.getType(), e))
                    }
                    _initNoDataFromSourceHandlers() {
                        this._isNoDataFromSourceEventsEnabled() && (this._setHandler("track_mute", (() => {
                            this._trackMutedTS = window.performance.now(), this._fireNoDataFromSourceEvent()
                        })), this._setHandler("track_unmute", (() => {
                            this._fireNoDataFromSourceEvent(), Mi.sendAnalyticsAndLog(nn, {
                                media_type: this.getType(),
                                track_type: "local",
                                value: window.performance.now() - this._trackMutedTS
                            })
                        })), this.isVideoTrack() && this.videoType === Yo.VideoType.CAMERA && this._setHandler("track_ended", (() => {
                            this.isReceivingData() || this._fireNoDataFromSourceEvent()
                        })))
                    }
                    _isNoDataFromSourceEventsEnabled() {
                        return !this.isVideoTrack() || this.videoType !== Yo.VideoType.DESKTOP
                    }
                    _queueSetMuted(e) {
                        const t = this._setMuted.bind(this, e);
                        return this._prevSetMuted = this._prevSetMuted.then(t, t), this._prevSetMuted
                    }
                    _removeStreamFromConferenceAsMute(e, t) {
                        this.conference ? this.conference._removeLocalTrackFromPc(this).then(e, (e => t(new Error(e)))) : e()
                    }
                    _sendMuteStatus(e) {
                        this.conference && this.conference._setTrackMuteStatus(this.getType(), this, e) && this.conference.room.sendPresence()
                    }
                    _setMuted(e) {
                        if (this.isMuted() === e && this.videoType !== Yo.VideoType.DESKTOP) return Promise.resolve();
                        if (this.disposed) return Promise.reject(new dr(tr));
                        let t = Promise.resolve();
                        const n = () => oc.info(`Mute ${this}: ${e}`),
                            i = ci.isReactNative() ? this.videoType === Yo.VideoType.DESKTOP : ci.doesVideoMuteByStreamRemove();
                        if (this.isAudioTrack() || !i) n(), this._streamEffect && this._streamEffect.setMuted ? this._streamEffect.setMuted(e) : this.track && (this.track.enabled = !e);
                        else if (e) t = new Promise(((e, t) => {
                            n(), this._removeStreamFromConferenceAsMute((() => {
                                this._streamEffect && this._stopStreamEffect(), this._unregisterHandlers(), this.stopStream(), this._setStream(null), e()
                            }), t)
                        }));
                        else {
                            n();
                            const e = {
                                cameraDeviceId: this.getDeviceId(),
                                devices: [Ri.VIDEO],
                                effects: this._streamEffect ? [this._streamEffect] : [],
                                facingMode: this.getCameraFacingMode()
                            };
                            t = tc.obtainAudioAndVideoPermissions(Object.assign({}, e, {
                                constraints: {
                                    video: this._constraints
                                }
                            })), t = t.then((e => {
                                const t = e.find((e => e.track.kind === this.getType()));
                                if (!t) throw new dr(nr);
                                return this._setStream(t.stream), this.track = t.track, this.videoType !== t.videoType && (oc.warn(`${this}: video type has changed after unmute!`, this.videoType, t.videoType), this.videoType = t.videoType), this._streamEffect && this._startStreamEffect(this._streamEffect), this.containers.map((e => tc.attachMediaStream(e, this.stream).catch((() => {
                                    oc.error(`Attach media failed for ${this} on video unmute!`)
                                })))), this._addStreamToConferenceAsUnmute()
                            }))
                        }
                        return t.then((() => {
                            this._sendMuteStatus(e), this.isVideoTrack() && this.conference && this.conference._sendBridgeVideoTypeMessage(this), this.emit(Rt, this)
                        }))
                    }
                    _setRealDeviceIdFromDeviceList(e) {
                        const t = this.getTrack(),
                            n = `${t.kind}input`;
                        let i = e.find((e => e.kind === n && e.label === t.label && e.deviceId === this.deviceId));
                        if (!i && "default" === this._realDeviceId) {
                            const r = (t.label || "").replace("Default - ", "");
                            i = e.find((e => e.kind === n && e.label === r))
                        }
                        this._realDeviceId = i ? i.deviceId : void 0
                    }
                    _setStream(e) {
                        super._setStream(e), e ? (this.storedMSID = this.getMSID(), oc.debug(`Setting new MSID: ${this.storedMSID} on ${this}`)) : oc.debug(`Setting 'null' stream on ${this}`)
                    }
                    _startStreamEffect(e) {
                        this._streamEffect = e, this._originalStream = this.stream, this._setStream(this._streamEffect.startEffect(this._originalStream)), this.track = this.stream.getTracks()[0]
                    }
                    _stopStreamEffect() {
                        this._streamEffect && (this._streamEffect.stopEffect(), this._setStream(this._originalStream), this._originalStream = null, this.track = this.stream ? this.stream.getTracks()[0] : null)
                    }
                    _switchCamera() {
                        this.isVideoTrack() && this.videoType === Yo.VideoType.CAMERA && "function" == typeof this.track._switchCamera && (this.track._switchCamera(), this._facingMode = this._facingMode === ja.ENVIRONMENT ? ja.USER : ja.ENVIRONMENT)
                    }
                    _switchStreamEffect(e) {
                        this._streamEffect && (this._stopStreamEffect(), this._streamEffect = void 0), e && this._startStreamEffect(e)
                    }
                    async dispose() {
                        return this._streamEffect && await this.setEffect(), this.conference && await this.conference.removeTrack(this), this.stream && (this.stopStream(), this.detach()), tc.removeListener(ji.default.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._onAudioOutputDeviceChanged && tc.removeListener(ji.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged), super.dispose()
                    }
                    getCameraFacingMode() {
                        if (this.isVideoTrack() && this.videoType === Yo.VideoType.CAMERA) {
                            var e, t;
                            const n = null === (e = (t = this.track).getSettings) || void 0 === e ? void 0 : e.call(t);
                            return n && "facingMode" in n ? n.facingMode : void 0 !== this._facingMode ? this._facingMode : ja.USER
                        }
                    }
                    getCaptureResolution() {
                        return this.videoType !== Yo.VideoType.CAMERA && ci.isWebKitBased() ? this.getHeight() : this.resolution
                    }
                    getDeviceId() {
                        return this._realDeviceId || this.deviceId
                    }
                    getDuration() {
                        return Date.now() / 1e3 - this.metadata.timestamp / 1e3
                    }
                    getParticipantId() {
                        return this.conference && this.conference.myUserId()
                    }
                    getSourceName() {
                        return this._sourceName
                    }
                    isEnded() {
                        return this.isVideoTrack() && this.isMuted() ? this._trackEnded : "ended" === this.getTrack().readyState || this._trackEnded
                    }
                    isLocal() {
                        return !0
                    }
                    isMuted() {
                        return !this.stream || !(!this.isVideoTrack() || this.isActive()) || (this._streamEffect && this._streamEffect.isMuted ? this._streamEffect.isMuted() : !this.track || !this.track.enabled)
                    }
                    isReceivingData() {
                        return !(!this.isVideoTrack() || !this.isMuted() && !this._stopStreamInProgress && this.videoType !== Yo.VideoType.DESKTOP) || !!this.stream && (this._effectEnabled ? this._originalStream : this.stream).getTracks().some((e => !("readyState" in e && "live" !== e.readyState || "muted" in e && !0 === e.muted)))
                    }
                    mute() {
                        return this._queueSetMuted(!0)
                    }
                    onByteSentStatsReceived(e, t) {
                        t > 0 && (this._hasSentData = !0);
                        const n = e.getConnectionState();
                        this._testDataSent && "connected" === n && (setTimeout((() => {
                            this._hasSentData || (oc.warn(`${this} 'bytes sent' <= 0:                         ${t}`), Mi.analytics.sendEvent(tn, {
                                media_type: this.getType()
                            }))
                        }), 3e3), this._testDataSent = !1)
                    }
                    setConference(e) {
                        this.conference = e
                    }
                    setEffect(e) {
                        if (void 0 === this._streamEffect && void 0 === e) return Promise.resolve();
                        if (void 0 !== e && !e.isEnabled(this)) return Promise.reject(new Error("Incompatible effect instance!"));
                        if (!0 === this._setEffectInProgress) return Promise.reject(new Error("setEffect already in progress!"));
                        if (this.isMuted() && !this.isAudioTrack()) return this._streamEffect = e, Promise.resolve();
                        const t = this.conference;
                        return t ? (this._setEffectInProgress = !0, t._removeLocalTrackFromPc(this).then((() => (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach((e => {
                            tc.attachMediaStream(e, this.stream).catch((() => {
                                oc.error(`Attach media failed for ${this} when trying to set effect.`)
                            }))
                        })), t._addLocalTrackToPc(this)))).then((() => {
                            this._setEffectInProgress = !1
                        })).catch((e => {
                            throw this._setEffectInProgress = !1, this._switchStreamEffect(), oc.error("Failed to switch to the new stream!", e), e
                        }))) : (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach((e => {
                            tc.attachMediaStream(e, this.stream).catch((() => {
                                oc.error(`Attach media failed for ${this} when trying to set effect.`)
                            }))
                        })), Promise.resolve())
                    }
                    setSourceName(e) {
                        this._sourceName = e
                    }
                    stopStream() {
                        this._stopStreamInProgress = !0;
                        try {
                            tc.stopMediaStream(this.stream)
                        } finally {
                            this._stopStreamInProgress = !1
                        }
                    }
                    toString() {
                        return `LocalTrack[${this.rtcId},${this.getType()}]`
                    }
                    unmute() {
                        return this._queueSetMuted(!1)
                    }
                }
                var ac = n(561);
                const dc = function(e, t) {
                        return void 0 !== e && void 0 !== e.media && Array.isArray(e.media) && e.media.forEach((e => {
                            e.sources && e.sources.length && (e.ssrcs = [], e.sources.forEach((t => {
                                Object.keys(t).forEach((n => {
                                    "id" !== n && e.ssrcs.push({
                                        id: t.id,
                                        attribute: n,
                                        value: t[n]
                                    })
                                }))
                            })), delete e.sources), e.ssrcGroups && e.ssrcGroups.length && e.ssrcGroups.forEach((e => {
                                void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.ssrcs = e.ssrcs.join(" "))
                            }))
                        })), ac.write(e, t)
                    },
                    cc = function(e) {
                        const t = ac.parse(e);
                        return void 0 !== t && void 0 !== t.media && Array.isArray(t.media) && t.media.forEach((e => {
                            void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.sources = [], e.ssrcs.forEach((t => {
                                const n = e.sources.findIndex((e => e.id === t.id));
                                if (n > -1) e.sources[n][t.attribute] = t.value;
                                else {
                                    const n = {
                                        id: t.id
                                    };
                                    n[t.attribute] = t.value, e.sources.push(n)
                                }
                            })), delete e.ssrcs), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach((e => {
                                "string" == typeof e.ssrcs && (e.ssrcs = e.ssrcs.split(" "))
                            }))
                        })), t
                    },
                    lc = ["audio", "video", "data"],
                    hc = e => e.find((e => "SIM" === e.semantics)),
                    uc = e => e.find((e => "FID" === e.semantics));

                function pc(e, t, n, i) {
                    if (!e || !t) return;
                    const r = e => i.find((t => t.id.toString() === e));
                    t.ssrcs.forEach((t => {
                        e.sources.push(r(t));
                        const i = n[parseInt(t, 10)].find((e => "FID" === e.semantics));
                        if (i) {
                            const n = i.ssrcs.find((e => e !== t));
                            e.sources.push(r(n)), e.ssrcGroups.push(i)
                        }
                    })), e.ssrcGroups.push(t)
                }

                function mc(e, t, n, i) {
                    if (!e || !t) return;
                    if (e.sources = [], e.ssrcGroups = [], !n[t.id]) return e.sources.push(t), void(e.msid = t.msid);
                    const r = hc(n[t.id]),
                        o = uc(n[t.id]);
                    if (r) pc(e, r, n, i);
                    else if (o) {
                        const r = o.ssrcs.find((e => e !== t)),
                            s = hc(n[r]);
                        s ? pc(e, s, n, i) : (o.ssrcs.forEach((t => {
                            e.sources.push((e => i.find((t => t.id.toString() === e)))(t))
                        })), e.ssrcGroups.push(o))
                    }
                    e.msid = e.sources[0].msid
                }

                function gc(e, t, n) {
                    if (!n.find((t => !!t.sources && t.sources.some((t => t.id === e.id))))) {
                        if (!t[e.id]) return !1;
                        const i = hc(t[e.id]),
                            r = uc(t[e.id]);
                        return i ? n.some((e => e.sources && e.sources.some((e => e.id.toString() === i.ssrcs[0])))) : !(!r || e.id.toString() === r.ssrcs[0]) && gc({
                            id: r.ssrcs[0]
                        }, t, n)
                    }
                    return !0
                }
                class fc {
                    toPlanB(e) {
                        if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
                        const t = cc(e.sdp);
                        if (!t.media || !t.media.length) return console.warn("The description has no media."), e;
                        if (t.media.every((e => -1 !== lc.indexOf(e.mid)))) return console.warn("The description does not look like unified plan sdp"), e;
                        const n = {},
                            i = t.media;
                        t.media = [], i.forEach((e => {
                            const t = e.type;
                            if ("application" === t) return e.mid = "data", void(n[e.mid] = e);
                            if (void 0 === n[t]) {
                                const i = ys(e);
                                i.sources && Array.isArray(i.sources) && i.sources.forEach((t => {
                                    e.msid ? t.msid = e.msid : delete t.msid
                                })), i.ssrcGroups && e.msid || (i.ssrcGroups = []), delete i.msid, i.mid = t, n[t] = i
                            } else if (e.msid) {
                                const i = ys(e);
                                i.sources && Array.isArray(i.sources) && (i.sources.forEach((t => {
                                    t.msid = e.msid
                                })), n[t].sources = (n[t].sources || []).concat(i.sources)), void 0 !== i.ssrcGroups && Array.isArray(i.ssrcGroups) && (n[t].ssrcGroups = (n[t].ssrcGroups || []).concat(i.ssrcGroups))
                            }
                        })), t.media = Object.values(n);
                        const r = [];
                        Object.values(n).forEach((e => {
                            "inactive" !== e.direction && r.push(e.mid)
                        })), t.groups.forEach((e => {
                            "BUNDLE" === e.type && (e.mids = r.join(" "))
                        })), t.msidSemantic = {
                            semantic: "WMS",
                            token: "*"
                        };
                        const o = dc(t);
                        return new RTCSessionDescription({
                            type: e.type,
                            sdp: o
                        })
                    }
                    toUnifiedPlan(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                        if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
                        const n = cc(e.sdp);
                        if (!n.media || !n.media.length) return console.warn("The description has no media."), e;
                        if (n.media.length > 3 || n.media.every((e => -1 === lc.indexOf(e.mid)))) return console.warn("The description does not look like plan-b"), e;
                        const i = t ? cc(t.sdp) : null,
                            r = function(e, t) {
                                if (!e || !t || 0 === e.media.length || 0 === t.media.length) return !1;
                                const n = e.media[0],
                                    i = t.media[0];
                                return n.iceUfrag !== i.iceUfrag || n.icePwd !== i.icePwd
                            }(n, i),
                            o = n.media[0].iceUfrag,
                            s = n.media[0].icePwd,
                            a = n.media[0].fingerprint,
                            d = {};
                        n.media.forEach((e => {
                            const t = e.type;
                            if ("application" === t) {
                                if (!i || !i.media) {
                                    const t = ys(e);
                                    return t.mid = Object.keys(d).length.toString(), void(d[e.mid] = t)
                                }
                                const n = i.media.findIndex((e => e.type === t));
                                return void(n && (i.media[n] = e, i.media[n].mid = n))
                            }
                            const n = function(e) {
                                const t = {};
                                return e && Array.isArray(e) ? (e.forEach((e => {
                                    e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach((n => {
                                        void 0 === t[n] && (t[n] = []), t[n].push(e)
                                    }))
                                })), t) : t
                            }(e.ssrcGroups);
                            if (e.sources) e.sources.forEach(((t, r) => {
                                if (!t.msid) return;
                                if (!i || !i.media) {
                                    if (gc(t, n, Object.values(d))) return;
                                    const i = ys(e);
                                    return i.mid = Object.keys(d).length.toString(), i.direction = r || "sendonly" === e.direction ? "sendonly" : "sendrecv", i.bundleOnly = void 0, mc(i, t, n, e.sources), void(d[i.mid] = i)
                                }
                                if (gc(t, n, i.media)) return;
                                const o = ys(e);
                                o.mid = i.media.length.toString(), o.direction = "sendonly", mc(o, t, n, e.sources), i.media.push(o)
                            }));
                            else if (!i) {
                                const t = ys(e);
                                t.mid = Object.keys(d).length.toString(), d[e.mid] = t
                            }
                        })), n.media = i ? i.media : Object.values(d);
                        const c = [];
                        n.media.forEach((e => {
                            c.push(e.mid), r && (e.iceUfrag = o, e.icePwd = s, e.fingerprint = a)
                        })), n.groups.forEach((e => {
                            "BUNDLE" === e.type && (e.mids = c.join(" "))
                        })), n.msidSemantic = {
                            semantic: "WMS",
                            token: "*"
                        }, n.origin.sessionVersion++;
                        const l = dc(n);
                        return new RTCSessionDescription({
                            type: e.type,
                            sdp: l
                        })
                    }
                }
                let vc;
                ! function(e) {
                    e.PEER_MUTED_CHANGED = "signaling.peerMuted", e.PEER_VIDEO_TYPE_CHANGED = "signaling.peerVideoType", e.SOURCE_MUTED_CHANGED = "signaling.sourceMuted", e.SOURCE_UPDATED = "signaling.sourceUpdated", e.SOURCE_VIDEO_TYPE_CHANGED = "signaling.sourceVideoType"
                }(vc || (vc = {}));
                const _c = vc.PEER_MUTED_CHANGED,
                    yc = vc.PEER_VIDEO_TYPE_CHANGED,
                    Ec = vc.SOURCE_MUTED_CHANGED,
                    Sc = vc.SOURCE_UPDATED,
                    bc = vc.SOURCE_VIDEO_TYPE_CHANGED;

                function Tc(e, t, n) {
                    return `${e}-${t.substring(0,1)}${n}`
                }

                function Cc(e) {
                    const t = e.lastIndexOf("-") + 1;
                    if (t <= 0) throw new Error(`Invalid source name: ${e}`);
                    const n = e.substr(t, 1);
                    for (const e of Object.values(Ri))
                        if (e.substr(0, 1) === n) return e;
                    throw new Error(`Invalid source name: ${e}`)
                }

                function xc(e) {
                    const t = e.split("-"),
                        n = Number(t[t.length - 1].substring(1));
                    if (Number.isNaN(n)) throw new Error(`Failed to parse track idx for source name: ${e}`);
                    return n
                }
                class Rc extends Cr {
                    getPeerMediaInfo(e, t, n) {
                        throw new Error("not implemented")
                    }
                    getPeerSourceInfo(e, t) {
                        throw new Error("not implemented")
                    }
                    getSSRCOwner(e) {
                        throw new Error("not implemented")
                    }
                    getTrackSourceName(e) {
                        throw new Error("not implemented")
                    }
                    removeSSRCOwners(e) {}
                    setSSRCOwner(e, t, n) {}
                    setTrackMuteStatus(e, t) {}
                    setTrackVideoType(e, t) {}
                    updateSsrcOwnersOnLeave(e) {}
                }
                const Ac = [{
                        rid: "1",
                        scaleFactor: 4
                    }, {
                        rid: "2",
                        scaleFactor: 2
                    }, {
                        rid: "3",
                        scaleFactor: 1
                    }],
                    wc = {
                        av1: {
                            maxBitratesVideo: {
                                low: 1e5,
                                standard: 3e5,
                                high: 1e6,
                                fullHd: 2e6,
                                ultraHd: 4e6,
                                ssHigh: 25e5,
                                none: 0
                            },
                            scalabilityModeEnabled: ci.supportsScalabilityModeAPI(),
                            useSimulcast: !1,
                            useKSVC: !0
                        },
                        h264: {
                            maxBitratesVideo: {
                                low: 2e5,
                                standard: 5e5,
                                high: 15e5,
                                fullHd: 3e6,
                                ultraHd: 6e6,
                                ssHigh: 25e5,
                                none: 0
                            },
                            scalabilityModeEnabled: ci.supportsScalabilityModeAPI()
                        },
                        vp8: {
                            maxBitratesVideo: {
                                low: 2e5,
                                standard: 5e5,
                                high: 15e5,
                                fullHd: 3e6,
                                ultraHd: 6e6,
                                ssHigh: 25e5,
                                none: 0
                            },
                            scalabilityModeEnabled: !1
                        },
                        vp9: {
                            maxBitratesVideo: {
                                low: 1e5,
                                standard: 3e5,
                                high: 12e5,
                                fullHd: 25e5,
                                ultraHd: 5e6,
                                ssHigh: 25e5,
                                none: 0
                            },
                            scalabilityModeEnabled: ci.supportsScalabilityModeAPI(),
                            useSimulcast: !1,
                            useKSVC: !0
                        }
                    },
                    Ic = [{
                        height: 2160,
                        level: "ultraHd"
                    }, {
                        height: 1080,
                        level: "fullHd"
                    }, {
                        height: 720,
                        level: "high"
                    }, {
                        height: 540,
                        level: "standard"
                    }, {
                        height: 480,
                        level: "standard"
                    }, {
                        height: 360,
                        level: "standard"
                    }, {
                        height: 270,
                        level: "low"
                    }, {
                        height: 180,
                        level: "low"
                    }, {
                        height: 90,
                        level: "low"
                    }, {
                        height: 0,
                        level: "none"
                    }];
                let Pc;

                function Dc(e) {
                    return parseInt(e.ssrcs.split(" ")[0], 10)
                }

                function Oc(e) {
                    return parseInt(e.ssrcs.split(" ")[1], 10)
                }

                function Nc(e) {
                    return e.ssrcs ? e.ssrcs.map((e => e.id)).filter(((e, t, n) => n.indexOf(e) === t)).length : 0
                }! function(e) {
                    e.ULTRA = "ultraHd", e.FULL = "fullHd", e.HIGH = "high", e.STANDARD = "standard", e.LOW = "low", e.NONE = "none"
                }(Pc || (Pc = {}));
                class kc {
                    constructor(e) {
                        if (!e) throw new Error("mLine is undefined");
                        this.mLine = e
                    }
                    get ssrcs() {
                        return this.mLine.ssrcs || (this.mLine.ssrcs = []), this.mLine.ssrcs
                    }
                    set ssrcs(e) {
                        this.mLine.ssrcs = e
                    }
                    get direction() {
                        return this.mLine.direction
                    }
                    set direction(e) {
                        this.mLine.direction = e
                    }
                    get ssrcGroups() {
                        return this.mLine.ssrcGroups || (this.mLine.ssrcGroups = []), this.mLine.ssrcGroups
                    }
                    set ssrcGroups(e) {
                        this.mLine.ssrcGroups = e
                    }
                    getSSRCAttrValue(e, t) {
                        const n = this.ssrcs.find((n => n.id === e && n.attribute === t));
                        return n && n.value
                    }
                    removeSSRC(e) {
                        this.mLine.ssrcs && this.mLine.ssrcs.length && (this.mLine.ssrcs = this.mLine.ssrcs.filter((t => t.id !== e)))
                    }
                    addSSRCAttribute(e) {
                        this.ssrcs.push(e)
                    }
                    findGroup(e, t) {
                        return this.ssrcGroups.find((n => n.semantics === e && (!t || t === n.ssrcs)))
                    }
                    findGroups(e) {
                        return this.ssrcGroups.filter((t => t.semantics === e))
                    }
                    findGroupByPrimarySSRC(e, t) {
                        return this.ssrcGroups.find((n => n.semantics === e && Dc(n) === t))
                    }
                    findSSRCByMSID(e) {
                        return this.ssrcs.find((t => "msid" === t.attribute && (null === e || t.value === e)))
                    }
                    getSSRCCount() {
                        return Nc(this.mLine)
                    }
                    containsAnySSRCGroups() {
                        return void 0 !== this.mLine.ssrcGroups
                    }
                    getPrimaryVideoSsrc() {
                        const e = this.mLine.type;
                        if ("video" !== e) throw new Error(`getPrimarySsrc doesn't work with '${e}'`);
                        if (1 === Nc(this.mLine)) return this.mLine.ssrcs[0].id;
                        if (this.mLine.ssrcGroups) {
                            const e = this.findGroup("SIM");
                            if (e) return Dc(e);
                            const t = this.findGroup("FID");
                            if (t) return Dc(t);
                            const n = this.findGroup("FEC-FR");
                            if (n) return Dc(n)
                        }
                    }
                    getRtxSSRC(e) {
                        const t = this.findGroupByPrimarySSRC("FID", e);
                        return t && Oc(t)
                    }
                    getSSRCs() {
                        return this.ssrcs.map((e => e.id)).filter(((e, t, n) => n.indexOf(e) === t))
                    }
                    getPrimaryVideoSSRCs() {
                        const e = this.mLine.type;
                        if ("video" !== e) throw new Error(`getPrimaryVideoSSRCs doesn't work with ${e}`);
                        const t = this.getSSRCs();
                        for (const e of this.ssrcGroups)
                            if ("FID" === e.semantics || "FEC-FR" === e.semantics) {
                                const n = Oc(e);
                                t.splice(t.indexOf(n), 1)
                            } return t
                    }
                    dumpSSRCGroups() {
                        return JSON.stringify(this.mLine.ssrcGroups)
                    }
                    removeGroupsWithSSRC(e) {
                        this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((t => -1 === t.ssrcs.indexOf(`${e}`))))
                    }
                    removeGroupsBySemantics(e) {
                        this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((t => t.semantics !== e)))
                    }
                    replaceSSRC(e, t) {
                        this.mLine.ssrcs && this.mLine.ssrcs.forEach((n => {
                            n.id === e && (n.id = t)
                        }))
                    }
                    addSSRCGroup(e) {
                        this.ssrcGroups.push(e)
                    }
                }
                class Mc {
                    constructor(e) {
                        this.parsedSDP = Is.parse(e)
                    }
                    selectMedia(e) {
                        const t = this.parsedSDP.media.filter((t => t.type === e)).map((e => new kc(e)));
                        return null != t ? t : null
                    }
                    toRawSDP() {
                        return Is.write(this.parsedSDP)
                    }
                }
                const Lc = (0, E.getLogger)("modules/sdp/LocalSdpMunger.js");
                class Fc {
                    constructor(e, t) {
                        this.tpc = e, this.localEndpointId = t, this.audioSourcesToMsidMap = new Map, this.videoSourcesToMsidMap = new Map
                    }
                    _generateMsidAttribute(e, t, n) {
                        if (!e || !t) return Lc.error(`Unable to munge local MSID - track id=${t} or media type=${e} is missing`), null;
                        const i = this.tpc.id;
                        return `${n}-${i} ${t}-${i}`
                    }
                    _transformMediaIdentifiers(e) {
                        var t, n, i, r, o;
                        const s = null === (t = e.mLine) || void 0 === t ? void 0 : t.type,
                            a = null === (n = e.mLine) || void 0 === n ? void 0 : n.direction,
                            d = null === (i = e.mLine) || void 0 === i ? void 0 : i.msid,
                            c = [...new Set(null === (r = e.mLine) || void 0 === r || null === (o = r.ssrcs) || void 0 === o ? void 0 : o.map((e => e.id)))],
                            l = `${this.localEndpointId}-${s}`;
                        let h = d ? d.split(" ")[1] : `${this.localEndpointId}-${e.mLine.mid}`;
                        for (const t of c) {
                            const n = e.ssrcs.find((e => e.id === t && "msid" === e.attribute));
                            n && (h = n.value.split(" ")[1]), this._updateSourcesToMsidMap(s, l, h);
                            const i = s === Ri.VIDEO ? this.videoSourcesToMsidMap.get(h) : this.audioSourcesToMsidMap.get(h),
                                r = this._generateMsidAttribute(s, h, i);
                            n ? n.value = r : a !== Rs.SENDONLY && a !== Rs.SENDRECV || e.ssrcs.push({
                                id: t,
                                attribute: "msid",
                                value: r
                            })
                        }
                        e.ssrcs = e.ssrcs.filter((e => "msid" === e.attribute)), !ci.isFirefox() || a !== Rs.RECVONLY && a !== Rs.INACTIVE || (s !== Ri.VIDEO || this.tpc._hasHadVideoTrack) && (s !== Ri.AUDIO || this.tpc._hasHadAudioTrack) || (e.ssrcs = void 0, e.ssrcGroups = void 0)
                    }
                    _updateSourcesToMsidMap(e, t, n) {
                        if (e === Ri.VIDEO) {
                            if (!this.videoSourcesToMsidMap.has(n)) {
                                const e = `${t}-${this.videoSourcesToMsidMap.size}`;
                                this.videoSourcesToMsidMap.set(n, e)
                            }
                        } else if (!this.audioSourcesToMsidMap.has(n)) {
                            const e = `${t}-${this.audioSourcesToMsidMap.size}`;
                            this.audioSourcesToMsidMap.set(n, e)
                        }
                    }
                    transformStreamIdentifiers(e) {
                        var t;
                        if (!e || !e.sdp || !e.type) return e;
                        const n = new Mc(e.sdp),
                            i = null === (t = n.selectMedia(Ri.AUDIO)) || void 0 === t ? void 0 : t[0];
                        i && (this._transformMediaIdentifiers(i), this._injectSourceNames(i));
                        const r = n.selectMedia(Ri.VIDEO);
                        for (const e of r) this._transformMediaIdentifiers(e), this._injectSourceNames(e);
                        return this.audioSourcesToMsidMap.clear(), this.videoSourcesToMsidMap.clear(), new RTCSessionDescription({
                            type: e.type,
                            sdp: n.toRawSDP()
                        })
                    }
                    _injectSourceNames(e) {
                        var t, n, i;
                        const r = [...new Set(null === (t = e.mLine) || void 0 === t || null === (n = t.ssrcs) || void 0 === n ? void 0 : n.map((e => e.id)))],
                            o = null === (i = e.mLine) || void 0 === i ? void 0 : i.type;
                        if (!o) throw new Error("_transformMediaIdentifiers - no media type in mediaSection");
                        for (const t of r) {
                            const n = e.ssrcs.find((e => e.id === t && "name" === e.attribute)),
                                i = e.ssrcs.find((e => e.id === t && "msid" === e.attribute)).value.split(" ")[0].split("-"),
                                r = i[i.length - 2],
                                a = Tc(this.localEndpointId, o, r);
                            if (n || e.ssrcs.push({
                                    id: t,
                                    attribute: "name",
                                    value: a
                                }), o === Ri.VIDEO) {
                                var s;
                                const n = null === (s = this.tpc.getLocalVideoTracks().find((e => e.getSourceName() === a))) || void 0 === s ? void 0 : s.getVideoType();
                                n && e.ssrcs.push({
                                    id: t,
                                    attribute: "videoType",
                                    value: n
                                })
                            }
                        }
                    }
                }
                const jc = (0, E.getLogger)("modules/sdp/RtxModifier.js");

                function Vc(e, t, n) {
                    const i = t.id,
                        r = t.msid,
                        o = t.cname,
                        s = e.getRtxSSRC(i);
                    s !== n && (s && (e.removeSSRC(s), e.removeGroupsWithSSRC(s)), e.addSSRCAttribute({
                        id: n,
                        attribute: "cname",
                        value: o
                    }), r && e.addSSRCAttribute({
                        id: n,
                        attribute: "msid",
                        value: r
                    }), e.addSSRCGroup({
                        semantics: "FID",
                        ssrcs: `${i} ${n}`
                    }))
                }
                class Uc {
                    constructor() {
                        this.correspondingRtxSsrcs = new Map
                    }
                    clearSsrcCache() {
                        this.correspondingRtxSsrcs.clear()
                    }
                    setSsrcCache(e) {
                        jc.debug("Setting ssrc cache to ", e), this.correspondingRtxSsrcs = e
                    }
                    modifyRtxSsrcs(e) {
                        let t = !1;
                        const n = new Mc(e),
                            i = n.selectMedia(Ri.VIDEO);
                        if (null == i || !i.length) return jc.debug(`No 'video' media found in the sdp: ${e}`), e;
                        for (const e of i) this.modifyRtxSsrcs2(e) && (t = !0);
                        return t ? n.toRawSDP() : e
                    }
                    modifyRtxSsrcs2(e) {
                        if (e.direction === Rs.RECVONLY) return !1;
                        if (e.getSSRCCount() < 1) return !1;
                        const t = e.getPrimaryVideoSSRCs();
                        for (const n of t) {
                            const t = e.getSSRCAttrValue(n, "msid"),
                                i = e.getSSRCAttrValue(n, "cname");
                            let r = this.correspondingRtxSsrcs.get(n);
                            if (!r) {
                                r = e.getRtxSSRC(n) || Ns.generateSsrc(), this.correspondingRtxSsrcs.set(n, r)
                            }
                            Vc(e, {
                                id: n,
                                cname: i,
                                msid: t
                            }, r)
                        }
                        return !0
                    }
                    stripRtx(e) {
                        const t = new Mc(e),
                            n = t.selectMedia(Ri.VIDEO);
                        if (null == n || !n.length) return jc.debug(`No 'video' media found in the sdp: ${e}`), e;
                        for (const e of n)
                            if (e.direction !== Rs.RECVONLY && e.getSSRCCount() && e.containsAnySSRCGroups()) {
                                const t = e.findGroups("FID");
                                e.removeGroupsBySemantics("FID");
                                for (const n of t) {
                                    const t = Oc(n);
                                    e.removeSSRC(t)
                                }
                            } return t.toRawSDP()
                    }
                }
                class Hc {
                    constructor() {
                        this._ssrcCache = new Map, this._numOfLayers = Ac.length
                    }
                    _fillSsrcsFromCache(e) {
                        const t = e.mid,
                            n = this._ssrcCache.get(t),
                            i = this._parseSimLayers(e),
                            r = this._getSsrcAttribute(e, i[0], "msid"),
                            o = this._getSsrcAttribute(e, i[0], "cname");
                        e.ssrcs = [], e.ssrcGroups = [];
                        for (const t of n) e.ssrcs.push({
                            id: t,
                            attribute: "msid",
                            value: r
                        }), e.ssrcs.push({
                            id: t,
                            attribute: "cname",
                            value: o
                        });
                        return e.ssrcGroups.push({
                            semantics: "SIM",
                            ssrcs: n.join(" ")
                        }), e
                    }
                    _generateNewSsrcsForSimulcast(e, t) {
                        const n = this._getSsrcAttribute(e, t, "cname");
                        let i = this._getSsrcAttribute(e, t, "msid");
                        const r = (e, t) => {
                            e.ssrcs.push({
                                id: t,
                                attribute: "cname",
                                value: n
                            }), e.ssrcs.push({
                                id: t,
                                attribute: "msid",
                                value: i
                            })
                        };
                        i || (i = e.msid, e.ssrcs.forEach((t => {
                            e.ssrcs.push({
                                id: t.id,
                                attribute: "msid",
                                value: i
                            })
                        })));
                        const o = [];
                        for (let t = 0; t < this._numOfLayers - 1; ++t) {
                            const t = this._generateSsrc();
                            r(e, t), o.push(t)
                        }
                        return e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                            semantics: "SIM",
                            ssrcs: t + " " + o.join(" ")
                        }), e
                    }
                    _generateSsrc() {
                        return Math.floor(4294967295 * Math.random())
                    }
                    _getSsrcAttribute(e, t, n) {
                        var i, r;
                        return null === (i = e.ssrcs) || void 0 === i || null === (r = i.find((e => Number(e.id) === t && e.attribute === n))) || void 0 === r ? void 0 : r.value
                    }
                    _parseSimLayers(e) {
                        var t, n;
                        const i = null === (t = e.ssrcGroups) || void 0 === t ? void 0 : t.find((e => "SIM" === e.semantics));
                        return i ? i.ssrcs.split(" ").map((e => Number(e))) : null !== (n = e.ssrcs) && void 0 !== n && n.length ? [Number(e.ssrcs[0].id)] : null
                    }
                    mungeLocalDescription(e) {
                        if (!e || !e.sdp) return e;
                        const t = Is.parse(e.sdp);
                        for (let e of t.media) {
                            var n, i, r;
                            if (e.direction === Rs.RECVONLY || e.direction === Rs.INACTIVE) continue;
                            if (e.type !== Ri.VIDEO) continue;
                            const t = e.mid,
                                s = new Set(null === (n = e.ssrcs) || void 0 === n ? void 0 : n.map((e => e.id))),
                                a = null !== (i = null === (r = e.ssrcGroups) || void 0 === r ? void 0 : r.length) && void 0 !== i ? i : 0;
                            let d;
                            if (!(0 === s.size || s.size > 2 || 2 === s.size && 0 === a)) {
                                if (1 === s.size) {
                                    var o;
                                    d = Number(null === (o = e.ssrcs[0]) || void 0 === o ? void 0 : o.id)
                                } else {
                                    const t = e.ssrcGroups.find((e => "FID" === e.semantics));
                                    t && (d = Number(t.ssrcs.split(" ")[0]))
                                }
                                if (this._ssrcCache.has(t)) e = this._fillSsrcsFromCache(e);
                                else {
                                    e = this._generateNewSsrcsForSimulcast(e, d);
                                    const n = this._parseSimLayers(e);
                                    this._ssrcCache.set(t, n)
                                }
                            }
                        }
                        return new RTCSessionDescription({
                            type: e.type,
                            sdp: Is.write(t)
                        })
                    }
                }
                let $c;
                ! function(e) {
                    e.ACTIVE = "active", e.INACTIVE = "inactive", e.INTERRUPTED = "interrupted", e.RESTORING = "restoring"
                }($c || ($c = {}));
                const Jc = (0, E.getLogger)("modules/connectivity/TrackStreamingStatus.ts");
                class Bc {
                    static _getNewStateForJvbMode(e, t, n, i) {
                        return n ? $c.ACTIVE : ci.supportsVideoMuteOnConnInterrupted() ? i ? e ? t ? $c.INTERRUPTED : $c.RESTORING : $c.INACTIVE : $c.ACTIVE : e ? $c.ACTIVE : $c.INACTIVE
                    }
                    static _getNewStateForP2PMode(e, t) {
                        return ci.supportsVideoMuteOnConnInterrupted() ? e || !t ? $c.ACTIVE : $c.INTERRUPTED : $c.ACTIVE
                    }
                    constructor(e, t, n, i) {
                        this.rtc = e, this.conference = t, this.track = n, this.restoringTimer = null, this.rtcMutedTimestamp = null, this.streamingStatusMap = {}, this.trackTimer = null, this.outOfForwardedSourcesTimeout = "number" == typeof i.outOfForwardedSourcesTimeout ? i.outOfForwardedSourcesTimeout : 500, this.p2pRtcMuteTimeout = "number" == typeof i.p2pRtcMuteTimeout ? i.p2pRtcMuteTimeout : 2500, this.rtcMuteTimeout = "number" == typeof i.rtcMuteTimeout ? i.rtcMuteTimeout : 1e4, Jc.info(`RtcMuteTimeout set to: ${this.rtcMuteTimeout}`)
                    }
                    _getVideoFrozenTimeout() {
                        const e = this.track.getSourceName();
                        return this.rtc.isInForwardedSources(e) ? this.rtcMuteTimeout : this.conference.isP2PActive() ? this.p2pRtcMuteTimeout : this.outOfForwardedSourcesTimeout
                    }
                    init() {
                        this._onP2PStatus = this.figureOutStreamingStatus.bind(this), this.conference.on(B.P2P_STATUS, this._onP2PStatus), this._onUserLeft = this.onUserLeft.bind(this), this.conference.on(B.USER_LEFT, this._onUserLeft), ci.supportsVideoMuteOnConnInterrupted() && (this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this), this.rtc.addListener(ji.default.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this), this.rtc.addListener(ji.default.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this._onSignallingMuteChanged = this.onSignallingMuteChanged.bind(this), this.track.on(Rt, this._onSignallingMuteChanged), this._onTrackVideoTypeChanged = this.onTrackVideoTypeChanged.bind(this), this.track.on(At, this._onTrackVideoTypeChanged)), this._onForwardedSourcesChanged = this.onForwardedSourcesChanged.bind(this), this.conference.on(B.FORWARDED_SOURCES_CHANGED, this._onForwardedSourcesChanged), this._onLastNValueChanged = this.figureOutStreamingStatus.bind(this), this.rtc.on(ji.default.LASTN_VALUE_CHANGED, this._onLastNValueChanged)
                    }
                    dispose() {
                        ci.supportsVideoMuteOnConnInterrupted() && (this.rtc.removeListener(ji.default.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this.rtc.removeListener(ji.default.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this.track.off(Rt, this._onSignallingMuteChanged), this.track.off(At, this._onTrackVideoTypeChanged)), this.conference.off(B.FORWARDED_SOURCES_CHANGED, this._onForwardedSourcesChanged), this.conference.off(B.P2P_STATUS, this._onP2PStatus), this.conference.off(B.USER_LEFT, this._onUserLeft), this.rtc.removeListener(ji.default.LASTN_VALUE_CHANGED, this._onLastNValueChanged), this.clearTimeout(), this.clearRtcMutedTimestamp(), this.maybeSendTrackStreamingStatusEvent(Date.now()), this.figureOutStreamingStatus()
                    }
                    _changeStreamingStatus(e) {
                        if (this.track.getTrackStreamingStatus() !== e) {
                            const t = this.track.getSourceName();
                            this.track._setTrackStreamingStatus(e), Jc.debug(`Emit track streaming status(${Date.now()}) ${t}: ${e}`), this.track.emit(Pt, this.track, e)
                        }
                    }
                    clearTimeout() {
                        this.trackTimer && (window.clearTimeout(this.trackTimer), this.trackTimer = null)
                    }
                    clearRtcMutedTimestamp() {
                        this.rtcMutedTimestamp = null
                    }
                    isVideoTrackFrozen() {
                        if (!ci.supportsVideoMuteOnConnInterrupted()) return !1;
                        const e = this.track.isWebRTCTrackMuted(),
                            t = this.rtcMutedTimestamp,
                            n = this._getVideoFrozenTimeout();
                        return e && "number" == typeof t && Date.now() - t >= n
                    }
                    figureOutStreamingStatus() {
                        const e = this.track.getSourceName(),
                            t = this.conference.isP2PActive(),
                            n = this._isRestoringTimedout(),
                            i = 0 === this.conference.getLastN(),
                            r = this.track.isMuted() || i,
                            o = this.isVideoTrackFrozen(),
                            s = this.rtc.isInForwardedSources(e),
                            a = t ? Bc._getNewStateForP2PMode(r, o) : Bc._getNewStateForJvbMode(s, n, r, o);
                        a !== $c.RESTORING && this._clearRestoringTimer(), Jc.debug(`Figure out conn status for ${e}, is video muted: ${r} video track frozen: ${o} p2p mode: ${t} is in forwarded sources: ${s} currentStatus => newStatus: ${this.track.getTrackStreamingStatus()} => ${a}`);
                        const d = this.streamingStatusMap || {};
                        if (!("p2p" in d) || !("streamingStatus" in d) || d.p2p !== t || d.streamingStatus !== a) {
                            const e = Date.now();
                            this.maybeSendTrackStreamingStatusEvent(e), this.streamingStatusMap = {
                                ...d,
                                streamingStatus: a,
                                p2p: t,
                                startedMs: e
                            }, "videoType" in this.streamingStatusMap || (this.streamingStatusMap.videoType = this.track.getVideoType())
                        }
                        this._changeStreamingStatus(a)
                    }
                    maybeSendTrackStreamingStatusEvent(e) {
                        const t = this.streamingStatusMap;
                        t && "startedMs" in t && "videoType" in t && "streamingStatus" in t && "p2p" in t && (t.value = e - t.startedMs, Mi.sendAnalytics(function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            return {
                                type: Nt.TYPE_OPERATIONAL,
                                source: "track.streaming.status",
                                action: "duration",
                                attributes: e
                            }
                        }(t)))
                    }
                    onForwardedSourcesChanged() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                            n = arguments.length > 2 ? arguments[2] : void 0;
                        const i = this.track.getSourceName();
                        ci.supportsVideoMuteOnConnInterrupted() || this.figureOutStreamingStatus(), e.includes(i) && (this.track._clearEnteredForwardedSourcesTimestamp(), this._clearRestoringTimer(), ci.supportsVideoMuteOnConnInterrupted() && this.figureOutStreamingStatus()), t.includes(i) && (this.track._setEnteredForwardedSourcesTimestamp(n), ci.supportsVideoMuteOnConnInterrupted() && this.figureOutStreamingStatus())
                    }
                    _clearRestoringTimer() {
                        const e = this.restoringTimer;
                        e && (clearTimeout(e), this.restoringTimer = null)
                    }
                    _isRestoringTimedout() {
                        const e = this.track._getEnteredForwardedSourcesTimestamp();
                        return !!(e && Date.now() - e >= 1e4) || (this.restoringTimer || (this.restoringTimer = setTimeout((() => this.figureOutStreamingStatus()), 1e4)), !1)
                    }
                    _isCurrentTrack(e) {
                        return e.getSourceName() === this.track.getSourceName()
                    }
                    onUserLeft(e) {
                        this.track.getParticipantId() === e && (this.maybeSendTrackStreamingStatusEvent(Date.now()), this.streamingStatusMap = {})
                    }
                    onTrackRtcMuted(e) {
                        if (!this._isCurrentTrack(e)) return;
                        const t = e.getSourceName();
                        if (Jc.debug(`Detector track RTC muted: ${t}`, Date.now()), this.rtcMutedTimestamp = Date.now(), !e.isMuted()) {
                            this.clearTimeout();
                            const e = this._getVideoFrozenTimeout();
                            this.trackTimer = window.setTimeout((() => {
                                Jc.debug(`Set track RTC muted for: ${t} after the timeout of ${e} ms`), this.clearTimeout(), this.figureOutStreamingStatus()
                            }), e)
                        }
                    }
                    onTrackRtcUnmuted(e) {
                        if (!this._isCurrentTrack(e)) return;
                        const t = this.track.getSourceName();
                        Jc.debug(`Detector track RTC unmuted: ${t}`, Date.now()), this.clearTimeout(), this.clearRtcMutedTimestamp(), this.figureOutStreamingStatus()
                    }
                    onSignallingMuteChanged(e) {
                        this._isCurrentTrack(e) && (this.track.getSourceName(), this.figureOutStreamingStatus())
                    }
                    onTrackVideoTypeChanged(e) {
                        const t = Date.now();
                        this.maybeSendTrackStreamingStatusEvent(t), this.streamingStatusMap = {
                            ...this.streamingStatusMap || {},
                            videoType: e,
                            startedMs: t
                        }
                    }
                }
                const qc = Bc,
                    Gc = n(810).getLogger("modules/RTC/JitsiRemoteTrack.js"),
                    zc = n(987);
                let Kc = !1,
                    Wc = !1;
                const Xc = ["abort", "canplaythrough", "ended", "error", "stalled", "suspend", "waiting"];
                class Yc extends rc {
                    constructor(e, t, n, i, r, o, s, a, d, c, l) {
                        if (super(t, i, r, (() => {}), o, s), this.rtc = e, "number" != typeof a) throw new TypeError(`SSRC ${a} is not a number`);
                        this.ssrc = a, this.ownerEndpointId = n, this.muted = d, this.isP2P = c, this._sourceName = l, this._trackStreamingStatus = null, this._trackStreamingStatusImpl = null, this._enteredForwardedSourcesTimestamp = null, this.addEventListener = this.on = this._addEventListener.bind(this), this.removeEventListener = this.off = this._removeEventListener.bind(this), Gc.debug(`New remote track created: ${this}`), this.hasBeenMuted = d, this.rtc && this.track && this._bindTrackHandlers(), this._containerHandlers = {}, Xc.forEach((e => {
                            this._containerHandlers[e] = this._containerEventHandler.bind(this, e)
                        }))
                    }
                    _bindTrackHandlers() {
                        this.track.addEventListener("mute", (() => this._onTrackMute())), this.track.addEventListener("unmute", (() => this._onTrackUnmute())), this.track.addEventListener("ended", (() => {
                            Gc.debug(`"onended" event(${Date.now()}): ${this}`)
                        }))
                    }
                    _addEventListener(e, t) {
                        super.addListener(e, t), e === Pt && this.listenerCount(Pt) && !this._trackStreamingStatusImpl && (this._initTrackStreamingStatus(), Gc.debug(`Initializing track streaming status: ${this._sourceName}`))
                    }
                    _removeEventListener(e, t) {
                        super.removeListener(e, t), e !== Pt || this.listenerCount(Pt) || (this._disposeTrackStreamingStatus(), Gc.debug(`Disposing track streaming status: ${this._sourceName}`))
                    }
                    _onTrackMute() {
                        Gc.debug(`"onmute" event(${Date.now()}): ${this}`), this.videoType !== Yo.VideoType.DESKTOP ? this.rtc.eventEmitter.emit(zc.REMOTE_TRACK_MUTE, this) : Gc.debug("Ignoring mute event on desktop tracks.")
                    }
                    _onTrackUnmute() {
                        Gc.debug(`"onunmute" event(${Date.now()}): ${this}`), this.rtc.eventEmitter.emit(zc.REMOTE_TRACK_UNMUTE, this)
                    }
                    dispose() {
                        return this._disposeTrackStreamingStatus(), super.dispose()
                    }
                    setMute(e) {
                        this.muted !== e && (e && (this.hasBeenMuted = !0), this.stream && (this.stream.muted = e), this.muted = e, Gc.info(`Mute ${this}: ${e}`), this.emit(Rt, this))
                    }
                    isMuted() {
                        return this.muted
                    }
                    getParticipantId() {
                        return this.ownerEndpointId
                    }
                    isLocal() {
                        return !1
                    }
                    getSSRC() {
                        return this.ssrc
                    }
                    getSourceName() {
                        return this._sourceName
                    }
                    setOwner(e) {
                        this.ownerEndpointId = e, this.emit(Dt, e)
                    }
                    setSourceName(e) {
                        this._sourceName = e
                    }
                    _setVideoType(e) {
                        this.videoType !== e && (this.videoType = e, this.emit(At, e))
                    }
                    _playCallback() {
                        if (!this.conference.room) return;
                        const e = this.isVideoTrack() ? "video" : "audio",
                            t = window.performance.now();
                        Gc.info(`(TIME) Render ${e}:\t`, t), this.conference.getConnectionTimes()[`${e}.render`] = t;
                        const n = window.connectionTimes["obtainPermissions.start"],
                            i = window.connectionTimes["obtainPermissions.end"],
                            r = isNaN(i) || isNaN(n) ? 0 : i - n,
                            o = t - (this.conference.getConnectionTimes()["session.initiate"] - this.conference.getConnectionTimes()["muc.joined"]) - r;
                        var s;
                        this.conference.getConnectionTimes()[`${e}.ttfm`] = o, Gc.info(`(TIME) TTFM ${e}:\t`, o), Mi.sendAnalytics((s = {
                            media_type: e,
                            muted: this.hasBeenMuted,
                            value: o
                        }, sn("ttfm", s)))
                    }
                    _attachTTFMTracker(e) {
                        Kc && this.isAudioTrack() || Wc && this.isVideoTrack() || (this.isAudioTrack() && (Kc = !0), this.isVideoTrack() && (Wc = !0), e.addEventListener("canplay", this._playCallback.bind(this)))
                    }
                    _onTrackAttach(e) {
                        Xc.forEach((t => {
                            e.addEventListener(t, this._containerHandlers[t])
                        }))
                    }
                    _onTrackDetach(e) {
                        Xc.forEach((t => {
                            e.removeEventListener(t, this._containerHandlers[t])
                        }))
                    }
                    _containerEventHandler(e) {
                        Gc.debug(`${e} handler was called for a container with attached ${this}`)
                    }
                    _getStatus() {
                        const {
                            enabled: e,
                            muted: t,
                            readyState: n
                        } = this.track;
                        return `readyState: ${n}, muted: ${t}, enabled: ${e}`
                    }
                    _initTrackStreamingStatus() {
                        const e = this.conference.options.config;
                        this._trackStreamingStatus = $c.ACTIVE, this._trackStreamingStatusImpl = new qc(this.rtc, this.conference, this, {
                            p2pRtcMuteTimeout: e._p2pConnStatusRtcMuteTimeout,
                            rtcMuteTimeout: e._peerConnStatusRtcMuteTimeout,
                            outOfForwardedSourcesTimeout: e._peerConnStatusOutOfLastNTimeout
                        }), this._trackStreamingStatusImpl.init(), !this._trackStreamingStatusImpl.isVideoTrackFrozen() && this.rtc.eventEmitter.emit(Pt, this, this._trackStreamingStatus)
                    }
                    _disposeTrackStreamingStatus() {
                        this._trackStreamingStatusImpl && (this._trackStreamingStatusImpl.dispose(), this._trackStreamingStatusImpl = null, this._trackStreamingStatus = null)
                    }
                    _setTrackStreamingStatus(e) {
                        this._trackStreamingStatus = e
                    }
                    getTrackStreamingStatus() {
                        return this._trackStreamingStatus
                    }
                    _clearEnteredForwardedSourcesTimestamp() {
                        this._enteredForwardedSourcesTimestamp = null
                    }
                    _setEnteredForwardedSourcesTimestamp(e) {
                        this._enteredForwardedSourcesTimestamp = e
                    }
                    _getEnteredForwardedSourcesTimestamp() {
                        return this._enteredForwardedSourcesTimestamp
                    }
                    toString() {
                        return `RemoteTrack[userID: ${this.getParticipantId()}, type: ${this.getType()}, ssrc: ${this.getSSRC()}, p2p: ${this.isP2P}, sourceName: ${this._sourceName}, status: {${this._getStatus()}}]`
                    }
                }
                let Qc;
                ! function(e) {
                    e.L1T3 = "L1T3", e.L2T3 = "L2T3", e.L2T3_KEY = "L2T3_KEY", e.L3T3 = "L3T3", e.L3T3_KEY = "L3T3_KEY"
                }(Qc || (Qc = {}));
                const Zc = (0, E.getLogger)("modules/RTC/TPCUtils.js"),
                    el = [Ps.AV1, Ps.H264, Ps.VP8, Ps.VP9];
                class tl {
                    constructor(e) {
                        var t;
                        this.pc = e, this.codecSettings = Es()(wc);
                        const n = null === (t = this.pc.options) || void 0 === t ? void 0 : t.videoQuality;
                        if (n)
                            for (const e of el) {
                                var i;
                                const t = n[e],
                                    r = null !== (i = null == t ? void 0 : t.maxBitratesVideo) && void 0 !== i ? i : n.maxbitratesvideo && n.maxbitratesvideo[e.toUpperCase()];
                                r && [...Object.values(Pc), "ssHigh"].forEach((t => {
                                    r[t] && (this.codecSettings[e].maxBitratesVideo[t] = r[t])
                                })), t && (this.codecSettings[e].scalabilityModeEnabled && (void 0 === t.scalabilityModeEnabled || t.scalabilityModeEnabled) ? (void 0 !== t.useSimulcast && (this.codecSettings[e].useSimulcast = t.useSimulcast), void 0 !== t.useKSVC && (this.codecSettings[e].useKSVC = t.useKSVC)) : this.codecSettings[e].scalabilityModeEnabled = !1)
                            }
                    }
                    _calculateActiveEncodingParams(e, t, n) {
                        var i, r;
                        const o = this.codecSettings[t].maxBitratesVideo,
                            s = e.getCaptureResolution(),
                            a = n > s ? s : n,
                            d = (null === (i = this.pc.options) || void 0 === i || null === (r = i.videoQuality) || void 0 === r ? void 0 : r.desktopbitrate) || o.ssHigh,
                            c = e.getVideoType() === Yo.VideoType.DESKTOP;
                        let l = this.codecSettings[t].useKSVC ? Qc.L3T3_KEY : Qc.L3T3;
                        const {
                            height: h,
                            level: u
                        } = Ic.find((e => e.height <= a));
                        let p, m = Ac[2].scaleFactor;
                        this._isScreenshareBitrateCapped(e) ? (l = Qc.L1T3, p = d) : c ? p = o.ssHigh : (p = o[u], a && (m = s / a), h !== a && Zc.debug(`Quality level with height=${h} was picked when requested height=${n} fortrack with capture height=${s}`));
                        const g = {
                            active: a > 0,
                            maxBitrate: p,
                            scalabilityMode: l,
                            scaleResolutionDownBy: m
                        };
                        if (!g.active || c) return g;
                        switch (u) {
                            case Pc.ULTRA:
                            case Pc.FULL:
                            case Pc.HIGH:
                                g.scalabilityMode = this.codecSettings[t].useKSVC ? Qc.L3T3_KEY : Qc.L3T3;
                                break;
                            case Pc.STANDARD:
                                g.scalabilityMode = this.codecSettings[t].useKSVC ? Qc.L2T3_KEY : Qc.L2T3;
                                break;
                            default:
                                g.scalabilityMode = Qc.L1T3
                        }
                        return g
                    }
                    _configureSenderEncodings(e) {
                        var t, n;
                        const i = e.getType(),
                            r = null != e && e.track && e.getOriginalStream() ? this.pc.peerconnection.getTransceivers().find((t => {
                                var n, i;
                                return (null === (n = t.sender) || void 0 === n || null === (i = n.track) || void 0 === i ? void 0 : i.id) === e.getTrackId()
                            })) : this.pc.peerconnection.getTransceivers().find((e => {
                                var t, n;
                                return (null === (t = e.receiver) || void 0 === t || null === (n = t.track) || void 0 === n ? void 0 : n.kind) === i
                            })),
                            o = null == r || null === (t = r.sender) || void 0 === t ? void 0 : t.getParameters();
                        return null != o && null !== (n = o.encodings) && void 0 !== n && n.length ? (o.encodings = this._getStreamEncodings(e), r.sender.setParameters(o)) : Promise.resolve()
                    }
                    _enableSenderEncodings(e, t) {
                        var n;
                        const i = e.getParameters();
                        if (null != i && null !== (n = i.encodings) && void 0 !== n && n.length)
                            for (const e of i.encodings) e.active = t;
                        return e.setParameters(i)
                    }
                    _getStreamEncodings(e) {
                        if (e.isAudioTrack()) return [{
                            active: this.pc.audioTransferActive
                        }];
                        const t = this.pc.getConfiguredVideoCodec();
                        return this.pc.isSpatialScalabilityOn() ? this._getVideoStreamEncodings(e, t) : [{
                            active: this.pc.videoTransferActive,
                            maxBitrate: this.codecSettings[t].maxBitratesVideo.high
                        }]
                    }
                    _getVideoStreamEncodings(e, t) {
                        const n = e.getCaptureResolution(),
                            i = this.codecSettings[t].maxBitratesVideo,
                            r = e.getVideoType();
                        let o, s = Ac.map((e => e.scaleFactor));
                        if (r === Yo.VideoType.CAMERA) {
                            const {
                                level: e
                            } = Ic.find((e => e.height <= n));
                            o = i[e], e === Pc.ULTRA ? (s[1] = 6, s[0] = 12) : e === Pc.FULL && (s[1] = 3, s[0] = 6)
                        }
                        const a = r === Yo.VideoType.DESKTOP ? i.ssHigh : o;
                        let d = [i.low, i.standard, a];
                        ci.isFirefox() && (r === Yo.VideoType.DESKTOP || ci.isVersionLessThan(117)) && (d = d.reverse(), s = s.reverse());
                        const c = [{
                            active: this.pc.videoTransferActive,
                            maxBitrate: d[0],
                            rid: Ac[0].rid,
                            scaleResolutionDownBy: s[0]
                        }, {
                            active: this.pc.videoTransferActive,
                            maxBitrate: d[1],
                            rid: Ac[1].rid,
                            scaleResolutionDownBy: s[1]
                        }, {
                            active: this.pc.videoTransferActive,
                            maxBitrate: d[2],
                            rid: Ac[2].rid,
                            scaleResolutionDownBy: s[2]
                        }];
                        if (this.codecSettings[t].scalabilityModeEnabled) {
                            if (this.codecSettings[t].useSimulcast || t === Ps.H264) {
                                for (const e of c) e.scalabilityMode = Qc.L1T3;
                                return c
                            }
                            return [{
                                active: this.pc.videoTransferActive,
                                maxBitrate: d[2],
                                rid: Ac[0].rid,
                                scaleResolutionDownBy: s[2],
                                scalabilityMode: this.codecSettings[t].useKSVC ? Qc.L3T3_KEY : Qc.L3T3
                            }, {
                                active: !1,
                                maxBitrate: 0
                            }, {
                                active: !1,
                                maxBitrate: 0
                            }]
                        }
                        return c
                    }
                    _isRunningInFullSvcMode(e) {
                        return (e === Ps.VP9 || e === Ps.AV1) && this.codecSettings[e].scalabilityModeEnabled && !this.codecSettings[e].useSimulcast
                    }
                    _isScreenshareBitrateCapped(e) {
                        return e.getVideoType() === Yo.VideoType.DESKTOP && this.pc._capScreenshareBitrate && !ci.isWebKitBased()
                    }
                    _updateSenderEncodings(e, t) {
                        var n;
                        const i = e.getParameters();
                        if (null != i && null !== (n = i.encodings) && void 0 !== n && n.length)
                            for (const e of i.encodings) e.active = t;
                        return e.setParameters(i)
                    }
                    addTrack(e, t) {
                        const n = e.getTrack();
                        if (t) {
                            const t = [];
                            e.getOriginalStream() && t.push(e.getOriginalStream());
                            const i = {
                                direction: Rs.SENDRECV,
                                streams: t,
                                sendEncodings: []
                            };
                            ci.isFirefox() || (i.sendEncodings = this._getStreamEncodings(e)), this.pc.peerconnection.addTransceiver(n, i)
                        } else this.pc.peerconnection.addTrack(n)
                    }
                    calculateEncodingsActiveState(e, t, n) {
                        const i = e.getCaptureResolution(),
                            r = this._getVideoStreamEncodings(e, t);
                        return r.map((e => i / e.scaleResolutionDownBy)).map(((i, o) => {
                            if (!this.pc.isSpatialScalabilityOn() || this._isRunningInFullSvcMode(t)) {
                                const {
                                    active: i
                                } = this._calculateActiveEncodingParams(e, t, n);
                                return 0 === o && i
                            }
                            let s = !1;
                            var a;
                            return n > 0 && (s = e.getVideoType() === Yo.VideoType.CAMERA ? i <= n || (null === (a = r[o]) || void 0 === a ? void 0 : a.scaleResolutionDownBy) === Ac[0].scaleFactor : r[o].scaleResolutionDownBy === Ac[2].scaleFactor || !this._isScreenshareBitrateCapped(e)), s
                        }))
                    }
                    calculateEncodingsBitrates(e, t, n) {
                        var i, r;
                        const o = this.codecSettings[t].maxBitratesVideo,
                            s = (null === (i = this.pc.options) || void 0 === i || null === (r = i.videoQuality) || void 0 === r ? void 0 : r.desktopbitrate) || o.ssHigh;
                        return this._getVideoStreamEncodings(e, t).map(((i, r) => {
                            let o = i.maxBitrate;
                            if (!this.pc.isSpatialScalabilityOn() || this._isRunningInFullSvcMode(t)) {
                                const {
                                    maxBitrate: i
                                } = this._calculateActiveEncodingParams(e, t, n);
                                return 0 === r ? i : 0
                            }
                            return this._isScreenshareBitrateCapped(e) && (o = s), o
                        }))
                    }
                    calculateEncodingsScalabilityMode(e, t, n) {
                        if (!this.pc.isSpatialScalabilityOn() || !this.codecSettings[t].scalabilityModeEnabled) return;
                        const i = [Qc.L1T3, Qc.L1T3, Qc.L1T3];
                        if (this._isRunningInFullSvcMode(t)) {
                            const {
                                scalabilityMode: r
                            } = this._calculateActiveEncodingParams(e, t, n);
                            return i[0] = r, i[1] = void 0, i[2] = void 0, i
                        }
                        return i
                    }
                    calculateEncodingsScaleFactor(e, t, n) {
                        if (this.pc.isSpatialScalabilityOn() && this.isRunningInSimulcastMode(t)) return this._getVideoStreamEncodings(e, t).map((e => e.scaleResolutionDownBy));
                        const {
                            scaleResolutionDownBy: i
                        } = this._calculateActiveEncodingParams(e, t, n);
                        return [i, void 0, void 0]
                    }
                    ensureCorrectOrderOfSsrcs(e) {
                        const t = Is.parse(e.sdp);
                        return t.media.forEach((e => {
                            if (e.type === Ri.AUDIO) return;
                            if (!e.ssrcGroups || !e.ssrcGroups.length) return;
                            let t = [];
                            const n = new Set;
                            e.ssrcGroups.map((e => e.ssrcs.split(" ").filter(Boolean).forEach((e => n.add(e))))), n.forEach((n => {
                                const i = e.ssrcs.filter((e => e.id.toString() === n));
                                t = t.concat(i)
                            })), e.ssrcs = t
                        })), new RTCSessionDescription({
                            type: e.type,
                            sdp: Is.write(t)
                        })
                    }
                    insertUnifiedPlanSimulcastReceive(e) {
                        if (ci.usesSdpMungingForSimulcast()) return e;
                        const t = [{
                                id: Ac[0].rid,
                                direction: "recv"
                            }, {
                                id: Ac[1].rid,
                                direction: "recv"
                            }, {
                                id: Ac[2].rid,
                                direction: "recv"
                            }],
                            n = `recv ${t.map((e=>e.id)).join(";")}`,
                            i = Is.parse(e.sdp),
                            r = i.media.filter((e => e.type === Ri.VIDEO)),
                            o = Array.from(this.pc._localTrackTransceiverMids.values());
                        return r.forEach(((e, i) => {
                            o.find((t => e.mid.toString() === t.toString())) || 0 === i ? e.simulcast_03 && e.simulcast || (e.rids = t, e.simulcast_03 = {
                                value: n
                            }) : (e.rids = void 0, e.simulcast = void 0, e.simulcast_03 = void 0)
                        })), new RTCSessionDescription({
                            type: e.type,
                            sdp: Is.write(i)
                        })
                    }
                    isRunningInSimulcastMode(e) {
                        return e === Ps.VP8 || !this.codecSettings[e].scalabilityModeEnabled && e === Ps.VP9 || this.codecSettings[e].scalabilityModeEnabled && (e === Ps.H264 || this.codecSettings[e].useSimulcast)
                    }
                    replaceTrack(e, t) {
                        var n, i;
                        const r = null !== (n = null == t ? void 0 : t.getType()) && void 0 !== n ? n : null == e ? void 0 : e.getType(),
                            o = this.pc.getLocalTracks(r),
                            s = null !== (i = null == t ? void 0 : t.getTrack()) && void 0 !== i ? i : null,
                            a = (null == o ? void 0 : o.length) && !e && t && !o.find((e => e === t));
                        let d;
                        if (e && !e.isMuted()) d = this.pc.peerconnection.getTransceivers().find((t => t.sender.track === e.getTrack()));
                        else if (a) d = this.pc.peerconnection.getTransceivers().find((e => e.receiver.track.kind === r && e.direction === Rs.RECVONLY && (this.pc.isP2P && e.currentDirection === Rs.RECVONLY || e.currentDirection === Rs.INACTIVE && !e.stopped)));
                        else {
                            var c;
                            d = this.pc.peerconnection.getTransceivers().find((e => e.receiver.track.kind === r));
                            const n = null !== (c = null == t ? void 0 : t.getSourceName()) && void 0 !== c ? c : null == e ? void 0 : e.getSourceName();
                            if (n) {
                                const t = xc(n);
                                if (this.pc.isP2P) d = this.pc.peerconnection.getTransceivers().filter((e => e.receiver.track.kind === r))[t];
                                else if (e) {
                                    const t = this.pc._localTrackTransceiverMids.get(e.rtcId);
                                    d = this.pc.peerconnection.getTransceivers().find((e => e.mid === t))
                                } else t && (d = this.pc.peerconnection.getTransceivers().filter((e => e.receiver.track.kind === r && e.direction !== Rs.RECVONLY))[t])
                            }
                        }
                        return d ? (Zc.debug(`${this.pc} Replacing ${e} with ${t}`), d.sender.replaceTrack(s).then((() => Promise.resolve(d)))) : Promise.reject(new Error(`Replace track failed - no transceiver for old: ${e}, new: ${t}`))
                    }
                    setEncodings(e) {
                        return e.getType() === Ri.VIDEO ? this.pc._updateVideoSenderParameters((() => this._configureSenderEncodings(e))) : this._configureSenderEncodings(e)
                    }
                    setMediaTransferActive(e, t) {
                        Zc.info(`${this.pc} ${e?"Resuming":"Suspending"} media transfer.`);
                        const n = this.pc.peerconnection.getSenders().filter((e => Boolean(e.track) && (!t || e.track.kind === t))),
                            i = [];
                        for (const t of n) t.track.kind === Ri.VIDEO ? i.push(this.pc._updateVideoSenderParameters((() => this._enableSenderEncodings(t, e)))) : i.push(this._enableSenderEncodings(t, e));
                        return Promise.allSettled(i).then((e => {
                            const t = e.filter((e => "rejected" === e.status)).map((e => e.reason));
                            return t.length ? Promise.reject(new Error(`Failed to change encodings on the RTCRtpSenders${t.join(" ")}`)) : Promise.resolve()
                        }))
                    }
                }
                const nl = (0, E.getLogger)("modules/RTC/TraceablePeerConnection.js"),
                    il = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";

                function rl(e, t, n, i, r, o, s) {
                    this.audioTransferActive = !(!0 === s.startSilent), this._dtmfSender = void 0, this._dtmfTonesQueue = [], this.videoTransferActive = !0, this.rtc = e, this.id = t, this.isP2P = o, this.remoteTracks = new Map, this.localTracks = new Map, this._addedStreams = [], this.localSSRCs = new Map, this.remoteSSRCs = new Set, this.remoteSources = new Map, this.localUfrag = null, this.remoteUfrag = null, this._dtlsTransport = null, this.signalingLayer = n, this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this), this.signalingLayer.on(yc, this._peerVideoTypeChanged), this._peerMutedChanged = this._peerMutedChanged.bind(this), this.signalingLayer.on(_c, this._peerMutedChanged), this.options = s, this.signalingLayer.on(Ec, ((e, t) => this._sourceMutedChanged(e, t))), this.signalingLayer.on(bc, ((e, t) => this._sourceVideoTypeChanged(e, t)));
                    const a = r || {};
                    a.optional = a.optional || [], Array.isArray(a.optional) ? a.optional.push({
                        rtcStatsSFUP2P: this.isP2P
                    }) : nl.warn("Optional param is not an array, rtcstats p2p data is omitted."), this.peerconnection = new RTCPeerConnection(i, a), this.tpcUtils = new tl(this), this.updateLog = [], this.stats = {}, this.statsinterval = null, this._capScreenshareBitrate = this.options.capScreenshareBitrate, this.codecSettings = this.options.codecSettings, ci.supportsCodecPreferences() && nl.info("Using RTCRtpTransceiver#setCodecPreferences for codec selection"), this._hasHadAudioTrack = !1, this._hasHadVideoTrack = !1, this.maxstats = s.maxstats, this.interop = new fc, this.simulcast = new Hc, this.localSdpMunger = new Fc(this, this.rtc.getLocalEndpointId()), this.eventEmitter = e.eventEmitter, this.rtxModifier = new Uc, this._senderMaxHeights = new Map, this._supportsDDHeaderExt = !1, this._localTrackTransceiverMids = new Map, this.trace = (e, t) => {
                        nl.trace(e, t), this.updateLog.push({
                            time: new Date,
                            type: e,
                            value: t || ""
                        })
                    }, this.onicecandidate = null, this.peerconnection.onicecandidate = e => {
                        this.trace("onicecandidate", JSON.stringify(e.candidate, null, " ")), null !== this.onicecandidate && this.onicecandidate(e)
                    }, this.onTrack = e => {
                        const t = e.streams[0];
                        this._remoteTrackAdded(t, e.track, e.transceiver), t.addEventListener("removetrack", (e => {
                            this._remoteTrackRemoved(t, e.track)
                        }))
                    }, this.peerconnection.addEventListener("track", this.onTrack), this.onsignalingstatechange = null, this.peerconnection.onsignalingstatechange = e => {
                        this.trace("onsignalingstatechange", this.signalingState), null !== this.onsignalingstatechange && this.onsignalingstatechange(e)
                    }, this.oniceconnectionstatechange = null, this.peerconnection.oniceconnectionstatechange = e => {
                        this.trace("oniceconnectionstatechange", this.iceConnectionState), null !== this.oniceconnectionstatechange && this.oniceconnectionstatechange(e)
                    }, this.onnegotiationneeded = null, this.peerconnection.onnegotiationneeded = e => {
                        this.trace("onnegotiationneeded"), null !== this.onnegotiationneeded && this.onnegotiationneeded(e)
                    }, this.onconnectionstatechange = null, this.peerconnection.onconnectionstatechange = e => {
                        this.trace("onconnectionstatechange", this.connectionState), null !== this.onconnectionstatechange && this.onconnectionstatechange(e)
                    }, this.ondatachannel = null, this.peerconnection.ondatachannel = e => {
                        this.trace("ondatachannel"), null !== this.ondatachannel && this.ondatachannel(e)
                    }, this.maxstats && (this.statsinterval = window.setInterval((() => {
                        this.getStats().then((e => {
                            if ("function" == typeof(null == e ? void 0 : e.result)) {
                                const t = e.result();
                                for (let e = 0; e < t.length; ++e) {
                                    const n = t[e];
                                    n.names().forEach((e => {
                                        this._processStat(n, e, n.stat(e))
                                    }))
                                }
                            } else e.forEach((e => this._processStat(e, "", e)))
                        }))
                    }), 1e3)), this._lastVideoSenderUpdatePromise = Promise.resolve(), nl.info(`Create new ${this}`)
                }
                rl.prototype._processStat = function(e, t, n) {
                    const i = `${e.id}-${t}`;
                    let r = this.stats[i];
                    const o = new Date;
                    r || (this.stats[i] = r = {
                        startTime: o,
                        endTime: o,
                        values: [],
                        times: []
                    }), r.values.push(n), r.times.push(o.getTime()), r.values.length > this.maxstats && (r.values.shift(), r.times.shift()), r.endTime = o
                };
                const ol = function(e) {
                    return null == e ? "" : `type: ${e.type}\r\n${e.sdp}`
                };
                rl.prototype.getConnectionState = function() {
                    const e = this.peerconnection.iceConnectionState;
                    return "completed" === e ? "connected" : e
                }, rl.prototype.getDesiredMediaDirection = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    const n = this.hasAnyTracksOfType(e);
                    return t ? n ? Rs.SENDRECV : Rs.SENDONLY : n ? Rs.RECVONLY : Rs.INACTIVE
                }, rl.prototype._getReceiversByEndpointIds = function(e, t) {
                    let n = [],
                        i = [];
                    for (const i of e) n = n.concat(this.getRemoteTracks(i, t));
                    const r = n.map((e => {
                        var t;
                        return null === (t = e.track) || void 0 === t ? void 0 : t.id
                    }));
                    return i = this.peerconnection.getReceivers().filter((e => e.track && e.track.kind === t && r.find((t => t === e.track.id)))), i
                }, rl.prototype.isSpatialScalabilityOn = function() {
                    const e = this.tpcUtils.codecSettings[Ps.H264].scalabilityModeEnabled && this._supportsDDHeaderExt;
                    return !this.options.disableSimulcast && (this.codecSettings.codecList[0] !== Ps.H264 || e)
                }, rl.prototype._peerVideoTypeChanged = function(e, t) {
                    if (!e) return void nl.error(`${this} No endpointID on peerVideoTypeChanged`);
                    const n = this.getRemoteTracks(e, Ri.VIDEO);
                    n.length && n[0]._setVideoType(t)
                }, rl.prototype._peerMutedChanged = function(e, t, n) {
                    if (!e) return void nl.error(`${this} On peerMuteChanged - no endpoint ID`);
                    const i = this.getRemoteTracks(e, t);
                    i.length && i[0].setMute(n)
                }, rl.prototype._sourceMutedChanged = function(e, t) {
                    const n = this.getRemoteTracks().find((t => t.getSourceName() === e));
                    n ? n.setMute(t) : Ai.isSsrcRewritingSupported() && nl.debug(`Remote track not found for source=${e}, mute update failed!`)
                }, rl.prototype._sourceVideoTypeChanged = function(e, t) {
                    const n = this.getRemoteTracks().find((t => t.getSourceName() === e));
                    n && n._setVideoType(t)
                }, rl.prototype.getAudioLevels = function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                    const t = {};
                    return (e.length ? this._getReceiversByEndpointIds(e, Ri.AUDIO) : this.peerconnection.getReceivers().filter((e => e.track && e.track.kind === Ri.AUDIO && e.track.enabled))).forEach((e => {
                        const n = e.getSynchronizationSources();
                        n && n.length && (t[n[0].source] = n[0].audioLevel)
                    })), t
                }, rl.prototype.doesTrueSimulcast = function() {
                    const e = this.getConfiguredVideoCodec();
                    return this.isSpatialScalabilityOn() && this.tpcUtils.isRunningInSimulcastMode(e)
                }, rl.prototype.getLocalVideoSSRCs = function(e) {
                    var t, n, i;
                    const r = [];
                    if (!e || !e.isVideoTrack()) return r;
                    const o = this.isSpatialScalabilityOn() ? "SIM" : "FID";
                    return (null === (t = this.localSSRCs.get(e.rtcId)) || void 0 === t || null === (n = t.groups) || void 0 === n || null === (i = n.find((e => e.semantics === o))) || void 0 === i ? void 0 : i.ssrcs) || r
                }, rl.prototype.getLocalTracks = function(e) {
                    let t = Array.from(this.localTracks.values());
                    return void 0 !== e && (t = t.filter((t => t.getType() === e))), t
                }, rl.prototype.getLocalVideoTracks = function() {
                    return this.getLocalTracks(Ri.VIDEO)
                }, rl.prototype.hasAnyTracksOfType = function(e) {
                    if (!e) throw new Error('"mediaType" is required');
                    return this.getLocalTracks(e).length > 0
                }, rl.prototype.getRemoteTracks = function(e, t) {
                    let n = [];
                    const i = e ? [e] : this.remoteTracks.keys();
                    for (const e of i) {
                        const i = this.remoteTracks.get(e);
                        if (i)
                            for (const e of i.keys()) t && t !== e || (n = n.concat(Array.from(i.get(e))))
                    }
                    return n
                }, rl.prototype.getRemoteSourceInfoByParticipant = function(e) {
                    const t = [],
                        n = this.getRemoteTracks(e);
                    if (null == n || !n.length) return t;
                    const i = n.map((e => e.getSSRC())),
                        r = new ks(this.remoteDescription.sdp);
                    return i.forEach(((e, n) => {
                        for (const i of r.media) {
                            let r = "",
                                o = Ns.findLines(i, `a=ssrc:${e}`);
                            if (o.length) {
                                t[n] || (t[n] = "");
                                const s = Ns.findLines(i, `a=ssrc-group:FID ${e}`);
                                if (s.length) {
                                    const e = s[0].split(" ")[2];
                                    r += `${s[0]}\r\n`, o = o.concat(Ns.findLines(i, `a=ssrc:${e}`))
                                }
                                t[n] += `${o.join("\r\n")}\r\n`, t[n] += r
                            }
                        }
                    })), t
                }, rl.prototype.getTargetVideoBitrates = function() {
                    const e = this.getConfiguredVideoCodec();
                    return this.tpcUtils.codecSettings[e].maxBitratesVideo
                }, rl.prototype.getTrackBySSRC = function(e) {
                    if ("number" != typeof e) throw new Error(`SSRC ${e} is not a number`);
                    for (const t of this.localTracks.values())
                        if (this.getLocalSSRC(t) === e) return t;
                    for (const t of this.getRemoteTracks())
                        if (t.getSSRC() === e) return t;
                    return null
                }, rl.prototype.getSsrcByTrackId = function(e) {
                    const t = t => t.getTrack().id === e,
                        n = this.getLocalTracks().find(t);
                    if (n) return this.getLocalSSRC(n);
                    const i = this.getRemoteTracks().find(t);
                    return i ? i.getSSRC() : null
                }, rl.prototype._remoteTrackAdded = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    const i = e.id,
                        r = t.kind;
                    if (!this.isP2P && !tc.isUserStreamById(i)) return;
                    if (nl.info(`${this} Received track event for remote stream[id=${i},type=${r}]`), !r) return void nl.error(`MediaType undefined for remote track, stream id: ${i}, track creation failed!`);
                    const o = new ks(this.peerconnection.remoteDescription.sdp);
                    let s;
                    if (null != n && n.mid) {
                        const e = n.mid;
                        s = o.media.find((t => Ns.findLine(t, `a=mid:${e}`)))
                    } else s = o.media.find((e => {
                        const t = Ns.findLine(e, "a=msid:");
                        return "string" == typeof t && i === t.substring(7).split(" ")[0]
                    }));
                    if (!s) return void nl.error(`Matching media line not found in remote SDP for remote stream[id=${i},type=${r}],track creation failed!`);
                    let a = Ns.findLines(s, "a=ssrc:");
                    if (a = a.filter((e => -1 !== e.indexOf(`msid:${i}`))), !a.length) return void nl.error(`No SSRC lines found in remote SDP for remote stream[msid=${i},type=${r}]track creation failed!`);
                    const d = a[0].substring(7).split(" ")[0],
                        c = Number(d),
                        l = this.signalingLayer.getSSRCOwner(c);
                    if (isNaN(c) || c < 0) return void nl.error(`Invalid SSRC for remote stream[ssrc=${c},id=${i},type=${r}]track creation failed!`);
                    if (!l) return void nl.error(`No SSRC owner known for remote stream[ssrc=${c},id=${i},type=${r}]track creation failed!`);
                    const h = this.signalingLayer.getTrackSourceName(c),
                        u = this.signalingLayer.getPeerMediaInfo(l, r, h);
                    let p = !0,
                        m = r === Ri.VIDEO ? Yo.VideoType.CAMERA : void 0;
                    u ? (p = u.muted, m = u.videoType) : nl.info(`${this}: no source-info available for ${l}:${h}, assuming default state`), this._createRemoteTrack(l, e, t, r, m, c, p, h)
                }, rl.prototype._createRemoteTrack = function(e, t, n, i, r, o, s, a) {
                    nl.info(`${this} creating remote track[endpoint=${e},ssrc=${o},type=${i},sourceName=${a}]`);
                    let d = this.remoteTracks.get(e);
                    d || (d = new Map, d.set(Ri.AUDIO, new Set), d.set(Ri.VIDEO, new Set), this.remoteTracks.set(e, d));
                    const c = d.get(i);
                    if (null != c && c.size && Array.from(c).find((e => e.getTrack() === n))) return void nl.info(`${this} ignored duplicated track event for track[endpoint=${e},type=${i}]`);
                    const l = new Yc(this.rtc, this.rtc.conference, e, t, n, i, r, o, s, this.isP2P, a);
                    c.add(l), this.eventEmitter.emit(ji.default.REMOTE_TRACK_ADDED, l, this)
                }, rl.prototype._remoteTrackRemoved = function(e, t) {
                    const n = e.id,
                        i = null == t ? void 0 : t.id;
                    if (!tc.isUserStreamById(n)) return;
                    if (!n) return void nl.error(`${this} remote track removal failed - no stream ID`);
                    if (!i) return void nl.error(`${this} remote track removal failed - no track ID`);
                    const r = this.getRemoteTracks().find((e => e.getStreamId() === n && e.getTrackId() === i));
                    r ? this._removeRemoteTrack(r) : nl.error(`${this} remote track removal failed - track not found`)
                }, rl.prototype.removeRemoteTracks = function(e) {
                    let t = [];
                    const n = this.remoteTracks.get(e);
                    return n && (t = t.concat(Array.from(n.get(Ri.AUDIO))), t = t.concat(Array.from(n.get(Ri.VIDEO))), this.remoteTracks.delete(e)), nl.debug(`${this} removed remote tracks[endpoint=${e},count=${t.length}`), t
                }, rl.prototype._removeRemoteTrack = function(e) {
                    var t;
                    nl.info(`${this} Removing remote track stream[id=${e.getStreamId()},trackId=${e.getTrackId()}]`), e.dispose();
                    const n = e.getParticipantId();
                    if (!n && Ai.isSsrcRewritingSupported()) return;
                    const i = this.remoteTracks.get(n);
                    i ? null !== (t = i.get(e.getType())) && void 0 !== t && t.delete(e) || nl.error(`${this} Failed to remove ${e} - type mapping messed up ?`) : nl.error(`${this} removeRemoteTrack: no remote tracks map for endpoint=${n}`), this.eventEmitter.emit(ji.default.REMOTE_TRACK_REMOVED, e)
                }, rl.prototype._extractSSRCMap = function(e) {
                    const t = new Map,
                        n = new Map;
                    if ("object" != typeof e || null === e || "string" != typeof e.sdp) return nl.warn("An empty description was passed as an argument"), t;
                    const i = Is.parse(e.sdp);
                    if (!Array.isArray(i.media)) return t;
                    let r = i.media;
                    r = r.filter((e => e.direction === Rs.SENDONLY || e.direction === Rs.SENDRECV));
                    let o = 0;
                    for (const e of r) {
                        if (!Array.isArray(e.ssrcs)) continue;
                        if (Array.isArray(e.ssrcGroups)) {
                            for (const t of e.ssrcGroups)
                                if (void 0 !== t.semantics && void 0 !== t.ssrcs) {
                                    const e = t.ssrcs.split(" ").map((e => parseInt(e, 10))),
                                        i = e[0];
                                    t.ssrcs = e, n.has(i) || n.set(i, []), n.get(i).push(t)
                                } if (!e.ssrcGroups.find((e => "SIM" === e.semantics))) {
                                const t = e.ssrcGroups.map((e => e.ssrcs[0]));
                                n.get(t[0]).push({
                                    semantics: "SIM",
                                    ssrcs: t
                                })
                            }
                        }
                        let i = e.ssrcs;
                        i = i.filter((e => "cname" === e.attribute));
                        for (const r of i) {
                            const i = `${e.type}-${o}`,
                                s = r.id;
                            let a = t.get(i);
                            if (a || (a = {
                                    ssrcs: [],
                                    groups: [],
                                    msid: i
                                }, t.set(i, a)), a.ssrcs.push(s), n.has(s)) {
                                const e = n.get(s);
                                for (const t of e) a.groups.push(t)
                            }
                        }
                        e.type === Ri.VIDEO && o++
                    }
                    return t
                }, rl.prototype.getLocalSSRC = function(e) {
                    const t = this._getSSRC(e.rtcId);
                    return t && t.ssrcs[0]
                }, rl.prototype._injectSsrcGroupForUnifiedSimulcast = function(e) {
                    const t = Is.parse(e.sdp),
                        n = t.media.find((e => "video" === e.type));
                    n.ssrcGroups = n.ssrcGroups || [];
                    const i = n.ssrcGroups.filter((e => "FID" === e.semantics));
                    if (n.simulcast || n.simulcast_03) {
                        const t = [];
                        if (i && i.length ? i.forEach((e => {
                                t.push(e.ssrcs.split(" ")[0])
                            })) : n.ssrcs.forEach((e => {
                                "msid" === e.attribute && t.push(e.id)
                            })), n.ssrcGroups.find((e => "SIM" === e.semantics))) return e;
                        for (let e = 0; e < t.length; e += 3) {
                            const i = t.slice(e, e + 3);
                            n.ssrcGroups.push({
                                semantics: "SIM",
                                ssrcs: i.join(" ")
                            })
                        }
                    }
                    return new RTCSessionDescription({
                        type: e.type,
                        sdp: Is.write(t)
                    })
                };
                const sl = {
                    signalingState() {
                        return this.peerconnection.signalingState
                    },
                    iceConnectionState() {
                        return this.peerconnection.iceConnectionState
                    },
                    connectionState() {
                        return this.peerconnection.connectionState
                    },
                    localDescription() {
                        let e = this.peerconnection.localDescription;
                        return e ? (this.trace("getLocalDescription::preTransform", ol(e)), this.isP2P || (e = this.interop.toPlanB(e), this.trace("getLocalDescription::postTransform (Plan B)", ol(e)), e = this._injectSsrcGroupForUnifiedSimulcast(e), this.trace("getLocalDescription::postTransform (inject ssrc group)", ol(e))), e = this.localSdpMunger.transformStreamIdentifiers(e), e) : (nl.debug(`${this} getLocalDescription no localDescription found`), {})
                    },
                    remoteDescription() {
                        let e = this.peerconnection.remoteDescription;
                        return e ? (this.trace("getRemoteDescription::preTransform", ol(e)), this.isP2P ? e = this._adjustRemoteMediaDirection(e) : (e = this.interop.toPlanB(e), this.trace("getRemoteDescription::postTransform (Plan B)", ol(e))), e) : (nl.debug(`${this} getRemoteDescription no remoteDescription found`), {})
                    }
                };
                Object.keys(sl).forEach((e => {
                    Object.defineProperty(rl.prototype, e, {
                        get: sl[e]
                    })
                })), rl.prototype._getSSRC = function(e) {
                    return this.localSSRCs.get(e)
                }, rl.prototype.isSharingLowFpsScreen = function() {
                    return this._isSharingScreen() && this._capScreenshareBitrate
                }, rl.prototype._isSharingScreen = function() {
                    const e = this.getLocalVideoTracks();
                    return Boolean(e.find((e => e.videoType === Yo.VideoType.DESKTOP)))
                }, rl.prototype._mungeCodecOrder = function(e) {
                    if (!this.codecSettings) return e;
                    const t = Is.parse(e.sdp),
                        n = t.media.filter((e => e.type === this.codecSettings.mediaType));
                    if (!n.length) return e;
                    for (const t of n) {
                        const n = this.getConfiguredVideoCodecs(e);
                        for (const e of n) this.isP2P && (e !== Ps.H264 && e !== Ps.VP9 || Ns.stripCodec(t, e, !0), e !== Ps.ULPFEC && e !== Ps.RED || Ns.stripCodec(t, e, !1));
                        for (const e of this.codecSettings.codecList.slice().reverse()) Ns.preferCodec(t, e, this.isP2P)
                    }
                    return new RTCSessionDescription({
                        type: e.type,
                        sdp: Is.write(t)
                    })
                }, rl.prototype._updateAv1DdHeaders = function(e) {
                    const t = Is.parse(e.sdp),
                        n = t.media.filter((e => e.type === Ri.VIDEO));
                    return n.length && ci.supportsDDExtHeaders() ? (n.forEach(((e, t) => {
                        var n;
                        const i = Array.from(this._localTrackTransceiverMids.values()),
                            r = i.length ? i.find((t => e.mid.toString() === t.toString())) : 0 === t,
                            o = e.payloads.split(" ")[0];
                        let {
                            codec: s
                        } = e.rtp.find((e => e.payload === Number(o)));
                        if (s = s.toLowerCase(), r && null !== (n = e.ext) && void 0 !== n && n.length) {
                            const t = e.ext.findIndex((e => e.uri === il)),
                                n = s === Ps.AV1 || s === Ps.H264;
                            !this._supportsDDHeaderExt && t >= 0 && (this._supportsDDHeaderExt = !0), this._supportsDDHeaderExt && n && t < 0 ? e.ext.push({
                                value: 11,
                                uri: il
                            }) : !n && t >= 0 && e.ext.splice(t, 1)
                        }
                    })), new RTCSessionDescription({
                        type: e.type,
                        sdp: Is.write(t)
                    })) : e
                }, rl.prototype.addTrack = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    const n = e.rtcId;
                    if (nl.info(`${this} adding ${e}`), this.localTracks.has(n)) return Promise.reject(new Error(`${e} is already in ${this}`));
                    this.localTracks.set(n, e);
                    const i = e.getOriginalStream();
                    try {
                        this.tpcUtils.addTrack(e, t), e && (e.isAudioTrack() ? this._hasHadAudioTrack = !0 : this._hasHadVideoTrack = !0)
                    } catch (t) {
                        return nl.error(`${this} Adding track=${e} failed: ${null==t?void 0:t.message}`), Promise.reject(t)
                    }
                    let r = Promise.resolve();
                    return ci.isFirefox() && (r = r.then((() => i && this.tpcUtils.setEncodings(e)))), r
                }, rl.prototype.addTrackToPc = function(e) {
                    return nl.info(`${this} Adding track=${e} to PC`), this._assertTrackBelongs("addTrackToPc", e) ? e.getOriginalStream() ? this.tpcUtils.replaceTrack(null, e).then((() => (e && (e.isAudioTrack() ? this._hasHadAudioTrack = !0 : this._hasHadVideoTrack = !0), !1))) : (nl.error(`${this} Unable to add track=${e} to PC - no WebRTC stream`), Promise.reject("Stream not found")) : Promise.reject("Track not found on the peerconnection")
                }, rl.prototype._assertTrackBelongs = function(e, t) {
                    const n = this.localTracks.has(null == t ? void 0 : t.rtcId);
                    return n || nl.error(`${this} ${e}: track=${t} does not belong to pc`), n
                }, rl.prototype.getConfiguredVideoCodec = function() {
                    var e;
                    const t = null === (e = this.peerconnection.remoteDescription) || void 0 === e ? void 0 : e.sdp,
                        n = Ps.VP8;
                    if (!t) return n;
                    const i = Is.parse(t).media.find((e => e.type === Ri.VIDEO)),
                        r = i.payloads.split(" ")[0],
                        {
                            codec: o
                        } = i.rtp.find((e => e.payload === Number(r)));
                    return o ? Object.values(Ps).find((e => e === o.toLowerCase())) : n
                }, rl.prototype.getConfiguredVideoCodecs = function(e) {
                    var t, n;
                    const i = null !== (t = null == e ? void 0 : e.sdp) && void 0 !== t ? t : null === (n = this.peerconnection.localDescription) || void 0 === n ? void 0 : n.sdp;
                    if (!i) return [];
                    const r = Is.parse(i).media.find((e => e.type === Ri.VIDEO)),
                        o = new Set(r.rtp.filter((e => "rtx" !== e.codec.toLowerCase())).map((e => e.codec.toLowerCase())));
                    return Array.from(o)
                }, rl.prototype.isVideoCodecDisabled = function(e) {
                    var t;
                    const n = null === (t = this.peerconnection.localDescription) || void 0 === t ? void 0 : t.sdp;
                    return !!n && !Is.parse(n).media.find((e => e.type === Ri.VIDEO)).rtp.find((t => t.codec === e))
                }, rl.prototype.setDesktopSharingFrameRate = function(e) {
                    const t = e <= 5;
                    this._capScreenshareBitrate = this.isSpatialScalabilityOn() && t
                }, rl.prototype.setVideoCodecs = function(e) {
                    this.codecSettings && null != e && e.length && (this.codecSettings.codecList = e)
                }, rl.prototype.isMediaStreamInPc = function(e) {
                    return this._addedStreams.indexOf(e) > -1
                }, rl.prototype.removeTrack = function(e) {
                    const t = e.getOriginalStream();
                    this.trace("removeStream", e.rtcId, t ? t.id : void 0), this._assertTrackBelongs("removeStream", e) && (this.localTracks.delete(e.rtcId), this.localSSRCs.delete(e.rtcId), t && this.peerconnection.removeStream(t))
                }, rl.prototype.findSenderByKind = function(e) {
                    if (this.peerconnection.getSenders) return this.peerconnection.getSenders().find((t => t.track && t.track.kind === e))
                }, rl.prototype.findReceiverForTrack = function(e) {
                    return this.peerconnection.getReceivers().find((t => t.track === e))
                }, rl.prototype.findSenderForTrack = function(e) {
                    if (this.peerconnection.getSenders) return this.peerconnection.getSenders().find((t => t.track === e))
                }, rl.prototype.processLocalSdpForTransceiverInfo = function(e) {
                    var t;
                    const n = null === (t = this.peerconnection.localDescription) || void 0 === t ? void 0 : t.sdp;
                    n && [Ri.AUDIO, Ri.VIDEO].forEach((t => {
                        const i = e.filter((e => e.getType() === t)),
                            r = Is.parse(n).media.filter((e => e.type === t));
                        i.forEach(((e, t) => {
                            this._localTrackTransceiverMids.has(e.rtcId) || this._localTrackTransceiverMids.set(e.rtcId, r[t].mid.toString())
                        }))
                    }))
                }, rl.prototype.replaceTrack = function(e, t) {
                    return e || t ? (nl.debug(`${this} TPC.replaceTrack old=${e}, new=${t}`), this.tpcUtils.replaceTrack(e, t).then((n => {
                        var i;
                        if (e && (this.localTracks.delete(e.rtcId), this._localTrackTransceiverMids.delete(e.rtcId)), t && (t.isAudioTrack() ? this._hasHadAudioTrack = !0 : this._hasHadVideoTrack = !0, this._localTrackTransceiverMids.set(t.rtcId, null == n || null === (i = n.mid) || void 0 === i ? void 0 : i.toString()), this.localTracks.set(t.rtcId, t)), e && t) {
                            const n = this.localSSRCs.get(e.rtcId);
                            n && (this.localSSRCs.delete(e.rtcId), this.localSSRCs.set(t.rtcId, n))
                        }
                        return n && (n.direction = t || ci.isFirefox() ? Rs.SENDRECV : Rs.RECVONLY), (ci.usesSdpMungingForSimulcast() || !t ? Promise.resolve() : this.tpcUtils.setEncodings(t)).then((() => this.isP2P))
                    }))) : (nl.info(`${this} replaceTrack called with no new track and no old track`), Promise.resolve())
                }, rl.prototype.removeTrackFromPc = function(e) {
                    const t = e.getOriginalStream();
                    return this.trace("removeTrack", e.rtcId, t ? t.id : null), this._assertTrackBelongs("removeTrack", e) ? this.tpcUtils.replaceTrack(e, null).then((() => !1)) : Promise.reject("Track not found in the peerconnection")
                }, rl.prototype.createDataChannel = function(e, t) {
                    return this.trace("createDataChannel", e, t), this.peerconnection.createDataChannel(e, t)
                }, rl.prototype._adjustRemoteMediaDirection = function(e) {
                    const t = new Mc(e.sdp);
                    return [Ri.AUDIO, Ri.VIDEO].forEach((e => {
                        const n = t.selectMedia(e),
                            i = this.getLocalTracks(e).length,
                            r = this.getRemoteTracks(null, e).length;
                        n.forEach(((e, t) => {
                            e.direction = i && i === r ? Rs.SENDRECV : i || r ? i ? r ? i > r ? t ? Rs.RECVONLY : Rs.SENDRECV : t ? Rs.SENDONLY : Rs.SENDRECV : Rs.RECVONLY : Rs.SENDONLY : Rs.INACTIVE
                        }))
                    })), new RTCSessionDescription({
                        type: e.type,
                        sdp: t.toRawSDP()
                    })
                }, rl.prototype._mungeOpus = function(e) {
                    const {
                        audioQuality: t
                    } = this.options;
                    if (!(null != t && t.enableOpusDtx || null != t && t.stereo || null != t && t.opusMaxAverageBitrate)) return e;
                    const n = Is.parse(e.sdp),
                        i = n.media;
                    for (const e of i)
                        if ("audio" === e.type) {
                            const {
                                payload: n
                            } = e.rtp.find((e => e.codec === Ps.OPUS));
                            if (!n) continue;
                            let i = e.fmtp.find((e => e.payload === n));
                            i || (i = {
                                payload: n,
                                config: ""
                            });
                            const r = Is.parseParams(i.config);
                            let o = !1;
                            if (null != t && t.stereo && (r.stereo = 1, o = !0), null != t && t.opusMaxAverageBitrate && (r.maxaveragebitrate = t.opusMaxAverageBitrate, o = !0), !ci.isFirefox() && null != t && t.enableOpusDtx && (r.usedtx = 1, o = !0), !o) continue;
                            let s = "";
                            for (const e of Object.keys(r)) s += `${e}=${r[e]}; `;
                            i.config = s.trim()
                        } return new RTCSessionDescription({
                        type: e.type,
                        sdp: Is.write(n)
                    })
                }, rl.prototype._mungeInactive = function(e) {
                    const t = Is.parse(e.sdp),
                        n = t.media;
                    for (const e of n) e.direction = Rs.INACTIVE, e.ssrcs = void 0, e.ssrcGroups = void 0;
                    return new RTCSessionDescription({
                        type: e.type,
                        sdp: Is.write(t)
                    })
                }, rl.prototype._initializeDtlsTransport = function() {
                    if (!this.peerconnection.getSenders || this._dtlsTransport) return;
                    const e = this.peerconnection.getSenders();
                    0 !== e.length && e[0].transport && (this._dtlsTransport = e[0].transport, this._dtlsTransport.onerror = e => {
                        nl.error(`${this} DtlsTransport error: ${e}`)
                    }, this._dtlsTransport.onstatechange = () => {
                        this.trace("dtlsTransport.onstatechange", this._dtlsTransport.state)
                    })
                }, rl.prototype._setMaxBitrates = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (!this.codecSettings) return e;
                    const n = Is.parse(e.sdp),
                        i = t ? Rs.RECVONLY : Rs.SENDONLY,
                        r = n.media.filter((e => e.type === Ri.VIDEO && e.direction !== i)),
                        o = this.codecSettings.codecList[0],
                        s = this.tpcUtils.codecSettings[o];
                    for (const e of r) {
                        const t = o === Ps.VP9 && !s.scalabilityModeEnabled,
                            n = this.getLocalVideoTracks().find((t => this._localTrackTransceiverMids.get(t.rtcId) === e.mid.toString()));
                        if ((t || this.tpcUtils._isRunningInFullSvcMode(o)) && n) {
                            let t;
                            if (n.getVideoType() === Yo.VideoType.DESKTOP) t = s.maxBitratesVideo.ssHigh;
                            else {
                                const {
                                    level: e
                                } = Ic.find((e => e.height <= n.getCaptureResolution()));
                                t = s.maxBitratesVideo[e]
                            }
                            const i = Math.floor(t / 1e3);
                            e.bandwidth = [{
                                type: "AS",
                                limit: i
                            }]
                        } else e.bandwidth = void 0
                    }
                    return new RTCSessionDescription({
                        type: e.type,
                        sdp: Is.write(n)
                    })
                }, rl.prototype.configureSenderVideoEncodings = function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                    if (!(this.isP2P || this.videoTransferActive && this.audioTransferActive)) return this.tpcUtils.setMediaTransferActive(!1);
                    if (e) return this.setSenderVideoConstraints(this._senderMaxHeights.get(e.getSourceName()), e);
                    const t = [];
                    for (const e of this.getLocalVideoTracks()) t.push(this.setSenderVideoConstraints(this._senderMaxHeights.get(e.getSourceName()), e));
                    return Promise.allSettled(t)
                }, rl.prototype.setLocalDescription = function(e) {
                    let t = e;
                    return this.trace("setLocalDescription::preTransform", ol(t)), t = this._mungeOpus(t), t = this._mungeCodecOrder(t), t = this._setMaxBitrates(t, !0), t = this._updateAv1DdHeaders(t), this.trace("setLocalDescription::postTransform", ol(t)), new Promise(((e, n) => {
                        this.peerconnection.setLocalDescription(t).then((() => {
                            this.trace("setLocalDescriptionOnSuccess");
                            const n = Ns.getUfrag(t.sdp);
                            n !== this.localUfrag && (this.localUfrag = n, this.eventEmitter.emit(ji.default.LOCAL_UFRAG_CHANGED, this, n)), this._initializeDtlsTransport(), e()
                        }), (e => {
                            this.trace("setLocalDescriptionOnFailure", e), this.eventEmitter.emit(ji.default.SET_LOCAL_DESCRIPTION_FAILED, e, this), n(e)
                        }))
                    }))
                }, rl.prototype.setRemoteDescription = function(e) {
                    let t = e;
                    if (this.trace("setRemoteDescription::preTransform", ol(e)), t = this._mungeOpus(t), !this.isP2P) {
                        const e = this.peerconnection.remoteDescription;
                        t = this.interop.toUnifiedPlan(t, e), this.trace("setRemoteDescription::postTransform (Unified)", ol(t))
                    }
                    return this.isSpatialScalabilityOn() && (t = this.tpcUtils.insertUnifiedPlanSimulcastReceive(t), this.trace("setRemoteDescription::postTransform (sim receive)", ol(t))), t = this.tpcUtils.ensureCorrectOrderOfSsrcs(t), this.trace("setRemoteDescription::postTransform (correct ssrc order)", ol(t)), t = this._mungeCodecOrder(t), t = this._setMaxBitrates(t), t = this._updateAv1DdHeaders(t), this.trace("setRemoteDescription::postTransform (munge codec order)", ol(t)), new Promise(((e, n) => {
                        this.peerconnection.setRemoteDescription(t).then((() => {
                            this.trace("setRemoteDescriptionOnSuccess");
                            const n = Ns.getUfrag(t.sdp);
                            n !== this.remoteUfrag && (this.remoteUfrag = n, this.eventEmitter.emit(ji.default.REMOTE_UFRAG_CHANGED, this, n)), this._initializeDtlsTransport(), e()
                        }), (e => {
                            this.trace("setRemoteDescriptionOnFailure", e), this.eventEmitter.emit(ji.default.SET_REMOTE_DESCRIPTION_FAILED, e, this), n(e)
                        }))
                    }))
                }, rl.prototype.setSenderVideoConstraints = function(e, t) {
                    if (e < 0 || isNaN(e)) throw new Error(`Invalid frameHeight: ${e}`);
                    if (!t) throw new Error("Local video track is missing");
                    const n = t.getSourceName();
                    return !this.isP2P && !this.videoTransferActive || t.isMuted() ? (this._senderMaxHeights.set(n, e), Promise.resolve()) : this._updateVideoSenderParameters((() => this._updateVideoSenderEncodings(e, t)))
                }, rl.prototype._updateVideoSenderParameters = function(e) {
                    const t = this._lastVideoSenderUpdatePromise.finally(e);
                    return this._lastVideoSenderUpdatePromise = t, t
                }, rl.prototype._updateVideoSenderEncodings = function(e, t) {
                    var n;
                    const i = this.findSenderForTrack(t.getTrack());
                    if (!i) return Promise.resolve();
                    const r = i.getParameters();
                    if (null == r || null === (n = r.encodings) || void 0 === n || !n.length) return Promise.resolve();
                    const o = t.getVideoType() === Yo.VideoType.DESKTOP && this._capScreenshareBitrate ? "maintain-resolution" : "maintain-framerate";
                    r.degradationPreference = o;
                    const s = this.getConfiguredVideoCodec(),
                        a = this.tpcUtils.calculateEncodingsBitrates(t, s, e),
                        d = this.tpcUtils.calculateEncodingsActiveState(t, s, e),
                        c = this.tpcUtils.calculateEncodingsScaleFactor(t, s, e),
                        l = this.tpcUtils.calculateEncodingsScalabilityMode(t, s, e);
                    let h = !1;
                    for (const e in r.encodings)
                        if (r.encodings.hasOwnProperty(e)) {
                            const {
                                active: t,
                                maxBitrate: n,
                                scalabilityMode: i,
                                scaleResolutionDownBy: u
                            } = r.encodings[e];
                            t !== d[e] && (r.encodings[e].active = d[e], h = !0), ci.isFirefox() && (r.encodings[e].degradationPreference = o), (s !== Ps.VP9 || !this.isSpatialScalabilityOn() || ci.supportsScalabilityModeAPI() && this.tpcUtils.codecSettings[s].scalabilityModeEnabled) && (u !== c[e] && (r.encodings[e].scaleResolutionDownBy = c[e], h = !0), n !== a[e] && (r.encodings[e].maxBitrate = a[e], h = !0)), l ? i !== l[e] && (r.encodings[e].scalabilityMode = l[e], h = !0) : r.encodings[e].scalabilityMode = void 0
                        } return h ? (nl.info(`${this} setting max height=${e},encodings=${JSON.stringify(r.encodings)}`), i.setParameters(r).then((() => {
                        this._senderMaxHeights.set(t.getSourceName(), e), t.maxEnabledResolution = e, this.eventEmitter.emit(ji.default.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, t)
                    }))) : Promise.resolve()
                }, rl.prototype.setVideoTransferActive = function(e) {
                    nl.debug(`${this} video transfer active: ${e}`);
                    const t = this.videoTransferActive !== e;
                    return this.videoTransferActive = e, t ? this.tpcUtils.setMediaTransferActive(e, Ri.VIDEO) : Promise.resolve()
                }, rl.prototype.sendTones = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 200,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 200;
                    if (!this._dtmfSender) {
                        if (this.peerconnection.getSenders) {
                            const e = this.peerconnection.getSenders().find((e => e.dtmf));
                            this._dtmfSender = e && e.dtmf, this._dtmfSender && nl.info(`${this} initialized DTMFSender using getSenders`)
                        }
                        if (!this._dtmfSender) {
                            const e = Array.from(this.localTracks.values()).find((e => e.isAudioTrack()));
                            this.peerconnection.createDTMFSender && e && (this._dtmfSender = this.peerconnection.createDTMFSender(e.getTrack())), this._dtmfSender && nl.info(`${this} initialized DTMFSender using deprecated createDTMFSender`)
                        }
                        this._dtmfSender && (this._dtmfSender.ontonechange = this._onToneChange.bind(this))
                    }
                    if (this._dtmfSender) {
                        if (this._dtmfSender.toneBuffer) return void this._dtmfTonesQueue.push({
                            tones: e,
                            duration: t,
                            interToneGap: n
                        });
                        this._dtmfSender.insertDTMF(e, t, n)
                    } else nl.warn(`${this} sendTones - failed to select DTMFSender`)
                }, rl.prototype._onToneChange = function(e) {
                    if (this._dtmfSender && "" === e.tone && this._dtmfTonesQueue.length) {
                        const {
                            tones: e,
                            duration: t,
                            interToneGap: n
                        } = this._dtmfTonesQueue.shift();
                        this._dtmfSender.insertDTMF(e, t, n)
                    }
                }, rl.prototype.close = function() {
                    this.trace("stop"), this.signalingLayer.off(_c, this._peerMutedChanged), this.signalingLayer.off(yc, this._peerVideoTypeChanged), this.peerconnection.removeEventListener("track", this.onTrack);
                    for (const e of this.remoteTracks.values())
                        for (const t of e.values())
                            for (const e of t) this._removeRemoteTrack(e);
                    this.remoteTracks.clear(), this._addedStreams = [], this._dtmfSender = null, this._dtmfTonesQueue = [], this.rtc._removePeerConnection(this) || nl.error(`${this} rtc._removePeerConnection returned false`), null !== this.statsinterval && (window.clearInterval(this.statsinterval), this.statsinterval = null), nl.info(`${this} Closing peerconnection`), this.peerconnection.close()
                }, rl.prototype.createAnswer = function(e) {
                    return this._createOfferOrAnswer(!1, e)
                }, rl.prototype.createOffer = function(e) {
                    return this._createOfferOrAnswer(!0, e)
                }, rl.prototype._createOfferOrAnswer = function(e, t) {
                    const n = e ? "Offer" : "Answer";
                    this.trace(`create${n}`, JSON.stringify(t, null, " "));
                    const i = (e, t, i) => {
                            try {
                                this.trace(`create${n}OnSuccess::preTransform`, ol(e)), this.isSpatialScalabilityOn() && ci.usesSdpMungingForSimulcast() && (e = this.simulcast.mungeLocalDescription(e), this.trace(`create${n} OnSuccess::postTransform (simulcast)`, ol(e))), !this.options.disableRtx && ci.usesSdpMungingForSimulcast() && (e = new RTCSessionDescription({
                                    type: e.type,
                                    sdp: this.rtxModifier.modifyRtxSsrcs(e.sdp)
                                }), this.trace(`create${n}OnSuccess::postTransform (rtx modifier)`, ol(e)));
                                const i = this._extractSSRCMap(e);
                                this._processLocalSSRCsMap(i), t(e)
                            } catch (t) {
                                this.trace(`create${n}OnError`, t), this.trace(`create${n}OnError`, ol(e)), nl.error(`${this} create${n}OnError`, t, ol(e)), i(t)
                            }
                        },
                        r = (t, i) => {
                            this.trace(`create${n}OnFailure`, t);
                            const r = e ? ji.default.CREATE_OFFER_FAILED : ji.default.CREATE_ANSWER_FAILED;
                            this.eventEmitter.emit(r, t, this), i(t)
                        };
                    if (ci.supportsCodecPreferences() && this.codecSettings) {
                        var o;
                        const {
                            codecList: e,
                            mediaType: t
                        } = this.codecSettings, n = this.peerconnection.getTransceivers().filter((e => {
                            var n, i;
                            return e.receiver && (null === (n = e.receiver) || void 0 === n || null === (i = n.track) || void 0 === i ? void 0 : i.kind) === t
                        }));
                        let i = null === (o = RTCRtpReceiver.getCapabilities(t)) || void 0 === o ? void 0 : o.codecs;
                        if (n.length && i) {
                            for (const n of e.slice().reverse()) i.sort((e => e.mimeType.toLowerCase() === `${t}/${n}` ? -1 : 1));
                            this.isP2P && t === Ri.VIDEO && (i = i.filter((e => e.mimeType.toLowerCase() !== `${Ri.VIDEO}/${Ps.ULPFEC}` && e.mimeType.toLowerCase() !== `${Ri.VIDEO}/${Ps.RED}`)));
                            for (const e of n) e.setCodecPreferences(i)
                        }
                    }
                    return new Promise(((n, o) => {
                        let s;
                        s = e ? this.peerconnection.createOffer(t) : this.peerconnection.createAnswer(t), s.then((e => i(e, n, o)), (e => r(e, o)))
                    }))
                }, rl.prototype._extractPrimarySSRC = function(e) {
                    return e && e.groups && e.groups.length ? e.groups[0].ssrcs[0] : e && e.ssrcs && e.ssrcs.length ? e.ssrcs[0] : null
                }, rl.prototype._processLocalSSRCsMap = function(e) {
                    for (const t of this.localTracks.values()) {
                        const n = xc(t.getSourceName()),
                            i = `${t.getType()}-${n}`;
                        if (e.has(i)) {
                            const n = e.get(i);
                            if (!n) return void nl.error(`${this} No SSRC found for stream=${i}`);
                            const r = this.localSSRCs.get(t.rtcId),
                                o = this._extractPrimarySSRC(n),
                                s = this._extractPrimarySSRC(r);
                            o !== s && (s && nl.error(`${this} Overwriting SSRC for track=${t}] with ssrc=${n}`), this.localSSRCs.set(t.rtcId, n), this.eventEmitter.emit(ji.default.LOCAL_TRACK_SSRC_UPDATED, t, o))
                        } else t.isVideoTrack() || t.isMuted() || nl.warn(`${this} No SSRCs found in the local SDP for track=${t}, stream=${i}`)
                    }
                }, rl.prototype.addRemoteSsrc = function(e) {
                    const t = this.remoteSSRCs.has(e);
                    return t || this.remoteSSRCs.add(e), !t
                }, rl.prototype.addIceCandidate = function(e) {
                    return this.trace("addIceCandidate", JSON.stringify({
                        candidate: e.candidate,
                        sdpMid: e.sdpMid,
                        sdpMLineIndex: e.sdpMLineIndex,
                        usernameFragment: e.usernameFragment
                    }, null, " ")), this.peerconnection.addIceCandidate(e)
                }, rl.prototype.getStats = function() {
                    return this.peerconnection.getStats()
                }, rl.prototype.toString = function() {
                    return `TPC[id=${this.id},type=${this.isP2P?"P2P":"JVB"}]`
                };
                const al = (0, E.getLogger)("modules/RTC/RTC.js");
                let dl, cl = 0,
                    ll = 0;

                function hl() {
                    return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).map((e => {
                        const {
                            constraints: t,
                            sourceId: n,
                            sourceType: i,
                            stream: r,
                            track: o,
                            videoType: s,
                            effects: a
                        } = e, {
                            deviceId: d,
                            facingMode: c
                        } = o.getSettings();
                        return ll = yi(ll), new sc({
                            constraints: t,
                            deviceId: d,
                            facingMode: c,
                            mediaType: o.kind,
                            rtcId: ll,
                            sourceId: n,
                            sourceType: i,
                            stream: r,
                            track: o,
                            videoType: s || null,
                            effects: a
                        })
                    }))
                }
                class ul extends Cr {
                    constructor(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        super(), this.conference = e, this.peerConnections = new Map, this.localTracks = [], this.options = t, this._channel = null, this._lastN = void 0, this._forwardedSources = null, this._forwardedSourcesChangeListener = this._onForwardedSourcesChanged.bind(this), this._onDeviceListChanged = this._onDeviceListChanged.bind(this), this._updateAudioOutputForAudioTracks = this._updateAudioOutputForAudioTracks.bind(this), tc.isDeviceChangeAvailable("output") && (tc.addListener(ji.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), tc.addListener(ji.default.DEVICE_LIST_CHANGED, this._onDeviceListChanged))
                    }
                    destroy() {
                        tc.removeListener(ji.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), tc.removeListener(ji.default.DEVICE_LIST_CHANGED, this._onDeviceListChanged), this._channelOpenListener && this.removeListener(ji.default.DATA_CHANNEL_OPEN, this._channelOpenListener)
                    }
                    static createLocalTracks(e) {
                        return hl(e)
                    }
                    static obtainAudioAndVideoPermissions(e) {
                        return tc.obtainAudioAndVideoPermissions(e).then((e => hl(e)))
                    }
                    initializeBridgeChannel(e, t) {
                        this._channel = new Fa(e, t, this.eventEmitter, this.conference), this._channelOpenListener = () => {
                            const e = (e, t, n) => {
                                al.error(`Cannot send ${t}(${JSON.stringify(n)}) endpoint message`, e)
                            };
                            if (this._receiverVideoConstraints) try {
                                this._channel.sendReceiverVideoConstraintsMessage(this._receiverVideoConstraints)
                            } catch (t) {
                                e(t, "ReceiverVideoConstraints", this._receiverVideoConstraints)
                            }
                            if (void 0 !== this._lastN && -1 !== this._lastN) try {
                                this._channel.sendSetLastNMessage(this._lastN)
                            } catch (t) {
                                e(t, "LastNChangedEvent", this._lastN)
                            }
                        }, this.addListener(ji.default.DATA_CHANNEL_OPEN, this._channelOpenListener), this.addListener(ji.default.FORWARDED_SOURCES_CHANGED, this._forwardedSourcesChangeListener)
                    }
                    _onDeviceListChanged() {
                        this._updateAudioOutputForAudioTracks(tc.getAudioOutputDevice())
                    }
                    _onForwardedSourcesChanged() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        const t = this._forwardedSources || [];
                        let n = [],
                            i = [];
                        const r = Date.now();
                        this._forwardedSources = e, n = t.filter((e => !this.isInForwardedSources(e))), i = e.filter((e => -1 === t.indexOf(e))), al.debug(`Fowarded sources changed leaving=${n}, entering=${i} at ${r}`), this.conference.eventEmitter.emit(Re, n, i, r)
                    }
                    onCallEnded() {
                        this._channel && (this._channel && "websocket" === this._channel.mode && this._channel.close(), this._channel = null)
                    }
                    setDesktopSharingFrameRate(e) {
                        tc.setDesktopSharingFrameRate(e)
                    }
                    setReceiverVideoConstraints(e) {
                        this._receiverVideoConstraints = e, this._channel && this._channel.isOpen() && this._channel.sendReceiverVideoConstraintsMessage(e)
                    }
                    sendSourceVideoType(e, t) {
                        this._channel && this._channel.isOpen() && this._channel.sendSourceVideoTypeMessage(e, t)
                    }
                    static addListener(e, t) {
                        tc.addListener(e, t)
                    }
                    static removeListener(e, t) {
                        tc.removeListener(e, t)
                    }
                    static init() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        return this.options = e, tc.init(this.options)
                    }
                    createPeerConnection(e, t, n, i) {
                        const r = Es()(tc.pcConstraints);
                        i.enableInsertableStreams && (al.debug("E2EE - setting insertable streams constraints"), t.encodedInsertableStreams = !0), i.forceTurnRelay && (t.iceTransportPolicy = "relay"), t.bundlePolicy = "max-bundle", cl = yi(cl);
                        const o = new rl(this, cl, e, t, r, n, i);
                        return this.peerConnections.set(o.id, o), o
                    }
                    _removePeerConnection(e) {
                        const t = e.id;
                        return !!this.peerConnections.has(t) && (this.peerConnections.delete(t), !0)
                    }
                    addLocalTrack(e) {
                        if (!e) throw new Error("track must not be null nor undefined");
                        this.localTracks.push(e), e.conference = this.conference
                    }
                    getForwardedSources() {
                        return this._forwardedSources
                    }
                    getLocalVideoTrack() {
                        const e = this.getLocalTracks(Ri.VIDEO);
                        return e.length ? e[0] : void 0
                    }
                    getLocalVideoTracks() {
                        return this.getLocalTracks(Ri.VIDEO)
                    }
                    getLocalAudioTrack() {
                        const e = this.getLocalTracks(Ri.AUDIO);
                        return e.length ? e[0] : void 0
                    }
                    getLocalEndpointId() {
                        return this.conference.myUserId()
                    }
                    getLocalTracks(e) {
                        let t = this.localTracks.slice();
                        return void 0 !== e && (t = t.filter((t => t.getType() === e))), t
                    }
                    getRemoteTracks(e) {
                        let t = [];
                        for (const n of this.peerConnections.values()) {
                            const i = n.getRemoteTracks(void 0, e);
                            i && (t = t.concat(i))
                        }
                        return t
                    }
                    setAudioMute(e) {
                        const t = [];
                        return this.getLocalTracks(Ri.AUDIO).forEach((n => {
                            t.push(e ? n.mute() : n.unmute())
                        })), Promise.all(t)
                    }
                    setVideoMute(e) {
                        const t = [];
                        return this.getLocalTracks(Ri.VIDEO).forEach((n => {
                            t.push(e ? n.mute() : n.unmute())
                        })), Promise.all(t)
                    }
                    removeLocalTrack(e) {
                        const t = this.localTracks.indexOf(e); - 1 !== t && this.localTracks.splice(t, 1)
                    }
                    static attachMediaStream(e, t) {
                        return tc.attachMediaStream(e, t)
                    }
                    static isDeviceListAvailable() {
                        return tc.isDeviceListAvailable()
                    }
                    static isDeviceChangeAvailable(e) {
                        return tc.isDeviceChangeAvailable(e)
                    }
                    static isWebRtcSupported() {
                        return ci.isSupported()
                    }
                    static getAudioOutputDevice() {
                        return tc.getAudioOutputDevice()
                    }
                    static getCurrentlyAvailableMediaDevices() {
                        return tc.getCurrentlyAvailableMediaDevices()
                    }
                    static arePermissionsGrantedForAvailableDevices() {
                        return tc.arePermissionsGrantedForAvailableDevices()
                    }
                    static getEventDataForActiveDevice(e) {
                        return tc.getEventDataForActiveDevice(e)
                    }
                    static setAudioOutputDevice(e) {
                        return tc.setAudioOutputDevice(e)
                    }
                    static enumerateDevices(e) {
                        tc.enumerateDevices(e)
                    }
                    static stopMediaStream(e) {
                        tc.stopMediaStream(e)
                    }
                    static isDesktopSharingEnabled() {
                        return tc.isDesktopSharingEnabled()
                    }
                    closeBridgeChannel() {
                        this._channel && (this._channel.close(), this._channel = null)
                    }
                    setAudioLevel(e, t, n, i) {
                        const r = e.getTrackBySSRC(t);
                        r && (r.isAudioTrack() ? (r.isLocal() !== i && al.error(`${r} was expected to ${i?"be":"not be"} local`), r.setAudioLevel(n, e)) : al.warn(`Received audio level for non-audio track: ${t}`))
                    }
                    sendChannelMessage(e, t) {
                        if (!this._channel) throw new Error("Channel support is disabled!");
                        this._channel.sendMessage(e, t)
                    }
                    sendEndpointStatsMessage(e) {
                        this._channel && this._channel.isOpen() && this._channel.sendEndpointStatsMessage(e)
                    }
                    setLastN(e) {
                        this._lastN !== e && (this._lastN = e, this._channel && this._channel.isOpen() && this._channel.sendSetLastNMessage(e), this.eventEmitter.emit(ji.default.LASTN_VALUE_CHANGED, e))
                    }
                    isInForwardedSources(e) {
                        return !this._forwardedSources || this._forwardedSources.indexOf(e) > -1
                    }
                    _updateAudioOutputForAudioTracks(e) {
                        const t = this.getRemoteTracks(Ri.AUDIO);
                        for (const n of t) n.setAudioOutput(e)
                    }
                }! function(e) {
                    e.LOCAL_STATS_UPDATED = "cq.local_stats_updated", e.REMOTE_STATS_UPDATED = "cq.remote_stats_updated"
                }(dl || (dl = {}));
                const pl = dl.LOCAL_STATS_UPDATED,
                    ml = dl.REMOTE_STATS_UPDATED,
                    gl = n(125),
                    {
                        VideoType: fl
                    } = n(408),
                    {
                        XMPPEvents: vl
                    } = n(609),
                    _l = (0, E.getLogger)("modules/connectivity/ConnectionQuality.js");
                let yl = 800;
                class El {
                    constructor(e, t, n) {
                        var i;
                        this.eventEmitter = t, this._conference = e, this._localStats = {
                            connectionQuality: 100,
                            jvbRTT: void 0
                        }, this._lastConnectionQualityUpdate = -1, this._options = n, this._remoteStats = {}, this._timeIceConnected = -1, this._timeVideoUnmuted = -1, (null === (i = this._options.config) || void 0 === i ? void 0 : i.startBitrate) > 0 && (yl = this._options.config.startBitrate), e.on(me, (() => {
                            this._updateLocalConnectionQuality(0), this.eventEmitter.emit(pl, this._localStats), this._broadcastLocalStats()
                        })), e.room.addListener(vl.ICE_CONNECTION_STATE_CHANGED, ((e, t) => {
                            e.isP2P || "connected" !== t || (this._timeIceConnected = window.performance.now())
                        })), e.on(Ce, ((e, t) => {
                            "stats" === t.type && this._updateRemoteStats(e.getId(), t.values)
                        })), e.on(xe, ((e, t) => {
                            this._updateRemoteStats(e.getId(), t)
                        })), this._options.config.disableLocalStats || e.statistics.addConnectionStatsListener(this._updateLocalStats.bind(this)), e.on(it, (e => {
                            e.isVideoTrack() && (e.isMuted() ? this._timeVideoUnmuted = -1 : this._maybeUpdateUnmuteTime())
                        })), e.on(tt, (e => {
                            e.isVideoTrack() && !e.isMuted() && this._maybeUpdateUnmuteTime()
                        })), e.rtc.on(ji.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, (e => {
                            this._localStats.maxEnabledResolution = e.maxEnabledResolution
                        })), e.on(We, (e => {
                            this._localStats.serverRegion = e
                        })), e.on(ze, (e => {
                            this._localStats.bridgeCount = Number((e || {})["bridge-count"])
                        }))
                    }
                    _maybeUpdateUnmuteTime() {
                        this._timeVideoUnmuted < 0 && (this._timeVideoUnmuted = window.performance.now())
                    }
                    _calculateConnectionQuality(e, t, n) {
                        const i = gl[n];
                        let r, o = 100;
                        if (this._localStats.packetLoss && (r = this._localStats.packetLoss.upload, t && (r *= .5)), t || !i || e === fl.DESKTOP || this._timeIceConnected < 0 || this._timeVideoUnmuted < 0) void 0 === r ? (_l.error("Cannot calculate connection quality, unknown packet loss."), o = 100) : o = r <= 2 ? 100 : r <= 4 ? 70 : r <= 6 ? 50 : r <= 8 ? 30 : r <= 12 ? 10 : 0;
                        else {
                            const e = this._conference.getActivePeerConnection();
                            if (e) {
                                var s, a;
                                const t = window.performance.now() - Math.max(this._timeVideoUnmuted, this._timeIceConnected),
                                    n = null !== (s = null === (a = this._options.config) || void 0 === a ? void 0 : a.pcStatsInterval) && void 0 !== s ? s : 1e4;
                                let r = function(e, t, n, i) {
                                    let r = 0,
                                        o = Math.min(t.height, t.width),
                                        s = Ic.find((e => e.height <= o));
                                    if (s && e)
                                        for (o = s.height; o >= 180; o /= 2) {
                                            const e = o;
                                            if (s = Ic.find((t => t.height === e)), !s) break;
                                            r += i[s.level]
                                        } else s && (r = i[s.level]);
                                    return Math.min(r / 1e3, function(e) {
                                        return e > 6e4 ? Number.MAX_SAFE_INTEGER : yl * Math.pow(1.08, e / 1e3)
                                    }(Math.max(0, n - 1e3)))
                                }(e.doesTrueSimulcast(), i, t, e.getTargetVideoBitrates());
                                r = Math.min(r, 2500), t > n && (o = 100 * this._localStats.bitrate.upload / r)
                            }
                            r && r >= 10 && (o = Math.min(o, 30))
                        }
                        if (this._lastConnectionQualityUpdate > 0) {
                            const e = 2,
                                t = this._localStats.connectionQuality,
                                n = (window.performance.now() - this._lastConnectionQualityUpdate) / 1e3;
                            o = Math.min(o, t + n * e)
                        }
                        return Math.min(100, o)
                    }
                    _updateLocalConnectionQuality(e) {
                        this._localStats.connectionQuality = e, this._lastConnectionQualityUpdate = window.performance.now()
                    }
                    _broadcastLocalStats() {
                        const e = {
                            bitrate: this._localStats.bitrate,
                            packetLoss: this._localStats.packetLoss,
                            connectionQuality: this._localStats.connectionQuality,
                            jvbRTT: this._localStats.jvbRTT,
                            serverRegion: this._localStats.serverRegion,
                            maxEnabledResolution: this._localStats.maxEnabledResolution,
                            avgAudioLevels: this._localStats.localAvgAudioLevels
                        };
                        try {
                            this._conference.sendEndpointStatsMessage(e)
                        } catch (e) {}
                    }
                    _updateLocalStats(e, t) {
                        if (!e.isP2P) {
                            const e = t.transport && t.transport.length && t.transport[0].rtt;
                            this._localStats.jvbRTT = e || void 0
                        }
                        if (e !== this._conference.getActivePeerConnection()) return;
                        let n;
                        const i = !this._conference.isConnectionInterrupted(),
                            r = this._conference.getLocalVideoTrack(),
                            o = r ? r.videoType : void 0,
                            s = !r || r.isMuted(),
                            a = r ? Math.min(r.resolution, r.maxEnabledResolution) : null;
                        for (n in s || this._maybeUpdateUnmuteTime(), t) t.hasOwnProperty(n) && (this._localStats[n] = t[n]);
                        i && this._updateLocalConnectionQuality(this._calculateConnectionQuality(o, s, a)), this.eventEmitter.emit(pl, this._localStats), this._broadcastLocalStats()
                    }
                    _updateRemoteStats(e, t) {
                        this._remoteStats[e] = {
                            bitrate: t.bitrate,
                            packetLoss: t.packetLoss,
                            connectionQuality: t.connectionQuality,
                            jvbRTT: t.jvbRTT,
                            serverRegion: t.serverRegion,
                            maxEnabledResolution: t.maxEnabledResolution,
                            avgAudioLevels: t.avgAudioLevels
                        }, this.eventEmitter.emit(ml, e, this._remoteStats[e])
                    }
                    getStats() {
                        return this._localStats
                    }
                }
                const Sl = (0, E.getLogger)("modules/connectivity/IceFailedHandling.js");
                class bl {
                    constructor(e) {
                        this._conference = e
                    }
                    _actOnIceFailed() {
                        if (!this._conference.room) return;
                        const {
                            enableForcedReload: e,
                            enableIceRestart: t
                        } = this._conference.options.config, n = void 0 !== t && !t, i = this._conference.room.supportsRestartByTerminate(), r = i && !t;
                        if (Sl.info(`ICE failed, enableForcedReload: ${e}, enableIceRestart: ${t}, supports restart by terminate: ${i}`), n || !t && !i || e) {
                            Sl.info("ICE failed, but ICE restarts are disabled");
                            const t = e ? I : F;
                            return void this._conference.eventEmitter.emit(ae, t)
                        }
                        const o = this._conference.jvbJingleSession,
                            s = o && o.getIceConnectionState();
                        o ? "connected" === s ? Sl.info("ICE connection restored - not sending ICE failed") : (Sl.info(`Sending ICE failed - the connection did not recover, ICE state: ${s}, use 'session-terminate': ${r}`), r ? this._conference._stopJvbSession({
                            reason: "connectivity-error",
                            reasonDescription: "ICE FAILED",
                            requestRestart: !0,
                            sendSessionTerminate: !0
                        }) : this._conference.jvbJingleSession.sendIceFailedNotification()) : Sl.warn("Not sending ICE failed - no JVB connection")
                    }
                    start() {
                        this._conference.xmpp.ping(65e3).then((() => {
                            this._canceled || (this._iceFailedTimeout = window.setTimeout((() => {
                                this._iceFailedTimeout = void 0, this._actOnIceFailed()
                            }), 2e3))
                        }), (e => {
                            Sl.error("PING error/timeout - not sending ICE failed", e)
                        }))
                    }
                    cancel() {
                        this._canceled = !0, window.clearTimeout(this._iceFailedTimeout)
                    }
                }
                let Tl;
                ! function(e) {
                    e.DETECTOR_STATE_CHANGE = "detector_state_change", e.AUDIO_INPUT_STATE_CHANGE = "audio_input_state_changed", e.NO_AUDIO_INPUT = "no_audio_input_detected", e.VAD_NOISY_DEVICE = "detection.vad_noise_device", e.VAD_REPORT_PUBLISHED = "vad-report-published", e.VAD_SCORE_PUBLISHED = "detection.vad_score_published", e.VAD_TALK_WHILE_MUTED = "detection.vad_talk_while_muted"
                }(Tl || (Tl = {}));
                const Cl = Tl.DETECTOR_STATE_CHANGE,
                    xl = Tl.AUDIO_INPUT_STATE_CHANGE,
                    Rl = Tl.NO_AUDIO_INPUT,
                    Al = Tl.VAD_NOISY_DEVICE,
                    wl = Tl.VAD_REPORT_PUBLISHED,
                    Il = Tl.VAD_SCORE_PUBLISHED,
                    Pl = Tl.VAD_TALK_WHILE_MUTED;
                class Dl extends ii {
                    constructor(e) {
                        super(), this._conference = e, this._timeoutTrigger = null, this._hasAudioInput = null, e.on(tt, this._trackAdded.bind(this))
                    }
                    _clearTriggerTimeout() {
                        clearTimeout(this._timeoutTrigger), this._timeoutTrigger = null
                    }
                    _handleAudioInputStateChange(e) {
                        const t = 0 !== e;
                        null !== this._hasAudioInput && this._hasAudioInput === t || (this._hasAudioInput = t, this.emit(xl, this._hasAudioInput))
                    }
                    _handleNoAudioInputDetection(e) {
                        this._eventFired || (0 !== e || this._timeoutTrigger ? 0 !== e && this._timeoutTrigger && this._clearTriggerTimeout() : this._timeoutTrigger = setTimeout((() => {
                            this._eventFired = !0, this.emit(Rl)
                        }), 4e3))
                    }
                    _audioLevel(e, t, n, i) {
                        if (!i || !this._audioTrack) return;
                        const r = e.localSSRCs.get(this._audioTrack.rtcId);
                        r && r.ssrcs.includes(t) && (this._handleAudioInputStateChange(n), this._handleNoAudioInputDetection(n))
                    }
                    _trackAdded(e) {
                        e.isLocalAudioTrack() && (this._audioTrack = e, this._eventFired = !1, this._clearTriggerTimeout(), e.on(It, (e => {
                            this._handleNoAudioInputDetection(e)
                        })), e.on(Ct, (e => {
                            this._handleNoAudioInputDetection(e), this._handleAudioInputStateChange(e)
                        })))
                    }
                }
                class Ol {
                    constructor(e) {
                        this.conference = e, e.addEventListener(nt, this._audioLevel.bind(this)), this.myUserID = this.conference.myUserId()
                    }
                    _audioLevel(e, t) {
                        !this.conference.isP2PActive() || t <= .6 || e === this.myUserID && this.conference.getLocalAudioTrack().isMuted() || this.conference.rtc.eventEmitter.emit(ji.default.DOMINANT_SPEAKER_CHANGED, e)
                    }
                }

                function Nl(e) {
                    const t = window.AudioContext || window.webkitAudioContext;
                    if (t) return new t(e)
                }
                class kl extends ii {
                    constructor(e, t, n) {
                        super(), this._procNodeSampleRate = e, this._vadProcessor = t, this._localTrack = n, this._bufferResidue = new Float32Array([]), this._audioContext = Nl({
                            sampleRate: t.getRequiredPCMFrequency()
                        }), this._vadSampleSize = t.getSampleLength(), this._onAudioProcess = this._onAudioProcess.bind(this), this._initializeAudioContext()
                    }
                    static create(e, t, n) {
                        return ul.obtainAudioAndVideoPermissions({
                            devices: ["audio"],
                            micDeviceId: e
                        }).then((i => {
                            if (!i[0]) throw new Error(`Failed to create jitsi local track for device id: ${e}`);
                            return new kl(t, n, i[0])
                        }))
                    }
                    _initializeAudioContext() {
                        this._audioSource = this._audioContext.createMediaStreamSource(this._localTrack.stream), this._audioProcessingNode = this._audioContext.createScriptProcessor(this._procNodeSampleRate, 1, 1)
                    }
                    _onAudioProcess(e) {
                        const t = e.inputBuffer.getChannelData(0),
                            n = [...this._bufferResidue, ...t],
                            i = Date.now();
                        let r = 0;
                        for (; r + this._vadSampleSize < n.length; r += this._vadSampleSize) {
                            const e = n.slice(r, r + this._vadSampleSize),
                                t = this._vadProcessor.calculateAudioFrameVAD(e.slice());
                            this.emit(Il, {
                                timestamp: i,
                                score: t,
                                pcmData: e,
                                deviceId: this._localTrack.getDeviceId()
                            })
                        }
                        this._bufferResidue = n.slice(r, n.length)
                    }
                    _connectAudioGraph() {
                        this._audioProcessingNode.onaudioprocess = this._onAudioProcess, this._audioSource.connect(this._audioProcessingNode), this._audioProcessingNode.connect(this._audioContext.destination)
                    }
                    _disconnectAudioGraph() {
                        this._audioProcessingNode.onaudioprocess = () => {}, this._audioProcessingNode.disconnect(), this._audioSource.disconnect()
                    }
                    _cleanupResources() {
                        this._disconnectAudioGraph(), this._localTrack.stopStream()
                    }
                    getDeviceId() {
                        return this._localTrack.getDeviceId()
                    }
                    getTrackLabel() {
                        return this._localTrack.getDeviceLabel()
                    }
                    start() {
                        this._connectAudioGraph()
                    }
                    stop() {
                        this._disconnectAudioGraph(), this._bufferResidue = []
                    }
                    destroy() {
                        this._destroyed || (this._cleanupResources(), this._destroyed = !0)
                    }
                }
                const Ml = (0, E.getLogger)("modules/detection/VADAudioAnalyser.js");
                class Ll extends ii {
                    constructor(e, t) {
                        super(), this._createVADProcessor = t, this._vadEmitter = null, this._isVADEmitterRunning = !1, this._detectionServices = [], this._vadInitTracker = Promise.resolve(), this._processVADScore = this._processVADScore.bind(this), e.on(tt, this._trackAdded.bind(this)), e.on(rt, this._trackRemoved.bind(this)), e.on(it, this._trackMuteChanged.bind(this))
                    }
                    addVADDetectionService(e) {
                        this._detectionServices.push(e), e.on(Cl, (() => {
                            !this._detectionServices.filter((e => !0 === e.isActive())).length && this._isVADEmitterRunning ? this._stopVADEmitter() : this._isVADEmitterRunning || this._startVADEmitter()
                        }))
                    }
                    _startVADEmitter() {
                        this._vadEmitter && (this._vadEmitter.on(Il, this._processVADScore), this._vadEmitter.start(), this._isVADEmitterRunning = !0)
                    }
                    _stopVADEmitter() {
                        this._vadEmitter && (this._vadEmitter.removeListener(Il, this._processVADScore), this._vadEmitter.stop()), this._isVADEmitterRunning = !1
                    }
                    _processVADScore(e) {
                        for (const t of this._detectionServices) t.processVADScore(e)
                    }
                    _changeDetectorsMuteState(e) {
                        for (const t of this._detectionServices) t.changeMuteState(e)
                    }
                    _trackAdded(e) {
                        e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => this._createVADProcessor())).then((t => kl.create(e.getDeviceId(), 4096, t))).then((t => {
                            Ml.debug("Created VAD emitter for track: ", e.getTrackLabel()), this._vadEmitter = t, this._changeDetectorsMuteState(e.isMuted())
                        })).catch((e => {
                            Ml.warn("Failed to start VADAudioAnalyser", e)
                        })))
                    }
                    _trackMuteChanged(e) {
                        e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => {
                            this._changeDetectorsMuteState(e.isMuted())
                        })))
                    }
                    _trackRemoved(e) {
                        e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => {
                            Ml.debug("Removing track from VAD detection - ", e.getTrackLabel()), this._vadEmitter && (this._stopVADEmitter(), this._vadEmitter.destroy(), this._vadEmitter = null);
                            for (const e of this._detectionServices) e.reset()
                        })))
                    }
                }
                class Fl extends ii {
                    constructor() {
                        super(), this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], this._active = !1, this._calculateNoisyScore = this._calculateNoisyScore.bind(this)
                    }
                    _calculateNoisyScore() {
                        const e = Ei(this._scoreArray),
                            t = Ei(this._audioLvlArray);
                        e < .2 && t > .04 && (this.emit(Al), this._setActiveState(!1)), this.reset()
                    }
                    _recordValues(e, t) {
                        this._scoreArray.push(e), this._audioLvlArray.push(t)
                    }
                    _setActiveState(e) {
                        this._active = e, this.emit(Cl, this._active)
                    }
                    changeMuteState(e) {
                        this._setActiveState(!e), this.reset()
                    }
                    isActive() {
                        return this._active
                    }
                    reset() {
                        this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], clearTimeout(this._processTimeout)
                    }
                    processVADScore(e) {
                        if (this._active)
                            if (this._processing) {
                                const t = Si(e.pcmData);
                                this._recordValues(e.score, Ei(t))
                            } else if (e.score < .2) {
                            const t = Ei(Si(e.pcmData));
                            t > .02 && (this._processing = !0, this._recordValues(e.score, t), this._processTimeout = setTimeout(this._calculateNoisyScore, 1500))
                        }
                    }
                }
                class jl extends ii {
                    constructor() {
                        super(), this._processing = !1, this._scoreArray = [], this._active = !1, this._calculateVADScore = this._calculateVADScore.bind(this)
                    }
                    _calculateVADScore() {
                        Ei(this._scoreArray) > .6 && (this.emit(Pl), this._setActiveState(!1)), this.reset()
                    }
                    _setActiveState(e) {
                        this._active = e, this.emit(Cl, this._active)
                    }
                    changeMuteState(e) {
                        this._setActiveState(e), this.reset()
                    }
                    isActive() {
                        return this._active
                    }
                    processVADScore(e) {
                        this._active && (this._processing ? this._scoreArray.push(e.score) : e.score > .9 && (this._processing = !0, this._scoreArray.push(e.score), this._processTimeout = setTimeout(this._calculateVADScore, 700)))
                    }
                    reset() {
                        this._processing = !1, this._scoreArray = [], clearTimeout(this._processTimeout)
                    }
                }
                let Vl;
                ! function(e) {
                    e.E2E_RTT_CHANGED = "e2eping.e2e_rtt_changed"
                }(Vl || (Vl = {}));
                const Ul = Vl.E2E_RTT_CHANGED,
                    Hl = (0, E.getLogger)("modules/e2eping/e2eping.js"),
                    $l = "e2e-ping-request",
                    Jl = "e2e-ping-response";
                class Bl {
                    constructor(e, t) {
                        this.participant = e, this.e2eping = t, this.id = e.getId(), this.requests = {}, this.lastRequestId = 1, this.sendRequest = this.sendRequest.bind(this), this.handleResponse = this.handleResponse.bind(this), this.maybeLogRttAndStop = this.maybeLogRttAndStop.bind(this), this.scheduleNext = this.scheduleNext.bind(this), this.stop = this.stop.bind(this), this.getDelay = this.getDelay.bind(this), this.timeout = this.scheduleNext()
                    }
                    scheduleNext() {
                        return window.setTimeout(this.sendRequest, this.getDelay())
                    }
                    stop() {
                        this.timeout && window.clearTimeout(this.timeout), this.e2eping.removeParticipant(this.id)
                    }
                    getDelay() {
                        const e = this.e2eping.conference.getParticipants().length,
                            t = e * (e - 1) / 2 * this.e2eping.numRequests / this.e2eping.maxMessagesPerSecond;
                        return (1.5 - Math.random()) * Math.max(t / this.e2eping.numRequests * 1e3, 1e3)
                    }
                    sendRequest() {
                        const e = this.lastRequestId++,
                            t = {
                                type: $l,
                                id: e
                            };
                        this.e2eping.sendMessage(t, this.id), this.requests[e] = {
                            id: e,
                            timeSent: window.performance.now()
                        }
                    }
                    handleResponse(e) {
                        const t = this.requests[e.id];
                        t && (t.rtt = window.performance.now() - t.timeSent), this.maybeLogRttAndStop()
                    }
                    maybeLogRttAndStop() {
                        let e, t, n = 1 / 0,
                            i = 0,
                            r = 0;
                        for (t in this.requests) this.requests.hasOwnProperty(t) && (e = this.requests[t], r++, e.rtt && (i++, n = Math.min(n, e.rtt)));
                        return i >= this.e2eping.numRequests ? (Hl.info(`Measured RTT=${n} ms to ${this.id} (in ${this.participant.getProperty("region")})`), this.stop(), void this.e2eping.conference.eventEmitter.emit(Ul, this.participant, n)) : r > 2 * this.e2eping.numRequests ? (Hl.info(`Stopping e2eping for ${this.id} because we sent ${r} with only ${i} responses.`), void this.stop()) : void(this.timeout = this.scheduleNext())
                    }
                }
                class ql {
                    constructor(e, t, n) {
                        this.conference = e, this.eventEmitter = e.eventEmitter, this.sendMessage = n, this.participants = {}, this.numRequests = 5, this.maxConferenceSize = 200, this.maxMessagesPerSecond = 250, t && t.e2eping && ("number" == typeof t.e2eping.numRequests && (this.numRequests = t.e2eping.numRequests), "number" == typeof t.e2eping.maxConferenceSize && (this.maxConferenceSize = t.e2eping.maxConferenceSize), "number" == typeof t.e2eping.maxMessagesPerSecond && (this.maxMessagesPerSecond = t.e2eping.maxMessagesPerSecond)), Hl.info(`Initializing e2e ping with numRequests=${this.numRequests}, maxConferenceSize=${this.maxConferenceSize}, maxMessagesPerSecond=${this.maxMessagesPerSecond}.`), this.participantJoined = this.participantJoined.bind(this), this.participantLeft = this.participantLeft.bind(this), e.on(dt, this.participantLeft), this.messageReceived = this.messageReceived.bind(this), e.on(Ce, this.messageReceived), this.conferenceJoined = this.conferenceJoined.bind(this), e.on(ce, this.conferenceJoined)
                    }
                    conferenceJoined() {
                        this.conference.getParticipants().forEach((e => this.participantJoined(e.getId(), e))), this.conference.on(at, this.participantJoined)
                    }
                    messageReceived(e, t) {
                        t.type === $l ? this.handleRequest(e.getId(), t) : t.type === Jl && this.handleResponse(e.getId(), t)
                    }
                    participantJoined(e, t) {
                        this.participants[e] && (Hl.info(`Participant wrapper already exists for ${e}. Clearing.`), this.participants[e].stop()), this.conference.getParticipants().length > this.maxConferenceSize || this.conference.myUserId() > e && (Hl.info(`Starting e2eping for participant ${e}`), this.participants[e] = new Bl(t, this))
                    }
                    removeParticipant(e) {
                        this.participants[e] && delete this.participants[e]
                    }
                    participantLeft(e) {
                        this.participants[e] && (this.participants[e].stop(), delete this.participants[e])
                    }
                    handleRequest(e, t) {
                        if (t && t.id) {
                            const n = {
                                type: Jl,
                                id: t.id
                            };
                            this.sendMessage(n, e)
                        } else Hl.info(`Received an invalid e2e ping request from ${e}.`)
                    }
                    handleResponse(e, t) {
                        const n = this.participants[e];
                        n && n.handleResponse(t)
                    }
                    stop() {
                        Hl.info("Stopping e2eping"), this.conference.off(at, this.participantJoined), this.conference.off(dt, this.participantLeft), this.conference.off(Ce, this.messageReceived);
                        for (const e in this.participants) this.participants.hasOwnProperty(e) && this.participants[e].stop();
                        this.participants = {}
                    }
                }
                const Gl = (0, E.getLogger)("modules/event/Jvb121EventGenerator.js");
                class zl {
                    constructor(e) {
                        this._conference = e, this._jvb121 = !0, this._conference.addEventListener(at, (() => this.evaluateStatus())), this._conference.addEventListener(dt, (() => this.evaluateStatus())), this._conference.addEventListener(Ue, (() => this.evaluateStatus()))
                    }
                    evaluateStatus() {
                        const e = this._jvb121,
                            t = !this._conference.isP2PActive() && this._conference.getParticipantCount() <= 2;
                        e !== t && (this._jvb121 = t, Gl.debug(`JVB121 status ${e} => ${t}`), this._conference.eventEmitter.emit(Ae, e, t))
                    }
                }
                const Kl = Symbol("kJitsiLiteMode"),
                    Wl = (0, E.getLogger)("modules/litemode/LiteModeContext.js");
                class Xl {
                    constructor(e) {
                        this.enabled = Ai.isRunInLiteModeEnabled(), this.enabled && e.rtc.on(ji.default.REMOTE_TRACK_ADDED, ((e, t) => this._setupLiteModeForTrack(t, e)))
                    }
                    _setupLiteModeForTrack(e, t) {
                        if (!this.enabled) return;
                        const n = e.findReceiverForTrack(t.track);
                        if (!n) return void Wl.warn(`Could not set up lite mode for ${t}: receiver not found in: ${e}`);
                        if (n[Kl]) return;
                        n[Kl] = !0;
                        const i = n.createEncodedStreams(),
                            r = new TransformStream({
                                transform: () => {}
                            });
                        i.readable.pipeThrough(r).pipeTo(i.writable)
                    }
                }
                const Yl = (0, E.getLogger)("modules/qualitycontrol/ReceiveVideoController.js"),
                    Ql = 2160;
                class Zl {
                    constructor(e) {
                        const {
                            lastN: t,
                            assumedBandwidthBps: n
                        } = e;
                        this._lastN = null != t ? t : -1, this._maxFrameHeight = Ql, this._assumedBandwidthBps = null != n ? n : -1, this._receiverVideoConstraints = {
                            assumedBandwidthBps: this._assumedBandwidthBps,
                            constraints: {},
                            defaultConstraints: {
                                maxHeight: this._maxFrameHeight
                            },
                            lastN: this._lastN
                        }
                    }
                    get constraints() {
                        this._receiverVideoConstraints.assumedBandwidthBps = this._assumedBandwidthBps, this._receiverVideoConstraints.lastN = this._lastN;
                        const e = this._receiverVideoConstraints.constraints;
                        if (e && Object.keys(e).length)
                            for (const [t, n] of Object.entries(e)) n.maxHeight = this._maxFrameHeight;
                        else this._receiverVideoConstraints.defaultConstraints = {
                            maxHeight: this._maxFrameHeight
                        };
                        return this._receiverVideoConstraints
                    }
                    updateAssumedBandwidthBps(e) {
                        const t = this._assumedBandwidthBps !== e;
                        return t && (this._assumedBandwidthBps = e, Yl.debug(`Updating receive assumedBandwidthBps: ${e}`)), t
                    }
                    updateLastN(e) {
                        const t = this._lastN !== e;
                        return t && (this._lastN = e, Yl.debug(`Updating ReceiverVideoConstraints lastN(${e})`)), t
                    }
                    updateReceiveResolution(e) {
                        const t = this._maxFrameHeight !== e;
                        return t && (this._maxFrameHeight = e, Yl.debug(`Updating receive maxFrameHeight: ${e}`)), t
                    }
                    updateReceiverVideoConstraints(e) {
                        const t = !Et()(this._receiverVideoConstraints, e);
                        var n;
                        return t && (this._receiverVideoConstraints = e, null !== (n = e.defaultConstraints) && void 0 !== n && n.maxHeight && this.updateReceiveResolution(e.defaultConstraints.maxHeight), Yl.debug(`Updating ReceiverVideoConstraints ${JSON.stringify(e)}`)), t
                    }
                }
                class eh {
                    constructor(e, t) {
                        var n;
                        this._conference = e, this._rtc = t;
                        const {
                            config: i
                        } = e.options;
                        this._lastN = null !== (n = null == i ? void 0 : i.startLastN) && void 0 !== n ? n : (null == i ? void 0 : i.channelLastN) || -1, this._maxFrameHeight = Ql, this._sourceReceiverConstraints = new Map, this._assumedBandwidthBps = -1, this._receiverVideoConstraints = new Zl({
                            lastN: this._lastN,
                            assumedBandwidthBps: this._assumedBandwidthBps
                        }), this._conference.on(q, (e => this._onMediaSessionStarted(e)))
                    }
                    _getDefaultSourceReceiverConstraints(e, t) {
                        var n;
                        const i = null != t ? t : Ql,
                            r = (null === (n = e.peerconnection) || void 0 === n ? void 0 : n.getRemoteTracks(null, Ri.VIDEO)) || [],
                            o = new Map;
                        for (const e of r) o.set(e.getSourceName(), i);
                        return o
                    }
                    _onMediaSessionStarted(e) {
                        e.isP2P ? e.setReceiverVideoConstraint(this._getDefaultSourceReceiverConstraints(e)) : this._rtc.setReceiverVideoConstraints(this._receiverVideoConstraints.constraints)
                    }
                    getLastN() {
                        return this._lastN
                    }
                    setAssumedBandwidthBps(e) {
                        this._receiverVideoConstraints.updateAssumedBandwidthBps(e) && this._rtc.setReceiverVideoConstraints(this._receiverVideoConstraints.constraints)
                    }
                    setLastN(e) {
                        this._lastN !== e && (this._lastN = e, this._receiverVideoConstraints.updateLastN(e) && this._rtc.setReceiverVideoConstraints(this._receiverVideoConstraints.constraints))
                    }
                    setPreferredReceiveMaxFrameHeight(e) {
                        this._maxFrameHeight = e;
                        for (const t of this._conference.getMediaSessions()) t.isP2P ? t.setReceiverVideoConstraint(this._getDefaultSourceReceiverConstraints(t, e)) : this._receiverVideoConstraints.updateReceiveResolution(e) && this._rtc.setReceiverVideoConstraints(this._receiverVideoConstraints.constraints)
                    }
                    setReceiverConstraints(e) {
                        if (e) {
                            if (Object.keys(e).includes("onStageEndpoints", "selectedEndpoints")) throw new Error('"onStageEndpoints" and "selectedEndpoints" are not supported when sourceNameSignaling is enabled.');
                            if (this._receiverVideoConstraints.updateReceiverVideoConstraints(e)) {
                                var t, n;
                                this._assumedBandwidthBps = null !== (t = e.assumedBandwidthBps) && void 0 !== t ? t : this._assumedBandwidthBps, this._lastN = null !== (n = e.lastN) && void 0 !== n ? n : this._lastN, this._rtc.setReceiverVideoConstraints(e);
                                const i = this._conference.getMediaSessions().find((e => e.isP2P));
                                if (!i || !e.constraints) return;
                                const r = Array.from(Object.entries(e.constraints)).map((e => (e[1] = e[1].maxHeight, e)));
                                this._sourceReceiverConstraints = new Map(r), i.setReceiverVideoConstraint(this._sourceReceiverConstraints)
                            }
                        }
                    }
                }
                const th = (0, E.getLogger)("modules/qualitycontrol/SendVideoController.js");
                class nh {
                    constructor(e, t) {
                        this._conference = e, this._preferredSendMaxFrameHeight = 2160, this._rtc = t, this._sourceSenderConstraints = new Map, this._conference.on(q, (e => this._onMediaSessionStarted(e))), this._conference.on(G, (() => this._configureConstraintsForLocalSources())), this._rtc.on(ji.default.SENDER_VIDEO_CONSTRAINTS_CHANGED, (e => this._onSenderConstraintsReceived(e)))
                    }
                    _configureConstraintsForLocalSources() {
                        for (const e of this._rtc.getLocalVideoTracks()) {
                            const t = e.getSourceName();
                            t && this._propagateSendMaxFrameHeight(t)
                        }
                    }
                    _onMediaSessionStarted(e) {
                        e.addListener(aa.REMOTE_SOURCE_CONSTRAINTS_CHANGED, ((e, t) => {
                            e === this._conference.getActiveMediaSession() && t.forEach((e => this._onSenderConstraintsReceived(e)))
                        }))
                    }
                    _onSenderConstraintsReceived(e) {
                        var t;
                        const {
                            maxHeight: n,
                            sourceName: i
                        } = e, r = null !== (t = this._conference.getLocalVideoTracks()) && void 0 !== t ? t : [];
                        for (const e of r) e.getSourceName() === i && this._sourceSenderConstraints.get(i) !== n && (this._sourceSenderConstraints.set(i, -1 === n ? Math.min(2160, this._preferredSendMaxFrameHeight) : n), th.debug(`Sender constraints for source:${i} changed to maxHeight:${n}`), this._propagateSendMaxFrameHeight(i))
                    }
                    _propagateSendMaxFrameHeight(e) {
                        if (!e) throw new Error("sourceName missing for calculating the sendMaxHeight for video tracks");
                        const t = this._selectSendMaxFrameHeight(e),
                            n = [];
                        if (t >= 0)
                            for (const i of this._conference.getMediaSessions()) n.push(i.setSenderVideoConstraint(t, e));
                        return Promise.all(n)
                    }
                    _selectSendMaxFrameHeight(e) {
                        if (!e) throw new Error("sourceName missing for calculating the sendMaxHeight for video tracks");
                        const t = this._conference.getActiveMediaSession() ? this._sourceSenderConstraints.get(e) : void 0;
                        return this._preferredSendMaxFrameHeight >= 0 && t >= 0 ? Math.min(this._preferredSendMaxFrameHeight, t) : t >= 0 ? t : this._preferredSendMaxFrameHeight
                    }
                    setPreferredSendMaxFrameHeight(e) {
                        this._preferredSendMaxFrameHeight = e;
                        const t = [];
                        for (const e of this._sourceSenderConstraints.keys()) t.push(this._propagateSendMaxFrameHeight(e));
                        return Promise.allSettled(t)
                    }
                }
                const ih = {
                    getFocusRecordingUpdate(e) {
                        const t = e && e.getElementsByTagName("jibri-recording-status")[0];
                        if (t) return {
                            error: t.getAttribute("failure_reason"),
                            initiator: t.getAttribute("initiator"),
                            recordingMode: t.getAttribute("recording_mode"),
                            sessionID: t.getAttribute("session_id"),
                            status: t.getAttribute("status")
                        }
                    },
                    getHiddenDomainUpdate(e) {
                        const t = e.getElementsByTagName("live-stream-view-url")[0],
                            n = t && t.textContent,
                            i = e.getElementsByTagName("mode")[0],
                            r = i && i.textContent && i.textContent.toLowerCase(),
                            o = e.getElementsByTagName("session_id")[0];
                        return {
                            liveStreamViewURL: n,
                            mode: r,
                            sessionID: o && o.textContent
                        }
                    },
                    getSessionIdFromIq(e) {
                        const t = e && e.getElementsByTagName("jibri")[0];
                        return t && t.getAttribute("session_id")
                    },
                    getSessionId(e) {
                        const t = e.getElementsByTagName("session_id")[0];
                        return t && t.textContent
                    },
                    isFromFocus: e => e.getAttribute("from").includes("focus")
                };
                class rh {
                    constructor() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        this._connection = e.connection, this._mode = e.mode, this._jibriJid = null, this._statusFromJicofo = "", this._setSessionID(e.sessionID), this.setStatus(e.status)
                    }
                    getError() {
                        return this._error
                    }
                    getID() {
                        return this._sessionID
                    }
                    getInitiator() {
                        return this._initiator
                    }
                    getLiveStreamViewURL() {
                        return this._liveStreamViewURL
                    }
                    getStatus() {
                        return this._status ? this._status : this._statusFromJicofo
                    }
                    getJibriJid() {
                        return this._jibriJid
                    }
                    getTerminator() {
                        return this._terminator
                    }
                    getMode() {
                        return this._mode
                    }
                    setError(e) {
                        this._error = e
                    }
                    setLiveStreamViewURL(e) {
                        this._liveStreamViewURL = e
                    }
                    setStatus(e) {
                        this._status = e
                    }
                    setStatusFromJicofo(e) {
                        this._statusFromJicofo = e
                    }
                    setJibriJid(e) {
                        this._jibriJid = e
                    }
                    setInitiator(e) {
                        this._initiator = e
                    }
                    setTerminator(e) {
                        this._terminator = e
                    }
                    start(e) {
                        let {
                            appData: t,
                            broadcastId: n,
                            focusMucJid: i,
                            streamId: r
                        } = e;
                        return new Promise(((e, o) => {
                            this._connection.sendIQ(this._createIQ({
                                action: "start",
                                appData: t,
                                focusMucJid: i,
                                broadcastId: n,
                                streamId: r
                            }), (t => {
                                this.setStatus("pending"), this._setSessionID(ih.getSessionIdFromIq(t)), e()
                            }), (e => {
                                this._setErrorFromIq(e), o(e)
                            }))
                        }))
                    }
                    stop(e) {
                        let {
                            focusMucJid: t
                        } = e;
                        return new Promise(((e, n) => {
                            this._connection.sendIQ(this._createIQ({
                                action: "stop",
                                focusMucJid: t
                            }), e, n)
                        }))
                    }
                    _createIQ(e) {
                        let {
                            action: t,
                            appData: n,
                            broadcastId: i,
                            focusMucJid: r,
                            streamId: o
                        } = e;
                        return (0, St.$iq)({
                            to: r,
                            type: "set"
                        }).c("jibri", {
                            xmlns: "http://jitsi.org/protocol/jibri",
                            action: t,
                            app_data: n,
                            recording_mode: this._mode,
                            streamid: o,
                            you_tube_broadcast_id: i
                        }).up()
                    }
                    _setErrorFromIq(e) {
                        const t = e.getElementsByTagName("error")[0];
                        this.setError(t.children[0].tagName)
                    }
                    _setSessionID(e) {
                        this._sessionID = e
                    }
                }
                const oh = (0, E.getLogger)("modules/recording/RecordingManager.js"),
                    sh = class {
                        constructor(e) {
                            this._sessions = {}, this._chatRoom = e, this.onPresence = this.onPresence.bind(this), this.onMemberLeft = this.onMemberLeft.bind(this), this._chatRoom.eventEmitter.addListener(Hi.XMPPEvents.PRESENCE_RECEIVED, this.onPresence), this._chatRoom.eventEmitter.addListener(Hi.XMPPEvents.MUC_MEMBER_LEFT, this.onMemberLeft)
                        }
                        getSession(e) {
                            return this._sessions[e]
                        }
                        getSessionByJibriJid(e) {
                            let t;
                            return Object.values(this._sessions).forEach((n => {
                                n.getJibriJid() === e && (t = n)
                            })), t
                        }
                        onPresence(e) {
                            let {
                                fromHiddenDomain: t,
                                presence: n
                            } = e;
                            ih.isFromFocus(n) ? this._handleFocusPresence(n) : t && this._handleJibriPresence(n)
                        }
                        onMemberLeft(e) {
                            const t = this.getSessionByJibriJid(e);
                            if (t) {
                                const e = t.getStatus();
                                t.setStatus(""), t.setJibriJid(null), t.getStatus() !== e && this._emitSessionUpdate(t)
                            }
                        }
                        startRecording(e) {
                            const t = new rh({
                                ...e,
                                connection: this._chatRoom.connection
                            });
                            return t.start({
                                appData: e.appData,
                                broadcastId: e.broadcastId,
                                focusMucJid: this._chatRoom.focusMucJid,
                                streamId: e.streamId
                            }).then((() => (this.getSession(t.getID()) || (this._addSession(t), this._emitSessionUpdate(t)), t))).catch((e => (this._emitSessionUpdate(t), Promise.reject(e))))
                        }
                        stopRecording(e) {
                            const t = this.getSession(e);
                            return t ? t.stop({
                                focusMucJid: this._chatRoom.focusMucJid
                            }) : Promise.reject(new Error("Could not find session"))
                        }
                        _addSession(e) {
                            this._sessions[e.getID()] = e
                        }
                        _createSession(e, t, n) {
                            const i = new rh({
                                connection: this._chatRoom.connection,
                                focusMucJid: this._chatRoom.focusMucJid,
                                mode: n,
                                sessionID: e,
                                status: t
                            });
                            return this._addSession(i), i
                        }
                        _emitSessionUpdate(e, t) {
                            this._chatRoom.eventEmitter.emit(Hi.XMPPEvents.RECORDER_STATE_CHANGED, e, t)
                        }
                        _handleFocusPresence(e) {
                            const t = ih.getFocusRecordingUpdate(e);
                            if (!t) return;
                            const {
                                error: n,
                                initiator: i,
                                recordingMode: r,
                                sessionID: o,
                                status: s
                            } = t;
                            let a = this.getSession(o);
                            a || "off" !== s ? a && a.getStatus() === s && a.getError() === n ? oh.warn("Ignoring duplicate presence update: ", JSON.stringify(t)) : (a || (a = this._createSession(o, s, r)), a.setStatusFromJicofo(s), n && a.setError(n), this._emitSessionUpdate(a, i)) : oh.warn("Ignoring recording presence update", "Received a new session with status off.")
                        }
                        _handleJibriPresence(e) {
                            const {
                                liveStreamViewURL: t,
                                mode: n,
                                sessionID: i
                            } = ih.getHiddenDomainUpdate(e);
                            if (!i) return void oh.warn("Ignoring potential jibri presence due to no session id.");
                            let r = this.getSession(i);
                            r || (r = this._createSession(i, "on", n)), r.setStatus("on"), r.setJibriJid(e.getAttribute("from")), r.setLiveStreamViewURL(t), this._emitSessionUpdate(r)
                        }
                    },
                    ah = (0, E.getLogger)("modules/statistics/AudioOutputProblemDetector.js");
                class dh {
                    constructor(e) {
                        this._conference = e, this._localAudioLevelCache = {}, this._reportedParticipants = [], this._audioProblemCandidates = {}, this._numberOfRemoteAudioLevelsReceived = {}, this._onLocalAudioLevelsReport = this._onLocalAudioLevelsReport.bind(this), this._onRemoteAudioLevelReceived = this._onRemoteAudioLevelReceived.bind(this), this._clearUserData = this._clearUserData.bind(this), this._conference.on(ml, this._onRemoteAudioLevelReceived), this._conference.statistics.addConnectionStatsListener(this._onLocalAudioLevelsReport), this._conference.on(dt, this._clearUserData)
                    }
                    _onRemoteAudioLevelReceived(e, t) {
                        let {
                            avgAudioLevels: n
                        } = t;
                        const i = this._numberOfRemoteAudioLevelsReceived[e] + 1 || 0;
                        if (this._numberOfRemoteAudioLevelsReceived[e] = i, -1 !== this._reportedParticipants.indexOf(e) || e in this._audioProblemCandidates || n <= 0 || i < 3) return;
                        const r = this._conference.getParticipantById(e);
                        if (r && r.getTracksByMediaType(Ri.AUDIO).length > 0 && r.isAudioMuted()) return;
                        const o = this._localAudioLevelCache[e];
                        Array.isArray(o) && !o.every((e => 0 === e)) || (this._audioProblemCandidates[e] = {
                            remoteAudioLevels: n,
                            localAudioLevels: []
                        })
                    }
                    _onLocalAudioLevelsReport(e, t) {
                        let {
                            avgAudioLevels: n
                        } = t;
                        e === this._conference.getActivePeerConnection() && (Object.keys(n).forEach((e => {
                            if (-1 !== this._reportedParticipants.indexOf(e)) return;
                            const t = this._localAudioLevelCache[e];
                            Array.isArray(t) ? t.length >= 2 && t.shift() : this._localAudioLevelCache[e] = [], this._localAudioLevelCache[e].push(n[e])
                        })), Object.keys(this._audioProblemCandidates).forEach((e => {
                            const {
                                localAudioLevels: t,
                                remoteAudioLevels: i
                            } = this._audioProblemCandidates[e];
                            if (t.push(n[e]), 2 === t.length) {
                                if (t.every((e => void 0 === e || 0 === e))) {
                                    const n = JSON.stringify(t);
                                    Mi.sendAnalytics(((e, t, n) => ({
                                        type: Nt.TYPE_OPERATIONAL,
                                        action: "audio.output.problem",
                                        attributes: {
                                            userID: e,
                                            localAudioLevels: t,
                                            remoteAudioLevels: n
                                        }
                                    }))(e, n, i)), ah.warn(`A potential problem is detected with the audio output for participant ${e}, local audio levels: ${n}, remote audio levels: ${i}`), this._reportedParticipants.push(e), this._clearUserData(e)
                                }
                                delete this._audioProblemCandidates[e]
                            }
                        })))
                    }
                    _clearUserData(e) {
                        delete this._localAudioLevelCache[e]
                    }
                    dispose() {
                        this._conference.off(ml, this._onRemoteAudioLevelReceived), this._conference.off(dt, this._clearUserData), this._conference.statistics.removeConnectionStatsListener(this._onLocalAudioLevelsReport), this._localAudioLevelCache = void 0, this._audioProblemCandidates = void 0, this._reportedParticipants = void 0, this._numberOfRemoteAudioLevelsReceived = void 0, this._conference = void 0
                    }
                }
                const ch = (0, E.getLogger)("modules/statistics/AvgRTPStatsReporter.js");
                class lh {
                    constructor(e) {
                        this.name = e, this.count = 0, this.sum = 0, this.samples = []
                    }
                    addNext(e) {
                        void 0 !== e && ("number" != typeof e ? ch.error(`${this.name} - invalid value for idx: ${this.count}`, e) : isNaN(e) || (this.sum += e, this.samples.push(e), this.count += 1))
                    }
                    calculate() {
                        return this.sum / this.count
                    }
                    appendReport(e) {
                        e[`${this.name}_avg`] = this.calculate(), e[`${this.name}_samples`] = JSON.stringify(this.samples)
                    }
                    reset() {
                        this.samples = [], this.sum = 0, this.count = 0
                    }
                }
                class hh {
                    constructor(e, t, n) {
                        this.isP2P = t, this._n = n, this._sampleIdx = 0, this._avgRTT = new lh("rtt"), this._avgRemoteRTTMap = new Map, this._avgRtpStatsReporter = e, this._avgEnd2EndRTT = void 0, this._onConnectionStats = (e, t) => {
                            this.isP2P === e.isP2P && this._calculateAvgStats(t)
                        };
                        const i = e._conference;
                        i.statistics.addConnectionStatsListener(this._onConnectionStats), this.isP2P || (this._onUserLeft = e => this._avgRemoteRTTMap.delete(e), i.on(dt, this._onUserLeft), this._onRemoteStatsUpdated = (e, t) => this._processRemoteStats(e, t), i.on(ml, this._onRemoteStatsUpdated))
                    }
                    _calculateAvgStats(e) {
                        if (e) {
                            if (ci.supportsRTTStatistics() && e.transport && e.transport.length && this._avgRTT.addNext(e.transport[0].rtt), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                                if (ci.supportsRTTStatistics()) {
                                    const t = this._avgRtpStatsReporter._conference,
                                        n = {
                                            p2p: this.isP2P,
                                            conference_size: t.getParticipantCount()
                                        };
                                    if (e.transport && e.transport.length && Object.assign(n, {
                                            local_candidate_type: e.transport[0].localCandidateType,
                                            remote_candidate_type: e.transport[0].remoteCandidateType,
                                            transport_type: e.transport[0].type
                                        }), this._avgRTT.appendReport(n), this.isP2P) {
                                        const e = this._avgRtpStatsReporter.jvbStatsMonitor._avgEnd2EndRTT;
                                        isNaN(e) || (n.rtt_diff = this._avgRTT.calculate() - e)
                                    } else {
                                        const e = this._calculateAvgRemoteRTT(),
                                            t = this._avgRTT.calculate();
                                        this._avgEnd2EndRTT = t + e, isNaN(t) || isNaN(e) || (n.end2end_rtt_avg = this._avgEnd2EndRTT)
                                    }
                                    Mi.sendAnalytics(hn(n))
                                }
                                this._resetAvgStats()
                            }
                        } else ch.error("No stats")
                    }
                    _calculateAvgRemoteRTT() {
                        let e = 0,
                            t = 0;
                        for (const n of this._avgRemoteRTTMap.values()) {
                            const i = n.calculate();
                            isNaN(i) || (t += i, e += 1, n.reset())
                        }
                        return t / e
                    }
                    _processRemoteStats(e, t) {
                        const n = "number" == typeof t.jvbRTT;
                        let i = this._avgRemoteRTTMap.get(e);
                        !i && n && (i = new lh(`${e}_stat_rtt`), this._avgRemoteRTTMap.set(e, i)), n ? i.addNext(t.jvbRTT) : i && this._avgRemoteRTTMap.delete(e)
                    }
                    _resetAvgStats() {
                        this._avgRTT.reset(), this._avgRemoteRTTMap && this._avgRemoteRTTMap.clear(), this._sampleIdx = 0
                    }
                    dispose() {
                        const e = this._avgRtpStatsReporter._conference;
                        e.statistics.removeConnectionStatsListener(this._onConnectionStats), this.isP2P || (e.off(ml, this._onRemoteStatsUpdated), e.off(dt, this._onUserLeft))
                    }
                }
                class uh {
                    constructor(e, t) {
                        this._n = t, t > 0 ? (ch.info(`Avg RTP stats will be calculated every ${t} samples`), this._sampleIdx = 0, this._conference = e, this._avgAudioBitrateUp = new lh("bitrate_audio_upload"), this._avgAudioBitrateDown = new lh("bitrate_audio_download"), this._avgVideoBitrateUp = new lh("bitrate_video_upload"), this._avgVideoBitrateDown = new lh("bitrate_video_download"), this._avgBandwidthUp = new lh("bandwidth_upload"), this._avgBandwidthDown = new lh("bandwidth_download"), this._avgPacketLossTotal = new lh("packet_loss_total"), this._avgPacketLossUp = new lh("packet_loss_upload"), this._avgPacketLossDown = new lh("packet_loss_download"), this._avgRemoteFPS = new lh("framerate_remote"), this._avgRemoteScreenFPS = new lh("framerate_screen_remote"), this._avgLocalFPS = new lh("framerate_local"), this._avgLocalScreenFPS = new lh("framerate_screen_local"), this._avgRemoteCameraPixels = new lh("pixels_remote"), this._avgRemoteScreenPixels = new lh("pixels_screen_remote"), this._avgLocalCameraPixels = new lh("pixels_local"), this._avgLocalScreenPixels = new lh("pixels_screen_local"), this._avgCQ = new lh("connection_quality"), this._cachedTransportStats = void 0, this._onLocalStatsUpdated = e => {
                            this._calculateAvgStats(e), this._maybeSendTransportAnalyticsEvent(e)
                        }, e.on(pl, this._onLocalStatsUpdated), this._onP2PStatusChanged = () => {
                            ch.debug("Resetting average stats calculation"), this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats(), this.p2pStatsMonitor._resetAvgStats()
                        }, e.on(Ue, this._onP2PStatusChanged), this._onJvb121StatusChanged = (e, t) => {
                            !0 === t && (ch.info("Resetting JVB avg RTP stats"), this._resetAvgJvbStats())
                        }, e.on(Ae, this._onJvb121StatusChanged), this.jvbStatsMonitor = new hh(this, !1, t), this.p2pStatsMonitor = new hh(this, !0, t)) : ch.info("Avg RTP stats reports are disabled.")
                    }
                    _calculateAvgStats(e) {
                        if (!e) return void ch.error("No stats");
                        const t = this._conference.isP2PActive(),
                            n = this._conference.getParticipantCount();
                        if (!t && n < 2) return;
                        const i = e.bitrate,
                            r = e.bandwidth,
                            o = e.packetLoss,
                            s = e.framerate,
                            a = e.resolution;
                        if (i)
                            if (r)
                                if (o)
                                    if (s)
                                        if (a) {
                                            if (this._avgAudioBitrateUp.addNext(i.audio.upload), this._avgAudioBitrateDown.addNext(i.audio.download), this._avgVideoBitrateUp.addNext(i.video.upload), this._avgVideoBitrateDown.addNext(i.video.download), ci.supportsBandwidthStatistics() && (this._avgBandwidthUp.addNext(r.upload), this._avgBandwidthDown.addNext(r.download)), this._avgPacketLossUp.addNext(o.upload), this._avgPacketLossDown.addNext(o.download), this._avgPacketLossTotal.addNext(o.total), this._avgCQ.addNext(e.connectionQuality), s && (this._avgRemoteFPS.addNext(this._calculateAvgVideoFps(s, !1, Yo.VideoType.CAMERA)), this._avgRemoteScreenFPS.addNext(this._calculateAvgVideoFps(s, !1, Yo.VideoType.DESKTOP)), this._avgLocalFPS.addNext(this._calculateAvgVideoFps(s, !0, Yo.VideoType.CAMERA)), this._avgLocalScreenFPS.addNext(this._calculateAvgVideoFps(s, !0, Yo.VideoType.DESKTOP))), a && (this._avgRemoteCameraPixels.addNext(this._calculateAvgVideoPixels(a, !1, Yo.VideoType.CAMERA)), this._avgRemoteScreenPixels.addNext(this._calculateAvgVideoPixels(a, !1, Yo.VideoType.DESKTOP)), this._avgLocalCameraPixels.addNext(this._calculateAvgVideoPixels(a, !0, Yo.VideoType.CAMERA)), this._avgLocalScreenPixels.addNext(this._calculateAvgVideoPixels(a, !0, Yo.VideoType.DESKTOP))), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                                                const i = {
                                                    p2p: t,
                                                    conference_size: n
                                                };
                                                e.transport && e.transport.length && Object.assign(i, {
                                                    local_candidate_type: e.transport[0].localCandidateType,
                                                    remote_candidate_type: e.transport[0].remoteCandidateType,
                                                    transport_type: e.transport[0].type
                                                }), this._avgAudioBitrateUp.appendReport(i), this._avgAudioBitrateDown.appendReport(i), this._avgVideoBitrateUp.appendReport(i), this._avgVideoBitrateDown.appendReport(i), ci.supportsBandwidthStatistics() && (this._avgBandwidthUp.appendReport(i), this._avgBandwidthDown.appendReport(i)), this._avgPacketLossUp.appendReport(i), this._avgPacketLossDown.appendReport(i), this._avgPacketLossTotal.appendReport(i), this._avgRemoteFPS.appendReport(i), isNaN(this._avgRemoteScreenFPS.calculate()) || this._avgRemoteScreenFPS.appendReport(i), this._avgLocalFPS.appendReport(i), isNaN(this._avgLocalScreenFPS.calculate()) || this._avgLocalScreenFPS.appendReport(i), this._avgRemoteCameraPixels.appendReport(i), isNaN(this._avgRemoteScreenPixels.calculate()) || this._avgRemoteScreenPixels.appendReport(i), this._avgLocalCameraPixels.appendReport(i), isNaN(this._avgLocalScreenPixels.calculate()) || this._avgLocalScreenPixels.appendReport(i), this._avgCQ.appendReport(i), Mi.sendAnalytics(hn(i)), this._resetAvgStats()
                                            }
                                        } else ch.error("No resolution");
                        else ch.error('No "framerate"');
                        else ch.error('No "packetloss"');
                        else ch.error('No "bandwidth"');
                        else ch.error('No "bitrate"')
                    }
                    _calculateAvgVideoPixels(e, t, n) {
                        let i = 0,
                            r = 0;
                        const o = this._conference.myUserId();
                        for (const s of Object.keys(e))
                            if (t ? s === o : s !== o) {
                                const o = t ? null : this._conference.getParticipantById(s),
                                    a = e[s];
                                if ((t || o) && a) {
                                    const e = this._calculatePeerAvgVideoPixels(a, o, n);
                                    isNaN(e) || (i += e, r += 1)
                                }
                            } return i / r
                    }
                    _calculatePeerAvgVideoPixels(e, t, n) {
                        let i = Object.keys(e).map((e => Number(e))),
                            r = null;
                        const o = this._conference.getActivePeerConnection();
                        t ? (r = t.getTracksByMediaType(Ri.VIDEO), r && (i = i.filter((e => r.find((t => !t.isMuted() && t.getSSRC() === e && t.videoType === n)))))) : (r = this._conference.getLocalTracks(Ri.VIDEO), i = i.filter((e => r.find((t => !t.isMuted() && o.getLocalSSRC(t) === e && t.videoType === n)))));
                        let s = 0,
                            a = 0;
                        for (const t of i) {
                            const n = Number(e[t].height) * Number(e[t].width);
                            !isNaN(n) && n > 0 && (s += n, a += 1)
                        }
                        return s / a
                    }
                    _calculateAvgVideoFps(e, t, n) {
                        let i = 0,
                            r = 0;
                        const o = this._conference.myUserId();
                        for (const s of Object.keys(e))
                            if (t ? s === o : s !== o) {
                                const o = t ? null : this._conference.getParticipantById(s),
                                    a = e[s];
                                if ((t || o) && a) {
                                    const e = this._calculatePeerAvgVideoFps(a, o, n);
                                    isNaN(e) || (i += e, r += 1)
                                }
                            } return i / r
                    }
                    _calculatePeerAvgVideoFps(e, t, n) {
                        let i = Object.keys(e).map((e => Number(e))),
                            r = null;
                        const o = this._conference.getActivePeerConnection();
                        t ? (r = t.getTracksByMediaType(Ri.VIDEO), r && (i = i.filter((e => r.find((t => !t.isMuted() && t.getSSRC() === e && t.videoType === n)))))) : (r = this._conference.getLocalTracks(Ri.VIDEO), i = i.filter((e => r.find((t => !t.isMuted() && o.getLocalSSRC(t) === e && t.videoType === n)))));
                        let s = 0,
                            a = 0;
                        for (const t of i) {
                            const n = Number(e[t]);
                            !isNaN(n) && n > 0 && (s += n, a += 1)
                        }
                        return s / a
                    }
                    _maybeSendTransportAnalyticsEvent(e) {
                        if (!e || !e.transport || !e.transport.length) return;
                        const t = {
                            p2p: e.transport[0].p2p,
                            local_candidate_type: e.transport[0].localCandidateType,
                            remote_candidate_type: e.transport[0].remoteCandidateType,
                            transport_type: e.transport[0].type
                        };
                        var n;
                        this._cachedTransportStats && Et()(t, this._cachedTransportStats) || (this._cachedTransportStats = t, Mi.sendAnalytics((n = t, {
                            type: Nt.TYPE_OPERATIONAL,
                            action: "transport.stats",
                            attributes: n
                        })))
                    }
                    _resetAvgJvbStats() {
                        this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats()
                    }
                    _resetAvgStats() {
                        this._avgAudioBitrateUp.reset(), this._avgAudioBitrateDown.reset(), this._avgVideoBitrateUp.reset(), this._avgVideoBitrateDown.reset(), this._avgBandwidthUp.reset(), this._avgBandwidthDown.reset(), this._avgPacketLossUp.reset(), this._avgPacketLossDown.reset(), this._avgPacketLossTotal.reset(), this._avgRemoteFPS.reset(), this._avgRemoteScreenFPS.reset(), this._avgLocalFPS.reset(), this._avgLocalScreenFPS.reset(), this._avgRemoteCameraPixels.reset(), this._avgRemoteScreenPixels.reset(), this._avgLocalCameraPixels.reset(), this._avgLocalScreenPixels.reset(), this._avgCQ.reset(), this._sampleIdx = 0
                    }
                    dispose() {
                        this._conference.off(Ue, this._onP2PStatusChanged), this._conference.off(pl, this._onLocalStatsUpdated), this._conference.off(Ae, this._onJvb121StatusChanged), this.jvbStatsMonitor.dispose(), this.p2pStatsMonitor.dispose()
                    }
                }
                var ph = n(444),
                    mh = n.n(ph);
                class gh {
                    constructor(e) {
                        this.stats = {
                            users: {},
                            dominantSpeakerId: null
                        };
                        const t = e.myUserId();
                        this.stats.users[t] = new(mh())(t, null, !0), this.conference = e, e.addEventListener(ye, this._onDominantSpeaker.bind(this)), e.addEventListener(at, this._onUserJoin.bind(this)), e.addEventListener(dt, this._onUserLeave.bind(this)), e.addEventListener(_e, this._onDisplayNameChange.bind(this)), e.on(Ce, ((e, t) => {
                            let {
                                type: n,
                                faceLandmarks: i
                            } = t;
                            "face-landmarks" === n && this._onFaceLandmarkAdd(e.getId(), i)
                        })), e.xmpp && e.xmpp.addListener(Hi.XMPPEvents.SPEAKER_STATS_RECEIVED, this._updateStats.bind(this))
                    }
                    _onDominantSpeaker(e, t, n) {
                        const i = this.stats.users[this.stats.dominantSpeakerId],
                            r = this.stats.users[e];
                        i && i.setDominantSpeaker(!1), r && r.setDominantSpeaker(!0, n), this.stats.dominantSpeakerId = e
                    }
                    _onUserJoin(e, t) {
                        t.isHidden() || this.stats.users[e] || (this.stats.users[e] = new(mh())(e, t.getDisplayName()))
                    }
                    _onUserLeave(e) {
                        const t = this.stats.users[e];
                        t && t.markAsHasLeft()
                    }
                    _onDisplayNameChange(e, t) {
                        const n = this.stats.users[e];
                        n && n.setDisplayName(t)
                    }
                    _onFaceLandmarkAdd(e, t) {
                        const n = this.stats.users[e];
                        n && t && n.addFaceLandmarks(t)
                    }
                    getStats() {
                        return this.stats.users
                    }
                    _updateStats(e) {
                        for (const t in e) {
                            let n;
                            const i = this.conference.getParticipantById(t);
                            i && i.isHidden() || (this.stats.users[t] ? (n = this.stats.users[t], n.getDisplayName() || n.setDisplayName(e[t].displayName)) : (n = new(mh())(t, e[t].displayName), this.stats.users[t] = n, n.markAsHasLeft()), n.totalDominantSpeakerTime = e[t].totalDominantSpeakerTime, Array.isArray(e[t].faceLandmarks) && n.setFaceLandmarks(e[t].faceLandmarks))
                        }
                    }
                }
                const fh = n(810).getLogger("modules/version/ComponentsVersions.js");

                function vh(e) {
                    this.versions = {}, this.conference = e, this.conference.addCommandListener("versions", this.processVersions.bind(this))
                }
                let _h, yh, Eh;
                vh.prototype.processVersions = function(e, t, n) {
                        this.conference.isFocus(n) ? e.children.forEach((e => {
                            const t = e.attributes.name,
                                n = e.value;
                            this.versions[t] !== n && (this.versions[t] = n, fh.info(`Got ${t} version: ${n}`))
                        })) : fh.warn(`Received versions not from the focus user: ${e}`, n)
                    }, vh.prototype.getComponentVersion = function(e) {
                        return this.versions[e]
                    },
                    function(e) {
                        e.STATUS_AVAILABLE = "available", e.STATUS_UNDEFINED = "undefined", e.STATUS_BUSY = "busy"
                    }(_h || (_h = {})),
                    function(e) {
                        e.STATE_ON = "on", e.STATE_OFF = "off", e.STATE_PENDING = "pending", e.STATE_RETRYING = "retrying", e.STATE_FAILED = "failed"
                    }(yh || (yh = {})),
                    function(e) {
                        e.ERROR_NO_CONNECTION = "error_no_connection", e.ERROR_SESSION_EXISTS = "error_session_already_exists"
                    }(Eh || (Eh = {}));
                const Sh = _h.STATUS_AVAILABLE,
                    bh = _h.STATUS_UNDEFINED,
                    Th = _h.STATUS_BUSY,
                    Ch = yh.STATE_ON,
                    xh = yh.STATE_OFF,
                    Rh = yh.STATE_PENDING,
                    Ah = yh.STATE_RETRYING,
                    wh = yh.STATE_FAILED,
                    Ih = Eh.ERROR_NO_CONNECTION,
                    Ph = Eh.ERROR_SESSION_EXISTS,
                    Dh = (0, E.getLogger)("modules/videosipgw/JitsiVideoSIPGWSession.js"),
                    Oh = "STATE_CHANGED";
                class Nh extends Cr {
                    constructor(e, t, n) {
                        super(), this.sipAddress = e, this.displayName = t, this.chatRoom = n, this.state = void 0
                    }
                    stop() {
                        this.state !== xh && this.state !== wh ? this._sendJibriIQ("stop") : Dh.warn("Video SIP GW session already stopped or failed!")
                    }
                    start() {
                        this.state !== Ch && this.state !== xh && this.state !== Rh && this.state !== Ah ? this._sendJibriIQ("start") : Dh.warn("Video SIP GW session already started!")
                    }
                    setState(e, t) {
                        if (e === this.state) return;
                        const n = this.state;
                        this.state = e, this.eventEmitter.emit(Oh, {
                            address: this.sipAddress,
                            failureReason: t,
                            oldState: n,
                            newState: this.state,
                            displayName: this.displayName
                        })
                    }
                    addStateListener(e) {
                        this.addListener(Oh, e)
                    }
                    removeStateListener(e) {
                        this.removeListener(Oh, e)
                    }
                    _sendJibriIQ(e) {
                        const t = {
                            xmlns: "http://jitsi.org/protocol/jibri",
                            action: e,
                            sipaddress: this.sipAddress
                        };
                        t.displayname = this.displayName;
                        const n = (0, St.$iq)({
                            to: this.chatRoom.focusMucJid,
                            type: "set"
                        }).c("jibri", t).up();
                        Dh.debug(`${e} video SIP GW session`, n.nodeTree), this.chatRoom.connection.sendIQ(n, (() => {}), (t => {
                            Dh.error(`Failed to ${e} video SIP GW session, error: `, t), this.setState(wh)
                        }))
                    }
                }
                const kh = (0, E.getLogger)("modules/videosipgw/VideoSIPGW.js");
                class Mh {
                    constructor(e) {
                        this.chatRoom = e, this.eventEmitter = e.eventEmitter, kh.debug("creating VideoSIPGW"), this.sessions = {}, this.sessionStateChangeListener = this.sessionStateChanged.bind(this), e.addPresenceListener("jibri-sip-call-state", this.handleJibriSIPState.bind(this))
                    }
                    handleJibriSIPState(e) {
                        const t = e.attributes;
                        if (!t) return;
                        kh.debug("Handle video sip gw state : ", t);
                        const n = t.state;
                        if (n !== this.state) switch (n) {
                            case Ch:
                            case xh:
                            case Rh:
                            case Ah:
                            case wh: {
                                const e = t.sipaddress;
                                if (!e) return;
                                const i = this.sessions[e];
                                i ? i.setState(n, t.failure_reason) : kh.warn("Video SIP GW session not found:", e)
                            }
                        }
                    }
                    createVideoSIPGWSession(e, t) {
                        if (this.sessions[e]) return kh.warn("There was already a Video SIP GW session for address", e), new Error(Ph);
                        const n = new Nh(e, t, this.chatRoom);
                        return n.addStateListener(this.sessionStateChangeListener), this.sessions[e] = n, n
                    }
                    sessionStateChanged(e) {
                        const t = e.address;
                        if (e.newState === xh || e.newState === wh) {
                            const e = this.sessions[t];
                            if (!e) return void kh.error("Missing Video SIP GW session with address:", t);
                            e.removeStateListener(this.sessionStateChangeListener), delete this.sessions[t]
                        }
                        this.eventEmitter.emit(Hi.XMPPEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED, e)
                    }
                }
                const Lh = (0, E.getLogger)("modules/xmpp/SignalingLayerImpl.js"),
                    Fh = "SourceInfo";
                class jh extends Rc {
                    constructor() {
                        super(), this.ssrcOwners = new Map, this.chatRoom = null, this._localSourceState = {}, this._remoteSourceState = {}
                    }
                    _addLocalSourceInfoToPresence() {
                        return !!this.chatRoom && this.chatRoom.addOrReplaceInPresence(Fh, {
                            value: JSON.stringify(this._localSourceState)
                        })
                    }
                    _bindChatRoomEventHandlers(e) {
                        const t = (e, t) => {
                            this.eventEmitter.emit(_c, e, Ri.AUDIO, t)
                        };
                        this._audioMuteHandler = (e, n) => {
                            this._doesEndpointSendNewSourceInfo(n) || t(n, "true" === e.value)
                        }, e.addPresenceListener("audiomuted", this._audioMuteHandler);
                        const n = (e, t) => {
                            this.eventEmitter.emit(_c, e, Ri.VIDEO, t)
                        };
                        this._videoMuteHandler = (e, t) => {
                            this._doesEndpointSendNewSourceInfo(t) || n(t, "true" === e.value)
                        }, e.addPresenceListener("videomuted", this._videoMuteHandler);
                        const i = (e, t) => {
                            this.eventEmitter.emit(yc, e, t)
                        };
                        this._videoTypeHandler = (e, t) => {
                            this._doesEndpointSendNewSourceInfo(t) || i(t, e.value)
                        }, e.addPresenceListener("videoType", this._videoTypeHandler), this._sourceInfoHandler = (e, t) => {
                            const n = t,
                                {
                                    value: i
                                } = e,
                                r = vr(i),
                                o = this._doesEndpointSendNewSourceInfo(n),
                                s = this._remoteSourceState[n] || (this._remoteSourceState[n] = {});
                            for (const e of Object.keys(r)) {
                                var a;
                                let n = !1;
                                const i = Cc(e),
                                    d = Boolean(r[e].muted),
                                    c = s[e] || (s[e] = {
                                        sourceName: e
                                    });
                                c.muted !== d && (n = !0, c.muted = d, o && !this._localSourceState[e] && this.eventEmitter.emit(Ec, e, d));
                                const l = i === Ri.VIDEO ? null !== (a = r[e].videoType) && void 0 !== a ? a : Yo.VideoType.CAMERA : void 0;
                                c.videoType !== l && (c.videoType = l, n = !0, o && !this._localSourceState[e] && this.eventEmitter.emit(bc, e, l)), n && Ai.isSsrcRewritingSupported() && this.eventEmitter.emit(Sc, e, t, d, l)
                            }
                            const d = Object.keys(r);
                            for (const e of Object.keys(s)) - 1 === d.indexOf(e) && delete s[e]
                        }, e.addPresenceListener("SourceInfo", this._sourceInfoHandler), this._memberLeftHandler = e => {
                            const t = St.Strophe.getResourceFromJid(e);
                            delete this._remoteSourceState[t]
                        }, e.addEventListener(Hi.XMPPEvents.MUC_MEMBER_LEFT, this._memberLeftHandler)
                    }
                    _doesEndpointSendNewSourceInfo(e) {
                        var t;
                        const n = null === (t = this.chatRoom) || void 0 === t ? void 0 : t.getLastPresence(e);
                        return Boolean(n && n.find((e => e.tagName === Fh)))
                    }
                    _logOwnerChangedMessage(e) {
                        Ai.isSsrcRewritingSupported() ? Lh.debug(e) : Lh.error(e)
                    }
                    getPeerMediaInfo(e, t, n) {
                        var i;
                        const r = null === (i = this.chatRoom) || void 0 === i ? void 0 : i.getLastPresence(e);
                        if (!r) return void Lh.warn(`getPeerMediaInfo - no presence stored for: ${e}`);
                        if (!this._doesEndpointSendNewSourceInfo(e)) return (() => {
                            if (this.chatRoom) return this.chatRoom.getMediaPresenceInfo(e, t);
                            Lh.warn("Requested peer media info, before room was set")
                        })();
                        if (n) return this.getPeerSourceInfo(e, n);
                        const o = {
                            muted: !0
                        };
                        if (t === Ri.VIDEO) {
                            o.videoType = void 0;
                            const e = ps(r, "jitsi_participant_codecList"),
                                t = ps(r, "jitsi_participant_codecType");
                            var s, a;
                            e.length ? o.codecList = null !== (s = null === (a = e[0].value) || void 0 === a ? void 0 : a.split(",")) && void 0 !== s ? s : [] : t.length > 0 && (o.codecType = t[0].value)
                        }
                        return o
                    }
                    getPeerSourceInfo(e, t) {
                        var n;
                        const i = {
                            muted: !0,
                            videoType: Cc(t) === Ri.VIDEO ? Yo.VideoType.CAMERA : void 0
                        };
                        return this._remoteSourceState[e] ? null !== (n = this._remoteSourceState[e][t]) && void 0 !== n ? n : i : void 0
                    }
                    getSSRCOwner(e) {
                        var t;
                        return null === (t = this.ssrcOwners.get(e)) || void 0 === t ? void 0 : t.endpointId
                    }
                    getTrackSourceName(e) {
                        var t;
                        return null === (t = this.ssrcOwners.get(e)) || void 0 === t ? void 0 : t.sourceName
                    }
                    removeSSRCOwners(e) {
                        if (null != e && e.length)
                            for (const t of e) this.ssrcOwners.delete(t)
                    }
                    setChatRoom(e) {
                        const t = this.chatRoom;
                        this.chatRoom = e, t && (t.removePresenceListener("audiomuted", this._audioMuteHandler), t.removePresenceListener("videomuted", this._videoMuteHandler), t.removePresenceListener("videoType", this._videoTypeHandler), this._sourceInfoHandler && t.removePresenceListener(Fh, this._sourceInfoHandler), this._memberLeftHandler && t.removeEventListener(Hi.XMPPEvents.MUC_MEMBER_LEFT, this._memberLeftHandler)), e && (this._bindChatRoomEventHandlers(e), this._addLocalSourceInfoToPresence())
                    }
                    setSSRCOwner(e, t, n) {
                        if ("number" != typeof e) throw new TypeError(`SSRC(${e}) must be a number`);
                        const i = this.ssrcOwners.get(e);
                        if (i) {
                            const {
                                endpointId: e,
                                sourceName: r
                            } = i;
                            e === t && r === n || this._logOwnerChangedMessage(`SSRC owner re-assigned from ${i}(source-name=${r}) to ${t}(source-name=${n})`)
                        }
                        this.ssrcOwners.set(e, {
                            endpointId: t,
                            sourceName: n
                        })
                    }
                    setTrackMuteStatus(e, t) {
                        return this._localSourceState[e] || (this._localSourceState[e] = {}), this._localSourceState[e].muted = t, Lh.debug(`Mute state of ${e} changed to muted=${t}`), !!this.chatRoom && this._addLocalSourceInfoToPresence()
                    }
                    setTrackVideoType(e, t) {
                        return this._localSourceState[e] || (this._localSourceState[e] = {}), this._localSourceState[e].videoType !== t && (this._localSourceState[e].videoType = t === Yo.VideoType.CAMERA ? void 0 : t, this._addLocalSourceInfoToPresence())
                    }
                    updateSsrcOwnersOnLeave(e) {
                        const t = [];
                        this.ssrcOwners.forEach(((n, i) => {
                            let {
                                endpointId: r
                            } = n;
                            r === e && t.push(i)
                        })), null != t && t.length && this.removeSSRCOwners(t)
                    }
                }
                let Vh;
                ! function(e) {
                    e.CAMERA = "camera", e.DESKTOP = "desktop", e.DESKTOP_HIGH_FPS = "desktop_high_fps", e.NONE = "none"
                }(Vh || (Vh = {}));
                const Uh = (0, E.getLogger)("JitsiConference.js");

                function Hh(e) {
                    return "string" == typeof e ? Object.values(Ps).find((t => t === e.toLowerCase())) : null
                }

                function $h(e) {
                    var t, n, i;
                    if (!e.name || e.name.toLowerCase() !== e.name.toString()) {
                        const t = "Invalid conference name (no conference name passed or it contains invalid characters like capital letters)!",
                            n = e.name ? `roomName=${e.name}; condition - ${e.name.toLowerCase()}!==${e.name.toString()}` : "No room name passed!";
                        throw Uh.error(`${t} ${n}`), new Error(t)
                    }
                    if (this.connection = e.connection, this.xmpp = null === (t = this.connection) || void 0 === t ? void 0 : t.xmpp, this.xmpp.isRoomCreated(e.name, e.customDomain)) {
                        const e = "A conference with the same name has already been created!";
                        throw delete this.connection, delete this.xmpp, Uh.error(e), new Error(e)
                    }
                    this.eventEmitter = new ii, this.options = e, this.eventManager = new Ji(this), this.participants = new Map, this._signalingLayer = new jh, this._init(e), this.componentsVersions = new vh(this), this.jvbJingleSession = null, this.lastDominantSpeaker = null, this.dtmfManager = null, this.somebodySupportsDTMF = !1, this.authEnabled = !1, this.startAudioMuted = !1, this.startVideoMuted = !1, this.startMutedPolicy = {
                        audio: !1,
                        video: !1
                    }, this.isMutedByFocus = !1, this.mutedByFocusActor = null, this.isVideoMutedByFocus = !1, this.mutedVideoByFocusActor = null, this.wasStopped = !1, this.properties = {}, this.connectionQuality = new El(this, this.eventEmitter, e), this.avgRtpStatsReporter = new uh(this, e.config.avgRtpStatsN || 15), e.config.disableAudioLevels || (this._audioOutputProblemDetector = new dh(this)), this.isJvbConnectionInterrupted = !1, this.speakerStatsCollector = new gh(this), this.deferredStartP2PTask = null;
                    const r = parseInt(e.config.p2p && e.config.p2p.backToP2PDelay, 10);
                    this.backToP2PDelay = isNaN(r) ? 5 : r, Uh.info(`backToP2PDelay: ${this.backToP2PDelay}`), this.isP2PConnectionInterrupted = !1, this.p2p = !1, this.p2pJingleSession = null, this.videoSIPGWHandler = new Mh(this.room), this.recordingManager = new sh(this.room), this._conferenceJoinAnalyticsEventSent = void 0, this.isE2EESupported() && (Uh.info("End-to-End Encryption is supported"), this._e2eEncryption = new oo(this)), Ai.isRunInLiteModeEnabled() && (Uh.info("Lite mode enabled"), this._liteModeContext = new Xl(this)), this._audioSenderLimitReached = void 0, this._videoSenderLimitReached = void 0, this._firefoxP2pEnabled = ci.isVersionGreaterThan(109) && (null === (n = null === (i = this.options.config.testing) || void 0 === i ? void 0 : i.enableFirefoxP2p) || void 0 === n || n)
                }

                function Jh(e, t, n) {
                    this.appID = e, this.token = t, this.options = n, this.xmpp = new Ia(n, t), this.addEventListener(ur, ((e, t, n, i) => {
                        Mi.sendAnalyticsAndLog(rn(e, t, i))
                    })), this.addEventListener(lr, (e => {
                        e && Mi.sendAnalytics(Xt, {
                            message: e
                        })
                    }))
                }
                let Bh;
                $h.prototype.constructor = $h, $h.resourceCreator = function(e, t) {
                    let n;
                    var i;
                    t ? n = ao().randomHexString(8).toLowerCase() : (n = null === (i = St.Strophe.getNodeFromJid(e)) || void 0 === i ? void 0 : i.substr(0, 8).toLowerCase(), n && /[0-9a-f]{8}/g.test(n) || (n = ao().randomHexString(8).toLowerCase()));
                    return n
                }, $h.prototype._init = function() {
                    var e, t, n, i, r, o, s, a, d, c;
                    let l = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    this.eventManager.setupXMPPListeners();
                    const {
                        config: h
                    } = this.options, u = {
                        jvb: {
                            preferenceOrder: ci.isMobileDevice() && null !== (e = h.videoQuality) && void 0 !== e && e.mobileCodecPreferenceOrder ? h.videoQuality.mobileCodecPreferenceOrder : null === (t = h.videoQuality) || void 0 === t ? void 0 : t.codecPreferenceOrder,
                            disabledCodec: Hh(null === (n = h.videoQuality) || void 0 === n ? void 0 : n.disabledCodec),
                            preferredCodec: Hh(null === (i = h.videoQuality) || void 0 === i ? void 0 : i.preferredCodec),
                            supportsAv1: null === (r = h.testing) || void 0 === r ? void 0 : r.enableAv1Support
                        },
                        p2p: {
                            preferenceOrder: ci.isMobileDevice() && null !== (o = h.p2p) && void 0 !== o && o.mobileCodecPreferenceOrder ? h.p2p.mobileCodecPreferenceOrder : null === (s = h.p2p) || void 0 === s ? void 0 : s.codecPreferenceOrder,
                            disabledCodec: Hh(null === (a = h.p2p) || void 0 === a ? void 0 : a.disabledCodec),
                            preferredCodec: Hh(null === (d = h.p2p) || void 0 === d ? void 0 : d.preferredCodec)
                        }
                    };
                    if (this.codecSelection = new Ma(this, u), this._statsCurrentId = h.statisticsId ? h.statisticsId : Ho.callStatsUserName, this.room = this.xmpp.createRoom(this.options.name, {
                            ...h,
                            statsId: this._statsCurrentId
                        }, $h.resourceCreator), this._signalingLayer.setChatRoom(this.room), this._signalingLayer.on(vc.SOURCE_UPDATED, ((e, t, n, i) => {
                            const r = this.participants.get(t),
                                o = Cc(e);
                            r && (r._setSources(o, n, e, i), this.eventEmitter.emit($e, r))
                        })), this._onIceConnectionInterrupted = this._onIceConnectionInterrupted.bind(this), this.room.addListener(Hi.XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this), this.room.addListener(Hi.XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored), this._onIceConnectionEstablished = this._onIceConnectionEstablished.bind(this), this.room.addListener(Hi.XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), this._updateProperties = this._updateProperties.bind(this), this.room.addListener(Hi.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), this._sendConferenceJoinAnalyticsEvent = this._sendConferenceJoinAnalyticsEvent.bind(this), this.room.addListener(Hi.XMPPEvents.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), this._removeLocalSourceOnReject = this._removeLocalSourceOnReject.bind(this), this._updateRoomPresence = this._updateRoomPresence.bind(this), this.room.addListener(Hi.XMPPEvents.SESSION_ACCEPT, this._updateRoomPresence), this.room.addListener(Hi.XMPPEvents.SOURCE_ADD, this._updateRoomPresence), this.room.addListener(Hi.XMPPEvents.SOURCE_ADD_ERROR, this._removeLocalSourceOnReject), this.room.addListener(Hi.XMPPEvents.SOURCE_REMOVE, this._updateRoomPresence), null !== (c = h.e2eping) && void 0 !== c && c.enabled && (this.e2eping = new ql(this, h, ((e, t) => {
                            try {
                                this.sendMessage(e, t, !0)
                            } catch (e) {
                                Uh.warn("Failed to send E2E ping request or response.", e && e.msg)
                            }
                        }))), this.rtc || (this.rtc = new ul(this, l), this.eventManager.setupRTCListeners(), this._registerRtcListeners(this.rtc)), this.receiveVideoController = new eh(this, this.rtc), this.sendVideoController = new nh(this, this.rtc), this.statistics || (this.statistics = new Mi(this, {
                            aliasName: this._statsCurrentId,
                            userName: h.statisticsDisplayName ? h.statisticsDisplayName : this.myUserId(),
                            confID: h.confID || `${this.connection.options.hosts.domain}/${this.options.name}`,
                            siteID: h.siteID,
                            roomName: this.options.name,
                            applicationName: h.applicationName
                        }), Mi.analytics.addPermanentProperties({
                            callstats_name: this._statsCurrentId
                        }), h.longTasksStatsInterval && this.statistics.attachLongTasksStats()), this.eventManager.setupChatRoomListeners(), this.eventManager.setupStatisticsListeners(), h.enableTalkWhileMuted && ci.supportsVADDetection())
                        if (h.createVADProcessor) {
                            Uh.info("Using VAD detection for generating talk while muted events"), this._audioAnalyser || (this._audioAnalyser = new Ll(this, h.createVADProcessor));
                            const e = new jl;
                            e.on(Pl, (() => this.eventEmitter.emit(et))), this._audioAnalyser.addVADDetectionService(e)
                        } else Uh.warn("No VAD Processor was provided. Talk while muted detection service was not initialized!");
                    if (h.enableNoisyMicDetection && ci.supportsVADDetection())
                        if (h.createVADProcessor) {
                            this._audioAnalyser || (this._audioAnalyser = new Ll(this, h.createVADProcessor));
                            const e = new Fl;
                            e.on(Al, (() => this.eventEmitter.emit(je))), this._audioAnalyser.addVADDetectionService(e)
                        } else Uh.warn("No VAD Processor was provided. Noisy microphone detection service was not initialized!");
                    h.enableNoAudioDetection && !h.disableAudioLevels && _i.isLocalStatsSupported() && (this._noAudioSignalDetection = new Dl(this), this._noAudioSignalDetection.on(Rl, (() => {
                        this.eventEmitter.emit(Fe)
                    })), this._noAudioSignalDetection.on(xl, (e => {
                        this.eventEmitter.emit(z, e)
                    }))), "channelLastN" in h && this.setLastN(h.channelLastN), this.jvb121Status = new zl(this), this.p2pDominantSpeakerDetection = new Ol(this), h && h.deploymentInfo && h.deploymentInfo.userRegion && this.setLocalParticipantProperty("region", h.deploymentInfo.userRegion), this.setLocalParticipantProperty("codecList", this.codecSelection.getCodecPreferenceList("jvb")), h && h.transcriptionLanguage && "en-US" !== h.transcriptionLanguage && this.setLocalParticipantProperty("transcription_language", h.transcriptionLanguage)
                }, $h.prototype.join = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    this.room && this.room.join(e, t).then((() => this._maybeSetSITimeout()))
                }, $h.prototype.authenticateAndUpgradeRole = function(e) {
                    return Pa.call(this, {
                        ...e,
                        onCreateResource: $h.resourceCreator
                    })
                }, $h.prototype.isJoined = function() {
                    return this.room && this.room.joined
                }, $h.prototype.isP2PEnabled = function() {
                    return Boolean(this.options.config.p2p && this.options.config.p2p.enabled) || void 0 === this.options.config.p2p
                }, $h.prototype.isP2PTestModeEnabled = function() {
                    return Boolean(this.options.config.testing && this.options.config.testing.p2pTestMode)
                }, $h.prototype.leave = async function(e) {
                        if (this.avgRtpStatsReporter && (this.avgRtpStatsReporter.dispose(), this.avgRtpStatsReporter = null), this._audioOutputProblemDetector && (this._audioOutputProblemDetector.dispose(), this._audioOutputProblemDetector = null), this.e2eping && (this.e2eping.stop(), this.e2eping = null), this.getLocalTracks().forEach((e => this.onLocalTrackRemoved(e))), this.rtc.closeBridgeChannel(), this._sendConferenceLeftAnalyticsEvent(), this.statistics && this.statistics.dispose(), this._delayedIceFailed && this._delayedIceFailed.cancel(), this._maybeClearSITimeout(), this.jvbJingleSession && (this.jvbJingleSession.close(), this.jvbJingleSession = null), this.p2pJingleSession && (this.p2pJingleSession.close(), this.p2pJingleSession = null), !this.room) throw new Error("You have already left the conference");
                        const t = this.room;
                        let n;
                        t.removeListener(Hi.XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), t.removeListener(Hi.XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored), t.removeListener(Hi.XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), t.removeListener(Hi.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), t.removeListener(Hi.XMPPEvents.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), t.removeListener(Hi.XMPPEvents.SESSION_ACCEPT, this._updateRoomPresence), t.removeListener(Hi.XMPPEvents.SOURCE_ADD, this._updateRoomPresence), t.removeListener(Hi.XMPPEvents.SOURCE_ADD_ERROR, this._removeLocalSourceOnReject), t.removeListener(Hi.XMPPEvents.SOURCE_REMOVE, this._updateRoomPresence), this.eventManager.removeXMPPListeners(), this._signalingLayer.setChatRoom(null), this.room = null;
                        try {
                            await t.leave(e)
                        } catch (e) {
                            n = e, this.getParticipants().forEach((e => this.onMemberLeft(e.getJid())))
                        }
                        if (this.rtc && this.rtc.destroy(), n) throw n
                    }, $h.prototype.isEndConferenceSupported = function() {
                        return Boolean(this.room && this.room.xmpp.endConferenceComponentAddress)
                    }, $h.prototype.end = function() {
                        if (this.isEndConferenceSupported()) {
                            if (!this.room) throw new Error("You have already left the conference");
                            this.room.end()
                        } else Uh.warn("Cannot end conference: is not supported.")
                    }, $h.prototype.getActiveMediaSession = function() {
                        return this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession
                    }, $h.prototype.getMediaSessions = function() {
                        const e = [];
                        return this.jvbJingleSession && e.push(this.jvbJingleSession), this.p2pJingleSession && e.push(this.p2pJingleSession), e
                    }, $h.prototype._registerRtcListeners = function(e) {
                        e.addListener(ji.default.DATA_CHANNEL_OPEN, (() => {
                            for (const e of this.rtc.localTracks) e.isVideoTrack() && this._sendBridgeVideoTypeMessage(e)
                        }))
                    }, $h.prototype._sendBridgeVideoTypeMessage = function(e) {
                        let t = !e || e.isMuted() ? Vh.NONE : e.getVideoType();
                        t === Vh.DESKTOP && this._desktopSharingFrameRate > 5 && (t = Vh.DESKTOP_HIGH_FPS), e && this.rtc.sendSourceVideoType(e.getSourceName(), t)
                    }, $h.prototype.getName = function() {
                        return this.options.name.toString()
                    }, $h.prototype.getConnection = function() {
                        return this.connection
                    }, $h.prototype.isAuthEnabled = function() {
                        return this.authEnabled
                    }, $h.prototype.isLoggedIn = function() {
                        return Boolean(this.authIdentity)
                    }, $h.prototype.getAuthLogin = function() {
                        return this.authIdentity
                    }, $h.prototype.getLocalTracks = function(e) {
                        let t = [];
                        return this.rtc && (t = this.rtc.getLocalTracks(e)), t
                    }, $h.prototype.getLocalAudioTrack = function() {
                        return this.rtc ? this.rtc.getLocalAudioTrack() : null
                    }, $h.prototype.getLocalVideoTrack = function() {
                        return this.rtc ? this.rtc.getLocalVideoTrack() : null
                    }, $h.prototype.getLocalVideoTracks = function() {
                        return this.rtc ? this.rtc.getLocalVideoTracks() : null
                    }, $h.prototype.getPerformanceStats = function() {
                        return {
                            longTasksStats: this.statistics.getLongTasksStats()
                        }
                    }, $h.prototype.on = function(e, t) {
                        this.eventEmitter && this.eventEmitter.on(e, t)
                    }, $h.prototype.once = function(e, t) {
                        this.eventEmitter && this.eventEmitter.once(e, t)
                    }, $h.prototype.off = function(e, t) {
                        this.eventEmitter && this.eventEmitter.removeListener(e, t)
                    }, $h.prototype.addEventListener = $h.prototype.on, $h.prototype.removeEventListener = $h.prototype.off, $h.prototype.addCommandListener = function(e, t) {
                        this.room && this.room.addPresenceListener(e, t)
                    }, $h.prototype.removeCommandListener = function(e, t) {
                        this.room && this.room.removePresenceListener(e, t)
                    }, $h.prototype.sendTextMessage = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body";
                        this.room && this.room.sendMessage(e, t)
                    }, $h.prototype.sendPrivateTextMessage = function(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "body";
                        this.room && this.room.sendPrivateMessage(e, t, n)
                    }, $h.prototype.sendCommand = function(e, t) {
                        this.room ? this.room.addOrReplaceInPresence(e, t) && this.room.sendPresence() : Uh.warn("Not sending a command, room not initialized.")
                    }, $h.prototype.sendCommandOnce = function(e, t) {
                        this.sendCommand(e, t), this.removeCommand(e)
                    }, $h.prototype.removeCommand = function(e) {
                        this.room && this.room.removeFromPresence(e)
                    }, $h.prototype.setDisplayName = function(e) {
                        if (this.room) {
                            const t = "nick";
                            e ? this.room.addOrReplaceInPresence(t, {
                                attributes: {
                                    xmlns: "http://jabber.org/protocol/nick"
                                },
                                value: e
                            }) && this.room.sendPresence() : this.room.getFromPresence(t) && (this.room.removeFromPresence(t), this.room.sendPresence())
                        }
                    }, $h.prototype.setSubject = function(e) {
                        this.room && this.isModerator() ? this.room.setSubject(e) : Uh.warn(`Failed to set subject, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
                    }, $h.prototype.getTranscriptionStatus = function() {
                        return this.room.transcriptionStatus
                    }, $h.prototype.addTrack = function(e) {
                        if (!e) throw new Error("addTrack - a track is required");
                        const t = e.getType(),
                            n = this.rtc.getLocalTracks(t);
                        if (n.length > 0) {
                            if (e === n[0]) return Promise.resolve(e);
                            if (t === Ri.VIDEO && !n.find((t => t.getVideoType() === e.getVideoType()))) {
                                var i;
                                const n = Tc(this.myUserId(), t, null === (i = this.getLocalTracks(t)) || void 0 === i ? void 0 : i.length);
                                e.setSourceName(n);
                                const r = [];
                                return this.p2pJingleSession && r.push(this.p2pJingleSession.addTracks([e])), this.jvbJingleSession && r.push(this.jvbJingleSession.addTracks([e])), Promise.all(r).then((() => {
                                    this._setupNewTrack(e), this._sendBridgeVideoTypeMessage(e), this._updateRoomPresence(this.getActiveMediaSession()), (this.isMutedByFocus || this.isVideoMutedByFocus) && this._fireMuteChangeEvent(e)
                                }))
                            }
                            return Promise.reject(new Error(`Cannot add second ${t} track to the conference`))
                        }
                        return this.replaceTrack(null, e).then((() => {
                            e.getVideoType() === Yo.VideoType.DESKTOP && this._updateRoomPresence(this.getActiveMediaSession())
                        }))
                    }, $h.prototype._fireAudioLevelChangeEvent = function(e, t) {
                        const n = this.getActivePeerConnection();
                        t && n !== t || this.eventEmitter.emit(nt, this.myUserId(), e)
                    }, $h.prototype._fireMuteChangeEvent = function(e) {
                        let t;
                        if (this.isMutedByFocus && e.isAudioTrack() && !e.isMuted() ? (this.isMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1, Ri.AUDIO)) : this.isVideoMutedByFocus && e.isVideoTrack() && !e.isMuted() && (this.isVideoMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1, Ri.VIDEO)), this.mutedByFocusActor && e.isAudioTrack()) {
                            const e = St.Strophe.getResourceFromJid(this.mutedByFocusActor);
                            t = this.participants.get(e)
                        } else if (this.mutedVideoByFocusActor && e.isVideoTrack()) {
                            const e = St.Strophe.getResourceFromJid(this.mutedVideoByFocusActor);
                            t = this.participants.get(e)
                        }
                        const n = ci.isReactNative() ? e.videoType === Yo.VideoType.DESKTOP : ci.doesVideoMuteByStreamRemove();
                        e.isVideoTrack() && !n && this._sendBridgeVideoTypeMessage(e), this.eventEmitter.emit(it, e, t)
                    }, $h.prototype._getInitialLocalTracks = function() {
                        return this.getLocalTracks().filter((e => {
                            const t = e.getType();
                            return !(t !== Ri.AUDIO || (this.isStartAudioMuted() || this.startMutedPolicy.audio) && !ci.isWebKitBased() && !ci.isReactNative()) || t === Ri.VIDEO && !this.isStartVideoMuted() && !this.startMutedPolicy.video || (this.onLocalTrackRemoved(e), !1)
                        }))
                    }, $h.prototype.onLocalTrackRemoved = function(e) {
                        e.setConference(null), this.rtc.removeLocalTrack(e), e.removeEventListener(Rt, e.muteHandler), e.isAudioTrack() && e.removeEventListener(Ct, e.audioLevelHandler), this.eventEmitter.emit(rt, e)
                    }, $h.prototype.removeTrack = function(e) {
                        return this.replaceTrack(e, null)
                    }, $h.prototype.replaceTrack = function(e, t) {
                        const n = null == e ? void 0 : e.getVideoType(),
                            i = (null == e ? void 0 : e.getType()) || (null == t ? void 0 : t.getType()),
                            r = null == t ? void 0 : t.getVideoType();
                        if (e && t && n !== r) throw new Error(`Replacing a track of videoType=${n} with a track of videoType=${r} is not supported in this mode.`);
                        if (t) {
                            var o;
                            const n = e ? e.getSourceName() : Tc(this.myUserId(), i, null === (o = this.getLocalTracks(i)) || void 0 === o ? void 0 : o.length);
                            t.setSourceName(n)
                        }
                        const s = this === (null == e ? void 0 : e.conference);
                        return s && e.disposed || null != t && t.disposed ? Promise.reject(new dr(tr)) : (e && !s && Uh.warn(`JitsiConference.replaceTrack oldTrack (${e} does not belong to this conference`), this._doReplaceTrack(s ? e : null, t).then((() => (!s || e.isMuted() || t || e._sendMuteStatus(!0), s && this.onLocalTrackRemoved(e), t && this._setupNewTrack(t), (s && null != e && e.isVideoTrack() || null != t && t.isVideoTrack()) && this._sendBridgeVideoTypeMessage(t), this._updateRoomPresence(this.getActiveMediaSession()), null !== t && (this.isMutedByFocus || this.isVideoMutedByFocus) && this._fireMuteChangeEvent(t), Promise.resolve()))).catch((e => (Uh.error(`replaceTrack failed: ${null==e?void 0:e.stack}`), Promise.reject(e)))))
                    }, $h.prototype._doReplaceTrack = function(e, t) {
                        const n = [];
                        return this.jvbJingleSession ? n.push(this.jvbJingleSession.replaceTrack(e, t)) : Uh.info("_doReplaceTrack - no JVB JingleSession"), this.p2pJingleSession ? n.push(this.p2pJingleSession.replaceTrack(e, t)) : Uh.info("_doReplaceTrack - no P2P JingleSession"), Promise.all(n)
                    }, $h.prototype._removeLocalSourceOnReject = function(e, t, n) {
                        if (!e) return;
                        Uh.warn(`Source-add rejected on ${e}, reason="${null==t?void 0:t.reason}", message="${null==t?void 0:t.msg}"`);
                        const i = this.getLocalTracks(n)[0];
                        this.eventEmitter.emit(ot, i)
                    }, $h.prototype._setupNewTrack = function(e) {
                        const t = e.getType();
                        if (!e.getSourceName()) {
                            var n;
                            const i = Tc(this.myUserId(), t, null === (n = this.getLocalTracks(t)) || void 0 === n ? void 0 : n.length);
                            e.setSourceName(i)
                        }
                        this.rtc.addLocalTrack(e), e.setConference(this), this.isP2PActive() && this._suspendMediaTransferForJvbConnection(), e.muteHandler = this._fireMuteChangeEvent.bind(this, e), e.addEventListener(Rt, e.muteHandler), e.isAudioTrack() && (e.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this), e.addEventListener(Ct, e.audioLevelHandler)), this.eventEmitter.emit(tt, e)
                    }, $h.prototype._setNewVideoType = function(e) {
                        let t = !1;
                        return e && (t = this._signalingLayer.setTrackVideoType(e.getSourceName(), e.videoType)), t
                    }, $h.prototype._setTrackMuteStatus = function(e, t, n) {
                        let i = !1;
                        return t && (i = this._signalingLayer.setTrackMuteStatus(t.getSourceName(), n), i && Uh.debug(`Mute state of ${t} changed to muted=${n}`)), i
                    }, $h.prototype._addLocalTrackToPc = function(e) {
                        const t = [];
                        return e.conference === this ? (this.jvbJingleSession ? t.push(this.jvbJingleSession.addTrackToPc(e)) : Uh.debug("Add local MediaStream - no JVB Jingle session started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.addTrackToPc(e)) : Uh.debug("Add local MediaStream - no P2P Jingle session started yet")) : t.push(this.addTrack(e)), Promise.allSettled(t)
                    }, $h.prototype._removeLocalTrackFromPc = function(e) {
                        const t = [];
                        return e.conference === this && (this.jvbJingleSession ? t.push(this.jvbJingleSession.removeTrackFromPc(e)) : Uh.debug("Remove local MediaStream - no JVB JingleSession started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.removeTrackFromPc(e)) : Uh.debug("Remove local MediaStream - no P2P JingleSession started yet")), Promise.allSettled(t)
                    }, $h.prototype.getRole = function() {
                        return this.room.role
                    }, $h.prototype.isHidden = function() {
                        return this.connection ? St.Strophe.getDomainFromJid(this.connection.getJid()) === this.options.config.hiddenDomain : null
                    }, $h.prototype.isModerator = function() {
                        return this.room ? this.room.isModerator() : null
                    }, $h.prototype.lock = function(e) {
                        return this.isModerator() ? new Promise(((t, n) => {
                            this.room.lockRoom(e || "", (() => t()), (e => n(e)), (() => n(U)))
                        })) : Promise.reject(new Error("You are not moderator."))
                    }, $h.prototype.unlock = function() {
                        return this.lock()
                    }, $h.prototype.getLastN = function() {
                        return this.receiveVideoController.getLastN()
                    }, $h.prototype.getForwardedSources = function() {
                        return this.rtc.getForwardedSources()
                    }, $h.prototype.setLastN = function(e) {
                        if (!Number.isInteger(e) && !Number.parseInt(e, 10)) throw new Error(`Invalid value for lastN: ${e}`);
                        const t = Number(e);
                        if (t < -1) throw new RangeError("lastN cannot be smaller than -1");
                        if (this.receiveVideoController.setLastN(t), this.p2pJingleSession) {
                            const e = 0 !== t;
                            this.p2pJingleSession.setP2pVideoTransferActive(e).catch((t => {
                                Uh.error(`Failed to adjust video transfer status (${e})`, t)
                            }))
                        }
                    }, $h.prototype.getParticipants = function() {
                        return Array.from(this.participants.values())
                    }, $h.prototype.getParticipantCount = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                            t = this.getParticipants();
                        return e || (t = t.filter((e => !e.isHidden()))), t.length + 1
                    }, $h.prototype.getParticipantById = function(e) {
                        return this.participants.get(e)
                    }, $h.prototype.grantOwner = function(e) {
                        const t = this.getParticipantById(e);
                        t && this.room.setAffiliation(t.getConnectionJid(), "owner")
                    }, $h.prototype.revokeOwner = function(e) {
                        const t = this.getParticipantById(e),
                            n = this.myUserId() === e,
                            i = this.isMembersOnly() ? "member" : "none";
                        n ? this.room.setAffiliation(this.connection.getJid(), i) : t && this.room.setAffiliation(t.getConnectionJid(), i)
                    }, $h.prototype.kickParticipant = function(e, t) {
                        const n = this.getParticipantById(e);
                        n && this.room.kick(n.getJid(), t)
                    }, $h.prototype._maybeClearSITimeout = function() {
                        this._sessionInitiateTimeout && (this.jvbJingleSession || this.getParticipantCount() < 2) && (window.clearTimeout(this._sessionInitiateTimeout), this._sessionInitiateTimeout = null)
                    }, $h.prototype._maybeSetSITimeout = function() {
                        !this.jvbJingleSession && this.getParticipantCount() >= 2 && !this._sessionInitiateTimeout && (this._sessionInitiateTimeout = window.setTimeout((() => {
                            this._sessionInitiateTimeout = null, Mi.sendAnalytics(dn(Ht, {
                                p2p: !1,
                                value: 5e3
                            }))
                        }), 5e3))
                    }, $h.prototype.muteParticipant = function(e, t) {
                        const n = t || Ri.AUDIO;
                        if (n !== Ri.AUDIO && n !== Ri.VIDEO) return void Uh.error(`Unsupported media type: ${n}`);
                        const i = this.getParticipantById(e);
                        i && this.room.muteParticipant(i.getJid(), !0, n)
                    }, $h.prototype.onMemberJoined = function(e, t, n, i, r, o, s, a, d, c, l) {
                        var h, u, p, m;
                        const g = St.Strophe.getResourceFromJid(e);
                        if ("focus" === g || this.myUserId() === g) return;
                        const f = new Bi(e, this, t, i, r, o, s);
                        f.setConnectionJid(d), f.setRole(n), f.setBotType(a), f.setFeatures(c), f.setIsReplacing(l);
                        const v = this.isP2PActive() ? null !== (h = null === (u = this.p2pJingleSession) || void 0 === u ? void 0 : u.peerconnection.getRemoteTracks(g)) && void 0 !== h ? h : [] : null !== (p = null === (m = this.jvbJingleSession) || void 0 === m ? void 0 : m.peerconnection.getRemoteTracks(g)) && void 0 !== p ? p : [];
                        for (const e of v) f._tracks.push(e);
                        this.participants.set(g, f), this.eventEmitter.emit(at, g, f), this._updateFeatures(f), this.isJoined() && this._maybeStartOrStopP2P(), this._maybeSetSITimeout()
                    }, $h.prototype._onMucJoined = function() {
                        this._numberOfParticipantsOnJoin = this.getParticipantCount(), this._maybeStartOrStopP2P()
                    }, $h.prototype._updateFeatures = function(e) {
                        e.getFeatures().then((t => {
                            e._supportsDTMF = t.has("urn:xmpp:jingle:dtmf:0"), this.updateDTMFSupport(), t.has(Aa) && e.setProperty("features_jigasi", !0), t.has(wa) && e.setProperty("features_e2ee", !0)
                        })).catch((() => !1))
                    }, $h.prototype._onMemberBotTypeChanged = function(e, t) {
                        const n = this.getParticipants().find((t => t.getJid() === e));
                        if (n) {
                            n.setBotType(t);
                            const i = St.Strophe.getResourceFromJid(e);
                            this.eventEmitter.emit(ne, i, t)
                        }
                        n.getBotType() || this._maybeStartOrStopP2P()
                    }, $h.prototype.onMemberLeft = function(e, t) {
                        const n = St.Strophe.getResourceFromJid(e);
                        if ("focus" === n || this.myUserId() === n) return;
                        const i = this.getMediaSessions();
                        let r = [];
                        for (const e of i) {
                            const t = e.peerconnection.getRemoteTracks(n);
                            t && (r = [...r, ...t]), e._signalingLayer.updateSsrcOwnersOnLeave(n), Ai.isSsrcRewritingSupported() || e.removeRemoteStreamsOnLeave(n)
                        }
                        r.forEach((e => {
                            Ai.isSsrcRewritingSupported() ? (e.setSourceName(null), e.setOwner(null)) : this.eventEmitter.emit(rt, e)
                        }));
                        const o = this.participants.get(n);
                        o && (this.participants.delete(n), this.eventEmitter.emit(dt, n, o, t)), null !== this.room && (this._maybeStartOrStopP2P(!0), this._maybeClearSITimeout())
                    }, $h.prototype.onMemberKicked = function(e, t, n, i, r) {
                        if (t === this.myUserId()) return;
                        const o = this.participants.get(t);
                        if (e) return this.leave().finally((() => this.xmpp.disconnect())), void this.eventEmitter.emit(we, o, i, r);
                        const s = this.participants.get(n);
                        s.setIsReplaced(r), this.eventEmitter.emit(He, o, s, i)
                    }, $h.prototype.onLocalRoleChanged = function(e) {
                        this.eventEmitter.emit(ct, this.myUserId(), e)
                    }, $h.prototype.onUserRoleChanged = function(e, t) {
                        const n = St.Strophe.getResourceFromJid(e),
                            i = this.getParticipantById(n);
                        i && (i.setRole(t), this.eventEmitter.emit(ct, n, t))
                    }, $h.prototype.onDisplayNameChanged = function(e, t) {
                        const n = St.Strophe.getResourceFromJid(e),
                            i = this.getParticipantById(n);
                        i && i._displayName !== t && (i._displayName = t, this.eventEmitter.emit(_e, n, t))
                    }, $h.prototype.onRemoteTrackAdded = function(e) {
                        if (e.isP2P && !this.isP2PActive()) return void Uh.info("Trying to add remote P2P track, when not in P2P - IGNORED");
                        if (!e.isP2P && this.isP2PActive()) return void Uh.info("Trying to add remote JVB track, when in P2P - IGNORED");
                        const t = e.getParticipantId(),
                            n = this.getParticipantById(t);
                        n ? n._tracks.push(e) : Uh.info(`Source signaling received before presence for ${t}`);
                        const i = this.eventEmitter;
                        e.addEventListener(Rt, (() => i.emit(it, e))), e.isAudioTrack() && e.addEventListener(Ct, ((e, n) => {
                            this.getActivePeerConnection() === n && i.emit(nt, t, e)
                        })), i.emit(tt, e)
                    }, $h.prototype.onCallAccepted = function(e, t) {
                        this.p2pJingleSession === e && (Uh.info("P2P setAnswer"), this.p2pJingleSession.setAnswer(t), this.eventEmitter.emit(q, this.p2pJingleSession))
                    }, $h.prototype.onTransportInfo = function(e, t) {
                        this.p2pJingleSession === e && (Uh.info("P2P addIceCandidates"), this.p2pJingleSession.addIceCandidates(t))
                    }, $h.prototype.onRemoteTrackRemoved = function(e) {
                        this.getParticipants().forEach((t => {
                            const n = t.getTracks();
                            for (let i = 0; i < n.length; i++)
                                if (n[i] === e) {
                                    t._tracks.splice(i, 1), this.eventEmitter.emit(rt, e);
                                    break
                                }
                        }), this)
                    }, $h.prototype._onIncomingCallP2P = function(e, t) {
                        let n;
                        const i = t.find(">content").attr("name");
                        "0" === i || "1" === i ? !this.isP2PEnabled() && !this.isP2PTestModeEnabled() || ci.isFirefox() && !this._firefoxP2pEnabled ? n = {
                            reason: "decline",
                            reasonDescription: "P2P disabled",
                            errorMsg: "P2P mode disabled in the configuration or browser unsupported"
                        } : this.p2pJingleSession ? n = {
                            reason: "busy",
                            reasonDescription: "P2P already in progress",
                            errorMsg: 'Duplicated P2P "session-initiate"'
                        } : this._shouldBeInP2PMode() || (n = {
                            reason: "decline",
                            reasonDescription: "P2P requirements not met",
                            errorMsg: 'Received P2P "session-initiate" when should not be in P2P mode'
                        }, Mi.sendAnalytics(dn(qt))) : n = {
                            reason: "decline",
                            reasonDescription: "P2P disabled",
                            errorMsg: "P2P across two endpoints in different SDP modes is disabled"
                        }, n ? this._rejectIncomingCall(e, n) : this._acceptP2PIncomingCall(e, t)
                    }, $h.prototype.onIncomingCall = function(e, t, n) {
                        if (e.isP2P) this._onIncomingCallP2P(e, t);
                        else {
                            if (!this.isFocus(e.remoteJid)) {
                                const t = "Rejecting session-initiate from non-focus.";
                                return void this._rejectIncomingCall(e, {
                                    reason: "security-error",
                                    reasonDescription: t,
                                    errorMsg: t
                                })
                            }
                            this._acceptJvbIncomingCall(e, t, n)
                        }
                    }, $h.prototype._acceptJvbIncomingCall = function(e, t, n) {
                        this.jvbJingleSession = e, this.room.connectionTimes["session.initiate"] = n, this._sendConferenceJoinAnalyticsEvent(), this.wasStopped && Mi.sendAnalyticsAndLog(dn(jt, {
                            p2p: !1
                        }));
                        const i = _t()(t).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("region");
                        this.eventEmitter.emit(We, i), this._maybeClearSITimeout(), Mi.sendAnalytics(dn(Ut, {
                            p2p: !1,
                            value: n
                        }));
                        try {
                            e.initialize(this.room, this.rtc, this._signalingLayer, {
                                ...this.options.config,
                                codecSettings: {
                                    mediaType: Ri.VIDEO,
                                    codecList: this.codecSelection.getCodecPreferenceList("jvb")
                                },
                                enableInsertableStreams: this.isE2EEEnabled() || Ai.isRunInLiteModeEnabled()
                            })
                        } catch (e) {
                            return void Uh.error(e)
                        }
                        this._setBridgeChannel(t, e.peerconnection);
                        const r = this._getInitialLocalTracks();
                        try {
                            e.acceptOffer(t, (() => {
                                this.isP2PActive() && this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), this.eventEmitter.emit(q, e), this.isP2PActive() || this.eventEmitter.emit(G, e)
                            }), (e => {
                                Uh.error("Failed to accept incoming Jingle session", e)
                            }), r), this._desktopSharingFrameRate && e.peerconnection.setDesktopSharingFrameRate(this._desktopSharingFrameRate), this.statistics.startRemoteStats(this.jvbJingleSession.peerconnection)
                        } catch (e) {
                            Uh.error(e)
                        }
                    }, $h.prototype._setBridgeChannel = function(e, t) {
                        var n, i, r, o, s, a, d;
                        const c = null === (n = this.connection) || void 0 === n || null === (i = n.options) || void 0 === i || null === (r = i.bridgeChannel) || void 0 === r ? void 0 : r.ignoreDomain,
                            l = null !== (o = null === (s = this.connection) || void 0 === s || null === (a = s.options) || void 0 === a || null === (d = a.bridgeChannel) || void 0 === d ? void 0 : d.preferSctp) && void 0 !== o && o,
                            h = 1 === _t()(e).find('>content[name="data"]').first().length;
                        let u = null;
                        if (Uh.info(`SCTP: offered=${h}, prefered=${l}`), !(h && l || (_t()(e).find(">content>transport>web-socket").toArray().map((e => e.getAttribute("url"))).forEach((e => {
                                u || c && c === new URL(e).hostname ? u || Uh.info(`Ignoring colibri-ws url with domain ${c}`) : (u = e, Uh.info(`Using colibri-ws url ${e}`))
                            })), u))) {
                            const t = _t()(e).find(">content>transport>web-socket").first();
                            1 === t.length && (u = t[0].getAttribute("url"), Uh.info(`Falling back to ${u}`))
                        }!u || h && l ? h ? this.rtc.initializeBridgeChannel(t, null) : Uh.warn("Neither SCTP nor a websocket is available. Will not initialize bridge channel.") : this.rtc.initializeBridgeChannel(null, u)
                    }, $h.prototype._rejectIncomingCall = function(e, t) {
                        null != t && t.errorMsg && Uh.warn(t.errorMsg), e.terminate(null, (e => {
                            Uh.warn("An error occurred while trying to terminate invalid Jingle session", e)
                        }), {
                            reason: t && t.reason,
                            reasonDescription: t && t.reasonDescription,
                            sendSessionTerminate: !0
                        })
                    }, $h.prototype.onCallEnded = function(e, t, n) {
                        if (Uh.info(`Call ended: ${t} - ${n} P2P ?${e.isP2P}`), e === this.jvbJingleSession) this.wasStopped = !0, Mi.sendAnalytics(dn($t, {
                            p2p: !1
                        })), this.statistics && this.statistics.stopRemoteStats(this.jvbJingleSession.peerconnection), this.jvbJingleSession = null, this.rtc.onCallEnded();
                        else if (e === this.p2pJingleSession) {
                            const e = {};
                            "connectivity-error" === t && "ICE FAILED" === n ? Mi.analytics.addPermanentProperties({
                                p2pFailed: !0
                            }) : "success" === t && "restart" === n && (e.requestRestart = !0), this._stopP2PSession(e)
                        } else Uh.error("Received onCallEnded for invalid session", e.sid, e.remoteJid, t, n)
                    }, $h.prototype.onSuspendDetected = function(e) {
                        e.isP2P || (this.leave(), this.eventEmitter.emit(Ze))
                    }, $h.prototype.updateDTMFSupport = function() {
                        let e = !1;
                        const t = this.getParticipants();
                        for (let n = 0; n < t.length; n += 1)
                            if (t[n].supportsDTMF()) {
                                e = !0;
                                break
                            } e !== this.somebodySupportsDTMF && (this.somebodySupportsDTMF = e, this.eventEmitter.emit(Ee, e))
                    }, $h.prototype.isDTMFSupported = function() {
                        return this.somebodySupportsDTMF
                    }, $h.prototype.myUserId = function() {
                        return this.room && this.room.myroomjid ? St.Strophe.getResourceFromJid(this.room.myroomjid) : null
                    }, $h.prototype.sendTones = function(e, t, n) {
                        const i = this.getActivePeerConnection();
                        i ? i.sendTones(e, t, n) : Uh.warn("cannot sendTones: no peer connection")
                    }, $h.prototype.startRecording = function(e) {
                        return this.room ? this.recordingManager.startRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
                    }, $h.prototype.stopRecording = function(e) {
                        return this.room ? this.recordingManager.stopRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
                    }, $h.prototype.isSIPCallingSupported = function() {
                        var e, t, n, i;
                        return null !== (e = null === (t = this.room) || void 0 === t || null === (n = t.xmpp) || void 0 === n || null === (i = n.moderator) || void 0 === i ? void 0 : i.isSipGatewayEnabled()) && void 0 !== e && e
                    }, $h.prototype.dial = function(e) {
                        return this.room ? this.room.dial(e) : Promise.reject(new Error("The conference is not created yet!"))
                    }, $h.prototype.hangup = function() {
                        return this.room ? this.room.hangup() : Promise.resolve()
                    }, $h.prototype.getPhoneNumber = function() {
                        return this.room ? this.room.getPhoneNumber() : null
                    }, $h.prototype.getPhonePin = function() {
                        return this.room ? this.room.getPhonePin() : null
                    }, $h.prototype.getMeetingUniqueId = function() {
                        if (this.room) return this.room.getMeetingId()
                    }, $h.prototype.getActivePeerConnection = function() {
                        const e = this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession;
                        return e ? e.peerconnection : null
                    }, $h.prototype.getConnectionState = function() {
                        const e = this.getActivePeerConnection();
                        return e ? e.getConnectionState() : null
                    }, $h.prototype.setStartMutedPolicy = function(e) {
                        this.isModerator() ? this.room.addOrReplaceInPresence("startmuted", {
                            attributes: {
                                audio: e.audio,
                                video: e.video,
                                xmlns: "http://jitsi.org/jitmeet/start-muted"
                            }
                        }) && this.room.sendPresence() : Uh.warn(`Failed to set start muted policy, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
                    }, $h.prototype.getStartMutedPolicy = function() {
                        return this.startMutedPolicy
                    }, $h.prototype.isStartAudioMuted = function() {
                        return this.startAudioMuted
                    }, $h.prototype.isStartVideoMuted = function() {
                        return this.startVideoMuted
                    }, $h.prototype.getConnectionTimes = function() {
                        return this.room.connectionTimes
                    }, $h.prototype.setLocalParticipantProperty = function(e, t) {
                        this.sendCommand(`jitsi_participant_${e}`, {
                            value: t
                        })
                    }, $h.prototype.removeLocalParticipantProperty = function(e) {
                        this.removeCommand(`jitsi_participant_${e}`), this.room.sendPresence()
                    }, $h.prototype.getLocalParticipantProperty = function(e) {
                        const t = this.room.presMap.nodes.find((t => t.tagName === `jitsi_participant_${e}`));
                        return t ? t.value : void 0
                    }, $h.prototype.sendFeedback = function(e, t) {
                        return this.statistics.sendFeedback(e, t)
                    }, $h.prototype.isCallstatsEnabled = function() {
                        return Uh.warn("Callstats is no longer supported"), !1
                    }, $h.prototype.getSsrcByTrack = function(e) {
                        var t;
                        return e.isLocal() ? null === (t = this.getActivePeerConnection()) || void 0 === t ? void 0 : t.getLocalSSRC(e) : e.getSSRC()
                    }, $h.prototype.sendApplicationLog = function() {}, $h.prototype.isFocus = function(e) {
                        return this.room ? this.room.isFocus(e) : null
                    }, $h.prototype._fireIncompatibleVersionsEvent = function() {
                        this.eventEmitter.emit(ae, j)
                    }, $h.prototype.sendEndpointMessage = function(e, t) {
                        this.rtc.sendChannelMessage(e, t)
                    }, $h.prototype.sendEndpointStatsMessage = function(e) {
                        this.rtc.sendEndpointStatsMessage(e)
                    }, $h.prototype.broadcastEndpointMessage = function(e) {
                        this.sendEndpointMessage("", e)
                    }, $h.prototype.sendMessage = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                            n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        const i = typeof e;
                        if ("object" === i || !n && "string" === i)
                            if (n) this.sendEndpointMessage(t, e);
                            else {
                                let n = e,
                                    r = "body";
                                if ("object" === i) {
                                    r = "json-message", n.hasOwnProperty(Ra) || (n[Ra] = "");
                                    try {
                                        n = JSON.stringify(n)
                                    } catch (e) {
                                        return void Uh.error("Can not send a message, stringify failed: ", e)
                                    }
                                }
                                t ? this.sendPrivateTextMessage(t, n, r) : this.sendTextMessage(n, r)
                            }
                        else Uh.error(`Can not send a message of type ${i}`)
                    }, $h.prototype.isConnectionInterrupted = function() {
                        return this.isP2PActive() ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted
                    }, $h.prototype._onConferenceRestarted = function(e) {
                        !e.isP2P && this.options.config.enableForcedReload && this.eventEmitter.emit(ae, I)
                    }, $h.prototype._onIceConnectionInterrupted = function(e) {
                        e.isP2P ? this.isP2PConnectionInterrupted = !0 : this.isJvbConnectionInterrupted = !0, e.isP2P === this.isP2PActive() && this.eventEmitter.emit(me)
                    }, $h.prototype._onIceConnectionFailed = function(e) {
                        e.isP2P ? (Mi.analytics.addPermanentProperties({
                            p2pFailed: !0
                        }), this.p2pJingleSession && Mi.sendAnalyticsAndLog(cn(zt, {
                            initiator: this.p2pJingleSession.isInitiator
                        })), this._stopP2PSession({
                            reason: "connectivity-error",
                            reasonDescription: "ICE FAILED"
                        })) : e && this.jvbJingleSession === e && (this._delayedIceFailed = new bl(this), this._delayedIceFailed.start(e))
                    }, $h.prototype._onIceConnectionRestored = function(e) {
                        e.isP2P ? this.isP2PConnectionInterrupted = !1 : (this.isJvbConnectionInterrupted = !1, this._delayedIceFailed && this._delayedIceFailed.cancel()), e.isP2P === this.isP2PActive() && this.eventEmitter.emit(ge)
                    }, $h.prototype._acceptP2PIncomingCall = function(e, t) {
                        this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = e, this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, this._signalingLayer, {
                            ...this.options.config,
                            codecSettings: {
                                mediaType: Ri.VIDEO,
                                codecList: this.codecSelection.getCodecPreferenceList("p2p")
                            },
                            enableInsertableStreams: this.isE2EEEnabled() || Ai.isRunInLiteModeEnabled()
                        });
                        const n = this.getLocalTracks();
                        this.p2pJingleSession.acceptOffer(t, (() => {
                            Uh.debug('Got RESULT for P2P "session-accept"'), this.eventEmitter.emit(q, e)
                        }), (e => {
                            Uh.error("Failed to accept incoming P2P Jingle session", e)
                        }), n)
                    }, $h.prototype._addRemoteJVBTracks = function() {
                        this._addRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
                    }, $h.prototype._addRemoteP2PTracks = function() {
                        this._addRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
                    }, $h.prototype._addRemoteTracks = function(e, t) {
                        for (const n of t)(Ai.isSsrcRewritingSupported() || this.participants.has(n.ownerEndpointId)) && (Uh.info(`Adding remote ${e} track: ${n}`), this.onRemoteTrackAdded(n))
                    }, $h.prototype._onIceConnectionEstablished = function(e) {
                        null !== this.p2pJingleSession && (this.p2pEstablishmentDuration = this.p2pJingleSession.establishmentDuration), null !== this.jvbJingleSession && (this.jvbEstablishmentDuration = this.jvbJingleSession.establishmentDuration);
                        let t = !1;
                        if (e.isP2P ? this.p2pJingleSession !== e && (Uh.error("CONNECTION_ESTABLISHED - wrong P2P session instance ?!"), t = !0) : t = !0, !isNaN(this.p2pEstablishmentDuration) && !isNaN(this.jvbEstablishmentDuration)) {
                            const e = this.p2pEstablishmentDuration - this.jvbEstablishmentDuration;
                            Mi.sendAnalytics(Zt, {
                                value: e
                            })
                        }
                        e.isP2P === this.isP2PActive() && this.eventEmitter.emit(pe), t || (this._setP2PStatus(!0), this.jvbJingleSession ? this._removeRemoteJVBTracks() : Uh.info("Not removing remote JVB tracks - no session yet"), this._addRemoteP2PTracks(), this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), Uh.info("Starting remote stats with p2p connection"), this.statistics.startRemoteStats(this.p2pJingleSession.peerconnection), Mi.sendAnalyticsAndLog(cn(Gt, {
                            initiator: this.p2pJingleSession.isInitiator
                        })))
                    }, $h.prototype._updateProperties = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        const t = !Et()(e, this.properties);
                        if (this.properties = e, t) {
                            var n, i;
                            this.eventEmitter.emit(ze, this.properties);
                            const t = "true" === this.properties["audio-limit-reached"],
                                r = "true" === this.properties["video-limit-reached"];
                            this._audioSenderLimitReached !== t && (this._audioSenderLimitReached = t, this.eventEmitter.emit(K, t), Uh.info(`Audio unmute permissions set by Jicofo to ${t}`)), this._videoSenderLimitReached !== r && (this._videoSenderLimitReached = r, this.eventEmitter.emit(pt, r), Uh.info(`Video unmute permissions set by Jicofo to ${r}`)), ["bridge-count"].forEach((t => {
                                void 0 !== e[t] && Mi.analytics.addPermanentProperties({
                                    [t.replace("-", "_")]: e[t]
                                })
                            }));
                            let o = null === (n = this.properties["visitor-codecs"]) || void 0 === n ? void 0 : n.split(",");
                            null !== (i = o) && void 0 !== i && i.length && (o = o.filter((e => "string" == typeof e && e.trim().length && Object.values(Ps).find((t => t === e))))), this._visitorCodecs !== o && (this._visitorCodecs = o, this.eventEmitter.emit(ue, this._visitorCodecs));
                            const s = this._hasVisitors;
                            this._hasVisitors = this.properties["visitor-count"] > 0, s !== this._hasVisitors && this._maybeStartOrStopP2P(!0)
                        }
                    }, $h.prototype.getProperty = function(e) {
                        return this.properties[e]
                    }, $h.prototype._maybeClearDeferredStartP2P = function() {
                        this.deferredStartP2PTask && (Uh.info("Cleared deferred start P2P task"), clearTimeout(this.deferredStartP2PTask), this.deferredStartP2PTask = null)
                    }, $h.prototype._removeRemoteJVBTracks = function() {
                        this._removeRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
                    }, $h.prototype._removeRemoteP2PTracks = function() {
                        this._removeRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
                    }, $h.prototype._removeRemoteTracks = function(e, t) {
                        for (const n of t) Uh.info(`Removing remote ${e} track: ${n}`), this.onRemoteTrackRemoved(n)
                    }, $h.prototype._resumeMediaTransferForJvbConnection = function() {
                        Uh.info("Resuming media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!0).then((() => {
                            Uh.info("Resumed media transfer over the JVB connection!")
                        })).catch((e => {
                            Uh.error("Failed to resume media transfer over the JVB connection:", e)
                        }))
                    }, $h.prototype._setP2PStatus = function(e) {
                        if (this.p2p !== e) {
                            if (this.p2p = e, e) {
                                Uh.info("Peer to peer connection established!"), Mi.analytics.addPermanentProperties({
                                    p2pFailed: !1
                                });
                                const e = 0 !== this.getLastN();
                                this.p2pJingleSession.setP2pVideoTransferActive(e).catch((t => {
                                    Uh.error(`Failed to sync up P2P video transfer status (${e}), ${t}`)
                                }))
                            } else Uh.info("Peer to peer connection closed!");
                            this.dtmfManager = null, this.eventEmitter.emit(Ue, this, this.p2p), this.eventEmitter.emit(G, this.getActiveMediaSession()), this.eventEmitter.emit(this.isConnectionInterrupted() ? me : ge)
                        } else Uh.debug(`Called _setP2PStatus with the same status: ${e}`)
                    }, $h.prototype._startP2PSession = function(e) {
                        if (this._maybeClearDeferredStartP2P(), this.p2pJingleSession) return void Uh.error("P2P session already started!");
                        this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = this.xmpp.connection.jingle.newP2PJingleSession(this.room.myroomjid, e), Uh.info("Created new P2P JingleSession", this.room.myroomjid, e), this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, this._signalingLayer, {
                            ...this.options.config,
                            codecSettings: {
                                mediaType: Ri.VIDEO,
                                codecList: this.codecSelection.getCodecPreferenceList("p2p")
                            },
                            enableInsertableStreams: this.isE2EEEnabled() || Ai.isRunInLiteModeEnabled()
                        });
                        const t = this.getLocalTracks();
                        this.p2pJingleSession.invite(t)
                    }, $h.prototype._suspendMediaTransferForJvbConnection = function() {
                        Uh.info("Suspending media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!1).then((() => {
                            Uh.info("Suspended media transfer over the JVB connection !")
                        })).catch((e => {
                            Uh.error("Failed to suspend media transfer over the JVB connection:", e)
                        }))
                    }, $h.prototype._maybeStartOrStopP2P = function(e) {
                        if (!this.isP2PEnabled() || this.isP2PTestModeEnabled() || ci.isFirefox() && !this._firefoxP2pEnabled || this.isE2EEEnabled()) return void Uh.info("Auto P2P disabled");
                        const t = this.getParticipants(),
                            n = t.length,
                            i = this._shouldBeInP2PMode();
                        if (!i && this.deferredStartP2PTask && this._maybeClearDeferredStartP2P(), !this.p2pJingleSession && i) {
                            const i = n && t[0],
                                r = this.myUserId(),
                                o = i.getId();
                            if (r > o) return void Uh.debug("I'm the bigger peersId - the other peer should start P2P", r, o);
                            if (r === o) return void Uh.error("The same IDs ? ", r, o);
                            const s = i.getJid();
                            if (e) {
                                if (this.deferredStartP2PTask) return void Uh.error("Deferred start P2P task's been set already!");
                                Uh.info(`Will start P2P with: ${s} after ${this.backToP2PDelay} seconds...`), this.deferredStartP2PTask = setTimeout(this._startP2PSession.bind(this, s), 1e3 * this.backToP2PDelay)
                            } else Uh.info(`Will start P2P with: ${s}`), this._startP2PSession(s)
                        } else this.p2pJingleSession && !i && (Uh.info(`Will stop P2P with: ${this.p2pJingleSession.remoteJid}`), this.p2pJingleSession.isInitiator && n > 1 && Mi.sendAnalyticsAndLog(cn(Kt)), this._stopP2PSession())
                    }, $h.prototype._shouldBeInP2PMode = function() {
                        const e = this.getParticipants(),
                            t = e.length,
                            n = void 0 !== e.find((e => "poltergeist" === e.getBotType() || e.hasFeature(Aa))),
                            i = 1 === t && !n && !this._hasVisitors;
                        return Uh.debug(`P2P? peerCount: ${t}, hasBotPeer: ${n} => ${i}`), i
                    }, $h.prototype._stopJvbSession = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        const {
                            requestRestart: t = !1,
                            sendSessionTerminate: n = !1
                        } = e;
                        this.jvbJingleSession ? (!this.isP2PActive() && this._removeRemoteJVBTracks(), Uh.info("Stopping stats for jvb connection"), this.statistics.stopRemoteStats(this.jvbJingleSession.peerconnection), this.jvbJingleSession.terminate((() => {
                            t && n && Uh.info("session-terminate for ice restart - done"), this.jvbJingleSession = null
                        }), (e => {
                            t && n && (Uh.error("session-terminate for ice restart failed: reloading the client"), this.eventEmitter.emit(ae, F)), Uh.error(`An error occurred while trying to terminate the JVB session', reason=${e.reason},msg=${e.msg}`)
                        }), e)) : Uh.error("No JVB session to be stopped")
                    }, $h.prototype._stopP2PSession = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        const {
                            reason: t = "success",
                            reasonDescription: n = "Turning off P2P session",
                            requestRestart: i = !1
                        } = e;
                        if (!this.p2pJingleSession) return void Uh.error("No P2P session to be stopped!");
                        const r = this.isP2PActive();
                        r && (this.jvbJingleSession && !i && this._resumeMediaTransferForJvbConnection(), this._removeRemoteP2PTracks()), Uh.info("Stopping remote stats for P2P connection"), this.statistics.stopRemoteStats(this.p2pJingleSession.peerconnection), this.p2pJingleSession.terminate((() => {
                            Uh.info("P2P session terminate RESULT"), this.p2pJingleSession = null
                        }), (e => {
                            "success" !== t && Uh.error("An error occurred while trying to terminate P2P Jingle session", e)
                        }), {
                            reason: t,
                            reasonDescription: n,
                            sendSessionTerminate: this.room && this.getParticipantById(St.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid))
                        }), this.p2pJingleSession = null, this._setP2PStatus(!1), r && (this.jvbJingleSession && !i ? this._addRemoteJVBTracks() : Uh.info("Not adding remote JVB tracks - no session yet"))
                    }, $h.prototype._updateRoomPresence = function(e, t) {
                        if (!e) return;
                        if (t) {
                            if (t.skip) return;
                            t.skip = !0
                        }
                        let n, i, r = !1;
                        const o = e.peerconnection.getLocalTracks();
                        for (const e of o) {
                            const t = e.isMuted();
                            n = this._setTrackMuteStatus(e.getType(), e, t), n && Uh.debug(`Updating mute state of ${e} in presence to muted=${t}`), e.getType() === Ri.VIDEO && (i = this._setNewVideoType(e), i && Uh.debug(`Updating videoType in presence to ${e.getVideoType()}`)), r = r || n || i
                        }
                        r && this.room.sendPresence()
                    }, $h.prototype.isP2PActive = function() {
                        return this.p2p
                    }, $h.prototype.getP2PConnectionState = function() {
                        return this.isP2PActive() ? this.p2pJingleSession.peerconnection.getConnectionState() : null
                    }, $h.prototype.setDesktopSharingFrameRate = function(e) {
                        return "number" != typeof e || isNaN(e) ? (Uh.error(`Invalid value ${e} specified for desktop capture frame rate`), !1) : (this._desktopSharingFrameRate = e, this.jvbJingleSession && this.jvbJingleSession.peerconnection.setDesktopSharingFrameRate(e), this.rtc.setDesktopSharingFrameRate(e), !0)
                    }, $h.prototype.startP2PSession = function() {
                        const e = this.getParticipants();
                        if (1 !== e.length) throw new Error("There must be exactly 1 participant to start the P2P session !");
                        {
                            const t = e[0].getJid();
                            this._startP2PSession(t)
                        }
                    }, $h.prototype.stopP2PSession = function(e) {
                        this._stopP2PSession(e)
                    }, $h.prototype.getSpeakerStats = function() {
                        return this.speakerStatsCollector.getStats()
                    }, $h.prototype.sendFaceLandmarks = function(e) {
                        e.faceExpression && this.xmpp.sendFaceLandmarksEvent(this.room.roomjid, e)
                    }, $h.prototype.setReceiverConstraints = function(e) {
                        this.receiveVideoController.setReceiverConstraints(e)
                    }, $h.prototype.setAssumedBandwidthBps = function(e) {
                        this.receiveVideoController.setAssumedBandwidthBps(e)
                    }, $h.prototype.setReceiverVideoConstraint = function(e) {
                        this.receiveVideoController.setPreferredReceiveMaxFrameHeight(e)
                    }, $h.prototype.setSenderVideoConstraint = function(e) {
                        return this.sendVideoController.setPreferredSendMaxFrameHeight(e)
                    }, $h.prototype.createVideoSIPGWSession = function(e, t) {
                        return this.room ? this.videoSIPGWHandler.createVideoSIPGWSession(e, t) : new Error(Ih)
                    }, $h.prototype._sendConferenceJoinAnalyticsEvent = function() {
                        var e, t, n;
                        const i = this.getMeetingUniqueId();
                        if (this._conferenceJoinAnalyticsEventSent || !i || null === this.getActivePeerConnection()) return;
                        const r = this.getConnectionTimes(),
                            o = this.connection.getConnectionTimes(),
                            s = window.connectionTimes["firstObtainPermissions.start"],
                            a = window.connectionTimes["firstObtainPermissions.end"],
                            d = null !== (e = null === (t = window.JitsiMeetJS) || void 0 === t || null === (n = t.app) || void 0 === n ? void 0 : n.connectionTimes) && void 0 !== e ? e : {},
                            c = {
                                ...r,
                                ...o,
                                ...d,
                                gumDuration: Ti(a, s),
                                xmppConnectingTime: Ti(o.connected, o.connecting),
                                connectedToMUCJoinedTime: Ti(r["muc.joined"], o.connected),
                                connectingToMUCJoinedTime: Ti(r["muc.joined"], o.connecting),
                                numberOfParticipantsOnJoin: this._numberOfParticipantsOnJoin
                            };
                        Mi.sendAnalytics(on("joined", {
                            ...c,
                            meetingId: i,
                            participantId: `${i}.${this._statsCurrentId}`
                        })), this._conferenceJoinAnalyticsEventSent = Date.now()
                    }, $h.prototype._sendConferenceLeftAnalyticsEvent = function() {
                        const e = this.getMeetingUniqueId();
                        e && this._conferenceJoinAnalyticsEventSent && Mi.sendAnalytics(on("left", {
                            meetingId: e,
                            participantId: `${e}.${this._statsCurrentId}`,
                            stats: {
                                duration: Math.floor((Date.now() - this._conferenceJoinAnalyticsEventSent) / 1e3),
                                perf: this.getPerformanceStats()
                            }
                        }))
                    }, $h.prototype._restartMediaSessions = function() {
                        this.p2pJingleSession && this._stopP2PSession({
                            reasonDescription: "restart",
                            requestRestart: !0
                        }), this.jvbJingleSession && this._stopJvbSession({
                            reason: "success",
                            reasonDescription: "restart required",
                            requestRestart: !0,
                            sendSessionTerminate: !0
                        }), this._maybeStartOrStopP2P(!1)
                    }, $h.prototype.isE2EEEnabled = function() {
                        return Boolean(this._e2eEncryption && this._e2eEncryption.isEnabled())
                    }, $h.prototype.isE2EESupported = function() {
                        return oo.isSupported(this.options.config)
                    }, $h.prototype.toggleE2EE = function(e) {
                        this.isE2EESupported() ? this._e2eEncryption.setEnabled(e) : Uh.warn("Cannot enable / disable E2EE: platform is not supported.")
                    }, $h.prototype.setMediaEncryptionKey = function(e) {
                        this._e2eEncryption.setEncryptionKey(e)
                    }, $h.prototype.startVerification = function(e) {
                        const t = this.getParticipantById(e);
                        t && this._e2eEncryption.startVerification(t)
                    }, $h.prototype.markParticipantVerified = function(e, t) {
                        const n = this.getParticipantById(e);
                        n && this._e2eEncryption.markParticipantVerified(n, t)
                    }, $h.prototype.isLobbySupported = function() {
                        return Boolean(this.room && this.room.getLobby().isSupported())
                    }, $h.prototype.isMembersOnly = function() {
                        return Boolean(this.room && this.room.membersOnlyEnabled)
                    }, $h.prototype.isVisitorsSupported = function() {
                        return Boolean(this.room && this.room.visitorsSupported)
                    }, $h.prototype.enableLobby = function() {
                        return this.room && this.isModerator() ? this.room.getLobby().enable() : Promise.reject(new Error("The conference not started or user is not moderator"))
                    }, $h.prototype.disableLobby = function() {
                        this.room && this.isModerator() ? this.room.getLobby().disable() : Uh.warn(`Failed to disable lobby, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
                    }, $h.prototype.joinLobby = function(e, t) {
                        return this.room ? this.room.getLobby().join(e, t) : Promise.reject(new Error("The conference not started"))
                    }, $h.prototype.myLobbyUserId = function() {
                        if (this.room) return this.room.getLobby().getLocalId()
                    }, $h.prototype.sendLobbyMessage = function(e, t) {
                        if (this.room) return t ? this.room.getLobby().sendPrivateMessage(t, e) : this.room.getLobby().sendMessage(e)
                    }, $h.prototype.addLobbyMessageListener = function(e) {
                        if (this.room) return this.room.getLobby().addMessageListener(e)
                    }, $h.prototype.removeLobbyMessageHandler = function(e) {
                        if (this.room) return this.room.getLobby().removeMessageHandler(e)
                    }, $h.prototype.lobbyDenyAccess = function(e) {
                        this.room && this.room.getLobby().denyAccess(e)
                    }, $h.prototype.lobbyApproveAccess = function(e) {
                        this.room && this.room.getLobby().approveAccess(e)
                    }, $h.prototype.isAVModerationSupported = function() {
                        return Boolean(this.room && this.room.getAVModeration().isSupported())
                    }, $h.prototype.enableAVModeration = function(e) {
                        this.room && this.isModerator() && (e === Ri.AUDIO || e === Ri.VIDEO) ? this.room.getAVModeration().enable(!0, e) : Uh.warn(`Failed to enable AV moderation, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                    }, $h.prototype.disableAVModeration = function(e) {
                        this.room && this.isModerator() && (e === Ri.AUDIO || e === Ri.VIDEO) ? this.room.getAVModeration().enable(!1, e) : Uh.warn(`Failed to disable AV moderation, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                    }, $h.prototype.avModerationApprove = function(e, t) {
                        if (this.room && this.isModerator() && (e === Ri.AUDIO || e === Ri.VIDEO)) {
                            const n = this.getParticipantById(t);
                            if (!n) return;
                            this.room.getAVModeration().approve(e, n.getJid())
                        } else Uh.warn(`AV moderation approve skipped , ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                    }, $h.prototype.avModerationReject = function(e, t) {
                        if (this.room && this.isModerator() && (e === Ri.AUDIO || e === Ri.VIDEO)) {
                            const n = this.getParticipantById(t);
                            if (!n) return;
                            this.room.getAVModeration().reject(e, n.getJid())
                        } else Uh.warn(`AV moderation reject skipped , ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                    }, $h.prototype.getBreakoutRooms = function() {
                        var e;
                        return null === (e = this.room) || void 0 === e ? void 0 : e.getBreakoutRooms()
                    }, $h.prototype.getMetadataHandler = function() {
                        var e;
                        return null === (e = this.room) || void 0 === e ? void 0 : e.getMetadataHandler()
                    }, Jh.prototype.connect = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        this.xmpp.moderator.targetUrl && !this.options.disableFocus && e.name ? this.xmpp.moderator.sendConferenceRequest(this.xmpp.getRoomJid(e.name)).then((() => {
                            this.xmpp.connect(e.id, e.password)
                        })) : this.xmpp.connect(e.id, e.password)
                    }, Jh.prototype.attach = function(e) {
                        this.xmpp.attach(e)
                    }, Jh.prototype.disconnect = function() {
                        return this.xmpp.disconnect(...arguments)
                    }, Jh.prototype.getJid = function() {
                        return this.xmpp.getJid()
                    }, Jh.prototype.setToken = function(e) {
                        this.token = e
                    }, Jh.prototype.initJitsiConference = function(e, t) {
                        return new $h({
                            name: e,
                            config: t,
                            connection: this
                        })
                    }, Jh.prototype.addEventListener = function(e, t) {
                        this.xmpp.addListener(e, t)
                    }, Jh.prototype.removeEventListener = function(e, t) {
                        this.xmpp.removeListener(e, t)
                    }, Jh.prototype.getConnectionTimes = function() {
                        return this.xmpp.connectionTimes
                    }, Jh.prototype.addFeature = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        this.xmpp.caps.addFeature(e, t, !0)
                    }, Jh.prototype.removeFeature = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        this.xmpp.caps.removeFeature(e, t, !0)
                    }, Jh.prototype.getLogs = function() {
                        const e = this.xmpp.getJingleLog(),
                            t = {};
                        t.time = new Date, t.url = window.location.href, t.ua = navigator.userAgent;
                        const n = this.xmpp.getXmppLog();
                        return n && (t.xmpp = n), e.metadata = t, e
                    },
                    function(e) {
                        e.DEVICE_LIST_CHANGED = "mediaDevices.devicechange", e.PERMISSIONS_CHANGED = "rtc.permissions_changed", e.PERMISSION_PROMPT_IS_SHOWN = "mediaDevices.permissionPromptIsShown", e.SLOW_GET_USER_MEDIA = "mediaDevices.slowGetUserMedia"
                    }(Bh || (Bh = {}));
                const qh = Bh.DEVICE_LIST_CHANGED,
                    Gh = Bh.PERMISSIONS_CHANGED,
                    zh = Bh.PERMISSION_PROMPT_IS_SHOWN,
                    Kh = Bh.SLOW_GET_USER_MEDIA,
                    Wh = "microphone",
                    Xh = "camera",
                    Yh = new class extends Cr {
                        constructor() {
                            super(), this._permissions = {}, ul.addListener(ji.default.DEVICE_LIST_CHANGED, (e => this.eventEmitter.emit(qh, e))), ul.addListener(ji.default.PERMISSIONS_CHANGED, (e => this._handlePermissionsChange(e))), this._permissionsApiSupported = new Promise((e => {
                                if (!navigator.permissions) return void e(!1);
                                const t = this,
                                    n = [];
                                n.push(navigator.permissions.query({
                                    name: Xh
                                }).then((e => (this._handlePermissionsChange({
                                    [Ri.VIDEO]: this._parsePermissionState(e)
                                }), e.onchange = function() {
                                    try {
                                        t._handlePermissionsChange({
                                            [Ri.VIDEO]: t._parsePermissionState(this)
                                        })
                                    } catch (e) {}
                                }, !0))).catch((() => !1))), n.push(navigator.permissions.query({
                                    name: Wh
                                }).then((e => (this._handlePermissionsChange({
                                    [Ri.AUDIO]: this._parsePermissionState(e)
                                }), e.onchange = function() {
                                    try {
                                        t._handlePermissionsChange({
                                            [Ri.AUDIO]: t._parsePermissionState(this)
                                        })
                                    } catch (e) {}
                                }, !0))).catch((() => !1))), Promise.all(n).then((t => e(t.every((e => e)))))
                            }))
                        }
                        _parsePermissionState() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            const t = e.state || e.status;
                            if ("string" != typeof t) throw new TypeError;
                            return "granted" === t
                        }
                        _handlePermissionsChange(e) {
                            [Ri.AUDIO, Ri.VIDEO].some((t => t in e && e[t] !== this._permissions[t])) && (this._permissions = {
                                ...this._permissions,
                                ...e
                            }, this.eventEmitter.emit(Gh, this._permissions), (this._permissions[Ri.AUDIO] || this._permissions[Ri.VIDEO]) && this.enumerateDevices((() => {})))
                        }
                        enumerateDevices(e) {
                            ul.enumerateDevices(e)
                        }
                        isDeviceListAvailable() {
                            return ul.isDeviceListAvailable()
                        }
                        isDeviceChangeAvailable(e) {
                            return ul.isDeviceChangeAvailable(e)
                        }
                        isDevicePermissionGranted(e) {
                            return new Promise((t => {
                                e in this._permissions ? t(this._permissions[e]) : this._permissionsApiSupported.then((n => {
                                    if (!n) return void t(!1);
                                    const i = [];
                                    switch (e) {
                                        case Ri.VIDEO:
                                            i.push(navigator.permissions.query({
                                                name: Xh
                                            }));
                                            break;
                                        case Ri.AUDIO:
                                            i.push(navigator.permissions.query({
                                                name: Wh
                                            }));
                                            break;
                                        default:
                                            i.push(navigator.permissions.query({
                                                name: Xh
                                            })), i.push(navigator.permissions.query({
                                                name: Wh
                                            }))
                                    }
                                    Promise.all(i).then((e => t(e.every((e => {
                                        try {
                                            return this._parsePermissionState(e)
                                        } catch {
                                            return !1
                                        }
                                    })))), (() => t(!1)))
                                }))
                            }))
                        }
                        isMultipleAudioInputSupported() {
                            return !(ci.isFirefox() && ci.isVersionLessThan("101") || ci.isIosBrowser())
                        }
                        getAudioOutputDevice() {
                            return ul.getAudioOutputDevice()
                        }
                        setAudioOutputDevice(e) {
                            return ul.setAudioOutputDevice(e)
                        }
                    },
                    Qh = (0, E.getLogger)("modules/detection/ActiveDeviceDetector.js");

                function Zh(e) {
                    for (const t of e) t.stopStream()
                }
                const eu = (0, E.getLogger)("modules/proxyconnection/CustomSignalingLayer.js");
                class tu extends Rc {
                    constructor() {
                        super(), this.ssrcOwners = new Map, this.chatRoom = null
                    }
                    getPeerMediaInfo(e, t, n) {
                        return {}
                    }
                    getPeerSourceInfo(e, t) {}
                    getSSRCOwner(e) {
                        return this.ssrcOwners.get(e)
                    }
                    getTrackSourceName(e) {}
                    removeSSRCOwners(e) {
                        if (null != e && e.length)
                            for (const t of e) this.ssrcOwners.delete(t)
                    }
                    setChatRoom(e) {
                        this.chatRoom = e
                    }
                    setSSRCOwner(e, t) {
                        if ("number" != typeof e) throw new TypeError(`SSRC(${e}) must be a number`);
                        const n = this.ssrcOwners.get(e);
                        n && n !== t && eu.error(`SSRC owner re-assigned from ${n} to ${t}`), this.ssrcOwners.set(e, t)
                    }
                    setTrackMuteStatus(e, t) {
                        return !1
                    }
                    setTrackVideoType(e, t) {
                        return !1
                    }
                    updateSsrcOwnersOnLeave(e) {
                        const t = Array.from(this.ssrcOwners).filter((t => t[1] === e)).map((e => e[0]));
                        null != t && t.length && this.removeSSRCOwners(t)
                    }
                }
                let nu;
                ! function(e) {
                    e.ACCEPT = "session-accept", e.CONNECTION_ERROR = "connection-error-encountered", e.INITIATE = "session-initiate", e.TERMINATE = "session-terminate", e.TRANSPORT_INFO = "transport-info", e.UNAVAILABLE = "unavailable"
                }(nu || (nu = {}));
                const iu = (0, E.getLogger)("modules/proxyconnection/ProxyConnectionPC.js");
                class ru {
                    constructor() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        this._options = {
                            pcConfig: {},
                            isInitiator: !1,
                            receiveAudio: !1,
                            receiveVideo: !1,
                            ...e
                        }, this._tracks = [], this._peerConnection = null, this._onError = this._onError.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this), this._onSendMessage = this._onSendMessage.bind(this)
                    }
                    getPeerJid() {
                        return this._options.peerJid
                    }
                    processMessage(e) {
                        switch (e.attr("action")) {
                            case nu.ACCEPT:
                                this._onSessionAccept(e);
                                break;
                            case nu.INITIATE:
                                this._onSessionInitiate(e);
                                break;
                            case nu.TERMINATE:
                                this._onSessionTerminate(e);
                                break;
                            case nu.TRANSPORT_INFO:
                                this._onTransportInfo(e)
                        }
                    }
                    start() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        this._peerConnection || (this._tracks = this._tracks.concat(e), this._peerConnection = this._createPeerConnection(), this._peerConnection.invite(e))
                    }
                    stop() {
                        this._peerConnection && this._peerConnection.terminate(), this._onSessionTerminate()
                    }
                    _createPeerConnection() {
                        const e = {
                                connected: !0,
                                jingle: {
                                    terminate: () => {}
                                },
                                sendIQ: this._onSendMessage,
                                addEventListener: () => () => {}
                            },
                            t = {
                                iceServers: xa,
                                ...this._options.pcConfig
                            },
                            n = {
                                addEventListener: () => {},
                                addPresenceListener: () => {},
                                connectionTimes: [],
                                eventEmitter: {
                                    emit: e => {
                                        switch (e) {
                                            case Hi.XMPPEvents.CONNECTION_ICE_FAILED:
                                            case Hi.XMPPEvents.CONNECTION_FAILED:
                                                this._onError(nu.CONNECTION_ERROR, e)
                                        }
                                    }
                                },
                                removeEventListener: () => {},
                                removePresenceListener: () => {},
                                supportsRestartByTerminate: () => !1
                            };
                        this._rtc = new ul({
                            myUserId: () => ""
                        }, {}), this._rtc.addListener(ji.default.REMOTE_TRACK_ADDED, this._onRemoteStream);
                        const i = new ha(void 0, void 0, this._options.peerJid, e, {
                                offerToReceiveAudio: this._options.receiveAudio,
                                offerToReceiveVideo: this._options.receiveVideo
                            }, t, !0, this._options.isInitiator),
                            r = new tu;
                        return r.setChatRoom(n), i.initialize(n, this._rtc, r, {}), i
                    }
                    _onError(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                        this._options.onError(this._options.peerJid, e, t)
                    }
                    _onRemoteStream(e) {
                        this._tracks.push(e), this._options.onRemoteStream(e)
                    }
                    _onSendMessage(e, t) {
                        this._options.onSendMessage(this._options.peerJid, e), t && setTimeout(t, 250)
                    }
                    _onSessionAccept(e) {
                        this._peerConnection ? this._peerConnection.setAnswer(e) : iu.error("Received an answer when no peer connection exists.")
                    }
                    _onSessionInitiate(e) {
                        this._peerConnection ? iu.error("Received an offer when an offer was already sent.") : (this._peerConnection = this._createPeerConnection(), this._peerConnection.acceptOffer(e, (() => {}), (() => this._onError(this._options.peerJid, nu.CONNECTION_ERROR, "session initiate error")), []))
                    }
                    _onSessionTerminate() {
                        this._tracks.forEach((e => e.dispose())), this._tracks = [], this._peerConnection && this._peerConnection.onTerminated(), this._rtc && (this._rtc.removeListener(ji.default.REMOTE_TRACK_ADDED, this._onRemoteStream), this._rtc.destroy())
                    }
                    _onTransportInfo(e) {
                        this._peerConnection.addIceCandidates(e)
                    }
                }
                const ou = (0, E.getLogger)("modules/proxyconnection/ProxyConnectionService.js");
                var su = n(549),
                    au = n.n(su);
                const du = (0, E.getLogger)("modules/webaudio/AudioMixer.js");
                class cu {
                    constructor() {
                        this._started = !1, this._streamsToMix = [], this._streamMSSArray = []
                    }
                    addMediaStream(e) {
                        e.getAudioTracks() || du.warn("Added MediaStream doesn't contain audio tracks."), this._streamsToMix.push(e)
                    }
                    start() {
                        if (this._started) return this._mixedMSD.stream;
                        if (this._audioContext = Nl(), !this._streamsToMix.length) return du.warn("No MediaStream's added to AudioMixer, nothing will happen."), null;
                        this._started = !0, this._mixedMSD = this._audioContext.createMediaStreamDestination();
                        for (const e of this._streamsToMix) {
                            const t = this._audioContext.createMediaStreamSource(e);
                            t.connect(this._mixedMSD), this._streamMSSArray.push(t)
                        }
                        return this._mixedMSD.stream
                    }
                    reset() {
                        this._started = !1, this._streamsToMix = [];
                        for (const e of this._streamMSSArray) e.disconnect();
                        this._streamMSSArray = [], this._audioContext && (this._audioContext = void 0)
                    }
                }
                const lu = S().getLogger("JitsiMeetJS.ts");
                let hu = !1;

                function uu(e) {
                    const t = {};
                    return t.audio_requested = e.devices.includes("audio"), t.video_requested = e.devices.includes("video"), t.screen_sharing_requested = e.devices.includes("desktop"), t.video_requested && (t.resolution = e.resolution), t
                }
                const pu = {
                    version: "315582f6",
                    JitsiConnection: Jh,
                    ProxyConnectionService: class {
                        constructor() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            const {
                                jitsiConnection: t,
                                ...n
                            } = e;
                            this._options = {
                                pcConfig: t && t.xmpp.connection.jingle.p2pIceConfig,
                                ...n
                            }, this._peerConnection = null, this._onFatalError = this._onFatalError.bind(this), this._onSendMessage = this._onSendMessage.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this)
                        }
                        processMessage(e) {
                            const t = e.from;
                            if (!t) return;
                            if (this._peerConnection && this._peerConnection.getPeerJid() !== t) return void this._onFatalError(t, nu.CONNECTION_ERROR, "rejected");
                            const n = this._convertStringToXML(e.data.iq),
                                i = n && n.find("jingle"),
                                r = i && i.attr("action");
                            r === nu.INITIATE && (this._peerConnection = this._createPeerConnection(t, {
                                isInitiator: !1,
                                receiveVideo: !0
                            })), this._peerConnection && this._peerConnection.processMessage(i), r !== nu.CONNECTION_ERROR && r !== nu.UNAVAILABLE && r !== nu.TERMINATE || this._selfCloseConnection()
                        }
                        start(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                            this._peerConnection = this._createPeerConnection(e, {
                                isInitiator: !0,
                                receiveVideo: !1
                            }), t.forEach(((e, t) => {
                                const n = Tc("peer", e.getType(), t);
                                e.setSourceName(n)
                            })), this._peerConnection.start(t)
                        }
                        stop() {
                            this._peerConnection && this._peerConnection.stop(), this._peerConnection = null
                        }
                        _convertStringToXML(e) {
                            try {
                                const t = (new DOMParser).parseFromString(e, "text/xml");
                                return _t()(t)
                            } catch (e) {
                                return ou.error("Attempted to convert incorrectly formatted xml"), null
                            }
                        }
                        _createPeerConnection(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            if (!e) throw new Error("Cannot create ProxyConnectionPC without a peer.");
                            const n = {
                                pcConfig: this._options.pcConfig,
                                onError: this._onFatalError,
                                onRemoteStream: this._onRemoteStream,
                                onSendMessage: this._onSendMessage,
                                peerJid: e,
                                ...t
                            };
                            return new ru(n)
                        }
                        _onFatalError(e, t) {
                            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
                            ou.error("Received a proxy connection error", e, t, n);
                            const i = (0, St.$iq)({
                                to: e,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: t
                            }).c("details").t(n).up();
                            this._onSendMessage(e, i), this._peerConnection && this._peerConnection.getPeerJid() === e && this._selfCloseConnection()
                        }
                        _onRemoteStream(e) {
                            if (!this._options.onRemoteStream) return ou.error("Remote track received without callback."), void e.dispose();
                            const t = e.isVideoTrack();
                            let n;
                            t && (n = this._options.convertVideoToDesktop ? Yo.VideoType.DESKTOP : Yo.VideoType.CAMERA);
                            const i = e.getOriginalStream(),
                                r = ul.createLocalTracks([{
                                    deviceId: `proxy:${this._peerConnection.getPeerJid()}`,
                                    mediaType: t ? Ri.VIDEO : Ri.AUDIO,
                                    sourceType: "proxy",
                                    stream: i,
                                    track: i.getVideoTracks()[0],
                                    videoType: n
                                }]);
                            this._options.onRemoteStream(r[0])
                        }
                        _onSendMessage(e, t) {
                            if (this._options.onSendMessage) try {
                                const n = (new XMLSerializer).serializeToString(t.nodeTree || t);
                                this._options.onSendMessage(e, {
                                    iq: n
                                })
                            } catch (e) {
                                ou.error("Attempted to send an incorrectly formatted iq.")
                            }
                        }
                        _selfCloseConnection() {
                            this.stop(), this._options.onConnectionClosed && this._options.onConnectionClosed()
                        }
                    },
                    constants: {
                        recording: {
                            error: {
                                BUSY: "busy",
                                ERROR: "error",
                                RESOURCE_CONSTRAINT: "resource-constraint",
                                UNEXPECTED_REQUEST: "unexpected-request",
                                SERVICE_UNAVAILABLE: "service-unavailable"
                            },
                            mode: {
                                FILE: "file",
                                STREAM: "stream"
                            },
                            status: {
                                OFF: "off",
                                ON: "on",
                                PENDING: "pending"
                            }
                        },
                        sipVideoGW: _,
                        transcriptionStatus: l,
                        trackStreamingStatus: $c
                    },
                    events: {
                        conference: r,
                        connection: d,
                        detection: f,
                        track: o,
                        mediaDevices: y,
                        connectionQuality: g,
                        e2eping: v,
                        rtcstats: s
                    },
                    errors: {
                        conference: i,
                        connection: c,
                        track: a
                    },
                    errorTypes: {
                        JitsiTrackError: dr
                    },
                    logLevels: S().levels,
                    mediaDevices: Yh,
                    analytics: Mi.analytics,
                    init() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        lu.info(`This appears to be ${ci.getName()}, ver: ${ci.getVersion()}`), Ho.init(e.externalStorage), Mi.init(e);
                        const t = e.flags || {};
                        return Ai.init(t), window.connectionTimes || (window.connectionTimes = {}), !0 !== e.enableAnalyticsLogging && (lu.warn("Analytics disabled, disposing."), this.analytics.dispose()), ul.init(e)
                    },
                    isDesktopSharingEnabled: () => ul.isDesktopSharingEnabled(),
                    isWebRtcSupported: () => ul.isWebRtcSupported(),
                    setLogLevel(e) {
                        S().setLogLevel(e)
                    },
                    rtcstats: {
                        sendIdentityEntry(e) {
                            si.sendIdentity(e)
                        },
                        sendStatsEntry(e, t) {
                            si.sendStatsEntry(e, null, t)
                        },
                        on(e, t) {
                            si.events.on(e, t)
                        }
                    },
                    setLogLevelById(e, t) {
                        S().setLogLevelById(e, t)
                    },
                    addGlobalLogTransport(e) {
                        S().addGlobalTransport(e)
                    },
                    removeGlobalLogTransport(e) {
                        S().removeGlobalTransport(e)
                    },
                    setGlobalLogOptions(e) {
                        S().setGlobalOptions(e)
                    },
                    createLocalTracks() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            t = arguments.length > 1 ? arguments[1] : void 0,
                            n = !1;
                        const {
                            firePermissionPromptIsShownEvent: i,
                            fireSlowPromiseEvent: r,
                            ...o
                        } = e;
                        !i && !t || ul.arePermissionsGrantedForAvailableDevices() ? r && window.setTimeout((() => {
                            n || Yh.emit(Kh)
                        }), 1e3) : Yh.emit(zh, ci.getName());
                        let s = !1,
                            a = window.performance.now();
                        return window.connectionTimes || (window.connectionTimes = {}), hu || (hu = !0, s = !0, window.connectionTimes["firstObtainPermissions.start"] = a), window.connectionTimes["obtainPermissions.start"] = a, ul.obtainAudioAndVideoPermissions(o).then((e => {
                            n = !0;
                            let t = window.performance.now();
                            if (window.connectionTimes["obtainPermissions.end"] = t, s && (window.connectionTimes["firstObtainPermissions.end"] = t), Mi.sendAnalytics(an("success", uu(o))), this.isCollectingLocalStats())
                                for (let t = 0; t < e.length; t++) {
                                    const n = e[t];
                                    n.getType() === Ri.AUDIO && Mi.startLocalStats(n, n.setAudioLevel.bind(n))
                                }
                            const i = ul.getCurrentlyAvailableMediaDevices();
                            if (i)
                                for (let t = 0; t < e.length; t++) e[t]._setRealDeviceIdFromDeviceList(i);
                            return e
                        })).catch((t => {
                            if (n = !0, t.name === Zi) Mi.sendAnalytics(an("warning", {
                                reason: "extension install user canceled"
                            }));
                            else if (t.name === Xi) {
                                const n = uu(e);
                                n.reason = "device not found", n.devices = t.gum.devices.join("."), Mi.sendAnalytics(an("error", n))
                            } else {
                                const n = uu(e);
                                n.reason = t.name, Mi.sendAnalytics(an("error", n))
                            }
                            let i = window.performance.now();
                            return window.connectionTimes["obtainPermissions.end"] = i, s && (window.connectionTimes["firstObtainPermissions.end"] = i), Promise.reject(t)
                        }))
                    },
                    createLocalTracksFromMediaStreams: e => ul.createLocalTracks(e.map((e => {
                        const t = e.stream.getTracks().filter((t => t.kind === e.mediaType));
                        if (!t || 0 === t.length) throw new dr(or, null, null);
                        if (t.length > 1) throw new dr(rr, null, null);
                        return e.track = t[0], e
                    }))),
                    createTrackVADEmitter: (e, t, n) => kl.create(e, t, n),
                    createAudioMixer: () => new cu,
                    getActiveAudioDevice: () => new Promise((e => {
                        ul.enumerateDevices((t => {
                            const n = t.filter((e => "audioinput" === e.kind)),
                                i = [];
                            for (const e of n) {
                                const t = ul.obtainAudioAndVideoPermissions({
                                    devices: ["audio"],
                                    micDeviceId: e.deviceId
                                }).then((e => {
                                    const t = e[0];
                                    return Mi.startLocalStats(t, t.setAudioLevel.bind(t)), t
                                }));
                                i.push(t)
                            }
                            Promise.allSettled(i).then((t => {
                                const n = t.filter((e => "fulfilled" === e.status)),
                                    i = t.filter((e => "rejected" === e.status)),
                                    r = n.map((e => e.value)),
                                    o = i.map((e => e.value));
                                for (const e of o) Qh.error("Failed to acquire audio device with error: ", e);
                                for (const t of r) t.on(Ct, (n => {
                                    n > .008 && (Zh(r), e({
                                        deviceId: t.deviceId,
                                        deviceLabel: t.track.label
                                    }))
                                }));
                                setTimeout((() => {
                                    Zh(r), e({
                                        deviceId: "",
                                        deviceLabel: ""
                                    })
                                }), 3e3)
                            }))
                        }))
                    })),
                    isDeviceListAvailable() {
                        return lu.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceListAvailable instead"), this.mediaDevices.isDeviceListAvailable()
                    },
                    isDeviceChangeAvailable(e) {
                        return lu.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead"), this.mediaDevices.isDeviceChangeAvailable(e)
                    },
                    isMultipleAudioInputSupported() {
                        return this.mediaDevices.isMultipleAudioInputSupported()
                    },
                    isCollectingLocalStats: () => Mi.audioLevelsEnabled && _i.isLocalStatsSupported(),
                    enumerateDevices(e) {
                        lu.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.enumerateDevices instead"), this.mediaDevices.enumerateDevices(e)
                    },
                    setNetworkInfo(e) {
                        let {
                            isOnline: t
                        } = e;
                        Co.updateNetworkInfo({
                            isOnline: t
                        })
                    },
                    util: {
                        ScriptUtil: au(),
                        browser: ci
                    }
                }
            }
        },
        __webpack_module_cache__ = {};

    function __webpack_require__(e) {
        var t = __webpack_module_cache__[e];
        if (void 0 !== t) return t.exports;
        var n = __webpack_module_cache__[e] = {
            id: e,
            loaded: !1,
            exports: {}
        };
        return __webpack_modules__[e].call(n.exports, n, n.exports, __webpack_require__), n.loaded = !0, n.exports
    }
    __webpack_require__.amdO = {}, __webpack_require__.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return __webpack_require__.d(t, {
            a: t
        }), t
    }, __webpack_require__.d = (e, t) => {
        for (var n in t) __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, {
            enumerable: !0,
            get: t[n]
        })
    }, __webpack_require__.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window) return window
        }
    }(), __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), __webpack_require__.r = e => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, __webpack_require__.nmd = e => (e.paths = [], e.children || (e.children = []), e);
    var __webpack_exports__ = __webpack_require__(449);
    return __webpack_exports__
})()));